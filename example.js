(() => {
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };

  // node_modules/easy/lib/offset.js
  var require_offset = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Offset = /* @__PURE__ */ function() {
      function Offset2(top, left) {
        _classCallCheck(this, Offset2);
        this.top = top;
        this.left = left;
      }
      _createClass(Offset2, [
        {
          key: "getTop",
          value: function getTop() {
            return this.top;
          }
        },
        {
          key: "getLeft",
          value: function getLeft() {
            return this.left;
          }
        }
      ]);
      return Offset2;
    }();
    exports.default = Offset;
  });

  // node_modules/easy/lib/bounds.js
  var require_bounds = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Bounds = /* @__PURE__ */ function() {
      function Bounds2(top, left, right, bottom) {
        _classCallCheck(this, Bounds2);
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
      }
      _createClass(Bounds2, [
        {
          key: "getTop",
          value: function getTop() {
            return this.top;
          }
        },
        {
          key: "getLeft",
          value: function getLeft() {
            return this.left;
          }
        },
        {
          key: "getRight",
          value: function getRight() {
            return this.right;
          }
        },
        {
          key: "getBottom",
          value: function getBottom() {
            return this.bottom;
          }
        },
        {
          key: "getWidth",
          value: function getWidth() {
            var width = this.right - this.left;
            return width;
          }
        },
        {
          key: "getHeight",
          value: function getHeight() {
            var height = this.bottom - this.top;
            return height;
          }
        },
        {
          key: "setTop",
          value: function setTop(top) {
            this.top = top;
          }
        },
        {
          key: "setLeft",
          value: function setLeft(left) {
            this.left = left;
          }
        },
        {
          key: "setRight",
          value: function setRight(right) {
            this.right = right;
          }
        },
        {
          key: "setBottom",
          value: function setBottom(bottom) {
            this.bottom = bottom;
          }
        },
        {
          key: "shift",
          value: function shift(horizontalOffset, verticalOffset) {
            this.top += verticalOffset;
            this.left += horizontalOffset;
            this.right += horizontalOffset;
            this.bottom += verticalOffset;
          }
        },
        {
          key: "isOverlappingMouse",
          value: function isOverlappingMouse(mouseTop, mouseLeft) {
            return this.top <= mouseTop && this.left <= mouseLeft && this.right > mouseLeft && this.bottom > mouseTop;
          }
        },
        {
          key: "areOverlapping",
          value: function areOverlapping(bounds) {
            return this.top < bounds.bottom && this.left < bounds.right && this.right > bounds.left && this.bottom > bounds.top;
          }
        }
      ], [
        {
          key: "fromBoundingClientRect",
          value: function fromBoundingClientRect(boundingClientRect) {
            var windowScrollTop = window.pageYOffset, windowScrollLeft = window.pageXOffset, top = boundingClientRect.top + windowScrollTop, left = boundingClientRect.left + windowScrollLeft, right = boundingClientRect.right + windowScrollLeft, bottom = boundingClientRect.bottom + windowScrollTop, bounds = new Bounds2(top, left, right, bottom);
            return bounds;
          }
        },
        {
          key: "fromTopLeftWidthAndHeight",
          value: function fromTopLeftWidthAndHeight(top, left, width, height) {
            var bottom = top + height, right = left + width, bounds = new Bounds2(top, left, right, bottom);
            return bounds;
          }
        }
      ]);
      return Bounds2;
    }();
    exports.default = Bounds;
  });

  // node_modules/easy/lib/constants.js
  var require_constants = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.IGNORED_PROPERTIES = exports.DEFAULT_PROPERTIES = exports.SVG_NAMESPACE_URI = exports.EMPTY_STRING = exports.ABOUT_BLANK = exports.CLASS_NAME = exports.UNDEFINED = exports.HTML_FOR = exports.WILDCARD = exports.FUNCTION = exports.DISABLED = exports.BOOLEAN = exports.DISPLAY = exports.STRING = exports.OBJECT = exports.HEIGHT = exports.BLOCK = exports.WIDTH = exports.CLASS = exports.SPACE = exports.NONE = exports.BODY = exports.FOR = void 0;
    var FOR = "for";
    exports.FOR = FOR;
    var BODY = "body";
    exports.BODY = BODY;
    var NONE = "none";
    exports.NONE = NONE;
    var SPACE = " ";
    exports.SPACE = SPACE;
    var CLASS = "class";
    exports.CLASS = CLASS;
    var WIDTH = "width";
    exports.WIDTH = WIDTH;
    var BLOCK = "block";
    exports.BLOCK = BLOCK;
    var HEIGHT = "height";
    exports.HEIGHT = HEIGHT;
    var OBJECT = "object";
    exports.OBJECT = OBJECT;
    var STRING = "string";
    exports.STRING = STRING;
    var DISPLAY = "display";
    exports.DISPLAY = DISPLAY;
    var BOOLEAN = "boolean";
    exports.BOOLEAN = BOOLEAN;
    var DISABLED = "disabled";
    exports.DISABLED = DISABLED;
    var FUNCTION = "function";
    exports.FUNCTION = FUNCTION;
    var WILDCARD = "*";
    exports.WILDCARD = WILDCARD;
    var HTML_FOR = "htmlFor";
    exports.HTML_FOR = HTML_FOR;
    var UNDEFINED = "undefined";
    exports.UNDEFINED = UNDEFINED;
    var CLASS_NAME = "className";
    exports.CLASS_NAME = CLASS_NAME;
    var ABOUT_BLANK = "about:blank";
    exports.ABOUT_BLANK = ABOUT_BLANK;
    var EMPTY_STRING = "";
    exports.EMPTY_STRING = EMPTY_STRING;
    var SVG_NAMESPACE_URI = "http://www.w3.org/2000/svg";
    exports.SVG_NAMESPACE_URI = SVG_NAMESPACE_URI;
    var DEFAULT_PROPERTIES = "defaultProperties";
    exports.DEFAULT_PROPERTIES = DEFAULT_PROPERTIES;
    var IGNORED_PROPERTIES = "ignoredProperties";
    exports.IGNORED_PROPERTIES = IGNORED_PROPERTIES;
  });

  // node_modules/easy/lib/utilities/object.js
  var require_object = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combine = combine;
    exports.prune = prune;
    var _constants = require_constants();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function combine(target) {
      var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      target = _objectSpread({}, target);
      var names = Object.keys(source);
      names.forEach(function(name) {
        var targetValue = target[name], sourceValue = source[name], targetHasOwnProperty = target.hasOwnProperty(name);
        target[name] = targetHasOwnProperty ? combineValues(targetValue, sourceValue) : sourceValue;
      });
      return target;
    }
    function prune(target) {
      var names = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      target = _objectSpread({}, target);
      names.forEach(function(name) {
        var targetHasOwnProperty = target.hasOwnProperty(name);
        if (targetHasOwnProperty) {
          delete target[name];
        }
      });
      return target;
    }
    function combineValues(targetValue, sourceValue) {
      var targetValueBoolean = isValueBoolean(targetValue), sourceValueBoolean = isValueBoolean(sourceValue), combinedValue = targetValueBoolean && sourceValueBoolean ? targetValue : "".concat(targetValue, " ").concat(sourceValue);
      return combinedValue;
    }
    function isValueBoolean(value) {
      var valueBoolean = (typeof value === "undefined" ? "undefined" : _typeof(value)) === _constants.BOOLEAN;
      return valueBoolean;
    }
  });

  // node_modules/easy/lib/utilities/array.js
  var require_array = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.first = first;
    exports.push = push;
    exports.augment = augment;
    exports.flatten = flatten;
    exports.guarantee = guarantee;
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function first(array) {
      return array[0];
    }
    function push(array1, array2) {
      Array.prototype.push.apply(array1, array2);
    }
    function augment(array1, array2, test) {
      array1 = _toConsumableArray(array1);
      array2.forEach(function(element, index) {
        var passed = test(element, index);
        if (passed) {
          array1.push(element);
        }
      });
      return array1;
    }
    function flatten(array1) {
      return array1.reduce(function(array, element) {
        array = array.concat(element);
        return array;
      }, []);
    }
    function guarantee(arrayOrElement) {
      arrayOrElement = arrayOrElement || [];
      return _instanceof(arrayOrElement, Array) ? arrayOrElement : [
        arrayOrElement
      ];
    }
  });

  // node_modules/easy/lib/utilities/name.js
  var require_name = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSVGTagName = isSVGTagName;
    exports.isSVGAttributeName = isSVGAttributeName;
    exports.isHTMLAttributeName = isHTMLAttributeName;
    function isSVGTagName(tagName) {
      return svgTagNames.includes(tagName);
    }
    function isSVGAttributeName(attributeName) {
      return svgAttributeNames.includes(attributeName);
    }
    function isHTMLAttributeName(attributeName) {
      return htmlAttributeNames.includes(attributeName);
    }
    var svgTagNames = [
      "altGlyph",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "animation",
      "audio",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "discard",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "handler",
      "hatch",
      "hatchpath",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "listener",
      "marker",
      "mask",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "prefetch",
      "radialGradient",
      "rect",
      "script",
      "set",
      "solidcolor",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "tbreak",
      "text",
      "textArea",
      "textPath",
      "title",
      "tref",
      "tspan",
      "unknown",
      "use",
      "video",
      "view",
      "vkern"
    ];
    var svgAttributeNames = [
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "alphabetic",
      "amplitude",
      "arabic-form",
      "ascent",
      "attributeName",
      "attributeType",
      "azimuth",
      "bandwidth",
      "baseFrequency",
      "baseProfile",
      "baseline-shift",
      "bbox",
      "begin",
      "bias",
      "by",
      "calcMode",
      "cap-height",
      "clip",
      "className",
      "clip-path",
      "clip-rule",
      "clipPathUnits",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "contentScriptType",
      "contentStyleType",
      "crossorigin",
      "cursor",
      "cx",
      "cy",
      "d",
      "defaultAction",
      "descent",
      "diffuseConstant",
      "direction",
      "display",
      "divisor",
      "dominant-baseline",
      "download",
      "dur",
      "dx",
      "dy",
      "edgeMode",
      "editable",
      "elevation",
      "enable-background",
      "end",
      "event",
      "exponent",
      "externalResourcesRequired",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterRes",
      "filterUnits",
      "flood-color",
      "flood-opacity",
      "focusHighlight",
      "focusable",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "format",
      "fr",
      "from",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "handler",
      "hanging",
      "hatchContentUnits",
      "hatchUnits",
      "height",
      "horiz-adv-x",
      "horiz-origin-x",
      "horiz-origin-y",
      "href",
      "hreflang",
      "id",
      "ideographic",
      "image-rendering",
      "in",
      "in2",
      "initialVisibility",
      "intercept",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kernelMatrix",
      "kernelUnitLength",
      "kerning",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "letter-spacing",
      "lighting-color",
      "limitingConeAngle",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "mask",
      "maskContentUnits",
      "maskUnits",
      "mathematical",
      "max",
      "media",
      "mediaCharacterEncoding",
      "mediaContentEncodings",
      "mediaSize",
      "mediaTime",
      "method",
      "min",
      "mode",
      "name",
      "nav-down",
      "nav-down-left",
      "nav-down-right",
      "nav-left",
      "nav-next",
      "nav-prev",
      "nav-right",
      "nav-up",
      "nav-up-left",
      "nav-up-right",
      "numOctaves",
      "observer",
      "offset",
      "opacity",
      "operator",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "overlay",
      "overline-position",
      "overline-thickness",
      "panose-1",
      "path",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "phase",
      "pitch",
      "playbackOrder",
      "playbackorder",
      "pointer-events",
      "points",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "propagate",
      "r",
      "radius",
      "refX",
      "refY",
      "rendering-intent",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "requiredFonts",
      "requiredFormats",
      "restart",
      "result",
      "rotate",
      "rx",
      "ry",
      "scale",
      "seed",
      "shape-rendering",
      "side",
      "slope",
      "snapshotTime",
      "spacing",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "src",
      "startOffset",
      "stdDeviation",
      "stemh",
      "stemv",
      "stitchTiles",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "string",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "style",
      "surfaceScale",
      "syncBehavior",
      "syncBehaviorDefault",
      "syncMaster",
      "syncTolerance",
      "syncToleranceDefault",
      "systemLanguage",
      "tableValues",
      "target",
      "targetX",
      "targetY",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textLength",
      "timelineBegin",
      "timelinebegin",
      "title",
      "to",
      "transform",
      "transformBehavior",
      "type",
      "u1",
      "u2",
      "underline-position",
      "underline-thickness",
      "unicode",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "values",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "viewBox",
      "viewTarget",
      "visibility",
      "width",
      "widths",
      "word-spacing",
      "writing-mode",
      "x",
      "x-height",
      "x1",
      "x2",
      "xChannelSelector",
      "y",
      "y1",
      "y2",
      "yChannelSelector",
      "z",
      "zoomAndPan"
    ];
    var htmlAttributeNames = [
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "allow",
      "allowFullScreen",
      "allowTransparency",
      "alt",
      "async",
      "autoComplete",
      "autoFocus",
      "autoPlay",
      "capture",
      "cellPadding",
      "cellSpacing",
      "challenge",
      "charSet",
      "checked",
      "cite",
      "classID",
      "className",
      "colSpan",
      "cols",
      "content",
      "contentEditable",
      "contextMenu",
      "controls",
      "coords",
      "crossOrigin",
      "data",
      "dateTime",
      "default",
      "defer",
      "dir",
      "disabled",
      "download",
      "draggable",
      "encType",
      "form",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "frameBorder",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hrefLang",
      "htmlFor",
      "httpEquiv",
      "icon",
      "id",
      "inputMode",
      "integrity",
      "is",
      "keyParams",
      "keyType",
      "kind",
      "label",
      "lang",
      "list",
      "loop",
      "low",
      "manifest",
      "marginHeight",
      "marginWidth",
      "max",
      "maxLength",
      "media",
      "mediaGroup",
      "method",
      "min",
      "minLength",
      "multiple",
      "muted",
      "name",
      "noValidate",
      "nonce",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "poster",
      "preload",
      "profile",
      "radioGroup",
      "readOnly",
      "rel",
      "required",
      "reversed",
      "role",
      "rowSpan",
      "rows",
      "sandbox",
      "scope",
      "scoped",
      "scrolling",
      "seamless",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "spellCheck",
      "src",
      "srcDoc",
      "srcLang",
      "srcSet",
      "start",
      "step",
      "style",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "value",
      "width",
      "wmode",
      "wrap"
    ];
  });

  // node_modules/easy/lib/utilities/dom.js
  var require_dom = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementsFromDOMElements = elementsFromDOMElements;
    exports.ascendantDOMNodesFromDOMNode = ascendantDOMNodesFromDOMNode;
    exports.descendantDOMNodesFromDOMNode = descendantDOMNodesFromDOMNode;
    exports.filterDOMNodesBySelector = filterDOMNodesBySelector;
    exports.domNodeMatchesSelector = domNodeMatchesSelector;
    exports.filterDOMNodes = filterDOMNodes;
    var _array = require_array();
    var _constants = require_constants();
    function elementsFromDOMElements(domElements) {
      var domElementsWithElements = filterDOMNodes(domElements, function(domElement) {
        return domElement.__element__ !== void 0;
      }), elements = domElementsWithElements.map(function(domElement) {
        return domElement.__element__;
      });
      return elements;
    }
    function ascendantDOMNodesFromDOMNode(domNode, height) {
      var ascendantDOMNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (height > 0) {
        var parentDOMNode = domNode.parentElement;
        if (parentDOMNode !== null) {
          ascendantDOMNodes.push(parentDOMNode);
          height--;
          ascendantDOMNodesFromDOMNode(parentDOMNode, height, ascendantDOMNodes);
        }
      }
      return ascendantDOMNodes;
    }
    function descendantDOMNodesFromDOMNode(domNode, depth) {
      var descendantDOMNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (depth > 0) {
        var childDOMNodes = domNode.childNodes;
        (0, _array).push(descendantDOMNodes, childDOMNodes);
        depth--;
        childDOMNodes.forEach(function(childDOMNode) {
          return descendantDOMNodesFromDOMNode(childDOMNode, depth, descendantDOMNodes);
        });
      }
      return descendantDOMNodes;
    }
    function filterDOMNodesBySelector(domNodes, selector) {
      var filteredDOMNodes = filterDOMNodes(domNodes, function(domNode) {
        return domNodeMatchesSelector(domNode, selector);
      });
      return filteredDOMNodes;
    }
    function domNodeMatchesSelector(domNode, selector) {
      var domNodeType = domNode.nodeType;
      switch (domNodeType) {
        case Node.ELEMENT_NODE: {
          var domElement = domNode;
          return domElement.matches(selector);
        }
        case Node.TEXT_NODE: {
          if (selector === _constants.WILDCARD) {
            return true;
          }
        }
      }
      return false;
    }
    function filterDOMNodes(domNodes, test) {
      var filteredDOMNodes = [], domNodesLength = domNodes.length;
      for (var index = 0; index < domNodesLength; index++) {
        var domNode = domNodes[index], result = test(domNode);
        if (result) {
          filteredDOMNodes.push(domNode);
        }
      }
      return filteredDOMNodes;
    }
  });

  // node_modules/easy/lib/mixins/element.js
  var require_element = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _array = require_array();
    var _constants = require_constants();
    var _dom = require_dom();
    function getParentElement() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.WILDCARD;
      var parentElement = null;
      var parentDOMElement = this.domElement.parentElement;
      if (parentDOMElement !== null) {
        if (parentDOMElement.matches(selector)) {
          var parentDOMElements = [
            parentDOMElement
          ], parentElements = (0, _dom).elementsFromDOMElements(parentDOMElements), firstParentElement = (0, _array).first(parentElements);
          parentElement = firstParentElement || null;
        }
      }
      return parentElement;
    }
    function getChildElements() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.WILDCARD;
      var childDOMNodes = this.domElement.childNodes, childDOMElements = (0, _dom).filterDOMNodesBySelector(childDOMNodes, selector), childElements = (0, _dom).elementsFromDOMElements(childDOMElements);
      return childElements;
    }
    function getAscendantElements() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.WILDCARD, maximumHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
      var height = maximumHeight, domNode = this.domElement, ascendantDOMNodes = (0, _dom).ascendantDOMNodesFromDOMNode(domNode, height), ascendantDOMElements = (0, _dom).filterDOMNodesBySelector(ascendantDOMNodes, selector), ascendantElements = (0, _dom).elementsFromDOMElements(ascendantDOMElements);
      return ascendantElements;
    }
    function getDescendantElements() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.WILDCARD, maximumDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
      var depth = maximumDepth, domNode = this.domElement, descendantDOMNodes = (0, _dom).descendantDOMNodesFromDOMNode(domNode, depth), descendantDOMElements = (0, _dom).filterDOMNodesBySelector(descendantDOMNodes, selector), descendantElements = (0, _dom).elementsFromDOMElements(descendantDOMElements);
      return descendantElements;
    }
    function getNextSiblingElement() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.WILDCARD;
      var nextSiblingElement = null;
      var nextSiblingDOMNode = this.domElement.nextSibling;
      if (nextSiblingDOMNode !== null && (0, _dom).domNodeMatchesSelector(nextSiblingDOMNode, selector)) {
        nextSiblingElement = nextSiblingDOMNode.__element__ || null;
      }
      return nextSiblingElement;
    }
    function getPreviousSiblingElement() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.WILDCARD;
      var previousSiblingElement = null;
      var previousSiblingDOMNode = this.domElement.previousSibling;
      if (previousSiblingDOMNode !== null && (0, _dom).domNodeMatchesSelector(previousSiblingDOMNode, selector)) {
        previousSiblingElement = previousSiblingDOMNode.__element__ || null;
      }
      return previousSiblingElement;
    }
    var elementMixins = {
      getParentElement,
      getChildElements,
      getAscendantElements,
      getDescendantElements,
      getNextSiblingElement,
      getPreviousSiblingElement
    };
    var _default = elementMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/textElement.js
  var require_textElement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _offset = _interopRequireDefault2(require_offset());
    var _bounds = _interopRequireDefault2(require_bounds());
    var _element = _interopRequireDefault2(require_element());
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TextElement = /* @__PURE__ */ function() {
      function TextElement2(text) {
        _classCallCheck(this, TextElement2);
        this.domElement = document.createTextNode(text);
        this.domElement.__element__ = this;
      }
      _createClass(TextElement2, [
        {
          key: "getText",
          value: function getText() {
            var nodeValue = this.domElement.nodeValue, text = nodeValue;
            return text;
          }
        },
        {
          key: "setText",
          value: function setText(text) {
            var nodeValue = text;
            this.domElement.nodeValue = nodeValue;
          }
        },
        {
          key: "getOffset",
          value: function getOffset() {
            var top = this.domElement.offsetTop, left = this.domElement.offsetLeft, offset = new _offset.default(top, left);
            return offset;
          }
        },
        {
          key: "getBounds",
          value: function getBounds() {
            var boundingClientRect = this.domElement.getBoundingClientRect(), bounds = _bounds.default.fromBoundingClientRect(boundingClientRect);
            return bounds;
          }
        },
        {
          key: "getWidth",
          value: function getWidth() {
            var clientWidth = this.domElement.clientWidth, width = clientWidth;
            return width;
          }
        },
        {
          key: "getHeight",
          value: function getHeight() {
            var clientHeight = this.domElement.clientHeight, height = clientHeight;
            return height;
          }
        },
        {
          key: "prependTo",
          value: function prependTo(parentElement) {
            parentElement.prepend(this);
          }
        },
        {
          key: "appendTo",
          value: function appendTo(parentElement) {
            parentElement.append(this);
          }
        },
        {
          key: "addTo",
          value: function addTo(parentElement) {
            parentElement.add(this);
          }
        },
        {
          key: "removeFrom",
          value: function removeFrom(parentElement) {
            parentElement.remove(this);
          }
        },
        {
          key: "insertBefore",
          value: function insertBefore(siblingElement) {
            var parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
            parentDOMNode.insertBefore(this.domElement, siblingDOMElement);
          }
        },
        {
          key: "insertAfter",
          value: function insertAfter(siblingElement) {
            var parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
            parentDOMNode.insertBefore(this.domElement, siblingDOMElement.nextSibling);
          }
        },
        {
          key: "remove",
          value: function remove() {
            this.domElement.remove();
          }
        }
      ]);
      return TextElement2;
    }();
    Object.assign(TextElement.prototype, _element.default);
    var _default = TextElement;
    exports.default = _default;
  });

  // node_modules/easy/lib/utilities/elements.js
  var require_elements = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.removeFalseyElements = removeFalseyElements;
    exports.replaceStringsWithTextElements = replaceStringsWithTextElements;
    var _textElement = _interopRequireDefault2(require_textElement());
    var _constants = require_constants();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function removeFalseyElements(elements1) {
      elements1 = elements1.reduce(function(elements, element) {
        if (element) {
          elements.push(element);
        }
        return elements;
      }, []);
      return elements1;
    }
    function replaceStringsWithTextElements(elements) {
      elements = elements.map(function(element) {
        if ((typeof element === "undefined" ? "undefined" : _typeof(element)) === _constants.STRING) {
          var text = element, textElement = new _textElement.default(text);
          element = textElement;
        }
        return element;
      });
      return elements;
    }
  });

  // node_modules/easy/lib/mixins/jsx.js
  var require_jsx = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _object = require_object();
    var _array = require_array();
    var _name = require_name();
    var _elements = require_elements();
    var _constants = require_constants();
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function applyProperties(properties, defaultProperties, ignoredProperties) {
      var _this = this;
      this.properties = (0, _object).combine(properties, defaultProperties);
      properties = (0, _object).prune(this.properties, ignoredProperties);
      var namespaceURI = this.domElement.namespaceURI, svg = namespaceURI === _constants.SVG_NAMESPACE_URI, propertiesKeys = Object.keys(properties), names = propertiesKeys;
      names.forEach(function(name) {
        var value = properties[name], nameHandlerName = isNameHandlerName(name);
        if (nameHandlerName) {
          addHandler(_this, name, value);
        } else {
          var nameAttributeName = isNameAttributeName(name, svg);
          if (nameAttributeName) {
            addAttribute(_this, name, value);
          }
        }
      });
      var childElements = childElementsFromElement(this) || properties.childElements, context = {};
      childElements.forEach(function(childElement) {
        updateContext(childElement, context);
        _this.add(childElement);
      });
      this.context = context;
    }
    function getProperties() {
      return this.properties;
    }
    function getContext() {
      return this.context;
    }
    function assignContext(names, thenDelete) {
      var _this = this;
      var argumentsLength = arguments.length;
      if (argumentsLength === 1) {
        var firstArgument = (0, _array).first(arguments);
        if ((typeof firstArgument === "undefined" ? "undefined" : _typeof(firstArgument)) === _constants.BOOLEAN) {
          names = Object.keys(this.context);
          thenDelete = firstArgument;
        } else {
          thenDelete = true;
        }
      }
      if (argumentsLength === 0) {
        names = Object.keys(this.context);
        thenDelete = true;
      }
      names.forEach(function(name) {
        var value = _this.context[name], propertyName = name, descriptor = {
          value
        };
        Object.defineProperty(_this, propertyName, descriptor);
        if (thenDelete) {
          delete _this.context[name];
        }
      }, []);
    }
    var jsxMixins = {
      applyProperties,
      getProperties,
      getContext,
      assignContext
    };
    var _default = jsxMixins;
    exports.default = _default;
    function childElementsFromElement(element) {
      var childElements = null;
      if (_typeof(element.childElements) === _constants.FUNCTION) {
        childElements = element.childElements.call(element);
        childElements = (0, _array).guarantee(childElements);
        childElements = (0, _elements).removeFalseyElements(childElements);
        childElements = (0, _elements).replaceStringsWithTextElements(childElements);
      }
      return childElements;
    }
    function updateContext(childElement, context) {
      var parentContext = _typeof(childElement.parentContext) === _constants.FUNCTION ? childElement.parentContext() : childElement.context;
      Object.assign(context, parentContext);
    }
    function addHandler(element, name, value) {
      var eventType = name.substr(2).toLowerCase(), handler = value;
      element.on(eventType, handler);
    }
    function addAttribute(element, name, value) {
      if (name === _constants.CLASS_NAME) {
        name = _constants.CLASS;
      }
      if (name === _constants.HTML_FOR) {
        name = _constants.FOR;
      }
      if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === _constants.OBJECT) {
        var keys = Object.keys(value);
        keys.forEach(function(key) {
          element.domElement[name][key] = value[key];
        });
      } else if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === _constants.BOOLEAN) {
        if (value) {
          value = name;
          element.addAttribute(name, value);
        }
      } else {
        element.addAttribute(name, value);
      }
    }
    function isNameHandlerName(name) {
      return /^on/.test(name);
    }
    function isNameAttributeName(name, svg) {
      return svg ? (0, _name).isSVGAttributeName(name) : (0, _name).isHTMLAttributeName(name);
    }
  });

  // node_modules/easy/lib/eventTypes.js
  var require_eventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.CONTEXTMENU_EVENT_TYPE = exports.START_DRAG_EVENT_TYPE = exports.STOP_DRAG_EVENT_TYPE = exports.DRAG_OVER_EVENT_TYPE = exports.MOUSEMOVE_EVENT_TYPE = exports.MOUSEDOWN_EVENT_TYPE = exports.MOUSEOVER_EVENT_TYPE = exports.DBLCLICK_EVENT_TYPE = exports.MOUSEOUT_EVENT_TYPE = exports.DRAG_OUT_EVENT_TYPE = exports.AUXCLICK_EVENT_TYPE = exports.MOUSEUP_EVENT_TYPE = exports.KEYDOWN_EVENT_TYPE = exports.SCROLL_EVENT_TYPE = exports.RESIZE_EVENT_TYPE = exports.CHANGE_EVENT_TYPE = exports.REMOVE_EVENT_TYPE = exports.KEYUP_EVENT_TYPE = exports.CLICK_EVENT_TYPE = exports.FOCUS_EVENT_TYPE = exports.INPUT_EVENT_TYPE = exports.WHEEL_EVENT_TYPE = exports.DROP_EVENT_TYPE = exports.DRAG_EVENT_TYPE = exports.BLUR_EVENT_TYPE = exports.MOVE_EVENT_TYPE = exports.OPEN_EVENT_TYPE = void 0;
    var OPEN_EVENT_TYPE = "open";
    exports.OPEN_EVENT_TYPE = OPEN_EVENT_TYPE;
    var MOVE_EVENT_TYPE = "move";
    exports.MOVE_EVENT_TYPE = MOVE_EVENT_TYPE;
    var BLUR_EVENT_TYPE = "blur";
    exports.BLUR_EVENT_TYPE = BLUR_EVENT_TYPE;
    var DRAG_EVENT_TYPE = "drag";
    exports.DRAG_EVENT_TYPE = DRAG_EVENT_TYPE;
    var DROP_EVENT_TYPE = "drop";
    exports.DROP_EVENT_TYPE = DROP_EVENT_TYPE;
    var WHEEL_EVENT_TYPE = "wheel";
    exports.WHEEL_EVENT_TYPE = WHEEL_EVENT_TYPE;
    var INPUT_EVENT_TYPE = "input";
    exports.INPUT_EVENT_TYPE = INPUT_EVENT_TYPE;
    var FOCUS_EVENT_TYPE = "focus";
    exports.FOCUS_EVENT_TYPE = FOCUS_EVENT_TYPE;
    var CLICK_EVENT_TYPE = "click";
    exports.CLICK_EVENT_TYPE = CLICK_EVENT_TYPE;
    var KEYUP_EVENT_TYPE = "keyup";
    exports.KEYUP_EVENT_TYPE = KEYUP_EVENT_TYPE;
    var REMOVE_EVENT_TYPE = "remove";
    exports.REMOVE_EVENT_TYPE = REMOVE_EVENT_TYPE;
    var CHANGE_EVENT_TYPE = "change";
    exports.CHANGE_EVENT_TYPE = CHANGE_EVENT_TYPE;
    var RESIZE_EVENT_TYPE = "resize";
    exports.RESIZE_EVENT_TYPE = RESIZE_EVENT_TYPE;
    var SCROLL_EVENT_TYPE = "scroll";
    exports.SCROLL_EVENT_TYPE = SCROLL_EVENT_TYPE;
    var KEYDOWN_EVENT_TYPE = "keydown";
    exports.KEYDOWN_EVENT_TYPE = KEYDOWN_EVENT_TYPE;
    var MOUSEUP_EVENT_TYPE = "mouseup";
    exports.MOUSEUP_EVENT_TYPE = MOUSEUP_EVENT_TYPE;
    var AUXCLICK_EVENT_TYPE = "auxclick";
    exports.AUXCLICK_EVENT_TYPE = AUXCLICK_EVENT_TYPE;
    var DRAG_OUT_EVENT_TYPE = "dragout";
    exports.DRAG_OUT_EVENT_TYPE = DRAG_OUT_EVENT_TYPE;
    var MOUSEOUT_EVENT_TYPE = "mouseout";
    exports.MOUSEOUT_EVENT_TYPE = MOUSEOUT_EVENT_TYPE;
    var DBLCLICK_EVENT_TYPE = "dblclick";
    exports.DBLCLICK_EVENT_TYPE = DBLCLICK_EVENT_TYPE;
    var MOUSEOVER_EVENT_TYPE = "mouseover";
    exports.MOUSEOVER_EVENT_TYPE = MOUSEOVER_EVENT_TYPE;
    var MOUSEDOWN_EVENT_TYPE = "mousedown";
    exports.MOUSEDOWN_EVENT_TYPE = MOUSEDOWN_EVENT_TYPE;
    var MOUSEMOVE_EVENT_TYPE = "mousemove";
    exports.MOUSEMOVE_EVENT_TYPE = MOUSEMOVE_EVENT_TYPE;
    var DRAG_OVER_EVENT_TYPE = "dragover";
    exports.DRAG_OVER_EVENT_TYPE = DRAG_OVER_EVENT_TYPE;
    var STOP_DRAG_EVENT_TYPE = "stopdrag";
    exports.STOP_DRAG_EVENT_TYPE = STOP_DRAG_EVENT_TYPE;
    var START_DRAG_EVENT_TYPE = "startdrag";
    exports.START_DRAG_EVENT_TYPE = START_DRAG_EVENT_TYPE;
    var CONTEXTMENU_EVENT_TYPE = "contextmenu";
    exports.CONTEXTMENU_EVENT_TYPE = CONTEXTMENU_EVENT_TYPE;
    var _default = {
      OPEN_EVENT_TYPE,
      MOVE_EVENT_TYPE,
      BLUR_EVENT_TYPE,
      DRAG_EVENT_TYPE,
      DROP_EVENT_TYPE,
      WHEEL_EVENT_TYPE,
      INPUT_EVENT_TYPE,
      FOCUS_EVENT_TYPE,
      CLICK_EVENT_TYPE,
      KEYUP_EVENT_TYPE,
      REMOVE_EVENT_TYPE,
      CHANGE_EVENT_TYPE,
      RESIZE_EVENT_TYPE,
      SCROLL_EVENT_TYPE,
      KEYDOWN_EVENT_TYPE,
      MOUSEUP_EVENT_TYPE,
      AUXCLICK_EVENT_TYPE,
      DRAG_OUT_EVENT_TYPE,
      MOUSEOUT_EVENT_TYPE,
      DBLCLICK_EVENT_TYPE,
      MOUSEOVER_EVENT_TYPE,
      MOUSEDOWN_EVENT_TYPE,
      MOUSEMOVE_EVENT_TYPE,
      DRAG_OVER_EVENT_TYPE,
      STOP_DRAG_EVENT_TYPE,
      START_DRAG_EVENT_TYPE,
      CONTEXTMENU_EVENT_TYPE
    };
    exports.default = _default;
  });

  // node_modules/easy/lib/mixins/key.js
  var require_key = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventTypes = require_eventTypes();
    function onKeyUp(keyUpHandler, element) {
      this.on(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function offKeyUp(keyUpHandler, element) {
      this.off(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function onKeyDown(keyDownHandler, element) {
      this.on(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    function offKeyDown(keyDownHandler, element) {
      this.off(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    var keyMixins = {
      onKeyUp,
      offKeyUp,
      onKeyDown,
      offKeyDown
    };
    var _default = keyMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/mixins/click.js
  var require_click = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventTypes = require_eventTypes();
    function onClick(clickHandler, element) {
      this.on(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function offClick(clickHandler, element) {
      this.off(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    var clickMixins = {
      onClick,
      offClick
    };
    var _default = clickMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/mixins/state.js
  var require_state = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function getState() {
      return this.state;
    }
    function setState(state) {
      this.state = state;
    }
    function updateState(state) {
      Object.assign(this.state, state);
    }
    var stateMixins = {
      getState,
      setState,
      updateState
    };
    var _default = stateMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/contentTypes.js
  var require_contentTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TEXT_HTML_CONTENT_TYPE = void 0;
    var TEXT_HTML_CONTENT_TYPE = "text/html";
    exports.TEXT_HTML_CONTENT_TYPE = TEXT_HTML_CONTENT_TYPE;
  });

  // node_modules/easy/lib/mixins/resize.js
  var require_resize = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.onResize = onResize;
    exports.offResize = offResize;
    exports.default = void 0;
    var _eventTypes = require_eventTypes();
    var _constants = require_constants();
    var _contentTypes = require_contentTypes();
    function onResize(resizeHandler, element) {
      this.on(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    function offResize(resizeHandler, element) {
      this.off(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    function addResizeObject() {
      var _this = this;
      var resizeObject = document.createElement(_constants.OBJECT), style = "display: block; \n                 position: absolute; \n                 top: 0; \n                 left: 0; \n                 height: 100%; \n                 width: 100%; \n                 overflow: hidden; \n                 pointer-events: none; \n                 z-index: -1;", data = _constants.ABOUT_BLANK, type = _contentTypes.TEXT_HTML_CONTENT_TYPE;
      resizeObject.setAttribute("style", style);
      resizeObject.data = data;
      resizeObject.type = type;
      this.__resizeObject__ = resizeObject;
      resizeObject.onload = function() {
        return resizeObjectLoadHandler(_this);
      };
      this.domElement.appendChild(resizeObject);
    }
    function removeResizeObject() {
      var resizeObject = this.__resizeObject__, objectWindow = resizeObject.contentDocument.defaultView;
      objectWindow.removeEventListener(_eventTypes.RESIZE_EVENT_TYPE, resizeEventListener);
      this.domElement.removeChild(resizeObject);
      delete this.__resizeObject__;
    }
    var resizeMixins = {
      onResize,
      offResize,
      addResizeObject,
      removeResizeObject
    };
    var _default = resizeMixins;
    exports.default = _default;
    function resizeObjectLoadHandler(element) {
      var resizeObject = element.__resizeObject__, resizeObjectWindow = resizeObject.contentDocument.defaultView;
      resizeObjectWindow.addEventListener(_eventTypes.RESIZE_EVENT_TYPE, function(event) {
        var resizeEventListeners = element.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE);
        resizeEventListeners.forEach(function(resizeEventListener2) {
          return resizeEventListener2(event);
        });
      });
    }
  });

  // node_modules/easy/lib/mixins/event.js
  var require_event = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    var _resize = require_resize();
    function on(eventTypes, handler) {
      var element = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this;
      var _this = this;
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach(function(eventType) {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          var resizeEventListeners = _this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            _this.addResizeObject();
          }
        }
        var eventListener = _this.addEventListener(eventType, handler, element);
        _this.domElement.addEventListener(eventType, eventListener);
      });
    }
    function off(eventTypes, handler) {
      var element = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this;
      var _this = this;
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach(function(eventType) {
        var eventListener = _this.removeEventListener(eventType, handler, element);
        _this.domElement.removeEventListener(eventType, eventListener);
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          var resizeEventListeners = _this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            (0, _resize).removeResizeObject(_this);
          }
        }
      });
    }
    function addEventListener(eventType, handler, element) {
      if (this.eventListeners === void 0) {
        this.eventListeners = [];
      }
      var eventListener = this.createEventListener(eventType, handler, element);
      this.eventListeners.push(eventListener);
      return eventListener;
    }
    function removeEventListener(eventType, handler, element) {
      var eventListener = this.findEventListener(eventType, handler, element), index = this.eventListeners.indexOf(eventListener), start = index, deleteCount = 1;
      this.eventListeners.splice(start, deleteCount);
      if (this.eventListeners.length === 0) {
        delete this.eventListeners;
      }
      return eventListener;
    }
    function findEventListener(eventType, handler, element) {
      var eventListener1 = this.eventListeners.find(function(eventListener) {
        if (eventListener.element === element && eventListener.handler === handler && eventListener.eventType === eventType) {
          return true;
        }
      });
      return eventListener1;
    }
    function findEventListeners(eventType) {
      var eventListeners = [];
      if (this.eventListeners !== void 0) {
        this.eventListeners.forEach(function(eventListener) {
          var found = eventListener.eventType === eventType;
          if (found) {
            eventListeners.push(eventListener);
          }
        });
      }
      return eventListeners;
    }
    function createEventListener(eventType, handler, element1) {
      var _this = this;
      var eventListener;
      var handlerElement = element1;
      eventListener = function(event) {
        var element = _this;
        handler.call(handlerElement, event, element);
      };
      Object.assign(eventListener, {
        element: element1,
        handler,
        eventType
      });
      return eventListener;
    }
    var eventMixins = {
      on,
      off,
      addEventListener,
      removeEventListener,
      createEventListener,
      findEventListener,
      findEventListeners
    };
    var _default = eventMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/mixins/mouse.js
  var require_mouse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventTypes = require_eventTypes();
    function onMouseUp(mouseUpHandler, element) {
      this.on(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function offMouseUp(mouseUpHandler, element) {
      this.off(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function onMouseOut(mouseOutHandler, element) {
      this.on(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function offMouseOut(mouseOutHandler, element) {
      this.off(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function onMouseDown(mouseDownHandler, element) {
      this.on(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function offMouseDown(mouseDownHandler, element) {
      this.off(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function onMouseOver(mouseOverHandler, element) {
      this.on(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function offMouseOver(mouseOverHandler, element) {
      this.off(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function onMouseMove(mouseMoveHandler, element) {
      this.on(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    function offMouseMove(mouseMoveHandler, element) {
      this.off(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    var mouseMixins = {
      onMouseUp,
      offMouseUp,
      onMouseOut,
      offMouseOut,
      onMouseDown,
      offMouseDown,
      onMouseOver,
      offMouseOver,
      onMouseMove,
      offMouseMove
    };
    var _default = mouseMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/mixins/scroll.js
  var require_scroll = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventTypes = require_eventTypes();
    function onScroll(scrollHandler, element) {
      this.on(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function offScroll(scrollHandler, element) {
      this.off(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function getScrollTop() {
      return this.domElement.scrollTop;
    }
    function getScrollLeft() {
      return this.domElement.scrollLeft;
    }
    function setScrollTop(scrollTop) {
      this.domElement.scrollTop = scrollTop;
    }
    function setScrollLeft(scrollLeft) {
      this.domElement.scrollLeft = scrollLeft;
    }
    var scrollMixins = {
      onScroll,
      offScroll,
      getScrollTop,
      getScrollLeft,
      setScrollTop,
      setScrollLeft
    };
    var _default = scrollMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/element.js
  var require_element2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _offset = _interopRequireDefault2(require_offset());
    var _bounds = _interopRequireDefault2(require_bounds());
    var _jsx = _interopRequireDefault2(require_jsx());
    var _key = _interopRequireDefault2(require_key());
    var _click = _interopRequireDefault2(require_click());
    var _state = _interopRequireDefault2(require_state());
    var _event = _interopRequireDefault2(require_event());
    var _mouse = _interopRequireDefault2(require_mouse());
    var _resize = _interopRequireDefault2(require_resize());
    var _scroll = _interopRequireDefault2(require_scroll());
    var _element = _interopRequireDefault2(require_element());
    var _object = require_object();
    var _name = require_name();
    var _array = require_array();
    var _constants = require_constants();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    var Element = /* @__PURE__ */ function() {
      function Element2(selector) {
        _classCallCheck(this, Element2);
        if (selector) {
          this.domElement = document.querySelector(selector);
          this.domElement.__element__ = this;
        }
      }
      _createClass(Element2, [
        {
          key: "getDOMElement",
          value: function getDOMElement() {
            return this.domElement;
          }
        },
        {
          key: "getOffset",
          value: function getOffset() {
            var top = this.domElement.offsetTop, left = this.domElement.offsetLeft, offset = new _offset.default(top, left);
            return offset;
          }
        },
        {
          key: "getBounds",
          value: function getBounds() {
            var boundingClientRect = this.domElement.getBoundingClientRect(), bounds = _bounds.default.fromBoundingClientRect(boundingClientRect);
            return bounds;
          }
        },
        {
          key: "getWidth",
          value: function getWidth() {
            var includeBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            var width = includeBorder ? this.domElement.offsetWidth : this.domElement.clientWidth;
            return width;
          }
        },
        {
          key: "setWidth",
          value: function setWidth(width) {
            width = "".concat(width, "px");
            this.style(_constants.WIDTH, width);
          }
        },
        {
          key: "getHeight",
          value: function getHeight() {
            var includeBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            var height = includeBorder ? this.domElement.offsetHeight : this.domElement.clientHeight;
            return height;
          }
        },
        {
          key: "setHeight",
          value: function setHeight(height) {
            height = "".concat(height, "px");
            this.style(_constants.HEIGHT, height);
          }
        },
        {
          key: "hasAttribute",
          value: function hasAttribute(name) {
            return this.domElement.hasAttribute(name);
          }
        },
        {
          key: "getAttribute",
          value: function getAttribute(name) {
            return this.domElement.getAttribute(name);
          }
        },
        {
          key: "setAttribute",
          value: function setAttribute(name, value) {
            this.domElement.setAttribute(name, value);
          }
        },
        {
          key: "clearAttribute",
          value: function clearAttribute(name) {
            this.domElement.removeAttribute(name);
          }
        },
        {
          key: "addAttribute",
          value: function addAttribute(name, value) {
            this.setAttribute(name, value);
          }
        },
        {
          key: "removeAttribute",
          value: function removeAttribute(name) {
            this.clearAttribute(name);
          }
        },
        {
          key: "setClass",
          value: function setClass(className) {
            this.domElement.className = className;
          }
        },
        {
          key: "addClass",
          value: function addClass(className) {
            this.domElement.classList.add(className);
          }
        },
        {
          key: "removeClass",
          value: function removeClass(className) {
            this.domElement.classList.remove(className);
          }
        },
        {
          key: "toggleClass",
          value: function toggleClass(className) {
            this.domElement.classList.toggle(className);
          }
        },
        {
          key: "hasClass",
          value: function hasClass(className) {
            return this.domElement.classList.contains(className);
          }
        },
        {
          key: "clearClasses",
          value: function clearClasses() {
            this.domElement.className = _constants.EMPTY_STRING;
          }
        },
        {
          key: "prependTo",
          value: function prependTo(parentElement) {
            parentElement.prepend(this);
          }
        },
        {
          key: "appendTo",
          value: function appendTo(parentElement) {
            parentElement.append(this);
          }
        },
        {
          key: "addTo",
          value: function addTo(parentElement) {
            parentElement.add(this);
          }
        },
        {
          key: "removeFrom",
          value: function removeFrom(parentElement) {
            parentElement.remove(this);
          }
        },
        {
          key: "insertBefore",
          value: function insertBefore(siblingElement) {
            var parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
            parentDOMNode.insertBefore(this.domElement, siblingDOMElement);
          }
        },
        {
          key: "insertAfter",
          value: function insertAfter(siblingElement) {
            var parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
            parentDOMNode.insertBefore(this.domElement, siblingDOMElement.nextSibling);
          }
        },
        {
          key: "prepend",
          value: function prepend(element) {
            var domElement = element.domElement, firstChildDOMElement = this.domElement.firstChild;
            this.domElement.insertBefore(domElement, firstChildDOMElement);
          }
        },
        {
          key: "append",
          value: function append(element) {
            var domElement = element.domElement;
            this.domElement.insertBefore(domElement, null);
          }
        },
        {
          key: "add",
          value: function add(element) {
            this.append(element);
          }
        },
        {
          key: "remove",
          value: function remove(element) {
            if (element) {
              var domElement = element.domElement;
              this.domElement.removeChild(domElement);
            } else {
              this.domElement.remove();
            }
          }
        },
        {
          key: "mount",
          value: function mount(element1) {
            var descendantElements = element1.getDescendantElements(), elements = [
              element1
            ].concat(_toConsumableArray(descendantElements));
            this.add(element1);
            elements.reverse();
            elements.forEach(function(element) {
              return element.didMount && element.didMount();
            });
          }
        },
        {
          key: "unmount",
          value: function unmount(element2) {
            var descendantElements = element2.getDescendantElements(), elements = [
              element2
            ].concat(_toConsumableArray(descendantElements));
            elements.forEach(function(element) {
              return element.willUnmount && element.willUnmount();
            });
            this.remove(element2);
          }
        },
        {
          key: "show",
          value: function show() {
            var displayStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.BLOCK;
            this.display(displayStyle);
          }
        },
        {
          key: "hide",
          value: function hide() {
            this.style(_constants.DISPLAY, _constants.NONE);
          }
        },
        {
          key: "display",
          value: function display1(display) {
            this.style(_constants.DISPLAY, display);
          }
        },
        {
          key: "enable",
          value: function enable() {
            this.clearAttribute(_constants.DISABLED);
          }
        },
        {
          key: "disable",
          value: function disable() {
            this.setAttribute(_constants.DISABLED, _constants.DISABLED);
          }
        },
        {
          key: "isEnabled",
          value: function isEnabled() {
            var disabled = this.isDisabled(), enabled = !disabled;
            return enabled;
          }
        },
        {
          key: "isDisabled",
          value: function isDisabled() {
            var disabled = this.hasAttribute(_constants.DISABLED);
            return disabled;
          }
        },
        {
          key: "isDisplayed",
          value: function isDisplayed() {
            var display = this.css(_constants.DISPLAY), displayed = display !== _constants.NONE;
            return displayed;
          }
        },
        {
          key: "isShowing",
          value: function isShowing() {
            var displayed = this.isDisplayed(), showing = displayed;
            return showing;
          }
        },
        {
          key: "isHidden",
          value: function isHidden() {
            var displayed = this.isDisplayed(), hidden = !displayed;
            return hidden;
          }
        },
        {
          key: "style",
          value: function style(name, value) {
            if (value !== void 0) {
              this.domElement.style[name] = value;
            } else {
              var style1 = this.domElement.style[name];
              return style1;
            }
          }
        },
        {
          key: "html",
          value: function html1(html) {
            if (html === void 0) {
              var innerHTML = this.domElement.innerHTML;
              html = innerHTML;
              return html;
            } else {
              var innerHTML1 = html;
              this.domElement.innerHTML = innerHTML1;
            }
          }
        },
        {
          key: "css",
          value: function css1(css) {
            if (css === void 0) {
              var computedStyle = getComputedStyle(this.domElement), css2 = {};
              for (var index = 0; index < computedStyle.length; index++) {
                var firstComputedStyle = _array.first[computedStyle], name = firstComputedStyle, value = computedStyle.getPropertyValue(name);
                css2[name] = value;
              }
              return css2;
            } else if ((typeof css === "undefined" ? "undefined" : _typeof(css)) === _constants.STRING) {
              var name1 = css;
              var computedStyle1 = getComputedStyle(this.domElement), value1 = computedStyle1.getPropertyValue(name1);
              css = value1;
              return css;
            } else {
              var _this = this;
              var names = Object.keys(css);
              names.forEach(function(name2) {
                var value2 = css[name2];
                _this.style(name2, value2);
              });
            }
          }
        },
        {
          key: "blur",
          value: function blur() {
            this.domElement.blur();
          }
        },
        {
          key: "focus",
          value: function focus() {
            this.domElement.focus();
          }
        },
        {
          key: "hasFocus",
          value: function hasFocus() {
            var focus = document.activeElement === this.domElement;
            return focus;
          }
        }
      ], [
        {
          key: "fromClass",
          value: function fromClass(Class, properties) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 2 ? _len - 2 : 0), _key1 = 2; _key1 < _len; _key1++) {
              remainingArguments[_key1 - 2] = arguments[_key1];
            }
            var tagName = Class.tagName, element = elementFromTagName.apply(void 0, [
              Class,
              tagName
            ].concat(_toConsumableArray(remainingArguments))), defaultProperties = defaultPropertiesFromClass(Class), ignoredProperties = ignoredPropertiesFromClass(Class);
            element.applyProperties(properties, defaultProperties, ignoredProperties);
            element.initialise && element.initialise();
            return element;
          }
        },
        {
          key: "fromTagName",
          value: function fromTagName(tagName, properties) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
              remainingArguments[_key2 - 2] = arguments[_key2];
            }
            var Class = Element2, element = elementFromTagName.apply(void 0, [
              Class,
              tagName
            ].concat(_toConsumableArray(remainingArguments))), defaultProperties = {}, ignoredProperties = [];
            element.applyProperties(properties, defaultProperties, ignoredProperties);
            element.initialise && element.initialise();
            return element;
          }
        }
      ]);
      return Element2;
    }();
    Object.assign(Element.prototype, _jsx.default);
    Object.assign(Element.prototype, _key.default);
    Object.assign(Element.prototype, _click.default);
    Object.assign(Element.prototype, _state.default);
    Object.assign(Element.prototype, _event.default);
    Object.assign(Element.prototype, _mouse.default);
    Object.assign(Element.prototype, _resize.default);
    Object.assign(Element.prototype, _scroll.default);
    Object.assign(Element.prototype, _element.default);
    var _default = Element;
    exports.default = _default;
    function elementFromTagName(Class, tagName) {
      for (var _len = arguments.length, remainingArguments = new Array(_len > 2 ? _len - 2 : 0), _key3 = 2; _key3 < _len; _key3++) {
        remainingArguments[_key3 - 2] = arguments[_key3];
      }
      var _bind;
      var selector = null, element = new ((_bind = Function.prototype.bind).call.apply(_bind, [
        Class,
        null,
        selector
      ].concat(_toConsumableArray(remainingArguments))))();
      element.domElement = (0, _name).isSVGTagName(tagName) ? document.createElementNS(_constants.SVG_NAMESPACE_URI, tagName) : document.createElement(tagName);
      element.domElement.__element__ = element;
      return element;
    }
    function defaultPropertiesFromClass(Class) {
      var defaultProperties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (Class.hasOwnProperty(_constants.DEFAULT_PROPERTIES)) {
        defaultProperties = (0, _object).combine(defaultProperties, Class[_constants.DEFAULT_PROPERTIES]);
      }
      var superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        defaultProperties = defaultPropertiesFromClass(superClass, defaultProperties);
      }
      return defaultProperties;
    }
    function ignoredPropertiesFromClass(Class) {
      var ignoredProperties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      if (Class.hasOwnProperty(_constants.IGNORED_PROPERTIES)) {
        ignoredProperties = (0, _array).augment(ignoredProperties, Class[_constants.IGNORED_PROPERTIES], function(ignoredProperty) {
          return !ignoredProperties.includes(ignoredProperty);
        });
      }
      var superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        ignoredProperties = ignoredPropertiesFromClass(superClass, ignoredProperties);
      }
      return ignoredProperties;
    }
  });

  // node_modules/easy/lib/react.js
  var require_react = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    var _array = require_array();
    var _constants = require_constants();
    var _elements = require_elements();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function createElement(firstArgument, properties) {
      for (var _len = arguments.length, childElements = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        childElements[_key - 2] = arguments[_key];
      }
      var element = null;
      if (firstArgument !== void 0) {
        childElements = sanitiseChildElements(childElements);
        properties = Object.assign({
          childElements
        }, properties);
        if (false) {
        } else if (isSubclassOf(firstArgument, _element.default)) {
          var Class = firstArgument;
          element = Class.fromClass(Class, properties);
        } else if ((typeof firstArgument === "undefined" ? "undefined" : _typeof(firstArgument)) === _constants.STRING) {
          var tagName = firstArgument;
          element = _element.default.fromTagName(tagName, properties);
        } else if ((typeof firstArgument === "undefined" ? "undefined" : _typeof(firstArgument)) === _constants.FUNCTION) {
          var elementFunction = firstArgument;
          element = elementFunction(properties);
        }
      }
      return element;
    }
    var React2 = {
      createElement
    };
    var _default = React2;
    exports.default = _default;
    function sanitiseChildElements(childElements) {
      childElements = (0, _array).flatten(childElements);
      childElements = (0, _elements).removeFalseyElements(childElements);
      childElements = (0, _elements).replaceStringsWithTextElements(childElements);
      return childElements;
    }
    function isSubclassOf(argument, Class) {
      var subclassOf = false;
      if (argument.name === Class.name) {
        subclassOf = true;
      } else {
        argument = Object.getPrototypeOf(argument);
        if (argument) {
          subclassOf = isSubclassOf(argument, Class);
        }
      }
      return subclassOf;
    }
  });

  // node_modules/easy/lib/element/body.js
  var require_body = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    var _constants = require_constants();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Body = /* @__PURE__ */ function(Element) {
      _inherits(Body2, Element);
      var _super = _createSuper(Body2);
      function Body2() {
        var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _constants.BODY;
        _classCallCheck(this, Body2);
        return _super.call(this, selector);
      }
      return Body2;
    }(_wrapNativeSuper(_element.default));
    _defineProperty(Body, "tagName", "body");
    exports.default = Body;
  });

  // node_modules/easy/lib/element/link.js
  var require_link = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Link = /* @__PURE__ */ function(Element) {
      _inherits(Link2, Element);
      var _super = _createSuper(Link2);
      function Link2() {
        _classCallCheck(this, Link2);
        return _super.apply(this, arguments);
      }
      _createClass(Link2, [
        {
          key: "getHRef",
          value: function getHRef() {
            return this.getAttribute("href");
          }
        },
        {
          key: "setHRef",
          value: function setHRef(href) {
            return this.setAttribute("href", href);
          }
        }
      ]);
      return Link2;
    }(_wrapNativeSuper(_element.default));
    _defineProperty(Link, "tagName", "a");
    exports.default = Link;
  });

  // node_modules/easy/lib/mixins/change.js
  var require_change = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventTypes = require_eventTypes();
    function onChange(changeHandler, element) {
      this.on(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function offChange(changeHandler, element) {
      this.off(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    var changeMixins = {
      onChange,
      offChange
    };
    var _default = changeMixins;
    exports.default = _default;
  });

  // node_modules/easy/lib/inputElement.js
  var require_inputElement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    var _change = _interopRequireDefault2(require_change());
    var _eventTypes = require_eventTypes();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var InputElement = /* @__PURE__ */ function(Element) {
      _inherits(InputElement2, Element);
      var _super = _createSuper(InputElement2);
      function InputElement2() {
        _classCallCheck(this, InputElement2);
        return _super.apply(this, arguments);
      }
      _createClass(InputElement2, [
        {
          key: "onChange",
          value: function onChange(changeHandler, element) {
            this.on(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
          }
        },
        {
          key: "offChange",
          value: function offChange(changeHandler, element) {
            this.off(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
          }
        },
        {
          key: "onResize",
          value: function onResize(resizeHandler, element) {
          }
        },
        {
          key: "offResize",
          value: function offResize(resizeHandler, element) {
          }
        },
        {
          key: "getValue",
          value: function getValue() {
            return this.domElement.value;
          }
        },
        {
          key: "getSelectionStart",
          value: function getSelectionStart() {
            return this.domElement.selectionStart;
          }
        },
        {
          key: "getSelectionEnd",
          value: function getSelectionEnd() {
            return this.domElement.selectionEnd;
          }
        },
        {
          key: "isReadOnly",
          value: function isReadOnly() {
            return this.domElement.readOnly;
          }
        },
        {
          key: "setValue",
          value: function setValue(value) {
            this.domElement.value = value;
          }
        },
        {
          key: "setSelectionStart",
          value: function setSelectionStart(selectionStart) {
            this.domElement.selectionStart = selectionStart;
          }
        },
        {
          key: "setSelectionEnd",
          value: function setSelectionEnd(selectionEnd) {
            this.domElement.selectionEnd = selectionEnd;
          }
        },
        {
          key: "setReadOnly",
          value: function setReadOnly(readOnly) {
            this.domElement.readOnly = readOnly;
          }
        },
        {
          key: "select",
          value: function select() {
            this.domElement.select();
          }
        }
      ]);
      return InputElement2;
    }(_wrapNativeSuper(_element.default));
    Object.assign(InputElement.prototype, _change.default);
    var _default = InputElement;
    exports.default = _default;
  });

  // node_modules/easy/lib/inputElement/input.js
  var require_input = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _inputElement = _interopRequireDefault2(require_inputElement());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Input = /* @__PURE__ */ function(InputElement) {
      _inherits(Input2, InputElement);
      var _super = _createSuper(Input2);
      function Input2() {
        _classCallCheck(this, Input2);
        return _super.apply(this, arguments);
      }
      return Input2;
    }(_inputElement.default);
    _defineProperty(Input, "tagName", "input");
    exports.default = Input;
  });

  // node_modules/easy/lib/element/button.js
  var require_button = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Button = /* @__PURE__ */ function(Element) {
      _inherits(Button2, Element);
      var _super = _createSuper(Button2);
      function Button2() {
        _classCallCheck(this, Button2);
        return _super.apply(this, arguments);
      }
      return Button2;
    }(_wrapNativeSuper(_element.default));
    _defineProperty(Button, "tagName", "button");
    exports.default = Button;
  });

  // node_modules/easy/lib/element/select.js
  var require_select = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    var _change = _interopRequireDefault2(require_change());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Select = /* @__PURE__ */ function(Element) {
      _inherits(Select2, Element);
      var _super = _createSuper(Select2);
      function Select2() {
        _classCallCheck(this, Select2);
        return _super.apply(this, arguments);
      }
      _createClass(Select2, [
        {
          key: "onResize",
          value: function onResize(resizeHandler, element) {
          }
        },
        {
          key: "offResize",
          value: function offResize(resizeHandler, element) {
          }
        },
        {
          key: "getValue",
          value: function getValue() {
            return this.domElement.value;
          }
        },
        {
          key: "setValue",
          value: function setValue(value) {
            this.domElement.value = value;
          }
        }
      ]);
      return Select2;
    }(_wrapNativeSuper(_element.default));
    _defineProperty(Select, "tagName", "select");
    Object.assign(Select.prototype, _change.default);
    var _default = Select;
    exports.default = _default;
  });

  // node_modules/easy/lib/element/checkbox.js
  var require_checkbox = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _element = _interopRequireDefault2(require_element2());
    var _change = _interopRequireDefault2(require_change());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Checkbox = /* @__PURE__ */ function(Element) {
      _inherits(Checkbox2, Element);
      var _super = _createSuper(Checkbox2);
      function Checkbox2() {
        _classCallCheck(this, Checkbox2);
        return _super.apply(this, arguments);
      }
      _createClass(Checkbox2, [
        {
          key: "isChecked",
          value: function isChecked() {
            return this.domElement.checked;
          }
        },
        {
          key: "check",
          value: function check() {
            var checked = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            this.domElement.checked = checked;
          }
        }
      ]);
      return Checkbox2;
    }(_wrapNativeSuper(_element.default));
    _defineProperty(Checkbox, "tagName", "input");
    _defineProperty(Checkbox, "defaultProperties", {
      type: "checkbox"
    });
    Object.assign(Checkbox.prototype, _change.default);
    var _default = Checkbox;
    exports.default = _default;
  });

  // node_modules/easy/lib/inputElement/textarea.js
  var require_textarea = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _inputElement = _interopRequireDefault2(require_inputElement());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var Textarea = /* @__PURE__ */ function(InputElement) {
      _inherits(Textarea2, InputElement);
      var _super = _createSuper(Textarea2);
      function Textarea2() {
        _classCallCheck(this, Textarea2);
        return _super.apply(this, arguments);
      }
      return Textarea2;
    }(_inputElement.default);
    _defineProperty(Textarea, "tagName", "textarea");
    exports.default = Textarea;
  });

  // node_modules/easy/lib/mixins/window.js
  var require_window = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _resize = require_resize();
    var _default = {
      onResize: _resize.onResize,
      offResize: _resize.offResize
    };
    exports.default = _default;
  });

  // node_modules/easy/lib/window.js
  var require_window2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _key = _interopRequireDefault2(require_key());
    var _event = _interopRequireDefault2(require_event());
    var _mouse = _interopRequireDefault2(require_mouse());
    var _click = _interopRequireDefault2(require_click());
    var _window = _interopRequireDefault2(require_window());
    var _constants = require_constants();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    var Window = /* @__PURE__ */ function() {
      function Window2() {
        _classCallCheck(this, Window2);
        this.domElement = window;
      }
      _createClass(Window2, [
        {
          key: "assign",
          value: function assign() {
            for (var _len = arguments.length, sources = new Array(_len), _key1 = 0; _key1 < _len; _key1++) {
              sources[_key1] = arguments[_key1];
            }
            var _Object;
            var target = this.domElement;
            (_Object = Object).assign.apply(_Object, [
              target
            ].concat(_toConsumableArray(sources)));
          }
        },
        {
          key: "addResizeObject",
          value: function addResizeObject() {
          }
        },
        {
          key: "removeResizeObject",
          value: function removeResizeObject() {
          }
        },
        {
          key: "getWidth",
          value: function getWidth() {
            return this.domElement.innerWidth;
          }
        },
        {
          key: "getHeight",
          value: function getHeight() {
            return this.domElement.innerHeight;
          }
        },
        {
          key: "getScrollTop",
          value: function getScrollTop() {
            return this.domElement.pageYOffset;
          }
        },
        {
          key: "getScrollLeft",
          value: function getScrollLeft() {
            return this.domElement.pageXOffset;
          }
        }
      ]);
      return Window2;
    }();
    Object.assign(Window.prototype, _key.default);
    Object.assign(Window.prototype, _event.default);
    Object.assign(Window.prototype, _mouse.default);
    Object.assign(Window.prototype, _click.default);
    Object.assign(Window.prototype, _window.default);
    var _default = (typeof window === "undefined" ? "undefined" : _typeof(window)) === _constants.UNDEFINED ? void 0 : new Window();
    exports.default = _default;
  });

  // node_modules/easy/lib/buttons.js
  var require_buttons = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.MIDDLE_MOUSE_BUTTON = exports.RIGHT_MOUSE_BUTTON = exports.LEFT_MOUSE_BUTTON = void 0;
    var LEFT_MOUSE_BUTTON = 0;
    exports.LEFT_MOUSE_BUTTON = LEFT_MOUSE_BUTTON;
    var RIGHT_MOUSE_BUTTON = 2;
    exports.RIGHT_MOUSE_BUTTON = RIGHT_MOUSE_BUTTON;
    var MIDDLE_MOUSE_BUTTON = 1;
    exports.MIDDLE_MOUSE_BUTTON = MIDDLE_MOUSE_BUTTON;
    var _default = {
      LEFT_MOUSE_BUTTON,
      RIGHT_MOUSE_BUTTON,
      MIDDLE_MOUSE_BUTTON
    };
    exports.default = _default;
  });

  // node_modules/easy/lib/document.js
  var require_document = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _key = _interopRequireDefault2(require_key());
    var _click = _interopRequireDefault2(require_click());
    var _event = _interopRequireDefault2(require_event());
    var _mouse = _interopRequireDefault2(require_mouse());
    var _constants = require_constants();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    var Document = function Document2() {
      _classCallCheck(this, Document2);
      this.domElement = document;
    };
    var _default = (typeof document === "undefined" ? "undefined" : _typeof(document)) === _constants.UNDEFINED ? void 0 : new Document();
    exports.default = _default;
    Object.assign(Document.prototype, _key.default);
    Object.assign(Document.prototype, _click.default);
    Object.assign(Document.prototype, _event.default);
    Object.assign(Document.prototype, _mouse.default);
  });

  // node_modules/easy/lib/index.js
  var require_lib = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "React", {
      enumerable: true,
      get: function() {
        return _react.default;
      }
    });
    Object.defineProperty(exports, "Bounds", {
      enumerable: true,
      get: function() {
        return _bounds.default;
      }
    });
    Object.defineProperty(exports, "Offset", {
      enumerable: true,
      get: function() {
        return _offset.default;
      }
    });
    Object.defineProperty(exports, "Body", {
      enumerable: true,
      get: function() {
        return _body.default;
      }
    });
    Object.defineProperty(exports, "Link", {
      enumerable: true,
      get: function() {
        return _link.default;
      }
    });
    Object.defineProperty(exports, "Input", {
      enumerable: true,
      get: function() {
        return _input.default;
      }
    });
    Object.defineProperty(exports, "Button", {
      enumerable: true,
      get: function() {
        return _button.default;
      }
    });
    Object.defineProperty(exports, "Select", {
      enumerable: true,
      get: function() {
        return _select.default;
      }
    });
    Object.defineProperty(exports, "Element", {
      enumerable: true,
      get: function() {
        return _element.default;
      }
    });
    Object.defineProperty(exports, "Checkbox", {
      enumerable: true,
      get: function() {
        return _checkbox.default;
      }
    });
    Object.defineProperty(exports, "Textarea", {
      enumerable: true,
      get: function() {
        return _textarea.default;
      }
    });
    Object.defineProperty(exports, "TextElement", {
      enumerable: true,
      get: function() {
        return _textElement.default;
      }
    });
    Object.defineProperty(exports, "InputElement", {
      enumerable: true,
      get: function() {
        return _inputElement.default;
      }
    });
    Object.defineProperty(exports, "window", {
      enumerable: true,
      get: function() {
        return _window.default;
      }
    });
    Object.defineProperty(exports, "buttons", {
      enumerable: true,
      get: function() {
        return _buttons.default;
      }
    });
    Object.defineProperty(exports, "document", {
      enumerable: true,
      get: function() {
        return _document.default;
      }
    });
    Object.defineProperty(exports, "eventTypes", {
      enumerable: true,
      get: function() {
        return _eventTypes.default;
      }
    });
    var _react = _interopRequireDefault2(require_react());
    var _bounds = _interopRequireDefault2(require_bounds());
    var _offset = _interopRequireDefault2(require_offset());
    var _body = _interopRequireDefault2(require_body());
    var _link = _interopRequireDefault2(require_link());
    var _input = _interopRequireDefault2(require_input());
    var _button = _interopRequireDefault2(require_button());
    var _select = _interopRequireDefault2(require_select());
    var _element = _interopRequireDefault2(require_element2());
    var _checkbox = _interopRequireDefault2(require_checkbox());
    var _textarea = _interopRequireDefault2(require_textarea());
    var _textElement = _interopRequireDefault2(require_textElement());
    var _inputElement = _interopRequireDefault2(require_inputElement());
    var _window = _interopRequireDefault2(require_window2());
    var _buttons = _interopRequireDefault2(require_buttons());
    var _document = _interopRequireDefault2(require_document());
    var _eventTypes = _interopRequireDefault2(require_eventTypes());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/juxtapose/lib/juxtapose.js
  var require_juxtapose = __commonJS(() => {
    "use strict";
    var _easy2 = require_lib();
    _easy2.window.assign({
      React: _easy2.React
    });
  });

  // node_modules/juxtapose/lib/index.js
  var require_lib2 = __commonJS(() => {
    "use strict";
    require_juxtapose();
  });

  // node_modules/with-style/lib/tagNames.js
  var require_tagNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tagNames = [
      "a",
      "abbr",
      "address",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ];
    var _default = tagNames;
    exports.default = _default;
  });

  // node_modules/necessary/lib/levels.js
  var require_levels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.FATAL_LEVEL = exports.ERROR_LEVEL = exports.WARNING_LEVEL = exports.INFO_LEVEL = exports.DEBUG_LEVEL = exports.TRACE_LEVEL = void 0;
    var TRACE_LEVEL = "trace";
    exports.TRACE_LEVEL = TRACE_LEVEL;
    var DEBUG_LEVEL = "debug";
    exports.DEBUG_LEVEL = DEBUG_LEVEL;
    var INFO_LEVEL = "info";
    exports.INFO_LEVEL = INFO_LEVEL;
    var WARNING_LEVEL = "warning";
    exports.WARNING_LEVEL = WARNING_LEVEL;
    var ERROR_LEVEL = "error";
    exports.ERROR_LEVEL = ERROR_LEVEL;
    var FATAL_LEVEL = "fatal";
    exports.FATAL_LEVEL = FATAL_LEVEL;
    var _default = {
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL,
      FATAL_LEVEL
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/methods.js
  var require_methods = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.OPTIONS_METHOD = exports.DELETE_METHOD = exports.PATCH_METHOD = exports.POST_METHOD = exports.GET_METHOD = void 0;
    var GET_METHOD = "GET";
    exports.GET_METHOD = GET_METHOD;
    var POST_METHOD = "POST";
    exports.POST_METHOD = POST_METHOD;
    var PATCH_METHOD = "PATCH";
    exports.PATCH_METHOD = PATCH_METHOD;
    var DELETE_METHOD = "DELETE";
    exports.DELETE_METHOD = DELETE_METHOD;
    var OPTIONS_METHOD = "OPTIONS";
    exports.OPTIONS_METHOD = OPTIONS_METHOD;
    var _default = {
      GET_METHOD,
      POST_METHOD,
      PATCH_METHOD,
      DELETE_METHOD,
      OPTIONS_METHOD
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/headers.js
  var require_headers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ACCESS_CONTROL_REQUEST_METHOD_HEADER = exports.ACCESS_CONTROL_ALLOW_HEADERS_HEADER = exports.ACCESS_CONTROL_ALLOW_METHODS_HEADER = exports.ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = exports.CONTENT_DISPOSITION_HEADER = exports.TRANSFER_ENCODING_HEADER = exports.CONTENT_LENGTH_HEADER = exports.CACHE_CONTROL_HEADER = exports.AUTHORIZATION_HEADER = exports.CONTENT_TYPE_HEADER = exports.USER_AGENT_HEADER = exports.LOCATION_HEADER = exports.ACCEPT_HEADER = exports.PRAGMA_HEADER = void 0;
    var PRAGMA_HEADER = "pragma";
    exports.PRAGMA_HEADER = PRAGMA_HEADER;
    var ACCEPT_HEADER = "accept";
    exports.ACCEPT_HEADER = ACCEPT_HEADER;
    var LOCATION_HEADER = "location";
    exports.LOCATION_HEADER = LOCATION_HEADER;
    var USER_AGENT_HEADER = "user-agent";
    exports.USER_AGENT_HEADER = USER_AGENT_HEADER;
    var CONTENT_TYPE_HEADER = "content-type";
    exports.CONTENT_TYPE_HEADER = CONTENT_TYPE_HEADER;
    var AUTHORIZATION_HEADER = "authorization";
    exports.AUTHORIZATION_HEADER = AUTHORIZATION_HEADER;
    var CACHE_CONTROL_HEADER = "cache-control";
    exports.CACHE_CONTROL_HEADER = CACHE_CONTROL_HEADER;
    var CONTENT_LENGTH_HEADER = "content-length";
    exports.CONTENT_LENGTH_HEADER = CONTENT_LENGTH_HEADER;
    var TRANSFER_ENCODING_HEADER = "transfer-encoding";
    exports.TRANSFER_ENCODING_HEADER = TRANSFER_ENCODING_HEADER;
    var CONTENT_DISPOSITION_HEADER = "content-disposition";
    exports.CONTENT_DISPOSITION_HEADER = CONTENT_DISPOSITION_HEADER;
    var ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = "access-control-allow-origin";
    exports.ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = ACCESS_CONTROL_ALLOW_ORIGIN_HEADER;
    var ACCESS_CONTROL_ALLOW_METHODS_HEADER = "access-control-allow-methods";
    exports.ACCESS_CONTROL_ALLOW_METHODS_HEADER = ACCESS_CONTROL_ALLOW_METHODS_HEADER;
    var ACCESS_CONTROL_ALLOW_HEADERS_HEADER = "access-control-allow-headers";
    exports.ACCESS_CONTROL_ALLOW_HEADERS_HEADER = ACCESS_CONTROL_ALLOW_HEADERS_HEADER;
    var ACCESS_CONTROL_REQUEST_METHOD_HEADER = "access-control-request-method";
    exports.ACCESS_CONTROL_REQUEST_METHOD_HEADER = ACCESS_CONTROL_REQUEST_METHOD_HEADER;
    var _default = {
      PRAGMA_HEADER,
      ACCEPT_HEADER,
      LOCATION_HEADER,
      USER_AGENT_HEADER,
      CONTENT_TYPE_HEADER,
      AUTHORIZATION_HEADER,
      CACHE_CONTROL_HEADER,
      CONTENT_LENGTH_HEADER,
      TRANSFER_ENCODING_HEADER,
      CONTENT_DISPOSITION_HEADER,
      ACCESS_CONTROL_ALLOW_ORIGIN_HEADER,
      ACCESS_CONTROL_ALLOW_METHODS_HEADER,
      ACCESS_CONTROL_ALLOW_HEADERS_HEADER,
      ACCESS_CONTROL_REQUEST_METHOD_HEADER
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/keyCodes.js
  var require_keyCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ESCAPE_KEYCODE = exports.SHIFT_KEY_CODE = void 0;
    var SHIFT_KEY_CODE = 16;
    exports.SHIFT_KEY_CODE = SHIFT_KEY_CODE;
    var ESCAPE_KEYCODE = 27;
    exports.ESCAPE_KEYCODE = ESCAPE_KEYCODE;
    var _default = {
      SHIFT_KEY_CODE,
      ESCAPE_KEYCODE
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/encodings.js
  var require_encodings = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.BASE64_ENCODING = exports.UTF_8_ENCODING = exports.UTF8_ENCODING = void 0;
    var UTF8_ENCODING = "utf8";
    exports.UTF8_ENCODING = UTF8_ENCODING;
    var UTF_8_ENCODING = "utf-8";
    exports.UTF_8_ENCODING = UTF_8_ENCODING;
    var BASE64_ENCODING = "base64";
    exports.BASE64_ENCODING = BASE64_ENCODING;
    var _default = {
      UTF8_ENCODING,
      UTF_8_ENCODING,
      BASE64_ENCODING
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/characters.js
  var require_characters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.EXCLAMATION_MARK_CHARACTER = exports.CARRIAGE_RETURN_CHARACTER = exports.FORWARD_SLASH_CHARACTER = exports.GREATER_THAN_CHARACTER = exports.LESS_THAN_CHARACTER = exports.AMPERSAND_CHARACTER = exports.BACKSPACE_CHARACTER = exports.NEW_LINE_CHARACTER = exports.BACKTICK_DELIMITER = exports.WILDCARD_CHARACTER = exports.CTRL_C_CHARACTER = exports.PERIOD_CHARACTER = exports.COLON_CHARACTER = exports.COMMA_CHARACTER = exports.SPACE_CHARACTER = exports.DASH_CHARACTER = exports.BAR_CHARACTER = exports.ETX_CHARACTER = void 0;
    var ETX_CHARACTER = "";
    exports.ETX_CHARACTER = ETX_CHARACTER;
    var BAR_CHARACTER = "|";
    exports.BAR_CHARACTER = BAR_CHARACTER;
    var DASH_CHARACTER = "-";
    exports.DASH_CHARACTER = DASH_CHARACTER;
    var SPACE_CHARACTER = " ";
    exports.SPACE_CHARACTER = SPACE_CHARACTER;
    var COMMA_CHARACTER = ",";
    exports.COMMA_CHARACTER = COMMA_CHARACTER;
    var COLON_CHARACTER = ":";
    exports.COLON_CHARACTER = COLON_CHARACTER;
    var PERIOD_CHARACTER = ".";
    exports.PERIOD_CHARACTER = PERIOD_CHARACTER;
    var CTRL_C_CHARACTER = "^C";
    exports.CTRL_C_CHARACTER = CTRL_C_CHARACTER;
    var WILDCARD_CHARACTER = "*";
    exports.WILDCARD_CHARACTER = WILDCARD_CHARACTER;
    var BACKTICK_DELIMITER = "`";
    exports.BACKTICK_DELIMITER = BACKTICK_DELIMITER;
    var NEW_LINE_CHARACTER = "\n";
    exports.NEW_LINE_CHARACTER = NEW_LINE_CHARACTER;
    var BACKSPACE_CHARACTER = String.fromCharCode(127);
    exports.BACKSPACE_CHARACTER = BACKSPACE_CHARACTER;
    var AMPERSAND_CHARACTER = "&";
    exports.AMPERSAND_CHARACTER = AMPERSAND_CHARACTER;
    var LESS_THAN_CHARACTER = "&lt;";
    exports.LESS_THAN_CHARACTER = LESS_THAN_CHARACTER;
    var GREATER_THAN_CHARACTER = "&gt;";
    exports.GREATER_THAN_CHARACTER = GREATER_THAN_CHARACTER;
    var FORWARD_SLASH_CHARACTER = "/";
    exports.FORWARD_SLASH_CHARACTER = FORWARD_SLASH_CHARACTER;
    var CARRIAGE_RETURN_CHARACTER = "\r";
    exports.CARRIAGE_RETURN_CHARACTER = CARRIAGE_RETURN_CHARACTER;
    var EXCLAMATION_MARK_CHARACTER = "!";
    exports.EXCLAMATION_MARK_CHARACTER = EXCLAMATION_MARK_CHARACTER;
    var _default = {
      ETX_CHARACTER,
      BAR_CHARACTER,
      DASH_CHARACTER,
      SPACE_CHARACTER,
      COMMA_CHARACTER,
      COLON_CHARACTER,
      PERIOD_CHARACTER,
      CTRL_C_CHARACTER,
      WILDCARD_CHARACTER,
      BACKTICK_DELIMITER,
      NEW_LINE_CHARACTER,
      AMPERSAND_CHARACTER,
      BACKSPACE_CHARACTER,
      LESS_THAN_CHARACTER,
      GREATER_THAN_CHARACTER,
      FORWARD_SLASH_CHARACTER,
      CARRIAGE_RETURN_CHARACTER,
      EXCLAMATION_MARK_CHARACTER
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/statusCodes.js
  var require_statusCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.INTERNAL_SERVER_ERROR_500_STATUS_CODE = exports.TOO_MANY_REQUESTS_429_STATUS_CODE = exports.UNAUTHORISED_401_STATUS_CODE = exports.BAD_REQUEST_400_STATUS_CODE = exports.BAD_GATEWAY_502_STATUS_CODE = exports.NO_CONTENT_204_STATUS_CODE = exports.NOT_FOUND_404_STATUS_CODE = exports.FORBIDDEN_403_STATUS_CODE = exports.SEE_OTHER_303_STATUS_CODE = exports.CREATED_201_STATUS_CODE = exports.FOUND_302_STATUS_CODE = exports.OK_200_STATUS_CODE = exports.ZERO_0_STATUS_CODE = void 0;
    var ZERO_0_STATUS_CODE = 0;
    exports.ZERO_0_STATUS_CODE = ZERO_0_STATUS_CODE;
    var OK_200_STATUS_CODE = 200;
    exports.OK_200_STATUS_CODE = OK_200_STATUS_CODE;
    var FOUND_302_STATUS_CODE = 302;
    exports.FOUND_302_STATUS_CODE = FOUND_302_STATUS_CODE;
    var CREATED_201_STATUS_CODE = 201;
    exports.CREATED_201_STATUS_CODE = CREATED_201_STATUS_CODE;
    var SEE_OTHER_303_STATUS_CODE = 303;
    exports.SEE_OTHER_303_STATUS_CODE = SEE_OTHER_303_STATUS_CODE;
    var FORBIDDEN_403_STATUS_CODE = 403;
    exports.FORBIDDEN_403_STATUS_CODE = FORBIDDEN_403_STATUS_CODE;
    var NOT_FOUND_404_STATUS_CODE = 404;
    exports.NOT_FOUND_404_STATUS_CODE = NOT_FOUND_404_STATUS_CODE;
    var NO_CONTENT_204_STATUS_CODE = 204;
    exports.NO_CONTENT_204_STATUS_CODE = NO_CONTENT_204_STATUS_CODE;
    var BAD_GATEWAY_502_STATUS_CODE = 502;
    exports.BAD_GATEWAY_502_STATUS_CODE = BAD_GATEWAY_502_STATUS_CODE;
    var BAD_REQUEST_400_STATUS_CODE = 400;
    exports.BAD_REQUEST_400_STATUS_CODE = BAD_REQUEST_400_STATUS_CODE;
    var UNAUTHORISED_401_STATUS_CODE = 401;
    exports.UNAUTHORISED_401_STATUS_CODE = UNAUTHORISED_401_STATUS_CODE;
    var TOO_MANY_REQUESTS_429_STATUS_CODE = 429;
    exports.TOO_MANY_REQUESTS_429_STATUS_CODE = TOO_MANY_REQUESTS_429_STATUS_CODE;
    var INTERNAL_SERVER_ERROR_500_STATUS_CODE = 500;
    exports.INTERNAL_SERVER_ERROR_500_STATUS_CODE = INTERNAL_SERVER_ERROR_500_STATUS_CODE;
    var _default = {
      ZERO_0_STATUS_CODE,
      OK_200_STATUS_CODE,
      FOUND_302_STATUS_CODE,
      CREATED_201_STATUS_CODE,
      SEE_OTHER_303_STATUS_CODE,
      FORBIDDEN_403_STATUS_CODE,
      NOT_FOUND_404_STATUS_CODE,
      NO_CONTENT_204_STATUS_CODE,
      BAD_GATEWAY_502_STATUS_CODE,
      BAD_REQUEST_400_STATUS_CODE,
      UNAUTHORISED_401_STATUS_CODE,
      TOO_MANY_REQUESTS_429_STATUS_CODE,
      INTERNAL_SERVER_ERROR_500_STATUS_CODE
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/contentTypes.js
  var require_contentTypes2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE = exports.APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE = exports.TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE = exports.TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE = exports.APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE = exports.APPLICATION_JSON_CONTENT_TYPE = exports.TEXT_PLAIN_CONTENT_TYPE = exports.TEXT_HTML_CONTENT_TYPE = void 0;
    var TEXT_HTML_CONTENT_TYPE = "text/html";
    exports.TEXT_HTML_CONTENT_TYPE = TEXT_HTML_CONTENT_TYPE;
    var TEXT_PLAIN_CONTENT_TYPE = "text/plain";
    exports.TEXT_PLAIN_CONTENT_TYPE = TEXT_PLAIN_CONTENT_TYPE;
    var APPLICATION_JSON_CONTENT_TYPE = "application/json";
    exports.APPLICATION_JSON_CONTENT_TYPE = APPLICATION_JSON_CONTENT_TYPE;
    var APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE = "application/x-www-form-urlencoded";
    exports.APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE = APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE;
    var TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE = "text/html; charset=utf-8";
    exports.TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE = TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE;
    var TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE = "text/plain; charset=utf-8";
    exports.TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE = TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE;
    var APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE = "application/json; charset=utf-8";
    exports.APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE = APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE;
    var APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE = "application/x-www-form-urlencoded; charset=utf-8";
    exports.APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE = APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE;
    var _default = {
      TEXT_HTML_CONTENT_TYPE,
      TEXT_PLAIN_CONTENT_TYPE,
      APPLICATION_JSON_CONTENT_TYPE,
      APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE,
      TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE,
      TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/statusMessages.js
  var require_statusMessages = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE = exports.TOO_MANY_REQUESTS_429_STATUS_MESSAGE = exports.UNAUTHORISED_401_STATUS_MESSAGE = exports.BAD_REQUEST_400_STATUS_MESSAGE = exports.BAD_GATEWAY_502_STATUS_MESSAGE = exports.NO_CONTENT_204_STATUS_MESSAGE = exports.NOT_FOUND_404_STATUS_MESSAGE = exports.FORBIDDEN_403_STATUS_MESSAGE = exports.SEE_OTHER_303_STATUS_MESSAGE = exports.CREATED_201_STATUS_MESSAGE = exports.FOUND_302_STATUS_MESSAGE = exports.OK_200_STATUS_MESSAGE = void 0;
    var OK_200_STATUS_MESSAGE = "OK";
    exports.OK_200_STATUS_MESSAGE = OK_200_STATUS_MESSAGE;
    var FOUND_302_STATUS_MESSAGE = "Found";
    exports.FOUND_302_STATUS_MESSAGE = FOUND_302_STATUS_MESSAGE;
    var CREATED_201_STATUS_MESSAGE = "Created";
    exports.CREATED_201_STATUS_MESSAGE = CREATED_201_STATUS_MESSAGE;
    var SEE_OTHER_303_STATUS_MESSAGE = "See other";
    exports.SEE_OTHER_303_STATUS_MESSAGE = SEE_OTHER_303_STATUS_MESSAGE;
    var FORBIDDEN_403_STATUS_MESSAGE = "Forbidden";
    exports.FORBIDDEN_403_STATUS_MESSAGE = FORBIDDEN_403_STATUS_MESSAGE;
    var NOT_FOUND_404_STATUS_MESSAGE = "Not found";
    exports.NOT_FOUND_404_STATUS_MESSAGE = NOT_FOUND_404_STATUS_MESSAGE;
    var NO_CONTENT_204_STATUS_MESSAGE = "No content";
    exports.NO_CONTENT_204_STATUS_MESSAGE = NO_CONTENT_204_STATUS_MESSAGE;
    var BAD_GATEWAY_502_STATUS_MESSAGE = "Bad gateway";
    exports.BAD_GATEWAY_502_STATUS_MESSAGE = BAD_GATEWAY_502_STATUS_MESSAGE;
    var BAD_REQUEST_400_STATUS_MESSAGE = "Bad request";
    exports.BAD_REQUEST_400_STATUS_MESSAGE = BAD_REQUEST_400_STATUS_MESSAGE;
    var UNAUTHORISED_401_STATUS_MESSAGE = "Unauthorised";
    exports.UNAUTHORISED_401_STATUS_MESSAGE = UNAUTHORISED_401_STATUS_MESSAGE;
    var TOO_MANY_REQUESTS_429_STATUS_MESSAGE = "Too many requests";
    exports.TOO_MANY_REQUESTS_429_STATUS_MESSAGE = TOO_MANY_REQUESTS_429_STATUS_MESSAGE;
    var INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE = "Internal server error";
    exports.INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE = INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE;
    var _default = {
      OK_200_STATUS_MESSAGE,
      FOUND_302_STATUS_MESSAGE,
      CREATED_201_STATUS_MESSAGE,
      SEE_OTHER_303_STATUS_MESSAGE,
      FORBIDDEN_403_STATUS_MESSAGE,
      NOT_FOUND_404_STATUS_MESSAGE,
      NO_CONTENT_204_STATUS_MESSAGE,
      BAD_GATEWAY_502_STATUS_MESSAGE,
      BAD_REQUEST_400_STATUS_MESSAGE,
      UNAUTHORISED_401_STATUS_MESSAGE,
      TOO_MANY_REQUESTS_429_STATUS_MESSAGE,
      INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/utilities/array.js
  var require_array2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.first = first;
    exports.second = second;
    exports.third = third;
    exports.fourth = fourth;
    exports.fifth = fifth;
    exports.fifthLast = fifthLast;
    exports.fourthLast = fourthLast;
    exports.thirdLast = thirdLast;
    exports.secondLast = secondLast;
    exports.firstLast = firstLast;
    exports.last = last;
    exports.head = head;
    exports.tail = tail;
    exports.back = back;
    exports.front = front;
    exports.push = push;
    exports.unshift = unshift;
    exports.concat = concat;
    exports.clear = clear;
    exports.copy = copy;
    exports.merge = merge;
    exports.splice = splice;
    exports.replace = replace;
    exports.filter = filter;
    exports.find = find;
    exports.prune = prune;
    exports.patch = patch;
    exports.augment = augment;
    exports.separate = separate;
    exports.forwardsSome = forwardsSome;
    exports.backwardsSome = backwardsSome;
    exports.forwardsEvery = forwardsEvery;
    exports.backwardsEvery = backwardsEvery;
    exports.forwardsReduce = forwardsReduce;
    exports.backwardsReduce = backwardsReduce;
    exports.forwardsForEach = forwardsForEach;
    exports.backwardsForEach = backwardsForEach;
    exports.default = void 0;
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function first(array) {
      return array[0];
    }
    function second(array) {
      return array[1];
    }
    function third(array) {
      return array[2];
    }
    function fourth(array) {
      return array[3];
    }
    function fifth(array) {
      return array[4];
    }
    function fifthLast(array) {
      return array[array.length - 5];
    }
    function fourthLast(array) {
      return array[array.length - 4];
    }
    function thirdLast(array) {
      return array[array.length - 3];
    }
    function secondLast(array) {
      return array[array.length - 2];
    }
    function firstLast(array) {
      return array[array.length - 1];
    }
    function last(array) {
      return array[array.length - 1];
    }
    function head(array) {
      return array.slice(0, 1);
    }
    function tail(array) {
      return array.slice(1);
    }
    function back(array) {
      return array.slice(array.length - 1);
    }
    function front(array) {
      return array.slice(0, array.length - 1);
    }
    function push(array1, array2) {
      Array.prototype.push.apply(array1, array2);
    }
    function unshift(array1, array2) {
      Array.prototype.unshift.apply(array1, array2);
    }
    function concat(array1, elementOrArray2) {
      var array2 = _instanceof(elementOrArray2, Array) ? elementOrArray2 : [
        elementOrArray2
      ];
      push(array1, array2);
    }
    function clear(array) {
      var start = 0;
      return array.splice(start);
    }
    function copy(array1, array2) {
      var start = 0, deleteCount = array2.length;
      splice(array1, start, deleteCount, array2);
    }
    function merge(array1, array2) {
      Array.prototype.push.apply(array1, array2);
    }
    function splice(array1, start) {
      var deleteCount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity, array2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var args = [
        start,
        deleteCount
      ].concat(_toConsumableArray(array2)), deletedItemsArray = Array.prototype.splice.apply(array1, args);
      return deletedItemsArray;
    }
    function replace(array, element1, test) {
      var start;
      var found = array.some(function(element, index) {
        var passed = test(element, index);
        if (passed) {
          start = index;
          return true;
        }
      });
      if (found) {
        var deleteCount = 1;
        array.splice(start, deleteCount, element1);
      }
      return found;
    }
    function filter(array, test) {
      var filteredElements = [];
      backwardsForEach(array, function(element, index) {
        var passed = test(element, index);
        if (!passed) {
          var start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first(deletedElements);
          filteredElements.unshift(firstDeletedElement);
        }
      });
      return filteredElements;
    }
    function find(array, test) {
      var elements = [];
      forwardsForEach(array, function(element, index) {
        var passed = test(element, index);
        if (passed) {
          elements.push(element);
        }
      });
      return elements;
    }
    function prune(array, test) {
      var prunedElement = void 0;
      array.some(function(element, index) {
        var passed = test(element, index);
        if (!passed) {
          var start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first(deletedElements);
          prunedElement = firstDeletedElement;
          return true;
        }
      });
      return prunedElement;
    }
    function patch(array, element2, test) {
      var found = array.some(function(element, index) {
        var passed = test(element, index);
        if (passed) {
          return true;
        }
      });
      if (found) {
        array.push(element2);
      }
      return found;
    }
    function augment(array1, array2, test) {
      array2.forEach(function(element, index) {
        var passed = test(element, index);
        if (passed) {
          array1.push(element);
        }
      });
    }
    function separate(array, array1, array2, test) {
      array.forEach(function(element, index) {
        var passed = test(element, index);
        passed ? array1.push(element) : array2.push(element);
      });
    }
    function forwardsSome(array, callback) {
      var arrayLength = array.length;
      for (var index = 0; index < arrayLength; index++) {
        var element = array[index], result = callback(element, index);
        if (result) {
          return true;
        }
      }
      return false;
    }
    function backwardsSome(array, callback) {
      var arrayLength = array.length;
      for (var index = arrayLength - 1; index >= 0; index--) {
        var element = array[index], result = callback(element, index);
        if (result) {
          return true;
        }
      }
      return false;
    }
    function forwardsEvery(array, callback) {
      var arrayLength = array.length;
      for (var index = 0; index < arrayLength; index++) {
        var element = array[index], result = callback(element, index);
        if (!result) {
          return false;
        }
      }
      return true;
    }
    function backwardsEvery(array, callback) {
      var arrayLength = array.length;
      for (var index = arrayLength - 1; index >= 0; index--) {
        var element = array[index], result = callback(element, index);
        if (!result) {
          return false;
        }
      }
      return true;
    }
    function forwardsReduce(array, callback, initialValue) {
      var value = initialValue;
      forwardsForEach(array, function(element, index) {
        value = callback(value, element, index);
      });
      return value;
    }
    function backwardsReduce(array, callback, initialValue) {
      var value = initialValue;
      backwardsForEach(array, function(element, index) {
        value = callback(value, element, index);
      });
      return value;
    }
    function forwardsForEach(array, callback) {
      var arrayLength = array.length;
      for (var index = 0; index < arrayLength; index++) {
        var element = array[index];
        callback(element, index);
      }
    }
    function backwardsForEach(array, callback) {
      var arrayLength = array.length;
      for (var index = arrayLength - 1; index >= 0; index--) {
        var element = array[index];
        callback(element, index);
      }
    }
    var _default = {
      first,
      second,
      third,
      fourth,
      fifth,
      fifthLast,
      fourthLast,
      thirdLast,
      secondLast,
      firstLast,
      last,
      head,
      tail,
      back,
      front,
      push,
      unshift,
      concat,
      clear,
      copy,
      merge,
      splice,
      replace,
      filter,
      find,
      prune,
      patch,
      augment,
      separate,
      forwardsSome,
      backwardsSome,
      forwardsEvery,
      backwardsEvery,
      forwardsReduce,
      backwardsReduce,
      forwardsForEach,
      backwardsForEach
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/constants.js
  var require_constants2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EMPTY_STRING = exports.ENVIRONMENT = exports.DEFAULT = exports.BOOLEAN = exports.NUMBER = exports.STRING = exports.ERROR = exports.DATA = void 0;
    var DATA = "data";
    exports.DATA = DATA;
    var ERROR = "error";
    exports.ERROR = ERROR;
    var STRING = "string";
    exports.STRING = STRING;
    var NUMBER = "number";
    exports.NUMBER = NUMBER;
    var BOOLEAN = "boolean";
    exports.BOOLEAN = BOOLEAN;
    var DEFAULT = "default";
    exports.DEFAULT = DEFAULT;
    var ENVIRONMENT = "ENVIRONMENT";
    exports.ENVIRONMENT = ENVIRONMENT;
    var EMPTY_STRING = "";
    exports.EMPTY_STRING = EMPTY_STRING;
  });

  // node_modules/necessary/lib/utilities/http.js
  var require_http = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.overwrite = overwrite;
    exports.underwrite = underwrite;
    exports.portFromHost = portFromHost;
    exports.secureFromHost = secureFromHost;
    exports.hostnameFromHost = hostnameFromHost;
    exports.queryStringFromQuery = queryStringFromQuery;
    exports.urlFromHostURIAndQuery = urlFromHostURIAndQuery;
    exports.default = void 0;
    var _array = require_array2();
    var _constants = require_constants2();
    var _characters = require_characters();
    function overwrite(headers, name, value) {
      var lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName1 = existingNames.find(function(existingName) {
        var existingLowerCaseName = existingName.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName1 !== null) {
        headers[existingName1] = value;
      }
    }
    function underwrite(headers, name, value) {
      var lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName2 = existingNames.find(function(existingName) {
        var existingLowerCaseName = existingName.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName2 === null) {
        headers[name] = value;
      }
    }
    function portFromHost(host) {
      var port;
      var matches = host.match(/^https?:\/\/([^\/]+)/), secondMatch = (0, _array).second(matches), index = secondMatch.indexOf(_characters.COLON_CHARACTER);
      if (index === -1) {
        var secure = secureFromHost(host);
        port = secure ? 443 : 80;
      } else {
        var start = index + 1, portString = secondMatch.substring(start);
        port = Number(portString);
      }
      return port;
    }
    function secureFromHost(host) {
      var secure = /^https:\/\//.test(host);
      return secure;
    }
    function hostnameFromHost(host) {
      var matches = host.match(/^https?:\/\/([^:\/]+)/), secondMatch = (0, _array).second(matches), hostname = secondMatch;
      return hostname;
    }
    function queryStringFromQuery(query) {
      var names = Object.keys(query), namesLength = names.length, lastIndex = namesLength - 1, queryString1 = names.reduce(function(queryString, name, index) {
        var value = query[name], encodedName = encodeURIComponent(name), encodedValue = encodeURIComponent(value), ampersandOrNothing = index !== lastIndex ? _characters.AMPERSAND_CHARACTER : _constants.EMPTY_STRING;
        queryString += "".concat(encodedName, "=").concat(encodedValue).concat(ampersandOrNothing);
        return queryString;
      }, _constants.EMPTY_STRING);
      return queryString1;
    }
    function urlFromHostURIAndQuery(host, uri, query) {
      var queryString = queryStringFromQuery(query), url = queryString === _constants.EMPTY_STRING ? "".concat(host).concat(uri) : "".concat(host).concat(uri, "?").concat(queryString);
      return url;
    }
    var _default = {
      overwrite,
      underwrite,
      portFromHost,
      secureFromHost,
      hostnameFromHost,
      queryStringFromQuery,
      urlFromHostURIAndQuery
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/utilities/ajax.js
  var require_ajax = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.get = get;
    exports.post = post;
    exports.request = request;
    exports.default = void 0;
    var _methods = require_methods();
    var _contentTypes = require_contentTypes2();
    var _headers = require_headers();
    var _http = require_http();
    function get(host, uri, query, headers, callback) {
      if (callback === void 0) {
        callback = headers;
        headers = {};
      }
      var method = _methods.GET_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, content = null;
      underwriteAcceptHeader(headers, accept);
      request(host, uri, query, method, headers, content, callback);
    }
    function post(host, uri, query, headers, content, callback) {
      if (callback === void 0) {
        callback = content;
        content = headers;
        headers = {};
      }
      var method = _methods.POST_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, contentType = _contentTypes.APPLICATION_JSON_CONTENT_TYPE;
      underwriteAcceptHeader(headers, accept);
      underwriteContentTypeHeader(headers, contentType);
      request(host, uri, query, method, headers, content, callback);
    }
    function request(host, uri, query, method, headers, content1, callback) {
      var url = (0, _http).urlFromHostURIAndQuery(host, uri, query), accept = headers[_headers.ACCEPT_HEADER] || null, contentType = headers[_headers.CONTENT_TYPE_HEADER] || null, xmlHttpRequest = new XMLHttpRequest();
      if (contentType === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
        var json = content1, jsonString = JSON.stringify(json);
        content1 = jsonString;
      }
      xmlHttpRequest.onreadystatechange = function() {
        var readyState = xmlHttpRequest.readyState, status = xmlHttpRequest.status, response = xmlHttpRequest.response, statusCode = status;
        if (readyState == 4) {
          var content = response;
          if (accept === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
            try {
              var jsonString2 = content, json2 = JSON.parse(jsonString2);
              content = json2;
            } catch (error) {
              content = null;
            }
          }
          callback(content, statusCode);
        }
      };
      xmlHttpRequest.open(method, url);
      if (accept !== null) {
        xmlHttpRequest.setRequestHeader(_headers.ACCEPT_HEADER, accept);
      }
      if (contentType !== null) {
        xmlHttpRequest.setRequestHeader(_headers.CONTENT_TYPE_HEADER, contentType);
      }
      content1 !== null ? xmlHttpRequest.send(content1) : xmlHttpRequest.send();
    }
    var _default = {
      get,
      post,
      request
    };
    exports.default = _default;
    function underwriteAcceptHeader(headers, accept) {
      var name = _headers.ACCEPT_HEADER, value = accept;
      (0, _http).underwrite(headers, name, value);
    }
    function underwriteContentTypeHeader(headers, contentTYpe) {
      var name = _headers.CONTENT_TYPE_HEADER, value = contentTYpe;
      (0, _http).underwrite(headers, name, value);
    }
  });

  // node_modules/necessary/lib/utilities/path.js
  var require_path = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPathName = isPathName;
    exports.isPathTopmostName = isPathTopmostName;
    exports.isPathRelativePath = isPathRelativePath;
    exports.isPathAbsolutePath = isPathAbsolutePath;
    exports.isTopmostNameInAbsolutePath = isTopmostNameInAbsolutePath;
    exports.combinePaths = combinePaths;
    exports.concatenatePaths = concatenatePaths;
    exports.bottommostNameFromPath = bottommostNameFromPath;
    exports.topmostDirectoryPathFromPath = topmostDirectoryPathFromPath;
    exports.topmostDirectoryNameFromPath = topmostDirectoryNameFromPath;
    exports.pathWithoutBottommostNameFromPath = pathWithoutBottommostNameFromPath;
    exports.pathWithoutTopmostDirectoryNameFromPath = pathWithoutTopmostDirectoryNameFromPath;
    exports.default = void 0;
    var _constants = require_constants2();
    var _array = require_array2();
    function isPathName(path) {
      path = path.replace(/^\//, _constants.EMPTY_STRING).replace(/\/$/, _constants.EMPTY_STRING);
      var pathName = /\//.test(path) === false;
      return pathName;
    }
    function isPathTopmostName(path) {
      var pathName = isPathName(path), pathAbsolutePath = isPathAbsolutePath(path), pathTopmostName = pathName && pathAbsolutePath;
      return pathTopmostName;
    }
    function isPathRelativePath(path) {
      var pathRelativePath = !/^\//.test(path);
      return pathRelativePath;
    }
    function isPathAbsolutePath(path) {
      var pathAbsolutePath = /^\//.test(path);
      return pathAbsolutePath;
    }
    function isTopmostNameInAbsolutePath(topmostName, absolutePath) {
      var regExp = new RegExp("^".concat(topmostName, "(?:\\/.+)?$")), topmostNameInAbsolutePath = regExp.test(absolutePath);
      return topmostNameInAbsolutePath;
    }
    function combinePaths(path, relativePath) {
      var combinedPath = null;
      var pathNames = path.split(/\//), relativePathNames = relativePath.split(/\//);
      var lastPathName, firstRelativePathName = (0, _array).first(relativePathNames);
      if (firstRelativePathName === ".") {
        relativePathNames.shift();
      }
      firstRelativePathName = (0, _array).first(relativePathNames);
      lastPathName = (0, _array).last(pathNames);
      while (firstRelativePathName === ".." && lastPathName !== void 0) {
        relativePathNames.shift();
        pathNames.pop();
        firstRelativePathName = (0, _array).first(relativePathNames);
        lastPathName = (0, _array).last(pathNames);
      }
      if (lastPathName !== void 0) {
        var combinedPathNames = [].concat(pathNames).concat(relativePathNames);
        combinedPath = combinedPathNames.join("/");
      }
      return combinedPath;
    }
    function concatenatePaths(path, relativePath) {
      path = path.replace(/\/$/, _constants.EMPTY_STRING);
      var concatenatedPath = "".concat(path, "/").concat(relativePath);
      return concatenatedPath;
    }
    function bottommostNameFromPath(path) {
      var bottommostName = null;
      var matches = path.match(/^.*\/([^\/]+\/?)$/);
      if (matches !== null) {
        var secondMatch = (0, _array).second(matches);
        bottommostName = secondMatch;
      }
      return bottommostName;
    }
    function topmostDirectoryPathFromPath(path) {
      var matches = path.match(/^(.+)\/[^\/]+\/?$/), secondMatch = (0, _array).second(matches), topmostDirectoryPath = secondMatch;
      return topmostDirectoryPath;
    }
    function topmostDirectoryNameFromPath(path) {
      var topmostDirectoryName = null;
      var matches = path.match(/^([^\/]+)\/.+$/);
      if (matches !== null) {
        var secondMatch = (0, _array).second(matches);
        topmostDirectoryName = secondMatch;
      }
      return topmostDirectoryName;
    }
    function pathWithoutBottommostNameFromPath(path) {
      var pathWithoutBottommostName = null;
      var matches = path.match(/^(.*)\/[^\/]+\/?$/);
      if (matches !== null) {
        var secondMatch = (0, _array).second(matches);
        pathWithoutBottommostName = secondMatch;
      }
      return pathWithoutBottommostName;
    }
    function pathWithoutTopmostDirectoryNameFromPath(path) {
      var pathWithoutTopmostDirectoryName = null;
      var matches = path.match(/^[^\/]+\/(.+)$/);
      if (matches !== null) {
        var secondMatch = (0, _array).second(matches);
        pathWithoutTopmostDirectoryName = secondMatch;
      }
      return pathWithoutTopmostDirectoryName;
    }
    var _default = {
      isPathName,
      isPathTopmostName,
      isPathRelativePath,
      isPathAbsolutePath,
      isTopmostNameInAbsolutePath,
      combinePaths,
      concatenatePaths,
      bottommostNameFromPath,
      topmostDirectoryPathFromPath,
      topmostDirectoryNameFromPath,
      pathWithoutBottommostNameFromPath,
      pathWithoutTopmostDirectoryNameFromPath
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/utilities/asynchronous.js
  var require_asynchronous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.whilst = whilst;
    exports.forEach = forEach;
    exports.sequence = sequence;
    exports.eventually = eventually;
    exports.repeatedly = repeatedly;
    exports.forwardsForEach = forwardsForEach;
    exports.backwardsForEach = backwardsForEach;
    exports.default = void 0;
    function whilst(operation, done, context) {
      var count = -1;
      function next() {
        count++;
        var index = count, terminate = operation(next, done, context, index);
        if (terminate) {
          done();
        }
      }
      next();
    }
    function forEach(array, operation, done, context) {
      var length = array.length;
      var count = -1;
      function next() {
        count++;
        var terminate = count === length;
        if (terminate) {
          done();
        } else {
          var index = count, element = array[index];
          operation(element, next, done, context, index);
        }
      }
      next();
    }
    function sequence(operations, done, context) {
      var length = operations.length;
      var count = -1;
      function next() {
        count++;
        var terminate = count === length;
        if (terminate) {
          done();
        } else {
          var index = count, operation = operations[index];
          operation(next, done, context, index);
        }
      }
      next();
    }
    function eventually(operations, done, context) {
      var next = function next2() {
        count++;
        var terminate = count === length;
        if (terminate) {
          done();
        }
      };
      var length = operations.length;
      var count = 0;
      operations.forEach(function(operation, index) {
        operation(next, done, context, index);
      });
    }
    function repeatedly(operation, length, done, context) {
      var next = function next2() {
        count++;
        var terminate = count === length;
        if (terminate) {
          done();
        }
      };
      var count = 0;
      for (var index = 0; index < length; index++) {
        operation(next, done, context, index);
      }
    }
    function forwardsForEach(array, operation, done, context) {
      var length = array.length;
      var count = -1;
      function next() {
        count++;
        var terminate = count === length;
        if (terminate) {
          done();
        } else {
          var index = count, element = array[index];
          operation(element, next, done, context, index);
        }
      }
      next();
    }
    function backwardsForEach(array, operation, done, context) {
      var length = array.length;
      var count = length;
      function next() {
        count--;
        var terminate = count === -1;
        if (terminate) {
          done();
        } else {
          var index = count, element = array[index];
          operation(element, next, done, context, index);
        }
      }
      next();
    }
    var _default = {
      whilst,
      forEach,
      sequence,
      eventually,
      repeatedly,
      forwardsForEach,
      backwardsForEach
    };
    exports.default = _default;
  });

  // node_modules/necessary/lib/browser.js
  var require_browser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "levels", {
      enumerable: true,
      get: function() {
        return _levels.default;
      }
    });
    Object.defineProperty(exports, "methods", {
      enumerable: true,
      get: function() {
        return _methods.default;
      }
    });
    Object.defineProperty(exports, "headers", {
      enumerable: true,
      get: function() {
        return _headers.default;
      }
    });
    Object.defineProperty(exports, "keyCodes", {
      enumerable: true,
      get: function() {
        return _keyCodes.default;
      }
    });
    Object.defineProperty(exports, "encodings", {
      enumerable: true,
      get: function() {
        return _encodings.default;
      }
    });
    Object.defineProperty(exports, "characters", {
      enumerable: true,
      get: function() {
        return _characters.default;
      }
    });
    Object.defineProperty(exports, "statusCodes", {
      enumerable: true,
      get: function() {
        return _statusCodes.default;
      }
    });
    Object.defineProperty(exports, "contentTypes", {
      enumerable: true,
      get: function() {
        return _contentTypes.default;
      }
    });
    Object.defineProperty(exports, "statusMessages", {
      enumerable: true,
      get: function() {
        return _statusMessages.default;
      }
    });
    Object.defineProperty(exports, "ajaxUtilities", {
      enumerable: true,
      get: function() {
        return _ajax.default;
      }
    });
    Object.defineProperty(exports, "pathUtilities", {
      enumerable: true,
      get: function() {
        return _path.default;
      }
    });
    Object.defineProperty(exports, "httpUtilities", {
      enumerable: true,
      get: function() {
        return _http.default;
      }
    });
    Object.defineProperty(exports, "arrayUtilities", {
      enumerable: true,
      get: function() {
        return _array.default;
      }
    });
    Object.defineProperty(exports, "asynchronousUtilities", {
      enumerable: true,
      get: function() {
        return _asynchronous.default;
      }
    });
    var _levels = _interopRequireDefault2(require_levels());
    var _methods = _interopRequireDefault2(require_methods());
    var _headers = _interopRequireDefault2(require_headers());
    var _keyCodes = _interopRequireDefault2(require_keyCodes());
    var _encodings = _interopRequireDefault2(require_encodings());
    var _characters = _interopRequireDefault2(require_characters());
    var _statusCodes = _interopRequireDefault2(require_statusCodes());
    var _contentTypes = _interopRequireDefault2(require_contentTypes2());
    var _statusMessages = _interopRequireDefault2(require_statusMessages());
    var _ajax = _interopRequireDefault2(require_ajax());
    var _path = _interopRequireDefault2(require_path());
    var _http = _interopRequireDefault2(require_http());
    var _array = _interopRequireDefault2(require_array2());
    var _asynchronous = _interopRequireDefault2(require_asynchronous());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-lexers/lib/utilities/content.js
  var require_content = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sanitiseContent = sanitiseContent;
    var _necessary = require_browser();
    var LESS_THAN_CHARACTER = _necessary.characters.LESS_THAN_CHARACTER;
    var AMPERSAND_CHARACTER = _necessary.characters.AMPERSAND_CHARACTER;
    var GREATER_THAN_CHARACTER = _necessary.characters.GREATER_THAN_CHARACTER;
    function sanitiseContent(content) {
      var sanitisedContent = content.replace(/&/, AMPERSAND_CHARACTER).replace(/</, LESS_THAN_CHARACTER).replace(/>/, GREATER_THAN_CHARACTER);
      return sanitisedContent;
    }
  });

  // node_modules/occam-lexers/lib/types.js
  var require_types = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.middleOfMultiLineCommentType = exports.startOfMultiLineCommentType = exports.endOfMultiLineCommentType = exports.regularExpressionType = exports.singleLineCommentType = exports.endOfLineCommentType = exports.stringLiteralType = exports.whitespaceType = exports.endOfLineType = exports.commentType = exports.nameType = exports.typeType = void 0;
    var typeType = "type";
    exports.typeType = typeType;
    var nameType = "name";
    exports.nameType = nameType;
    var commentType = "comment";
    exports.commentType = commentType;
    var endOfLineType = "end-of-line";
    exports.endOfLineType = endOfLineType;
    var whitespaceType = "whitespace";
    exports.whitespaceType = whitespaceType;
    var stringLiteralType = "string-literal";
    exports.stringLiteralType = stringLiteralType;
    var endOfLineCommentType = "".concat(endOfLineType, " ").concat(commentType);
    exports.endOfLineCommentType = endOfLineCommentType;
    var singleLineCommentType = "single-line ".concat(commentType);
    exports.singleLineCommentType = singleLineCommentType;
    var regularExpressionType = "regular-expression";
    exports.regularExpressionType = regularExpressionType;
    var endOfMultiLineCommentType = "end-of-multi-line ".concat(commentType);
    exports.endOfMultiLineCommentType = endOfMultiLineCommentType;
    var startOfMultiLineCommentType = "start-of-multi-line ".concat(commentType);
    exports.startOfMultiLineCommentType = startOfMultiLineCommentType;
    var middleOfMultiLineCommentType = "middle-of-multi-line ".concat(commentType);
    exports.middleOfMultiLineCommentType = middleOfMultiLineCommentType;
    var _default = {
      typeType,
      nameType,
      commentType,
      endOfLineType,
      whitespaceType,
      stringLiteralType,
      endOfLineCommentType,
      singleLineCommentType,
      regularExpressionType,
      endOfMultiLineCommentType,
      startOfMultiLineCommentType,
      middleOfMultiLineCommentType
    };
    exports.default = _default;
  });

  // node_modules/occam-lexers/lib/token.js
  var require_token = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _content = require_content();
    var _types = require_types();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    var first = _necessary.arrayUtilities.first;
    var Token = /* @__PURE__ */ function() {
      function Token2(type, content, innerHTML, significant) {
        _classCallCheck(this, Token2);
        this.type = type;
        this.content = content;
        this.innerHTML = innerHTML;
        this.significant = significant;
      }
      _createClass(Token2, [
        {
          key: "getType",
          value: function getType() {
            return this.type;
          }
        },
        {
          key: "getContent",
          value: function getContent() {
            return this.content;
          }
        },
        {
          key: "getInnerHTML",
          value: function getInnerHTML() {
            return this.innerHTML;
          }
        },
        {
          key: "getContentLength",
          value: function getContentLength() {
            var contentLength = this.content.length;
            return contentLength;
          }
        },
        {
          key: "isSignificant",
          value: function isSignificant() {
            return this.significant;
          }
        },
        {
          key: "isCommentToken",
          value: function isCommentToken() {
            var typeIncludesCommentType = this.type.includes(_types.commentType), commentToken = typeIncludesCommentType;
            return commentToken;
          }
        },
        {
          key: "isEndOfLineToken",
          value: function isEndOfLineToken() {
            var typeEndOfLineType = this.type.includes(_types.endOfLineType), endOfLineToken = typeEndOfLineType;
            return endOfLineToken;
          }
        },
        {
          key: "isWhitespaceToken",
          value: function isWhitespaceToken() {
            var typeWhitespaceType = this.type === _types.whitespaceType, whitespaceToken = typeWhitespaceType;
            return whitespaceToken;
          }
        },
        {
          key: "isEqualTo",
          value: function isEqualTo(token) {
            var equalToToken = this === token;
            return equalToToken;
          }
        },
        {
          key: "match",
          value: function match(token) {
            var type = token.getType(), content = token.getContent(), significant = token.isSignificant(), matches = this.type === type && this.content === content && this.significant === significant;
            return matches;
          }
        },
        {
          key: "asHTML",
          value: function asHTML() {
            var className = this.type, html = '<span class="'.concat(className, '">').concat(this.innerHTML, "</span>");
            return html;
          }
        },
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition, significant) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
              remainingArguments[_key - 4] = arguments[_key];
            }
            var token = null;
            if (startPosition !== endPosition) {
              var content = this.getContent();
              content = content.substring(startPosition, endPosition);
              var type = this.getType(), sanitisedContent = (0, _content).sanitiseContent(content), innerHTML = sanitisedContent;
              token = _construct(Class, [
                type,
                content,
                innerHTML,
                significant
              ].concat(_toConsumableArray(remainingArguments)));
            }
            return token;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content, significant) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
              remainingArguments[_key - 3] = arguments[_key];
            }
            var token = null;
            var regularExpression = Class.regularExpression, matches = content.match(regularExpression);
            if (matches !== null) {
              var index = matches.index;
              if (index === 0) {
                var firstMatch = first(matches);
                content = firstMatch;
                var contentLength = content.length;
                if (contentLength > 0) {
                  var type = Class.type, sanitisedContent = (0, _content).sanitiseContent(content), innerHTML = sanitisedContent;
                  token = _construct(Class, [
                    type,
                    content,
                    innerHTML,
                    significant
                  ].concat(_toConsumableArray(remainingArguments)));
                }
              }
            }
            return token;
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content, significant) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
              remainingArguments[_key - 3] = arguments[_key];
            }
            var type = Class.type, sanitisedContent = (0, _content).sanitiseContent(content), innerHTML = sanitisedContent, token = _construct(Class, [
              type,
              content,
              innerHTML,
              significant
            ].concat(_toConsumableArray(remainingArguments)));
            return token;
          }
        },
        {
          key: "fromContentAndType",
          value: function fromContentAndType(Class, content, type, significant) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
              remainingArguments[_key - 4] = arguments[_key];
            }
            var sanitisedContent = (0, _content).sanitiseContent(content), innerHTML = sanitisedContent, token = _construct(Class, [
              type,
              content,
              innerHTML,
              significant
            ].concat(_toConsumableArray(remainingArguments)));
            return token;
          }
        }
      ]);
      return Token2;
    }();
    exports.default = Token;
  });

  // node_modules/occam-lexers/lib/token/significant.js
  var require_significant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = _interopRequireDefault2(require_token());
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var significant = true;
    var SignificantToken = /* @__PURE__ */ function(Token) {
      _inherits(SignificantToken2, Token);
      var _super = _createSuper(SignificantToken2);
      function SignificantToken2() {
        _classCallCheck(this, SignificantToken2);
        return _super.apply(this, arguments);
      }
      _createClass(SignificantToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
              remainingArguments[_key - 3] = arguments[_key];
            }
            var _instance;
            if (endPosition === void 0) {
              endPosition = startPosition;
              startPosition = Class;
              Class = SignificantToken2;
            }
            var significantToken = (_instance = _get(_getPrototypeOf(SignificantToken2.prototype), "clone", this)).call.apply(_instance, [
              this,
              Class,
              startPosition,
              endPosition,
              significant
            ].concat(_toConsumableArray(remainingArguments)));
            return significantToken;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              remainingArguments[_key - 2] = arguments[_key];
            }
            var _Token;
            if (content === void 0) {
              content = Class;
              Class = SignificantToken2;
            }
            var significantToken = (_Token = _token.default).match.apply(_Token, [
              Class,
              content,
              significant
            ].concat(_toConsumableArray(remainingArguments)));
            return significantToken;
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              remainingArguments[_key - 2] = arguments[_key];
            }
            var _Token;
            if (content === void 0) {
              content = Class;
              Class = SignificantToken2;
            }
            var significantToken = (_Token = _token.default).fromContent.apply(_Token, [
              Class,
              content,
              significant
            ].concat(_toConsumableArray(remainingArguments)));
            return significantToken;
          }
        },
        {
          key: "fromContentAndType",
          value: function fromContentAndType(Class, content, type) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
              remainingArguments[_key - 3] = arguments[_key];
            }
            var _Token;
            if (type === void 0) {
              type = content;
              content = Class;
              Class = SignificantToken2;
            }
            var significantToken = (_Token = _token.default).fromContentAndType.apply(_Token, [
              Class,
              content,
              type,
              significant
            ].concat(_toConsumableArray(remainingArguments)));
            return significantToken;
          }
        }
      ]);
      return SignificantToken2;
    }(_token.default);
    exports.default = SignificantToken;
  });

  // node_modules/occam-lexers/lib/constants.js
  var require_constants3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EMPTY_STRING = exports.U = void 0;
    var U = "u";
    exports.U = U;
    var EMPTY_STRING = "";
    exports.EMPTY_STRING = EMPTY_STRING;
  });

  // node_modules/occam-lexers/lib/rule.js
  var require_rule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _significant = _interopRequireDefault2(require_significant());
    var _constants = require_constants3();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var first = _necessary.arrayUtilities.first;
    var Rule = /* @__PURE__ */ function() {
      function Rule2(type, regularExpression) {
        _classCallCheck(this, Rule2);
        this.type = type;
        this.regularExpression = regularExpression;
      }
      _createClass(Rule2, [
        {
          key: "getType",
          value: function getType() {
            return this.type;
          }
        },
        {
          key: "getRegularExpression",
          value: function getRegularExpression() {
            return this.regularExpression;
          }
        },
        {
          key: "match",
          value: function match(content) {
            var significantToken = null;
            var matches = content.match(this.regularExpression);
            if (matches !== null) {
              var index = matches.index;
              if (index === 0) {
                var firstMatch = first(matches);
                content = firstMatch;
                var contentLength = content.length;
                if (contentLength > 0) {
                  significantToken = _significant.default.fromContentAndType(content, this.type);
                }
              }
            }
            return significantToken;
          }
        },
        {
          key: "asEntry",
          value: function asEntry() {
            var entry = {}, regularExpressionPattern = "".concat(this.regularExpression);
            entry[this.type] = regularExpressionPattern;
            return entry;
          }
        }
      ], [
        {
          key: "fromToken",
          value: function fromToken(Token) {
            var type = Token.type, regularExpression = Token.regularExpression, rule = new Rule2(type, regularExpression);
            return rule;
          }
        },
        {
          key: "fromEntry",
          value: function fromEntry(entry) {
            var entryKeys = Object.keys(entry), firstEntryKey = first(entryKeys), type = firstEntryKey, regularExpressionPattern = entry[type], rule = Rule2.fromTypeAndRegularExpressionPattern(type, regularExpressionPattern);
            return rule;
          }
        },
        {
          key: "fromTypeAndRegularExpressionPattern",
          value: function fromTypeAndRegularExpressionPattern(type, regularExpressionPattern) {
            var unicode = isUnicode(regularExpressionPattern), flags = unicode ? _constants.U : _constants.EMPTY_STRING, regExp = new RegExp(regularExpressionPattern, flags), regularExpression = regExp, rule = new Rule2(type, regularExpression);
            return rule;
          }
        }
      ]);
      return Rule2;
    }();
    exports.default = Rule;
    function isUnicode(regularExpressionPattern) {
      var unicodeRegularExpression = /u{/, index = regularExpressionPattern.search(unicodeRegularExpression), unicode = index !== -1;
      return unicode;
    }
  });

  // node_modules/occam-lexers/lib/specialSymbols.js
  var require_specialSymbols = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.END_OF_LINE = exports.NO_WHITESPACE = exports.exclamationMark = exports.questionMark = exports.closeBracket = exports.openBracket = exports.verticalBar = exports.terminator = exports.separator = exports.ellipsis = exports.asterisk = exports.wildcard = exports.plus = void 0;
    var plus = "+";
    exports.plus = plus;
    var wildcard = ".";
    exports.wildcard = wildcard;
    var asterisk = "*";
    exports.asterisk = asterisk;
    var ellipsis = "...";
    exports.ellipsis = ellipsis;
    var separator = "::=";
    exports.separator = separator;
    var terminator = ";";
    exports.terminator = terminator;
    var verticalBar = "|";
    exports.verticalBar = verticalBar;
    var openBracket = "(";
    exports.openBracket = openBracket;
    var closeBracket = ")";
    exports.closeBracket = closeBracket;
    var questionMark = "?";
    exports.questionMark = questionMark;
    var exclamationMark = "!";
    exports.exclamationMark = exclamationMark;
    var NO_WHITESPACE = "<NO_WHITESPACE>";
    exports.NO_WHITESPACE = NO_WHITESPACE;
    var END_OF_LINE = "<END_OF_LINE>";
    exports.END_OF_LINE = END_OF_LINE;
    var _default = {
      plus,
      wildcard,
      asterisk,
      ellipsis,
      separator,
      terminator,
      verticalBar,
      openBracket,
      closeBracket,
      questionMark,
      exclamationMark,
      NO_WHITESPACE,
      END_OF_LINE
    };
    exports.default = _default;
  });

  // node_modules/occam-lexers/lib/bnf/entries.js
  var require_entries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var entries = [
      {
        special: "^(?:::=|\\||\\(|\\)|\\?|\\!|\\*|\\+|\\.\\.\\.|\\.|\u03B5|;|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        name: "^[\\w~]+"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
    exports.default = _default;
  });

  // node_modules/occam-lexers/lib/utilities/token.js
  var require_token2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inCommentFromTokenAndInComment = inCommentFromTokenAndInComment;
    function inCommentFromTokenAndInComment(token, inComment) {
      var tokenCommentToken = token.isCommentToken();
      if (tokenCommentToken) {
        var commentToken = token, commentTokenInCommentPreserving = commentToken.isInCommentPreserving();
        inComment = commentTokenInCommentPreserving;
      }
      return inComment;
    }
  });

  // node_modules/occam-lexers/lib/common/lexer.js
  var require_lexer = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule());
    var _constants = require_constants3();
    var _token = require_token2();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CommonLexer = /* @__PURE__ */ function() {
      function CommonLexer2(rules, InCommentClasses, NotInCommentClasses) {
        _classCallCheck(this, CommonLexer2);
        this.rules = rules;
        this.InCommentClasses = InCommentClasses;
        this.NotInCommentClasses = NotInCommentClasses;
      }
      _createClass(CommonLexer2, [
        {
          key: "getRules",
          value: function getRules() {
            return this.rules;
          }
        },
        {
          key: "getInCommentClasses",
          value: function getInCommentClasses() {
            return this.InCommentClasses;
          }
        },
        {
          key: "getNotInCommentClasses",
          value: function getNotInCommentClasses() {
            return this.NotInCommentClasses;
          }
        },
        {
          key: "tokenise",
          value: function tokenise(content) {
            var inComment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var tokens = [];
            while (content !== _constants.EMPTY_STRING) {
              var token = null;
              var Classes = inComment ? this.InCommentClasses : this.NotInCommentClasses;
              Classes.some(function(Class) {
                if (Class !== null) {
                  token = Class.match(content);
                  if (token !== null) {
                    return true;
                  }
                }
              });
              if (token === null) {
                var significantToken = null;
                this.rules.some(function(rule) {
                  significantToken = rule.match(content);
                  if (significantToken !== null) {
                    token = significantToken;
                    return true;
                  }
                });
              }
              if (token === null) {
                throw new Error("The content '".concat(content, "' cannot be tokenised."));
              }
              tokens.push(token);
              inComment = (0, _token).inCommentFromTokenAndInComment(token, inComment);
              var tokenContentLength = token.getContentLength(), start = tokenContentLength;
              content = content.substring(start);
            }
            return tokens;
          }
        }
      ], [
        {
          key: "fromNothing",
          value: function fromNothing(Class) {
            var entries = Class.entries, InCommentClasses = InCommentClassesFromClass(Class), NotInCommentClasses = NotInCommentClassesFromClass(Class), rules = entries.map(function(entry) {
              return _rule.default.fromEntry(entry);
            }), lexer = new Class(rules, InCommentClasses, NotInCommentClasses);
            return lexer;
          }
        },
        {
          key: "fromRules",
          value: function fromRules(Class, rules) {
            var InCommentClasses = InCommentClassesFromClass(Class), NotInCommentClasses = NotInCommentClassesFromClass(Class), lexer = new Class(rules, InCommentClasses, NotInCommentClasses);
            return lexer;
          }
        },
        {
          key: "fromEntries",
          value: function fromEntries(Class, entries) {
            var rules = entries.map(function(entry) {
              return _rule.default.fromEntry(entry);
            }), InCommentClasses = InCommentClassesFromClass(Class), NotInCommentClasses = NotInCommentClassesFromClass(Class), lexer = new Class(rules, InCommentClasses, NotInCommentClasses);
            return lexer;
          }
        }
      ]);
      return CommonLexer2;
    }();
    exports.default = CommonLexer;
    function InCommentClassesFromClass(Class) {
      var EndOfLineCommentToken = Class.EndOfLineCommentToken, EndOfMultiLineCommentToken = Class.EndOfMultiLineCommentToken, MiddleOfMultiLineCommentToken = Class.MiddleOfMultiLineCommentToken, InCommentClasses = [
        EndOfLineCommentToken,
        EndOfMultiLineCommentToken,
        MiddleOfMultiLineCommentToken
      ];
      return InCommentClasses;
    }
    function NotInCommentClassesFromClass(Class) {
      var EndOfLineToken = Class.EndOfLineToken, WhitespaceToken = Class.WhitespaceToken, SingleLineCommentToken = Class.SingleLineCommentToken, RegularExpressionToken = Class.RegularExpressionToken, StartOfMultiLineCommentToken = Class.StartOfMultiLineCommentToken, SinglyQuotedStringLiteralToken = Class.SinglyQuotedStringLiteralToken, DoublyQuotedStringLiteralToken = Class.DoublyQuotedStringLiteralToken, NotInCommentClasses = [
        EndOfLineToken,
        WhitespaceToken,
        StartOfMultiLineCommentToken,
        SingleLineCommentToken,
        RegularExpressionToken,
        SinglyQuotedStringLiteralToken,
        DoublyQuotedStringLiteralToken
      ];
      return NotInCommentClasses;
    }
  });

  // node_modules/occam-lexers/lib/token/nonSignificant.js
  var require_nonSignificant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = _interopRequireDefault2(require_token());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var significant = false;
    var NonSignificantToken = /* @__PURE__ */ function(Token) {
      _inherits(NonSignificantToken2, Token);
      var _super = _createSuper(NonSignificantToken2);
      function NonSignificantToken2() {
        _classCallCheck(this, NonSignificantToken2);
        return _super.apply(this, arguments);
      }
      _createClass(NonSignificantToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            return _get(_getPrototypeOf(NonSignificantToken2.prototype), "clone", this).call(this, Class, startPosition, endPosition, significant);
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            return _token.default.match(Class, content, significant);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            return _token.default.fromContent(Class, content, significant);
          }
        },
        {
          key: "fromContentAndType",
          value: function fromContentAndType(Class, content, type) {
            return _token.default.fromContentAndType(Class, content, type, significant);
          }
        }
      ]);
      return NonSignificantToken2;
    }(_token.default);
    exports.default = NonSignificantToken;
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/whitespace.js
  var require_whitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var WhitespaceToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(WhitespaceToken2, NonSignificantToken);
      var _super = _createSuper(WhitespaceToken2);
      function WhitespaceToken2() {
        _classCallCheck(this, WhitespaceToken2);
        return _super.apply(this, arguments);
      }
      _createClass(WhitespaceToken2, [
        {
          key: "asHTML",
          value: function asHTML() {
            var html = this.innerHTML;
            return html;
          }
        },
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(WhitespaceToken2.prototype), "clone", this).call(this, WhitespaceToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _nonSignificant.default.match(WhitespaceToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _nonSignificant.default.fromContent(WhitespaceToken2, content);
          }
        }
      ]);
      return WhitespaceToken2;
    }(_nonSignificant.default);
    exports.default = WhitespaceToken;
    _defineProperty(WhitespaceToken, "type", _types.whitespaceType);
    _defineProperty(WhitespaceToken, "regularExpression", /^[\t ]+/);
  });

  // node_modules/occam-lexers/lib/token/significant/regularExpression.js
  var require_regularExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _significant = _interopRequireDefault2(require_significant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RegularExpressionToken = /* @__PURE__ */ function(SignificantToken) {
      _inherits(RegularExpressionToken2, SignificantToken);
      var _super = _createSuper(RegularExpressionToken2);
      function RegularExpressionToken2() {
        _classCallCheck(this, RegularExpressionToken2);
        return _super.apply(this, arguments);
      }
      _createClass(RegularExpressionToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(RegularExpressionToken2.prototype), "clone", this).call(this, RegularExpressionToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _significant.default.match(RegularExpressionToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _significant.default.fromContent(RegularExpressionToken2, content);
          }
        }
      ]);
      return RegularExpressionToken2;
    }(_significant.default);
    exports.default = RegularExpressionToken;
    _defineProperty(RegularExpressionToken, "type", _types.regularExpressionType);
    _defineProperty(RegularExpressionToken, "regularExpression", /^\/(?:\\[^\s]|[^\/\r\n])*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/endOfLine.js
  var require_endOfLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfLineNonSignificantToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(EndOfLineNonSignificantToken2, NonSignificantToken);
      var _super = _createSuper(EndOfLineNonSignificantToken2);
      function EndOfLineNonSignificantToken2() {
        _classCallCheck(this, EndOfLineNonSignificantToken2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineNonSignificantToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(EndOfLineNonSignificantToken2.prototype), "clone", this).call(this, EndOfLineNonSignificantToken2, startPosition, endPosition);
          }
        },
        {
          key: "asHTML",
          value: function asHTML() {
            var html = this.innerHTML;
            return html;
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _nonSignificant.default.match(EndOfLineNonSignificantToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _nonSignificant.default.fromContent(EndOfLineNonSignificantToken2, content);
          }
        }
      ]);
      return EndOfLineNonSignificantToken2;
    }(_nonSignificant.default);
    exports.default = EndOfLineNonSignificantToken;
    _defineProperty(EndOfLineNonSignificantToken, "type", _types.endOfLineType);
    _defineProperty(EndOfLineNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n)/);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral.js
  var require_stringLiteral = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _significant = _interopRequireDefault2(require_significant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var StringLiteralToken = /* @__PURE__ */ function(SignificantToken) {
      _inherits(StringLiteralToken2, SignificantToken);
      var _super = _createSuper(StringLiteralToken2);
      function StringLiteralToken2() {
        _classCallCheck(this, StringLiteralToken2);
        return _super.apply(this, arguments);
      }
      _createClass(StringLiteralToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            return _get(_getPrototypeOf(StringLiteralToken2.prototype), "clone", this).call(this, Class, startPosition, endPosition);
          }
        },
        {
          key: "getString",
          value: function getString() {
            var content = this.getContent(), contentLength = content.length, start = 1, end = contentLength - 1, string = content.substring(start, end);
            return string;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            return _significant.default.match(Class, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            return _significant.default.fromContent(Class, content);
          }
        }
      ]);
      return StringLiteralToken2;
    }(_significant.default);
    exports.default = StringLiteralToken;
    _defineProperty(StringLiteralToken, "type", _types.stringLiteralType);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/doublyQuoted.js
  var require_doublyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _stringLiteral = _interopRequireDefault2(require_stringLiteral());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DoublyQuotedStringLiteralToken = /* @__PURE__ */ function(StringLiteralToken) {
      _inherits(DoublyQuotedStringLiteralToken2, StringLiteralToken);
      var _super = _createSuper(DoublyQuotedStringLiteralToken2);
      function DoublyQuotedStringLiteralToken2() {
        _classCallCheck(this, DoublyQuotedStringLiteralToken2);
        return _super.apply(this, arguments);
      }
      _createClass(DoublyQuotedStringLiteralToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(DoublyQuotedStringLiteralToken2.prototype), "clone", this).call(this, DoublyQuotedStringLiteralToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _stringLiteral.default.match(DoublyQuotedStringLiteralToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _stringLiteral.default.fromContent(DoublyQuotedStringLiteralToken2, content);
          }
        }
      ]);
      return DoublyQuotedStringLiteralToken2;
    }(_stringLiteral.default);
    exports.default = DoublyQuotedStringLiteralToken;
    _defineProperty(DoublyQuotedStringLiteralToken, "regularExpression", /^"(?:\\[^\s]|[^"\\\r\n])*"/);
  });

  // node_modules/occam-lexers/lib/bnf/lexer.js
  var require_lexer2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _entries = _interopRequireDefault2(require_entries());
    var _lexer = _interopRequireDefault2(require_lexer());
    var _whitespace = _interopRequireDefault2(require_whitespace());
    var _regularExpression = _interopRequireDefault2(require_regularExpression());
    var _endOfLine = _interopRequireDefault2(require_endOfLine());
    var _doublyQuoted = _interopRequireDefault2(require_doublyQuoted());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var BNFLexer = /* @__PURE__ */ function(CommonLexer) {
      _inherits(BNFLexer2, CommonLexer);
      var _super = _createSuper(BNFLexer2);
      function BNFLexer2() {
        _classCallCheck(this, BNFLexer2);
        return _super.apply(this, arguments);
      }
      _createClass(BNFLexer2, [
        {
          key: "tokensFromBNF",
          value: function tokensFromBNF(bnf) {
            var content = bnf, tokens = _get(_getPrototypeOf(BNFLexer2.prototype), "tokenise", this).call(this, content);
            return tokens;
          }
        }
      ], [
        {
          key: "fromNothing",
          value: function fromNothing() {
            return _lexer.default.fromNothing(BNFLexer2);
          }
        },
        {
          key: "fromRules",
          value: function fromRules(rules) {
            return _lexer.default.fromRules(BNFLexer2, rules);
          }
        },
        {
          key: "fromEntries",
          value: function fromEntries(entries) {
            return _lexer.default.fromEntries(BNFLexer2, entries);
          }
        }
      ]);
      return BNFLexer2;
    }(_lexer.default);
    exports.default = BNFLexer;
    _defineProperty(BNFLexer, "entries", _entries.default);
    _defineProperty(BNFLexer, "EndOfLineToken", _endOfLine.default);
    _defineProperty(BNFLexer, "WhitespaceToken", _whitespace.default);
    _defineProperty(BNFLexer, "EndOfLineCommentToken", null);
    _defineProperty(BNFLexer, "RegularExpressionToken", _regularExpression.default);
    _defineProperty(BNFLexer, "SingleLineCommentToken", null);
    _defineProperty(BNFLexer, "EndOfMultiLineCommentToken", null);
    _defineProperty(BNFLexer, "StartOfMultiLineCommentToken", null);
    _defineProperty(BNFLexer, "MiddleOfMultiLineCommentToken", null);
    _defineProperty(BNFLexer, "SinglyQuotedStringLiteralToken", null);
    _defineProperty(BNFLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/basic/entries.js
  var require_entries2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var entries = [
      {
        digit: "^\\d+"
      },
      {
        bracket: "^(?:\\(|\\))"
      },
      {
        operator: "^(?:\\+|\\-|\\*|\\/)"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
    exports.default = _default;
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/singlyQuoted.js
  var require_singlyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _stringLiteral = _interopRequireDefault2(require_stringLiteral());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SinglyQuotedStringLiteralToken = /* @__PURE__ */ function(StringLiteralToken) {
      _inherits(SinglyQuotedStringLiteralToken2, StringLiteralToken);
      var _super = _createSuper(SinglyQuotedStringLiteralToken2);
      function SinglyQuotedStringLiteralToken2() {
        _classCallCheck(this, SinglyQuotedStringLiteralToken2);
        return _super.apply(this, arguments);
      }
      _createClass(SinglyQuotedStringLiteralToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(SinglyQuotedStringLiteralToken2.prototype), "clone", this).call(this, SinglyQuotedStringLiteralToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _stringLiteral.default.match(SinglyQuotedStringLiteralToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _stringLiteral.default.fromContent(SinglyQuotedStringLiteralToken2, content);
          }
        }
      ]);
      return SinglyQuotedStringLiteralToken2;
    }(_stringLiteral.default);
    exports.default = SinglyQuotedStringLiteralToken;
    _defineProperty(SinglyQuotedStringLiteralToken, "regularExpression", /^'(?:\\[^\s]|[^'\\\r\n])*'/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine.js
  var require_singleLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SingleLineCommentToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(SingleLineCommentToken2, NonSignificantToken);
      var _super = _createSuper(SingleLineCommentToken2);
      function SingleLineCommentToken2() {
        _classCallCheck(this, SingleLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(SingleLineCommentToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            return _get(_getPrototypeOf(SingleLineCommentToken2.prototype), "clone", this).call(this, Class, startPosition, endPosition);
          }
        },
        {
          key: "isInCommentPreserving",
          value: function isInCommentPreserving() {
            var inCommentPreserving = false;
            return inCommentPreserving;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            return _nonSignificant.default.match(Class, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            return _nonSignificant.default.fromContent(Class, content);
          }
        }
      ]);
      return SingleLineCommentToken2;
    }(_nonSignificant.default);
    exports.default = SingleLineCommentToken;
    _defineProperty(SingleLineCommentToken, "type", _types.singleLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/pythonStyle.js
  var require_pythonStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _singleLine = _interopRequireDefault2(require_singleLine());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var PythonStyleSingleLineCommentToken = /* @__PURE__ */ function(SingleLineCommentToken) {
      _inherits(PythonStyleSingleLineCommentToken2, SingleLineCommentToken);
      var _super = _createSuper(PythonStyleSingleLineCommentToken2);
      function PythonStyleSingleLineCommentToken2() {
        _classCallCheck(this, PythonStyleSingleLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(PythonStyleSingleLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(PythonStyleSingleLineCommentToken2.prototype), "clone", this).call(this, PythonStyleSingleLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _singleLine.default.match(PythonStyleSingleLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _singleLine.default.fromContent(PythonStyleSingleLineCommentToken2, content);
          }
        }
      ]);
      return PythonStyleSingleLineCommentToken2;
    }(_singleLine.default);
    exports.default = PythonStyleSingleLineCommentToken;
    _defineProperty(PythonStyleSingleLineCommentToken, "regularExpression", /^#[^\r\n]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/endOfLine.js
  var require_endOfLine2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfLineCommentNonSignificantToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(EndOfLineCommentNonSignificantToken2, NonSignificantToken);
      var _super = _createSuper(EndOfLineCommentNonSignificantToken2);
      function EndOfLineCommentNonSignificantToken2() {
        _classCallCheck(this, EndOfLineCommentNonSignificantToken2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineCommentNonSignificantToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(EndOfLineCommentNonSignificantToken2.prototype), "clone", this).call(this, EndOfLineCommentNonSignificantToken2, startPosition, endPosition);
          }
        },
        {
          key: "asHTML",
          value: function asHTML() {
            var html = this.innerHTML;
            return html;
          }
        },
        {
          key: "isInCommentPreserving",
          value: function isInCommentPreserving() {
            var inCommentPreserving = true;
            return inCommentPreserving;
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _nonSignificant.default.match(EndOfLineCommentNonSignificantToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _nonSignificant.default.fromContent(EndOfLineCommentNonSignificantToken2, content);
          }
        }
      ]);
      return EndOfLineCommentNonSignificantToken2;
    }(_nonSignificant.default);
    exports.default = EndOfLineCommentNonSignificantToken;
    _defineProperty(EndOfLineCommentNonSignificantToken, "type", _types.endOfLineCommentType);
    _defineProperty(EndOfLineCommentNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf.js
  var require_endOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfMultiLineCommentToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(EndOfMultiLineCommentToken2, NonSignificantToken);
      var _super = _createSuper(EndOfMultiLineCommentToken2);
      function EndOfMultiLineCommentToken2() {
        _classCallCheck(this, EndOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            return _get(_getPrototypeOf(EndOfMultiLineCommentToken2.prototype), "clone", this).call(this, Class, startPosition, endPosition);
          }
        },
        {
          key: "isInCommentPreserving",
          value: function isInCommentPreserving() {
            var inCommentPreserving = false;
            return inCommentPreserving;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            return _nonSignificant.default.match(Class, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            return _nonSignificant.default.fromContent(Class, content);
          }
        }
      ]);
      return EndOfMultiLineCommentToken2;
    }(_nonSignificant.default);
    exports.default = EndOfMultiLineCommentToken;
    _defineProperty(EndOfMultiLineCommentToken, "type", _types.endOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/pythonStyle.js
  var require_pythonStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _endOf = _interopRequireDefault2(require_endOf());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var PythonStyleEndOfMultiLineCommentToken = /* @__PURE__ */ function(EndOfMultiLineCommentToken) {
      _inherits(PythonStyleEndOfMultiLineCommentToken2, EndOfMultiLineCommentToken);
      var _super = _createSuper(PythonStyleEndOfMultiLineCommentToken2);
      function PythonStyleEndOfMultiLineCommentToken2() {
        _classCallCheck(this, PythonStyleEndOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(PythonStyleEndOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(PythonStyleEndOfMultiLineCommentToken2.prototype), "clone", this).call(this, PythonStyleEndOfMultiLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _endOf.default.match(PythonStyleEndOfMultiLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _endOf.default.fromContent(PythonStyleEndOfMultiLineCommentToken2, content);
          }
        }
      ]);
      return PythonStyleEndOfMultiLineCommentToken2;
    }(_endOf.default);
    exports.default = PythonStyleEndOfMultiLineCommentToken;
    _defineProperty(PythonStyleEndOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf.js
  var require_startOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var StartOfMultiLineCommentToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(StartOfMultiLineCommentToken2, NonSignificantToken);
      var _super = _createSuper(StartOfMultiLineCommentToken2);
      function StartOfMultiLineCommentToken2() {
        _classCallCheck(this, StartOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(StartOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            return _get(_getPrototypeOf(StartOfMultiLineCommentToken2.prototype), "clone", this).call(this, Class, startPosition, endPosition);
          }
        },
        {
          key: "isInCommentPreserving",
          value: function isInCommentPreserving() {
            var inCommentPreserving = true;
            return inCommentPreserving;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            return _nonSignificant.default.match(Class, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            return _nonSignificant.default.fromContent(Class, content);
          }
        }
      ]);
      return StartOfMultiLineCommentToken2;
    }(_nonSignificant.default);
    exports.default = StartOfMultiLineCommentToken;
    _defineProperty(StartOfMultiLineCommentToken, "type", _types.startOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/pythonStyle.js
  var require_pythonStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _startOf = _interopRequireDefault2(require_startOf());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var PythonStyleStartOfMultiLineCommentToken = /* @__PURE__ */ function(StartOfMultiLineCommentToken) {
      _inherits(PythonStyleStartOfMultiLineCommentToken2, StartOfMultiLineCommentToken);
      var _super = _createSuper(PythonStyleStartOfMultiLineCommentToken2);
      function PythonStyleStartOfMultiLineCommentToken2() {
        _classCallCheck(this, PythonStyleStartOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(PythonStyleStartOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(PythonStyleStartOfMultiLineCommentToken2.prototype), "clone", this).call(this, PythonStyleStartOfMultiLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _startOf.default.match(PythonStyleStartOfMultiLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _startOf.default.fromContent(PythonStyleStartOfMultiLineCommentToken2, content);
          }
        }
      ]);
      return PythonStyleStartOfMultiLineCommentToken2;
    }(_startOf.default);
    exports.default = PythonStyleStartOfMultiLineCommentToken;
    _defineProperty(PythonStyleStartOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf.js
  var require_middleOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var MiddleOfMultiLineCommentToken = /* @__PURE__ */ function(NonSignificantToken) {
      _inherits(MiddleOfMultiLineCommentToken2, NonSignificantToken);
      var _super = _createSuper(MiddleOfMultiLineCommentToken2);
      function MiddleOfMultiLineCommentToken2() {
        _classCallCheck(this, MiddleOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(MiddleOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(Class, startPosition, endPosition) {
            return _get(_getPrototypeOf(MiddleOfMultiLineCommentToken2.prototype), "clone", this).call(this, Class, startPosition, endPosition);
          }
        },
        {
          key: "isInCommentPreserving",
          value: function isInCommentPreserving() {
            var inCommentPreserving = true;
            return inCommentPreserving;
          }
        }
      ], [
        {
          key: "match",
          value: function match(Class, content) {
            return _nonSignificant.default.match(Class, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(Class, content) {
            return _nonSignificant.default.fromContent(Class, content);
          }
        }
      ]);
      return MiddleOfMultiLineCommentToken2;
    }(_nonSignificant.default);
    exports.default = MiddleOfMultiLineCommentToken;
    _defineProperty(MiddleOfMultiLineCommentToken, "type", _types.middleOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/pythonStyle.js
  var require_pythonStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _middleOf = _interopRequireDefault2(require_middleOf());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var PythonStyleMiddleOfMultiLineCommentToken = /* @__PURE__ */ function(MiddleOfMultiLineCommentToken) {
      _inherits(PythonStyleMiddleOfMultiLineCommentToken2, MiddleOfMultiLineCommentToken);
      var _super = _createSuper(PythonStyleMiddleOfMultiLineCommentToken2);
      function PythonStyleMiddleOfMultiLineCommentToken2() {
        _classCallCheck(this, PythonStyleMiddleOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(PythonStyleMiddleOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(PythonStyleMiddleOfMultiLineCommentToken2.prototype), "clone", this).call(this, PythonStyleMiddleOfMultiLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _middleOf.default.match(PythonStyleMiddleOfMultiLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _middleOf.default.fromContent(PythonStyleMiddleOfMultiLineCommentToken2, content);
          }
        }
      ]);
      return PythonStyleMiddleOfMultiLineCommentToken2;
    }(_middleOf.default);
    exports.default = PythonStyleMiddleOfMultiLineCommentToken;
    _defineProperty(PythonStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n]+?(?=###)|[^\r\n]+)/);
  });

  // node_modules/occam-lexers/lib/basic/lexer.js
  var require_lexer3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _entries = _interopRequireDefault2(require_entries2());
    var _lexer = _interopRequireDefault2(require_lexer());
    var _whitespace = _interopRequireDefault2(require_whitespace());
    var _regularExpression = _interopRequireDefault2(require_regularExpression());
    var _endOfLine = _interopRequireDefault2(require_endOfLine());
    var _singlyQuoted = _interopRequireDefault2(require_singlyQuoted());
    var _doublyQuoted = _interopRequireDefault2(require_doublyQuoted());
    var _pythonStyle = _interopRequireDefault2(require_pythonStyle());
    var _endOfLine1 = _interopRequireDefault2(require_endOfLine2());
    var _pythonStyle1 = _interopRequireDefault2(require_pythonStyle2());
    var _pythonStyle2 = _interopRequireDefault2(require_pythonStyle3());
    var _pythonStyle3 = _interopRequireDefault2(require_pythonStyle4());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var BasicLexer = /* @__PURE__ */ function(CommonLexer) {
      _inherits(BasicLexer2, CommonLexer);
      var _super = _createSuper(BasicLexer2);
      function BasicLexer2() {
        _classCallCheck(this, BasicLexer2);
        return _super.apply(this, arguments);
      }
      _createClass(BasicLexer2, null, [
        {
          key: "fromNothing",
          value: function fromNothing() {
            return _lexer.default.fromNothing(BasicLexer2);
          }
        },
        {
          key: "fromRules",
          value: function fromRules(rules) {
            return _lexer.default.fromRules(BasicLexer2, rules);
          }
        },
        {
          key: "fromEntries",
          value: function fromEntries(entries) {
            return _lexer.default.fromEntries(BasicLexer2, entries);
          }
        }
      ]);
      return BasicLexer2;
    }(_lexer.default);
    exports.default = BasicLexer;
    _defineProperty(BasicLexer, "entries", _entries.default);
    _defineProperty(BasicLexer, "EndOfLineToken", _endOfLine.default);
    _defineProperty(BasicLexer, "WhitespaceToken", _whitespace.default);
    _defineProperty(BasicLexer, "EndOfLineCommentToken", _endOfLine1.default);
    _defineProperty(BasicLexer, "RegularExpressionToken", _regularExpression.default);
    _defineProperty(BasicLexer, "SingleLineCommentToken", _pythonStyle.default);
    _defineProperty(BasicLexer, "EndOfMultiLineCommentToken", _pythonStyle1.default);
    _defineProperty(BasicLexer, "StartOfMultiLineCommentToken", _pythonStyle2.default);
    _defineProperty(BasicLexer, "MiddleOfMultiLineCommentToken", _pythonStyle3.default);
    _defineProperty(BasicLexer, "SinglyQuotedStringLiteralToken", _singlyQuoted.default);
    _defineProperty(BasicLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/token/significant/endOfLine.js
  var require_endOfLine3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _significant = _interopRequireDefault2(require_significant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfLineSignificantToken = /* @__PURE__ */ function(SignificantToken) {
      _inherits(EndOfLineSignificantToken2, SignificantToken);
      var _super = _createSuper(EndOfLineSignificantToken2);
      function EndOfLineSignificantToken2() {
        _classCallCheck(this, EndOfLineSignificantToken2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineSignificantToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(EndOfLineSignificantToken2.prototype), "clone", this).call(this, EndOfLineSignificantToken2, startPosition, endPosition);
          }
        },
        {
          key: "asHTML",
          value: function asHTML() {
            var html = this.innerHTML;
            return html;
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _significant.default.match(EndOfLineSignificantToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _significant.default.fromContent(EndOfLineSignificantToken2, content);
          }
        }
      ]);
      return EndOfLineSignificantToken2;
    }(_significant.default);
    exports.default = EndOfLineSignificantToken;
    _defineProperty(EndOfLineSignificantToken, "type", _types.endOfLineType);
    _defineProperty(EndOfLineSignificantToken, "regularExpression", /^(?:\r\n|\r|\n)/);
  });

  // node_modules/occam-lexers/lib/token/significant/comment/endOfLine.js
  var require_endOfLine4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _significant = _interopRequireDefault2(require_significant());
    var _types = require_types();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfLineCommentSignificantToken = /* @__PURE__ */ function(SignificantToken) {
      _inherits(EndOfLineCommentSignificantToken2, SignificantToken);
      var _super = _createSuper(EndOfLineCommentSignificantToken2);
      function EndOfLineCommentSignificantToken2() {
        _classCallCheck(this, EndOfLineCommentSignificantToken2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineCommentSignificantToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(EndOfLineCommentSignificantToken2.prototype), "clone", this).call(this, EndOfLineCommentSignificantToken2, startPosition, endPosition);
          }
        },
        {
          key: "asHTML",
          value: function asHTML() {
            var html = this.innerHTML;
            return html;
          }
        },
        {
          key: "isInCommentPreserving",
          value: function isInCommentPreserving() {
            var inCommentPreserving = true;
            return inCommentPreserving;
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _significant.default.match(EndOfLineCommentSignificantToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _significant.default.fromContent(EndOfLineCommentSignificantToken2, content);
          }
        }
      ]);
      return EndOfLineCommentSignificantToken2;
    }(_significant.default);
    exports.default = EndOfLineCommentSignificantToken;
    _defineProperty(EndOfLineCommentSignificantToken, "type", _types.endOfLineCommentType);
    _defineProperty(EndOfLineCommentSignificantToken, "regularExpression", /^(?:\r\n|\r|\n)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/cStyle.js
  var require_cStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _singleLine = _interopRequireDefault2(require_singleLine());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CStyleSingleLineCommentToken = /* @__PURE__ */ function(SingleLineCommentToken) {
      _inherits(CStyleSingleLineCommentToken2, SingleLineCommentToken);
      var _super = _createSuper(CStyleSingleLineCommentToken2);
      function CStyleSingleLineCommentToken2() {
        _classCallCheck(this, CStyleSingleLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(CStyleSingleLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(CStyleSingleLineCommentToken2.prototype), "clone", this).call(this, CStyleSingleLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _singleLine.default.match(CStyleSingleLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _singleLine.default.fromContent(CStyleSingleLineCommentToken2, content);
          }
        }
      ]);
      return CStyleSingleLineCommentToken2;
    }(_singleLine.default);
    exports.default = CStyleSingleLineCommentToken;
    _defineProperty(CStyleSingleLineCommentToken, "regularExpression", /^\/\/[^\r\n]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/cStyle.js
  var require_cStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _endOf = _interopRequireDefault2(require_endOf());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CStyleEndOfMultiLineCommentToken = /* @__PURE__ */ function(EndOfMultiLineCommentToken) {
      _inherits(CStyleEndOfMultiLineCommentToken2, EndOfMultiLineCommentToken);
      var _super = _createSuper(CStyleEndOfMultiLineCommentToken2);
      function CStyleEndOfMultiLineCommentToken2() {
        _classCallCheck(this, CStyleEndOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(CStyleEndOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(CStyleEndOfMultiLineCommentToken2.prototype), "clone", this).call(this, CStyleEndOfMultiLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _endOf.default.match(CStyleEndOfMultiLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _endOf.default.fromContent(CStyleEndOfMultiLineCommentToken2, content);
          }
        }
      ]);
      return CStyleEndOfMultiLineCommentToken2;
    }(_endOf.default);
    exports.default = CStyleEndOfMultiLineCommentToken;
    _defineProperty(CStyleEndOfMultiLineCommentToken, "regularExpression", /^\*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/cStyle.js
  var require_cStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _startOf = _interopRequireDefault2(require_startOf());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CStyleStartOfMultiLineCommentToken = /* @__PURE__ */ function(StartOfMultiLineCommentToken) {
      _inherits(CStyleStartOfMultiLineCommentToken2, StartOfMultiLineCommentToken);
      var _super = _createSuper(CStyleStartOfMultiLineCommentToken2);
      function CStyleStartOfMultiLineCommentToken2() {
        _classCallCheck(this, CStyleStartOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(CStyleStartOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(CStyleStartOfMultiLineCommentToken2.prototype), "clone", this).call(this, CStyleStartOfMultiLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _startOf.default.match(CStyleStartOfMultiLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _startOf.default.fromContent(CStyleStartOfMultiLineCommentToken2, content);
          }
        }
      ]);
      return CStyleStartOfMultiLineCommentToken2;
    }(_startOf.default);
    exports.default = CStyleStartOfMultiLineCommentToken;
    _defineProperty(CStyleStartOfMultiLineCommentToken, "regularExpression", /^\/\*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/cStyle.js
  var require_cStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _middleOf = _interopRequireDefault2(require_middleOf());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CStyleMiddleOfMultiLineCommentToken = /* @__PURE__ */ function(MiddleOfMultiLineCommentToken) {
      _inherits(CStyleMiddleOfMultiLineCommentToken2, MiddleOfMultiLineCommentToken);
      var _super = _createSuper(CStyleMiddleOfMultiLineCommentToken2);
      function CStyleMiddleOfMultiLineCommentToken2() {
        _classCallCheck(this, CStyleMiddleOfMultiLineCommentToken2);
        return _super.apply(this, arguments);
      }
      _createClass(CStyleMiddleOfMultiLineCommentToken2, [
        {
          key: "clone",
          value: function clone(startPosition, endPosition) {
            return _get(_getPrototypeOf(CStyleMiddleOfMultiLineCommentToken2.prototype), "clone", this).call(this, CStyleMiddleOfMultiLineCommentToken2, startPosition, endPosition);
          }
        }
      ], [
        {
          key: "match",
          value: function match(content) {
            return _middleOf.default.match(CStyleMiddleOfMultiLineCommentToken2, content);
          }
        },
        {
          key: "fromContent",
          value: function fromContent(content) {
            return _middleOf.default.fromContent(CStyleMiddleOfMultiLineCommentToken2, content);
          }
        }
      ]);
      return CStyleMiddleOfMultiLineCommentToken2;
    }(_middleOf.default);
    exports.default = CStyleMiddleOfMultiLineCommentToken;
    _defineProperty(CStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n]+?(?=\*\/)|[^\r\n]+)/);
  });

  // node_modules/occam-lexers/lib/index.js
  var require_lib3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Rule", {
      enumerable: true,
      get: function() {
        return _rule.default;
      }
    });
    Object.defineProperty(exports, "types", {
      enumerable: true,
      get: function() {
        return _types.default;
      }
    });
    Object.defineProperty(exports, "specialSymbols", {
      enumerable: true,
      get: function() {
        return _specialSymbols.default;
      }
    });
    Object.defineProperty(exports, "BNFLexer", {
      enumerable: true,
      get: function() {
        return _lexer.default;
      }
    });
    Object.defineProperty(exports, "BasicLexer", {
      enumerable: true,
      get: function() {
        return _lexer1.default;
      }
    });
    Object.defineProperty(exports, "CommonLexer", {
      enumerable: true,
      get: function() {
        return _lexer2.default;
      }
    });
    Object.defineProperty(exports, "SignificantToken", {
      enumerable: true,
      get: function() {
        return _significant.default;
      }
    });
    Object.defineProperty(exports, "NonSignificantToken", {
      enumerable: true,
      get: function() {
        return _nonSignificant.default;
      }
    });
    Object.defineProperty(exports, "EndOfLineSignificantToken", {
      enumerable: true,
      get: function() {
        return _endOfLine.default;
      }
    });
    Object.defineProperty(exports, "EndOfLineNonSignificantToken", {
      enumerable: true,
      get: function() {
        return _endOfLine1.default;
      }
    });
    Object.defineProperty(exports, "EndOfLineCommentSignificantToken", {
      enumerable: true,
      get: function() {
        return _endOfLine2.default;
      }
    });
    Object.defineProperty(exports, "EndOfLineCommentNonSignificantToken", {
      enumerable: true,
      get: function() {
        return _endOfLine3.default;
      }
    });
    Object.defineProperty(exports, "WhitespaceToken", {
      enumerable: true,
      get: function() {
        return _whitespace.default;
      }
    });
    Object.defineProperty(exports, "StringLiteralToken", {
      enumerable: true,
      get: function() {
        return _stringLiteral.default;
      }
    });
    Object.defineProperty(exports, "RegularExpressionToken", {
      enumerable: true,
      get: function() {
        return _regularExpression.default;
      }
    });
    Object.defineProperty(exports, "SinglyQuotedStringLiteralToken", {
      enumerable: true,
      get: function() {
        return _singlyQuoted.default;
      }
    });
    Object.defineProperty(exports, "DoublyQuotedStringLiteralToken", {
      enumerable: true,
      get: function() {
        return _doublyQuoted.default;
      }
    });
    Object.defineProperty(exports, "SingleLineCommentToken", {
      enumerable: true,
      get: function() {
        return _singleLine.default;
      }
    });
    Object.defineProperty(exports, "EndOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _endOf.default;
      }
    });
    Object.defineProperty(exports, "StartOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _startOf.default;
      }
    });
    Object.defineProperty(exports, "MiddleOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _middleOf.default;
      }
    });
    Object.defineProperty(exports, "CStyleSingleLineCommentToken", {
      enumerable: true,
      get: function() {
        return _cStyle.default;
      }
    });
    Object.defineProperty(exports, "CStyleEndOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _cStyle1.default;
      }
    });
    Object.defineProperty(exports, "CStyleStartOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _cStyle2.default;
      }
    });
    Object.defineProperty(exports, "CStyleMiddleOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _cStyle3.default;
      }
    });
    Object.defineProperty(exports, "PythonStyleSingleLineCommentToken", {
      enumerable: true,
      get: function() {
        return _pythonStyle.default;
      }
    });
    Object.defineProperty(exports, "PythonStyleEndOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _pythonStyle1.default;
      }
    });
    Object.defineProperty(exports, "PythonStyleStartOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _pythonStyle2.default;
      }
    });
    Object.defineProperty(exports, "PythonStyleMiddleOfMultiLineCommentToken", {
      enumerable: true,
      get: function() {
        return _pythonStyle3.default;
      }
    });
    var _rule = _interopRequireDefault2(require_rule());
    var _types = _interopRequireDefault2(require_types());
    var _specialSymbols = _interopRequireDefault2(require_specialSymbols());
    var _lexer = _interopRequireDefault2(require_lexer2());
    var _lexer1 = _interopRequireDefault2(require_lexer3());
    var _lexer2 = _interopRequireDefault2(require_lexer());
    var _significant = _interopRequireDefault2(require_significant());
    var _nonSignificant = _interopRequireDefault2(require_nonSignificant());
    var _endOfLine = _interopRequireDefault2(require_endOfLine3());
    var _endOfLine1 = _interopRequireDefault2(require_endOfLine());
    var _endOfLine2 = _interopRequireDefault2(require_endOfLine4());
    var _endOfLine3 = _interopRequireDefault2(require_endOfLine2());
    var _whitespace = _interopRequireDefault2(require_whitespace());
    var _stringLiteral = _interopRequireDefault2(require_stringLiteral());
    var _regularExpression = _interopRequireDefault2(require_regularExpression());
    var _singlyQuoted = _interopRequireDefault2(require_singlyQuoted());
    var _doublyQuoted = _interopRequireDefault2(require_doublyQuoted());
    var _singleLine = _interopRequireDefault2(require_singleLine());
    var _endOf = _interopRequireDefault2(require_endOf());
    var _startOf = _interopRequireDefault2(require_startOf());
    var _middleOf = _interopRequireDefault2(require_middleOf());
    var _cStyle = _interopRequireDefault2(require_cStyle());
    var _cStyle1 = _interopRequireDefault2(require_cStyle2());
    var _cStyle2 = _interopRequireDefault2(require_cStyle3());
    var _cStyle3 = _interopRequireDefault2(require_cStyle4());
    var _pythonStyle = _interopRequireDefault2(require_pythonStyle());
    var _pythonStyle1 = _interopRequireDefault2(require_pythonStyle2());
    var _pythonStyle2 = _interopRequireDefault2(require_pythonStyle3());
    var _pythonStyle3 = _interopRequireDefault2(require_pythonStyle4());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/entries.js
  var require_entries3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var entries = [
      {
        colour: "^#(?:[0-9a-fA-F]{6}|[0-9a-fA-F]{3})"
      },
      {
        keyword: "^(?:!important|@media)"
      },
      {
        percentage: "^(?:[0-9]+|[0-9]*\\.[0-9]+)\\%"
      },
      {
        frequency: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:hz|khz)"
      },
      {
        fraction: "^[1-9][0-9]*?fr"
      },
      {
        length: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:px|cm|mm|in|pt|pc)"
      },
      {
        angle: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:deg|rad|grad)"
      },
      {
        time: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:s|ms)"
      },
      {
        rems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)rem"
      },
      {
        ems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)em"
      },
      {
        number: "^[0-9]+|[0-9]*\\.[0-9]+"
      },
      {
        special: "^;|::|:|\\.|,|/|\\|=|~=|=|>|\\{|\\}|\\(|\\)|\\[|\\]"
      },
      {
        operator: "^^(?:and|not|only)$"
      },
      {
        identifier: "^[_a-zA-Z0-9-]+"
      },
      {
        "unary-operator": "^\\+|\\-"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
    exports.default = _default;
  });

  // node_modules/with-style/lib/css/lexer.js
  var require_lexer4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _entries = _interopRequireDefault2(require_entries3());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CSSLexer = /* @__PURE__ */ function(CommonLexer) {
      _inherits(CSSLexer2, CommonLexer);
      var _super = _createSuper(CSSLexer2);
      function CSSLexer2() {
        _classCallCheck(this, CSSLexer2);
        return _super.apply(this, arguments);
      }
      _createClass(CSSLexer2, null, [
        {
          key: "fromNothing",
          value: function fromNothing() {
            return _occamLexers.CommonLexer.fromNothing(CSSLexer2);
          }
        },
        {
          key: "fromRules",
          value: function fromRules(rules) {
            return _occamLexers.CommonLexer.fromRules(CSSLexer2, rules);
          }
        },
        {
          key: "fromEntries",
          value: function fromEntries(entries) {
            return _occamLexers.CommonLexer.fromEntries(CSSLexer2, entries);
          }
        }
      ]);
      return CSSLexer2;
    }(_occamLexers.CommonLexer);
    _defineProperty(CSSLexer, "entries", _entries.default);
    _defineProperty(CSSLexer, "EndOfLineToken", _occamLexers.EndOfLineNonSignificantToken);
    _defineProperty(CSSLexer, "WhitespaceToken", _occamLexers.WhitespaceToken);
    _defineProperty(CSSLexer, "EndOfLineCommentToken", null);
    _defineProperty(CSSLexer, "RegularExpressionToken", null);
    _defineProperty(CSSLexer, "SingleLineCommentToken", null);
    _defineProperty(CSSLexer, "EndOfMultiLineCommentToken", null);
    _defineProperty(CSSLexer, "StartOfMultiLineCommentToken", null);
    _defineProperty(CSSLexer, "MiddleOfMultiLineCommentToken", null);
    _defineProperty(CSSLexer, "SinglyQuotedStringLiteralToken", null);
    _defineProperty(CSSLexer, "DoublyQuotedStringLiteralToken", _occamLexers.DoublyQuotedStringLiteralToken);
    exports.default = CSSLexer;
  });

  // node_modules/occam-parsers/lib/bnf/bnf.js
  var require_bnf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bnf = '\n\n      document                 ::=  ( rule | error )+ ;\n\n      rule                     ::=  name ambiguousModifier? "::=" definitions ";" ;\n\n      name                     ::=  [name] ;\n\n      definitions              ::=  definition ( "|" definition )* ;\n\n      definition               ::=  part+ ;\n \n      part                     ::=  nonTerminalPart quantifier*\n\n                                 |  terminalPart quantifier*\n                              \n                                 |  noWhitespacePart\n\n                                 ;\n\n      nonTerminalPart          ::=  choiceOfParts\n\n                                 |  sequenceOfParts\n\n                                 |  ruleName lookAheadModifier?\n\n                                 ;\n\n      terminalPart             ::=  significantTokenType\n  \n                                 |  regularExpression\n \n                                 |  terminalSymbol\n  \n                                 |  endOfLine\n  \n                                 |  wildcard\n  \n                                 ;\n                              \n      noWhitespacePart         ::=  "<NO_WHITESPACE>" ;                              \n\n      choiceOfParts            ::=  "(" part ( "|" part )+ ")" ;\n\n      sequenceOfParts          ::=  "(" part part+ ")" ;\n\n      ruleName                 ::=  [name] ;\n\n      significantTokenType     ::=  [type] ;\n\n      regularExpression        ::=  [regular-expression] ;\n\n      terminalSymbol           ::=  [string-literal] ;\n\n      endOfLine                ::=  "<END_OF_LINE>" ;\n\n      wildcard                 ::=  "." ;\n\n      quantifier               ::=  optionalQuantifier\n \n                                 |  oneOrMoreQuantifier\n  \n                                 |  zeroOrMoreQuantifier\n  \n                                 ;\n\n      ambiguousModifier        ::=  <NO_WHITESPACE>"!" ;\n\n      lookAheadModifier        ::=  <NO_WHITESPACE>"..." ;\n\n      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;\n\n      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;\n\n      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;\n\n      error                    ::=  . ;\n\n';
    var _default = bnf;
    exports.default = _default;
  });

  // node_modules/occam-parsers/lib/constants.js
  var require_constants4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EMPTY_STRING = void 0;
    var EMPTY_STRING = "";
    exports.EMPTY_STRING = EMPTY_STRING;
  });

  // node_modules/occam-parsers/lib/utilities/string.js
  var require_string = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.paddingFromPaddingLength = paddingFromPaddingLength;
    var _necessary = require_browser();
    var _constants = require_constants4();
    var SPACE_CHARACTER = _necessary.characters.SPACE_CHARACTER;
    function paddingFromPaddingLength(paddingLength) {
      var padding = _constants.EMPTY_STRING;
      for (var position = 0; position < paddingLength; position++) {
        padding += SPACE_CHARACTER;
      }
      return padding;
    }
  });

  // node_modules/occam-parsers/lib/rule.js
  var require_rule2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _constants = require_constants4();
    var _string = require_string();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var exclamationMark = _occamLexers.specialSymbols.exclamationMark;
    var Rule = /* @__PURE__ */ function() {
      function Rule2(name, ambiguous, definitions, NonTerminalNode) {
        _classCallCheck(this, Rule2);
        this.name = name;
        this.ambiguous = ambiguous;
        this.definitions = definitions;
        this.NonTerminalNode = NonTerminalNode;
      }
      _createClass(Rule2, [
        {
          key: "getName",
          value: function getName() {
            return this.name;
          }
        },
        {
          key: "isAmbiguous",
          value: function isAmbiguous() {
            return this.ambiguous;
          }
        },
        {
          key: "getDefinitions",
          value: function getDefinitions() {
            return this.definitions;
          }
        },
        {
          key: "getNonTerminalNode",
          value: function getNonTerminalNode() {
            return this.NonTerminalNode;
          }
        },
        {
          key: "setName",
          value: function setName(name) {
            this.name = name;
          }
        },
        {
          key: "setAmbiguous",
          value: function setAmbiguous(ambiguous) {
            this.ambiguous = ambiguous;
          }
        },
        {
          key: "setDefinitions",
          value: function setDefinitions(definitions) {
            this.definitions = definitions;
          }
        },
        {
          key: "setNonTerminalNode",
          value: function setNonTerminalNode(NonTerminalNode) {
            this.NonTerminalNode = NonTerminalNode;
          }
        },
        {
          key: "addDefinition",
          value: function addDefinition(definition, position) {
            var definitionsIncludesDefinition = this.definitions.includes(definition);
            if (!definitionsIncludesDefinition) {
              if (position === void 0) {
                var definitionsLength = this.definitions.length;
                position = definitionsLength;
              }
              var start = position, deleteCount = 0;
              this.definitions.splice(start, deleteCount, definition);
            }
          }
        },
        {
          key: "removeDefinition",
          value: function removeDefinition(definition) {
            var definitionsIncludesDefinition = this.definitions.includes(definition);
            if (definitionsIncludesDefinition) {
              var definitionIndex = this.definitions.indexOf(definition), start = definitionIndex, deleteCount = 1;
              this.definitions.splice(start, deleteCount);
            }
          }
        },
        {
          key: "replaceDefinition",
          value: function replaceDefinition(oldDefinition, newDefinition) {
            var oldDefinitionIndex = this.definitions.indexOf(oldDefinition);
            if (oldDefinitionIndex > -1) {
              var start = oldDefinitionIndex, deleteCount = 1;
              this.definitions.splice(start, deleteCount, newDefinition);
            }
          }
        },
        {
          key: "parse",
          value: function parse(state, callback) {
            var _this = this;
            var ruleNode = null;
            state.increaseDepth();
            var tooDeep = state.isTooDeep();
            if (tooDeep) {
              throw new Error('The parse tree is too deep at rule "'.concat(this.name, '".'));
            }
            var parsed, definitionNodes;
            this.definitions.some(function(definition) {
              definitionNodes = [];
              parsed = _this.parseDefinition(definition, definitionNodes, state, callback);
              if (parsed) {
                return true;
              }
            });
            if (parsed) {
              var ruleName = this.name, childNodes = definitionNodes, nonTerminalNode = this.NonTerminalNode.fromRuleNameAndChildNodes(ruleName, childNodes);
              ruleNode = nonTerminalNode;
            }
            state.decreaseDepth();
            return ruleNode;
          }
        },
        {
          key: "parseDefinition",
          value: function parseDefinition(definition, nodes, state, callback) {
            var parsed;
            var savedIndex = state.getSavedIndex();
            parsed = definition.parse(nodes, state, callback);
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString(maximumRuleNameLength) {
            var multiLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var definitionsLength = this.definitions.length;
            multiLine = multiLine && definitionsLength > 1;
            var maximumPadding = (0, _string).paddingFromPaddingLength(maximumRuleNameLength), definitionsString1 = this.definitions.reduce(function(definitionsString, definition) {
              var definitionString = definition.asString();
              if (definitionsString === _constants.EMPTY_STRING) {
                definitionsString = definitionString;
              } else {
                definitionsString = multiLine ? "".concat(definitionsString, "\n\n").concat(maximumPadding, "   | ").concat(definitionString) : "".concat(definitionsString, " | ").concat(definitionString);
              }
              return definitionsString;
            }, _constants.EMPTY_STRING), ruleName = this.name, ruleNameLength = ruleName.length, ambiguousString = this.ambiguous ? exclamationMark : _constants.EMPTY_STRING, ambiguousStringLength = ambiguousString.length, paddingLength = maximumRuleNameLength - ruleNameLength - ambiguousStringLength, padding = (0, _string).paddingFromPaddingLength(paddingLength);
            var semicolonString = multiLine ? "\n\n".concat(maximumPadding, "   ;") : " ;", string = "\n\n".concat(this.name).concat(ambiguousString).concat(padding, " ::= ").concat(definitionsString1).concat(semicolonString);
            return string;
          }
        }
      ], [
        {
          key: "fromRule",
          value: function fromRule(Class, rule) {
            if (rule === void 0) {
              rule = Class;
              Class = Rule2;
            }
            var name = rule.getName(), ambiguous = rule.isAmbiguous(), definitions = rule.getDefinitions(), NonTerminalNode = rule.getNonTerminalNode();
            rule = new Class(name, ambiguous, definitions, NonTerminalNode);
            return rule;
          }
        }
      ]);
      return Rule2;
    }();
    exports.default = Rule;
  });

  // node_modules/occam-parsers/lib/defaults.js
  var require_defaults = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEFAULT_MAXIMUM_DEPTH = void 0;
    var DEFAULT_MAXIMUM_DEPTH = 99;
    exports.DEFAULT_MAXIMUM_DEPTH = DEFAULT_MAXIMUM_DEPTH;
  });

  // node_modules/occam-parsers/lib/state.js
  var require_state2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _defaults = require_defaults();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var State = /* @__PURE__ */ function() {
      function State2(ruleMap, tokens, index, depth, maximumDepth) {
        _classCallCheck(this, State2);
        this.ruleMap = ruleMap;
        this.tokens = tokens;
        this.index = index;
        this.depth = depth;
        this.maximumDepth = maximumDepth;
      }
      _createClass(State2, [
        {
          key: "getRuleMap",
          value: function getRuleMap() {
            return this.ruleMap;
          }
        },
        {
          key: "getTokens",
          value: function getTokens() {
            return this.tokens;
          }
        },
        {
          key: "getIndex",
          value: function getIndex() {
            return this.index;
          }
        },
        {
          key: "getDepth",
          value: function getDepth() {
            return this.depth;
          }
        },
        {
          key: "getMaximumDepth",
          value: function getMaximumDepth() {
            return this.maximumDepth;
          }
        },
        {
          key: "getSavedIndex",
          value: function getSavedIndex() {
            var savedIndex = this.index;
            return savedIndex;
          }
        },
        {
          key: "getNextToken",
          value: function getNextToken() {
            var nextToken = null;
            var tokensLength = this.tokens.length;
            if (this.index < tokensLength) {
              nextToken = this.tokens[this.index++];
            }
            return nextToken;
          }
        },
        {
          key: "getNextSignificantToken",
          value: function getNextSignificantToken() {
            var nextSignificantToken = null;
            var tokensLength = this.tokens.length;
            while (this.index < tokensLength) {
              var token = this.tokens[this.index++], tokenSignificant = token.isSignificant();
              if (tokenSignificant) {
                var significantToken = token;
                nextSignificantToken = significantToken;
                break;
              }
            }
            return nextSignificantToken;
          }
        },
        {
          key: "isNextTokenWhitespaceToken",
          value: function isNextTokenWhitespaceToken() {
            var nextTokenWhitespaceToken = false;
            var tokensLength = this.tokens.length;
            if (this.index < tokensLength) {
              var nextToken = this.tokens[this.index];
              nextTokenWhitespaceToken = nextToken.isWhitespaceToken();
            }
            return nextTokenWhitespaceToken;
          }
        },
        {
          key: "isTooDeep",
          value: function isTooDeep() {
            var tooDeep = this.depth > this.maximumDepth;
            return tooDeep;
          }
        },
        {
          key: "backtrack",
          value: function backtrack(savedIndex) {
            this.index = savedIndex;
          }
        },
        {
          key: "setIndex",
          value: function setIndex(index) {
            this.index = index;
          }
        },
        {
          key: "increaseDepth",
          value: function increaseDepth() {
            this.depth++;
          }
        },
        {
          key: "decreaseDepth",
          value: function decreaseDepth() {
            this.depth--;
          }
        }
      ], [
        {
          key: "fromTokensAndRuleMap",
          value: function fromTokensAndRuleMap(tokens, ruleMap) {
            var index = 0, depth = 0, maximumDepth = _defaults.DEFAULT_MAXIMUM_DEPTH, state = new State2(ruleMap, tokens, index, depth, maximumDepth);
            return state;
          }
        }
      ]);
      return State2;
    }();
    exports.default = State;
  });

  // node_modules/occam-parsers/lib/utilities/array.js
  var require_array3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.even = even;
    exports.allButFirstAndLast = allButFirstAndLast;
    exports.backwardsSome = exports.forwardsSome = exports.filter = exports.push = exports.last = exports.fourth = exports.third = exports.second = exports.first = void 0;
    var _necessary = require_browser();
    var first = _necessary.arrayUtilities.first;
    var second = _necessary.arrayUtilities.second;
    var third = _necessary.arrayUtilities.third;
    var fourth = _necessary.arrayUtilities.fourth;
    var last = _necessary.arrayUtilities.last;
    var push = _necessary.arrayUtilities.push;
    var filter = _necessary.arrayUtilities.filter;
    var forwardsSome = _necessary.arrayUtilities.forwardsSome;
    var backwardsSome = _necessary.arrayUtilities.backwardsSome;
    exports.first = first;
    exports.second = second;
    exports.third = third;
    exports.fourth = fourth;
    exports.last = last;
    exports.push = push;
    exports.filter = filter;
    exports.forwardsSome = forwardsSome;
    exports.backwardsSome = backwardsSome;
    function even(array) {
      return array.filter(function(entry, index) {
        return isEven(index);
      });
    }
    function allButFirstAndLast(array) {
      array = array.slice();
      array.shift();
      array.pop();
      return array;
    }
    function isEven(index) {
      var even1 = Math.floor(index / 2) === index / 2;
      return even1;
    }
  });

  // node_modules/occam-parsers/lib/parseTree.js
  var require_parseTree = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _array = require_array3();
    var _constants = require_constants4();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var NEW_LINE_CHARACTER = _necessary.characters.NEW_LINE_CHARACTER;
    var SPACE_CHARACTER = _necessary.characters.SPACE_CHARACTER;
    var ParseTree = /* @__PURE__ */ function() {
      function ParseTree2(lines) {
        _classCallCheck(this, ParseTree2);
        this.lines = lines;
      }
      _createClass(ParseTree2, [
        {
          key: "clone",
          value: function clone() {
            var lines = this.lines.slice(), parseTree = new ParseTree2(lines);
            return parseTree;
          }
        },
        {
          key: "getWidth",
          value: function getWidth() {
            var width;
            var linesLength = this.lines.length;
            if (linesLength === 0) {
              width = 0;
            } else {
              var lastLine = (0, _array).last(this.lines), lastLineLength = lastLine.length;
              width = lastLineLength;
            }
            return width;
          }
        },
        {
          key: "getDepth",
          value: function getDepth() {
            var linesLength = this.lines.length, depth = linesLength;
            return depth;
          }
        },
        {
          key: "forEachLine",
          value: function forEachLine(callback) {
            this.lines.forEach(callback);
          }
        },
        {
          key: "appendToTop",
          value: function appendToTop(parseTree) {
            var _this = this;
            parseTree.forEachLine(function(line) {
              _this.lines.unshift(line);
            });
          }
        },
        {
          key: "appendToLeft",
          value: function appendToLeft(parseTree) {
            var _this = this;
            parseTree.forEachLine(function(line, index) {
              _this.lines[index] = line + _this.lines[index];
            });
          }
        },
        {
          key: "appendToRight",
          value: function appendToRight(parseTree) {
            var _this = this;
            parseTree.forEachLine(function(line, index) {
              _this.lines[index] = _this.lines[index] + line;
            });
          }
        },
        {
          key: "appendToBottom",
          value: function appendToBottom(parseTree) {
            var _this = this;
            parseTree.forEachLine(function(line) {
              _this.lines.push(line);
            });
          }
        },
        {
          key: "addTopMargin",
          value: function addTopMargin(topMarginDepth) {
            var width = this.getWidth(), topMarginWidth = width, topMarginString = marginStringFromMarginWidth(topMarginWidth);
            for (var index = 0; index < topMarginDepth; index++) {
              this.lines.unshift(topMarginString);
            }
          }
        },
        {
          key: "addLeftMargin",
          value: function addLeftMargin(leftMarginWidth) {
            var leftMarginString = marginStringFromMarginWidth(leftMarginWidth), linesLength = this.lines.length;
            for (var index = 0; index < linesLength; index++) {
              this.lines[index] = leftMarginString + this.lines[index];
            }
          }
        },
        {
          key: "addRightMargin",
          value: function addRightMargin(rightMarginWidth) {
            var rightMarginString = marginStringFromMarginWidth(rightMarginWidth), linesLength = this.lines.length;
            for (var index = 0; index < linesLength; index++) {
              this.lines[index] = this.lines[index] + rightMarginString;
            }
          }
        },
        {
          key: "addBottomMargin",
          value: function addBottomMargin(bottomMarginDepth) {
            var width = this.getWidth(), bottomMarginWidth = width, bottomMarginString = marginStringFromMarginWidth(bottomMarginWidth);
            for (var index = 0; index < bottomMarginDepth; index++) {
              this.lines.push(bottomMarginString);
            }
          }
        },
        {
          key: "popLine",
          value: function popLine() {
            return this.lines.pop();
          }
        },
        {
          key: "shiftLine",
          value: function shiftLine() {
            return this.lines.shift();
          }
        },
        {
          key: "pushLine",
          value: function pushLine(line) {
            this.lines.push(line);
          }
        },
        {
          key: "unshiftLine",
          value: function unshiftLine(line) {
            this.lines.unshift(line);
          }
        },
        {
          key: "asString",
          value: function asString() {
            var string1 = this.lines.reduce(function(string, line) {
              string += line + NEW_LINE_CHARACTER;
              return string;
            }, _constants.EMPTY_STRING);
            return string1;
          }
        }
      ]);
      return ParseTree2;
    }();
    exports.default = ParseTree;
    function marginStringFromMarginWidth(marginWidth, spaceCharacter) {
      spaceCharacter = spaceCharacter || SPACE_CHARACTER;
      var marginString = _constants.EMPTY_STRING;
      for (var index = 0; index < marginWidth; index++) {
        marginString += spaceCharacter;
      }
      return marginString;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/verticalBranch.js
  var require_verticalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _parseTree = _interopRequireDefault2(require_parseTree());
    var _constants = require_constants4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var BAR_CHARACTER = _necessary.characters.BAR_CHARACTER;
    var VerticalBranchParseTree = /* @__PURE__ */ function(ParseTree) {
      _inherits(VerticalBranchParseTree2, ParseTree);
      var _super = _createSuper(VerticalBranchParseTree2);
      function VerticalBranchParseTree2(lines, verticalBranchPosition) {
        _classCallCheck(this, VerticalBranchParseTree2);
        var _this;
        _this = _super.call(this, lines);
        _this.verticalBranchPosition = verticalBranchPosition;
        return _this;
      }
      _createClass(VerticalBranchParseTree2, [
        {
          key: "getVerticalBranchPosition",
          value: function getVerticalBranchPosition() {
            return this.verticalBranchPosition;
          }
        },
        {
          key: "addLeftMargin",
          value: function addLeftMargin(leftMarginWidth) {
            _get(_getPrototypeOf(VerticalBranchParseTree2.prototype), "addLeftMargin", this).call(this, leftMarginWidth);
            this.verticalBranchPosition += leftMarginWidth;
          }
        }
      ], [
        {
          key: "fromWidth",
          value: function fromWidth(width) {
            var string = BAR_CHARACTER, verticalBranchPosition = 0, verticalBranchParseTree = VerticalBranchParseTree2.fromStringAndVerticalBranchPosition(VerticalBranchParseTree2, string, verticalBranchPosition), leftMarginWidth = Math.floor(width / 2), rightMarginWidth = width - leftMarginWidth - 1;
            verticalBranchParseTree.addLeftMargin(leftMarginWidth);
            verticalBranchParseTree.addRightMargin(rightMarginWidth);
            return verticalBranchParseTree;
          }
        },
        {
          key: "fromDepthAndVerticalBranchPosition",
          value: function fromDepthAndVerticalBranchPosition(Class, depth, verticalBranchPosition) {
            var lines = linesFromDepth(depth), args = [
              null,
              lines,
              verticalBranchPosition
            ], verticalBranchParseTree = new (Function.prototype.bind.apply(Class, args))();
            return verticalBranchParseTree;
          }
        },
        {
          key: "fromStringAndVerticalBranchPosition",
          value: function fromStringAndVerticalBranchPosition(Class, string, verticalBranchPosition) {
            if (verticalBranchPosition === void 0) {
              verticalBranchPosition = string;
              string = Class;
              Class = _parseTree.default;
            }
            var line = string, lines = [
              line
            ], args = [
              null,
              lines,
              verticalBranchPosition
            ], verticalBranchParseTree = new (Function.prototype.bind.apply(Class, args))();
            return verticalBranchParseTree;
          }
        }
      ]);
      return VerticalBranchParseTree2;
    }(_parseTree.default);
    exports.default = VerticalBranchParseTree;
    function linesFromDepth(depth) {
      var lines = [];
      var index = 0;
      while (index < depth) {
        lines[index++] = _constants.EMPTY_STRING;
      }
      return lines;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/ruleName.js
  var require_ruleName = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _verticalBranch = _interopRequireDefault2(require_verticalBranch());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleNameParseTree = /* @__PURE__ */ function(VerticalBranchParseTree) {
      _inherits(RuleNameParseTree2, VerticalBranchParseTree);
      var _super = _createSuper(RuleNameParseTree2);
      function RuleNameParseTree2() {
        _classCallCheck(this, RuleNameParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(RuleNameParseTree2, null, [
        {
          key: "fromNonTerminalNodeAndTokens",
          value: function fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
            var ruleName = nonTerminalNode.getRuleName(), tokenIndexes = tokenIndexesFromNonTerminalNodeAndTokens(nonTerminalNode, tokens), string = "".concat(ruleName).concat(tokenIndexes), stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), ruleNameParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(RuleNameParseTree2, string, verticalBranchPosition);
            ruleNameParseTree.appendToTop(verticalBranchParseTree);
            return ruleNameParseTree;
          }
        }
      ]);
      return RuleNameParseTree2;
    }(_verticalBranch.default);
    exports.default = RuleNameParseTree;
    function tokenIndexesFromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
      var firstSignificantToken = nonTerminalNode.getFirstSignificantToken(), lastSignificantToken = nonTerminalNode.getLastSignificantToken(), firstSignificantTokenIndex = tokens.indexOf(firstSignificantToken), lastSignificantTokenIndex = tokens.indexOf(lastSignificantToken), tokenIndexes = firstSignificantTokenIndex !== lastSignificantTokenIndex ? "(".concat(firstSignificantTokenIndex, "-").concat(lastSignificantTokenIndex, ")") : "(".concat(firstSignificantTokenIndex, ")");
      return tokenIndexes;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/horizontalBranch.js
  var require_horizontalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _parseTree = _interopRequireDefault2(require_parseTree());
    var _constants = require_constants4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DASH_CHARACTER = _necessary.characters.DASH_CHARACTER;
    var HorizontalBranchParseTree = /* @__PURE__ */ function(ParseTree) {
      _inherits(HorizontalBranchParseTree2, ParseTree);
      var _super = _createSuper(HorizontalBranchParseTree2);
      function HorizontalBranchParseTree2() {
        _classCallCheck(this, HorizontalBranchParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(HorizontalBranchParseTree2, null, [
        {
          key: "fromWidth",
          value: function fromWidth(width) {
            var string = stringFromCharactersWidth(width, DASH_CHARACTER), line = string, lines = [
              line
            ], horizontalBranchParseTree = new HorizontalBranchParseTree2(lines);
            return horizontalBranchParseTree;
          }
        }
      ]);
      return HorizontalBranchParseTree2;
    }(_parseTree.default);
    exports.default = HorizontalBranchParseTree;
    function stringFromCharactersWidth(charactersWidth, character) {
      var string = _constants.EMPTY_STRING;
      for (var index = 0; index < charactersWidth; index++) {
        string += character;
      }
      return string;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/childNodes.js
  var require_childNodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _verticalBranch = _interopRequireDefault2(require_verticalBranch());
    var _horizontalBranch = _interopRequireDefault2(require_horizontalBranch());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ChildNodesParseTree = /* @__PURE__ */ function(VerticalBranchParseTree) {
      _inherits(ChildNodesParseTree2, VerticalBranchParseTree);
      var _super = _createSuper(ChildNodesParseTree2);
      function ChildNodesParseTree2() {
        _classCallCheck(this, ChildNodesParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(ChildNodesParseTree2, null, [
        {
          key: "fromChildNodesAndTokens",
          value: function fromChildNodesAndTokens(childNodes, tokens) {
            var childNodesParseTree;
            var childNodeParseTrees1 = childNodes.reduce(function(childNodeParseTrees, childNode) {
              var childNodeParseTree = childNode.asParseTree(tokens);
              childNodeParseTrees.push(childNodeParseTree);
              return childNodeParseTrees;
            }, []), childNodeParseTreesLength = childNodeParseTrees1.length;
            if (childNodeParseTreesLength === 1) {
              var firstChildNodeParseTree = (0, _array).first(childNodeParseTrees1);
              childNodesParseTree = firstChildNodeParseTree;
            } else {
              var firstVerticalBranchPosition = void 0, lastVerticalBranchPosition = 0, childNodeParseTreesWidth = 0, childNodeParseTreesDepth = 0;
              childNodeParseTrees1.forEach(function(childNodeParseTree, index) {
                var childNodeParseTreeWidth = childNodeParseTree.getWidth(), childNodeParseTreeDepth = childNodeParseTree.getDepth();
                if (index === 0) {
                  var firstChildNodeParseTree2 = childNodeParseTree, firstChildNodeParseTreeVerticalBranchPosition = firstChildNodeParseTree2.getVerticalBranchPosition();
                  firstVerticalBranchPosition = firstChildNodeParseTreeVerticalBranchPosition;
                }
                if (index === childNodeParseTreesLength - 1) {
                  var lastChildNodeParseTree = childNodeParseTree, lastChildNodeParseTreeVerticalBranchPosition = lastChildNodeParseTree.getVerticalBranchPosition();
                  lastVerticalBranchPosition += lastChildNodeParseTreeVerticalBranchPosition;
                }
                if (index < childNodeParseTreesLength - 1) {
                  lastVerticalBranchPosition += childNodeParseTreeWidth;
                  lastVerticalBranchPosition += 1;
                  childNodeParseTreesWidth += 1;
                }
                childNodeParseTreesWidth += childNodeParseTreeWidth;
                childNodeParseTreesDepth = Math.max(childNodeParseTreesDepth, childNodeParseTreeDepth);
              });
              var width = lastVerticalBranchPosition - firstVerticalBranchPosition + 1, verticalBranchParseTree = _verticalBranch.default.fromWidth(width), horizontalBranchParseTree = _horizontalBranch.default.fromWidth(width), leftMarginWidth = firstVerticalBranchPosition, rightMarginWidth1 = childNodeParseTreesWidth - width - leftMarginWidth;
              verticalBranchParseTree.addLeftMargin(leftMarginWidth);
              verticalBranchParseTree.addRightMargin(rightMarginWidth1);
              horizontalBranchParseTree.addLeftMargin(leftMarginWidth);
              horizontalBranchParseTree.addRightMargin(rightMarginWidth1);
              var verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition();
              childNodesParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(ChildNodesParseTree2, childNodeParseTreesDepth, verticalBranchPosition);
              childNodeParseTrees1.forEach(function(childNodeParseTree, index) {
                var childNodeParseTreeDepth = childNodeParseTree.getDepth(), clonedChildNodeParseTree = childNodeParseTree.clone();
                if (index < childNodeParseTreesLength - 1) {
                  var rightMarginWidth = 1;
                  clonedChildNodeParseTree.addRightMargin(rightMarginWidth);
                }
                if (childNodeParseTreeDepth < childNodeParseTreesDepth) {
                  var bottomMarginDepth = childNodeParseTreesDepth - childNodeParseTreeDepth;
                  clonedChildNodeParseTree.addBottomMargin(bottomMarginDepth);
                }
                childNodesParseTree.appendToRight(clonedChildNodeParseTree);
              });
              childNodesParseTree.appendToTop(horizontalBranchParseTree);
              childNodesParseTree.appendToTop(verticalBranchParseTree);
            }
            return childNodesParseTree;
          }
        }
      ]);
      return ChildNodesParseTree2;
    }(_verticalBranch.default);
    exports.default = ChildNodesParseTree;
  });

  // node_modules/occam-parsers/lib/parseTree/nonTerminalNode.js
  var require_nonTerminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ruleName = _interopRequireDefault2(require_ruleName());
    var _childNodes = _interopRequireDefault2(require_childNodes());
    var _verticalBranch = _interopRequireDefault2(require_verticalBranch());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NonTerminalNodeParseTree = /* @__PURE__ */ function(VerticalBranchParseTree) {
      _inherits(NonTerminalNodeParseTree2, VerticalBranchParseTree);
      var _super = _createSuper(NonTerminalNodeParseTree2);
      function NonTerminalNodeParseTree2() {
        _classCallCheck(this, NonTerminalNodeParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(NonTerminalNodeParseTree2, null, [
        {
          key: "fromNonTerminalNodeAndTokens",
          value: function fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
            var childNodes = nonTerminalNode.getChildNodes(), ruleNameParseTree = _ruleName.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), childNodesParseTree = _childNodes.default.fromChildNodesAndTokens(childNodes, tokens);
            var ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
            var childNodesParseTreeVerticalBranchPosition = childNodesParseTree.getVerticalBranchPosition(), verticalBranchPositionsDifference = ruleNameParseTreeVerticalBranchPosition - childNodesParseTreeVerticalBranchPosition;
            var leftMarginWidth = void 0;
            if (false) {
            } else if (verticalBranchPositionsDifference < 0) {
              leftMarginWidth = -verticalBranchPositionsDifference;
              ruleNameParseTree.addLeftMargin(leftMarginWidth);
            } else if (verticalBranchPositionsDifference > 0) {
              leftMarginWidth = +verticalBranchPositionsDifference;
              childNodesParseTree.addLeftMargin(leftMarginWidth);
            }
            var ruleNameParseTreeWidth = ruleNameParseTree.getWidth(), childNodesParseTreeWidth = childNodesParseTree.getWidth(), widthsDifference = ruleNameParseTreeWidth - childNodesParseTreeWidth;
            var rightMarginWidth = void 0;
            if (false) {
            } else if (widthsDifference < 0) {
              rightMarginWidth = -widthsDifference;
              ruleNameParseTree.addRightMargin(rightMarginWidth);
            } else if (widthsDifference > 0) {
              rightMarginWidth = +widthsDifference;
              childNodesParseTree.addRightMargin(rightMarginWidth);
            }
            ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
            var ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), nonTerminalNodeParseTreeDepth = ruleNameParseTreeDepth, verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree2, nonTerminalNodeParseTreeDepth, verticalBranchPosition);
            nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
            nonTerminalNodeParseTree.appendToBottom(childNodesParseTree);
            return nonTerminalNodeParseTree;
          }
        }
      ]);
      return NonTerminalNodeParseTree2;
    }(_verticalBranch.default);
    exports.default = NonTerminalNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/nonTerminal.js
  var require_nonTerminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminalNode = _interopRequireDefault2(require_nonTerminalNode());
    var _array = require_array3();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNode = /* @__PURE__ */ function() {
      function NonTerminalNode2(ruleName, childNodes) {
        _classCallCheck(this, NonTerminalNode2);
        this.ruleName = ruleName;
        this.childNodes = childNodes;
      }
      _createClass(NonTerminalNode2, [
        {
          key: "isTerminalNode",
          value: function isTerminalNode() {
            var terminalNode = false;
            return terminalNode;
          }
        },
        {
          key: "isNonTerminalNode",
          value: function isNonTerminalNode() {
            var nonTerminalNode = true;
            return nonTerminalNode;
          }
        },
        {
          key: "getRuleName",
          value: function getRuleName() {
            return this.ruleName;
          }
        },
        {
          key: "getChildNodes",
          value: function getChildNodes() {
            return this.childNodes;
          }
        },
        {
          key: "getFirstSignificantToken",
          value: function getFirstSignificantToken() {
            var firstSignificantToken = null;
            (0, _array).forwardsSome(this.childNodes, function(childNode) {
              firstSignificantToken = childNode.getFirstSignificantToken();
              if (firstSignificantToken !== null) {
                return true;
              }
            });
            return firstSignificantToken;
          }
        },
        {
          key: "getLastSignificantToken",
          value: function getLastSignificantToken() {
            var lastSignificantToken = null;
            (0, _array).backwardsSome(this.childNodes, function(childNode) {
              lastSignificantToken = childNode.getLastSignificantToken();
              if (lastSignificantToken !== null) {
                return true;
              }
            });
            return lastSignificantToken;
          }
        },
        {
          key: "setRuleName",
          value: function setRuleName(ruleName) {
            this.ruleName = ruleName;
          }
        },
        {
          key: "setChildNodes",
          value: function setChildNodes(childNodes) {
            this.childNodes = childNodes;
          }
        },
        {
          key: "asParseTree",
          value: function asParseTree(tokens) {
            var nonTerminalNode = this, nonTerminalNodeParseTree = _nonTerminalNode.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), parseTree = nonTerminalNodeParseTree;
            return parseTree;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(Class, ruleName, childNodes) {
            if (childNodes === void 0) {
              childNodes = ruleName;
              ruleName = Class;
              Class = NonTerminalNode2;
            }
            var childNodesLength = childNodes.length;
            if (childNodesLength === 0) {
              throw new Error("There are no child nodes at rule '".concat(ruleName, "'."));
            }
            var nonTerminalNode = new Class(ruleName, childNodes);
            return nonTerminalNode;
          }
        }
      ]);
      return NonTerminalNode2;
    }();
    exports.default = NonTerminalNode;
  });

  // node_modules/occam-parsers/lib/node/bnf/name.js
  var require_name2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NameBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(NameBNFNode2, NonTerminalNode);
      var _super = _createSuper(NameBNFNode2);
      function NameBNFNode2() {
        _classCallCheck(this, NameBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(NameBNFNode2, [
        {
          key: "getName",
          value: function getName() {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), name = terminalNodeContent;
            return name;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(NameBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return NameBNFNode2;
    }(_nonTerminal.default);
    exports.default = NameBNFNode;
  });

  // node_modules/occam-parsers/lib/utilities/part.js
  var require_part = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPartRuleNamePartWithLookAhead = isPartRuleNamePartWithLookAhead;
    function isPartRuleNamePartWithLookAhead(part) {
      var partRuleNamePartWithLookAhead = false;
      var partRuleNamePart = isPartRuleNamePart(part);
      if (partRuleNamePart) {
        var ruleNamePart = part, lookAhead = ruleNamePart.isLookAhead();
        if (lookAhead) {
          partRuleNamePartWithLookAhead = true;
        }
      }
      return partRuleNamePartWithLookAhead;
    }
    function isPartRuleNamePart(part) {
      var partRuleNamePart = false;
      var partTerminalPart = part.isTerminalPart(), partNonTerminalPart = !partTerminalPart;
      if (partNonTerminalPart) {
        var nonTerminalPart = part, nonTerminalPartRuleNamePart = nonTerminalPart.isRuleNamePart();
        partRuleNamePart = nonTerminalPartRuleNamePart;
      }
      return partRuleNamePart;
    }
  });

  // node_modules/occam-parsers/lib/utilities/lookAhead.js
  var require_lookAhead = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseParts = parseParts;
    var _array = require_array3();
    var _part = require_part();
    function parseParts(parts, nodes, index, state, callback) {
      var parsed;
      var partsLength = parts.length;
      if (index === partsLength) {
        parsed = callback !== null ? callback() : true;
      } else {
        var part = parts[index];
        parsed = parsePartOfParts(part, parts, nodes, index, state, callback);
      }
      return parsed;
    }
    function parsePartOfParts(part, parts, nodes, index, state, callback) {
      var parsed;
      if (callback !== null) {
        var partsNodes = [];
        index++;
        parsed = part.parse(nodes, state, function() {
          return parseParts(parts, partsNodes, index, state, callback);
        });
        if (parsed) {
          (0, _array).push(nodes, partsNodes);
        }
      } else {
        var partRuleNamePartWithLookAhead = (0, _part).isPartRuleNamePartWithLookAhead(part);
        if (partRuleNamePartWithLookAhead) {
          var ruleNamePart = part, partsNodes1 = [];
          index++;
          parsed = ruleNamePart.parse(nodes, state, function() {
            return parseParts(parts, partsNodes1, index, state, callback);
          });
          if (parsed) {
            (0, _array).push(nodes, partsNodes1);
          }
        } else {
          parsed = part.parse(nodes, state, callback);
          if (parsed) {
            index++;
            parsed = parseParts(parts, nodes, index, state, callback);
          }
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/definition.js
  var require_definition = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _array = require_array3();
    var _lookAhead = require_lookAhead();
    var _constants = require_constants4();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Definition = /* @__PURE__ */ function() {
      function Definition2(parts) {
        _classCallCheck(this, Definition2);
        this.parts = parts;
      }
      _createClass(Definition2, [
        {
          key: "getParts",
          value: function getParts() {
            return this.parts;
          }
        },
        {
          key: "getFirstPart",
          value: function getFirstPart() {
            var firstPart = (0, _array).first(this.parts);
            return firstPart;
          }
        },
        {
          key: "getPartsLength",
          value: function getPartsLength() {
            var partsLength = this.parts.length;
            return partsLength;
          }
        },
        {
          key: "addPart",
          value: function addPart(part) {
            this.parts.push(part);
          }
        },
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var index = 0;
            parsed = (0, _lookAhead).parseParts(this.parts, nodes, index, state, callback);
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var partsString1 = this.parts.reduce(function(partsString, part) {
              var partString = part.asString();
              if (partsString === _constants.EMPTY_STRING) {
                partsString = partString;
              } else {
                partsString = "".concat(partsString, " ").concat(partString);
              }
              return partsString;
            }, _constants.EMPTY_STRING), string = partsString1;
            return string;
          }
        }
      ]);
      return Definition2;
    }();
    exports.default = Definition;
  });

  // node_modules/occam-parsers/lib/part/terminal.js
  var require_terminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    var TerminalPart = /* @__PURE__ */ function() {
      function TerminalPart2() {
        _classCallCheck(this, TerminalPart2);
      }
      _createClass(TerminalPart2, [
        {
          key: "isNonTerminalPart",
          value: function isNonTerminalPart() {
            var nonTerminalPart = false;
            return nonTerminalPart;
          }
        },
        {
          key: "isTerminalPart",
          value: function isTerminalPart() {
            var terminalPart = true;
            return terminalPart;
          }
        },
        {
          key: "isNoWhitespacePart",
          value: function isNoWhitespacePart() {
            var noWhitespacePart = false;
            return noWhitespacePart;
          }
        },
        {
          key: "clone",
          value: function clone(Part) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              remainingArguments[_key - 1] = arguments[_key];
            }
            return _construct(Part, _toConsumableArray(remainingArguments));
          }
        }
      ]);
      return TerminalPart2;
    }();
    exports.default = TerminalPart;
  });

  // node_modules/occam-parsers/lib/parseTree/terminalNode.js
  var require_terminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _verticalBranch = _interopRequireDefault2(require_verticalBranch());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalNodeParseTree = /* @__PURE__ */ function(VerticalBranchParseTree) {
      _inherits(TerminalNodeParseTree2, VerticalBranchParseTree);
      var _super = _createSuper(TerminalNodeParseTree2);
      function TerminalNodeParseTree2() {
        _classCallCheck(this, TerminalNodeParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(TerminalNodeParseTree2, null, [
        {
          key: "fromTerminalNodeAndTokens",
          value: function fromTerminalNodeAndTokens(terminalNode, tokens) {
            var significantToken = terminalNode.getSignificantToken(), content = terminalNode.getContent(), type = significantToken.getType(), tokenIndex = tokens.indexOf(significantToken), string = "".concat(content, "[").concat(type, "](").concat(tokenIndex, ")"), stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(TerminalNodeParseTree2, string, verticalBranchPosition);
            terminalNodeParseTree.appendToTop(verticalBranchParseTree);
            return terminalNodeParseTree;
          }
        }
      ]);
      return TerminalNodeParseTree2;
    }(_verticalBranch.default);
    exports.default = TerminalNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/terminal.js
  var require_terminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _terminalNode = _interopRequireDefault2(require_terminalNode());
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalNode = /* @__PURE__ */ function() {
      function TerminalNode2(significantToken) {
        _classCallCheck(this, TerminalNode2);
        this.significantToken = significantToken;
      }
      _createClass(TerminalNode2, [
        {
          key: "getSignificantToken",
          value: function getSignificantToken() {
            return this.significantToken;
          }
        },
        {
          key: "getFirstSignificantToken",
          value: function getFirstSignificantToken() {
            var firstSignificantToken = this.significantToken;
            return firstSignificantToken;
          }
        },
        {
          key: "getLastSignificantToken",
          value: function getLastSignificantToken() {
            var lastSignificantToken = this.significantToken;
            return lastSignificantToken;
          }
        },
        {
          key: "isNoWhitespaceNode",
          value: function isNoWhitespaceNode() {
            var noWhitespaceNode = false;
            return noWhitespaceNode;
          }
        },
        {
          key: "isTerminalNode",
          value: function isTerminalNode() {
            var terminalNode = true;
            return terminalNode;
          }
        },
        {
          key: "isNonTerminalNode",
          value: function isNonTerminalNode() {
            var nonTerminalNode = false;
            return nonTerminalNode;
          }
        },
        {
          key: "getType",
          value: function getType() {
            return this.significantToken.getType();
          }
        },
        {
          key: "getContent",
          value: function getContent() {
            return this.significantToken.getContent();
          }
        },
        {
          key: "setSignificantToken",
          value: function setSignificantToken(significantToken) {
            this.significantToken = significantToken;
          }
        },
        {
          key: "asParseTree",
          value: function asParseTree(tokens) {
            var terminalNode = this, terminalNodeParseTree = _terminalNode.default.fromTerminalNodeAndTokens(terminalNode, tokens), parseTree = terminalNodeParseTree;
            return parseTree;
          }
        }
      ], [
        {
          key: "fromSignificantToken",
          value: function fromSignificantToken(Class, significantToken) {
            if (significantToken === void 0) {
              significantToken = Class;
              Class = TerminalNode2;
            }
            var terminalNode = new Class(significantToken);
            return terminalNode;
          }
        }
      ]);
      return TerminalNode2;
    }();
    exports.default = TerminalNode;
  });

  // node_modules/occam-parsers/lib/part/terminal/significantTokenType.js
  var require_significantTokenType = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _terminal = _interopRequireDefault2(require_terminal());
    var _terminal1 = _interopRequireDefault2(require_terminal2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SignificantTokenTypePart = /* @__PURE__ */ function(TerminalPart) {
      _inherits(SignificantTokenTypePart2, TerminalPart);
      var _super = _createSuper(SignificantTokenTypePart2);
      function SignificantTokenTypePart2(significantTokenType) {
        _classCallCheck(this, SignificantTokenTypePart2);
        var _this;
        _this = _super.call(this);
        _this.significantTokenType = significantTokenType;
        return _this;
      }
      _createClass(SignificantTokenTypePart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var terminalNode = null;
            var savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
            if (significantToken !== null) {
              var significantTokenType = significantToken.getType();
              if (significantTokenType === this.significantTokenType) {
                terminalNode = _terminal1.default.fromSignificantToken(significantToken);
              }
            }
            parsed = terminalNode !== null;
            if (parsed) {
              nodes.push(terminalNode);
              if (callback !== null) {
                parsed = callback();
                if (!parsed) {
                  nodes.pop();
                }
              }
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var string = "[".concat(this.significantTokenType, "]");
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(SignificantTokenTypePart2.prototype), "clone", this).call(this, SignificantTokenTypePart2, this.significantTokenType);
          }
        }
      ]);
      return SignificantTokenTypePart2;
    }(_terminal.default);
    exports.default = SignificantTokenTypePart;
  });

  // node_modules/occam-parsers/lib/definition/name.js
  var require_name3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var nameType = _occamLexers.types.nameType;
    var NameDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(NameDefinition2, Definition);
      var _super = _createSuper(NameDefinition2);
      function NameDefinition2() {
        _classCallCheck(this, NameDefinition2);
        var nameSignificantTokenType = nameType, nameSignificantTokenTypePart = new _significantTokenType.default(nameSignificantTokenType), parts = [
          nameSignificantTokenTypePart
        ];
        return _super.call(this, parts);
      }
      return NameDefinition2;
    }(_definition.default);
    exports.default = NameDefinition;
  });

  // node_modules/occam-parsers/lib/ruleNames.js
  var require_ruleNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SignificantTokenTypeRuleName = exports.ZeroOrMoreQuantifierRuleName = exports.OneOrMoreQuantifierRuleName = exports.OptionalQuantifierRuleName = exports.RegularExpressionRuleName = exports.AmbiguousModifierRuleName = exports.LookAheadModifierRuleName = exports.NoWhitespacePartRuleName = exports.SequenceOfPartsRuleName = exports.NonTerminalPartRuleName = exports.TerminalSymbolRuleName = exports.ChoiceOfPartsRuleName = exports.TerminalPartRuleName = exports.DefinitionsRuleName = exports.QuantifierRuleName = exports.DefinitionRuleName = exports.EndOfLineRuleName = exports.WildcardRuleName = exports.DocumentRuleName = exports.RuleNameRuleName = exports.ErrorRuleName = exports.RuleRuleName = exports.PartRuleName = exports.NameRuleName = void 0;
    var NameRuleName = "name";
    exports.NameRuleName = NameRuleName;
    var PartRuleName = "part";
    exports.PartRuleName = PartRuleName;
    var RuleRuleName = "rule";
    exports.RuleRuleName = RuleRuleName;
    var ErrorRuleName = "error";
    exports.ErrorRuleName = ErrorRuleName;
    var RuleNameRuleName = "ruleName";
    exports.RuleNameRuleName = RuleNameRuleName;
    var DocumentRuleName = "document";
    exports.DocumentRuleName = DocumentRuleName;
    var WildcardRuleName = "wildcard";
    exports.WildcardRuleName = WildcardRuleName;
    var EndOfLineRuleName = "endOfLine";
    exports.EndOfLineRuleName = EndOfLineRuleName;
    var DefinitionRuleName = "definition";
    exports.DefinitionRuleName = DefinitionRuleName;
    var QuantifierRuleName = "quantifier";
    exports.QuantifierRuleName = QuantifierRuleName;
    var DefinitionsRuleName = "definitions";
    exports.DefinitionsRuleName = DefinitionsRuleName;
    var TerminalPartRuleName = "terminalPart";
    exports.TerminalPartRuleName = TerminalPartRuleName;
    var ChoiceOfPartsRuleName = "choiceOfParts";
    exports.ChoiceOfPartsRuleName = ChoiceOfPartsRuleName;
    var TerminalSymbolRuleName = "terminalSymbol";
    exports.TerminalSymbolRuleName = TerminalSymbolRuleName;
    var NonTerminalPartRuleName = "nonTerminalPart";
    exports.NonTerminalPartRuleName = NonTerminalPartRuleName;
    var SequenceOfPartsRuleName = "sequenceOfParts";
    exports.SequenceOfPartsRuleName = SequenceOfPartsRuleName;
    var NoWhitespacePartRuleName = "noWhitespacePart";
    exports.NoWhitespacePartRuleName = NoWhitespacePartRuleName;
    var LookAheadModifierRuleName = "lookAheadModifier";
    exports.LookAheadModifierRuleName = LookAheadModifierRuleName;
    var AmbiguousModifierRuleName = "AmbiguousModifier";
    exports.AmbiguousModifierRuleName = AmbiguousModifierRuleName;
    var RegularExpressionRuleName = "regularExpression";
    exports.RegularExpressionRuleName = RegularExpressionRuleName;
    var OptionalQuantifierRuleName = "optionalQuantifier";
    exports.OptionalQuantifierRuleName = OptionalQuantifierRuleName;
    var OneOrMoreQuantifierRuleName = "oneOrMoreQuantifier";
    exports.OneOrMoreQuantifierRuleName = OneOrMoreQuantifierRuleName;
    var ZeroOrMoreQuantifierRuleName = "zeroOrMoreQuantifier";
    exports.ZeroOrMoreQuantifierRuleName = ZeroOrMoreQuantifierRuleName;
    var SignificantTokenTypeRuleName = "significantTokenType";
    exports.SignificantTokenTypeRuleName = SignificantTokenTypeRuleName;
  });

  // node_modules/occam-parsers/lib/rule/name.js
  var require_name4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _name = _interopRequireDefault2(require_name2());
    var _name1 = _interopRequireDefault2(require_name3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NameRule = /* @__PURE__ */ function(Rule) {
      _inherits(NameRule2, Rule);
      var _super = _createSuper(NameRule2);
      function NameRule2() {
        _classCallCheck(this, NameRule2);
        var nameDefinition = new _name1.default(), name = _ruleNames.NameRuleName, ambiguous = false, definitions = [
          nameDefinition
        ], Node2 = _name.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return NameRule2;
    }(_rule.default);
    exports.default = NameRule;
  });

  // node_modules/occam-parsers/lib/part/nonTerminal.js
  var require_nonTerminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    var NonTerminalPart = /* @__PURE__ */ function() {
      function NonTerminalPart2(type) {
        _classCallCheck(this, NonTerminalPart2);
        this.type = type;
      }
      _createClass(NonTerminalPart2, [
        {
          key: "getType",
          value: function getType() {
            return this.type;
          }
        },
        {
          key: "isNonTerminalPart",
          value: function isNonTerminalPart() {
            var nonTerminalPart = true;
            return nonTerminalPart;
          }
        },
        {
          key: "isTerminalPart",
          value: function isTerminalPart() {
            var terminalPart = false;
            return terminalPart;
          }
        },
        {
          key: "isRuleNamePart",
          value: function isRuleNamePart() {
            var ruleNamePart = false;
            return ruleNamePart;
          }
        },
        {
          key: "clone",
          value: function clone(Part) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              remainingArguments[_key - 1] = arguments[_key];
            }
            return _construct(Part, _toConsumableArray(remainingArguments));
          }
        }
      ]);
      return NonTerminalPart2;
    }();
    exports.default = NonTerminalPart;
  });

  // node_modules/occam-parsers/lib/partTypes.js
  var require_partTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.SequenceOfPartsPartType = exports.ZeroOrMorePartsPartType = exports.OneOrMorePartsPartType = exports.ChoiceOfPartsPartType = exports.OptionalPartPartType = exports.RuleNamePartType = void 0;
    var RuleNamePartType = "ruleNamePart";
    exports.RuleNamePartType = RuleNamePartType;
    var OptionalPartPartType = "optionalPart";
    exports.OptionalPartPartType = OptionalPartPartType;
    var ChoiceOfPartsPartType = "choiceOfParts";
    exports.ChoiceOfPartsPartType = ChoiceOfPartsPartType;
    var OneOrMorePartsPartType = "oneOrMoreParts";
    exports.OneOrMorePartsPartType = OneOrMorePartsPartType;
    var ZeroOrMorePartsPartType = "zeroOrMoreParts";
    exports.ZeroOrMorePartsPartType = ZeroOrMorePartsPartType;
    var SequenceOfPartsPartType = "sequenceOfParts";
    exports.SequenceOfPartsPartType = SequenceOfPartsPartType;
    var _default = {
      RuleNamePartType,
      OptionalPartPartType,
      ChoiceOfPartsPartType,
      OneOrMorePartsPartType,
      ZeroOrMorePartsPartType,
      SequenceOfPartsPartType
    };
    exports.default = _default;
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/optionalPart.js
  var require_optionalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal2());
    var _array = require_array3();
    var _partTypes = require_partTypes();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var questionMark = _occamLexers.specialSymbols.questionMark;
    var OptionalPartPart = /* @__PURE__ */ function(NonTerminalPart) {
      _inherits(OptionalPartPart2, NonTerminalPart);
      var _super = _createSuper(OptionalPartPart2);
      function OptionalPartPart2(part) {
        _classCallCheck(this, OptionalPartPart2);
        var _this;
        var type = _partTypes.OptionalPartPartType;
        _this = _super.call(this, type);
        _this.part = part;
        return _this;
      }
      _createClass(OptionalPartPart2, [
        {
          key: "getPart",
          value: function getPart() {
            return this.part;
          }
        },
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var part = this.getPart(), partNodes = [], savedIndex = state.getSavedIndex();
            parsed = parsePart(part, partNodes, state, callback);
            if (parsed) {
              (0, _array).push(nodes, partNodes);
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var operatorString = questionMark, partString = this.part.asString(), string = "".concat(partString).concat(operatorString);
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(OptionalPartPart2.prototype), "clone", this).call(this, OptionalPartPart2, this.part);
          }
        }
      ]);
      return OptionalPartPart2;
    }(_nonTerminal.default);
    exports.default = OptionalPartPart;
    function parsePart(part, nodes, state, callback) {
      var parsed;
      if (callback !== null) {
        parsed = callback();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback);
        }
      } else {
        part.parse(nodes, state, callback);
        parsed = true;
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/collectionOfParts.js
  var require_collectionOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CollectionOfPartsPart = /* @__PURE__ */ function(NonTerminalPart) {
      _inherits(CollectionOfPartsPart2, NonTerminalPart);
      var _super = _createSuper(CollectionOfPartsPart2);
      function CollectionOfPartsPart2(type, part) {
        _classCallCheck(this, CollectionOfPartsPart2);
        var _this;
        _this = _super.call(this, type);
        _this.part = part;
        return _this;
      }
      _createClass(CollectionOfPartsPart2, [
        {
          key: "getPart",
          value: function getPart() {
            return this.part;
          }
        },
        {
          key: "asString",
          value: function asString(operatorString) {
            var partString = this.part.asString(), string = "".concat(partString).concat(operatorString);
            return string;
          }
        },
        {
          key: "clone",
          value: function clone(Part) {
            return _get(_getPrototypeOf(CollectionOfPartsPart2.prototype), "clone", this).call(this, Part, this.part);
          }
        }
      ]);
      return CollectionOfPartsPart2;
    }(_nonTerminal.default);
    exports.default = CollectionOfPartsPart;
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/oneOrMoreParts.js
  var require_oneOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _collectionOfParts = _interopRequireDefault2(require_collectionOfParts());
    var _array = require_array3();
    var _partTypes = require_partTypes();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var plus = _occamLexers.specialSymbols.plus;
    var OneOrMorePartsPart = /* @__PURE__ */ function(CollectionOfPartsPart) {
      _inherits(OneOrMorePartsPart2, CollectionOfPartsPart);
      var _super = _createSuper(OneOrMorePartsPart2);
      function OneOrMorePartsPart2(part) {
        _classCallCheck(this, OneOrMorePartsPart2);
        var type = _partTypes.OneOrMorePartsPartType;
        return _super.call(this, type, part);
      }
      _createClass(OneOrMorePartsPart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var part = this.getPart(), partNodes = [], savedIndex = state.getSavedIndex();
            parsed = parsePart(part, partNodes, state, callback);
            if (parsed) {
              (0, _array).push(nodes, partNodes);
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var operatorString = plus, string = _get(_getPrototypeOf(OneOrMorePartsPart2.prototype), "asString", this).call(this, operatorString);
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(OneOrMorePartsPart2.prototype), "clone", this).call(this, OneOrMorePartsPart2);
          }
        }
      ]);
      return OneOrMorePartsPart2;
    }(_collectionOfParts.default);
    exports.default = OneOrMorePartsPart;
    function parsePart(part, nodes, state, callback) {
      var parsed1;
      if (callback !== null) {
        parsed1 = part.parse(nodes, state, function() {
          var parsed = callback();
          if (!parsed) {
            parsed = parsePart(part, nodes, state, callback);
          }
          return parsed;
        });
      } else {
        parsed1 = part.parse(nodes, state, callback);
        if (parsed1) {
          parsePart(part, nodes, state, callback);
        }
      }
      return parsed1;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/zeroOrMoreParts.js
  var require_zeroOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _collectionOfParts = _interopRequireDefault2(require_collectionOfParts());
    var _array = require_array3();
    var _partTypes = require_partTypes();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var asterisk = _occamLexers.specialSymbols.asterisk;
    var ZeroOrMorePartsPart = /* @__PURE__ */ function(CollectionOfPartsPart) {
      _inherits(ZeroOrMorePartsPart2, CollectionOfPartsPart);
      var _super = _createSuper(ZeroOrMorePartsPart2);
      function ZeroOrMorePartsPart2(part) {
        _classCallCheck(this, ZeroOrMorePartsPart2);
        var type = _partTypes.ZeroOrMorePartsPartType;
        return _super.call(this, type, part);
      }
      _createClass(ZeroOrMorePartsPart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var part = this.getPart(), partNodes = [], savedIndex = state.getSavedIndex();
            parsed = parsePart(part, partNodes, state, callback);
            if (parsed) {
              (0, _array).push(nodes, partNodes);
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var operatorString = asterisk, string = _get(_getPrototypeOf(ZeroOrMorePartsPart2.prototype), "asString", this).call(this, operatorString);
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(ZeroOrMorePartsPart2.prototype), "clone", this).call(this, ZeroOrMorePartsPart2);
          }
        }
      ]);
      return ZeroOrMorePartsPart2;
    }(_collectionOfParts.default);
    exports.default = ZeroOrMorePartsPart;
    function parsePart(part, nodes, state, callback) {
      var parsed;
      if (callback !== null) {
        parsed = callback();
        if (!parsed) {
          parsed = part.parse(nodes, state, function() {
            return parsePart(part, nodes, state, callback);
          });
        }
      } else {
        parsed = part.parse(nodes, state, callback);
        if (parsed) {
          parsePart(part, nodes, state, callback);
        }
        parsed = true;
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/utilities/bnf.js
  var require_bnf2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isNodeChoiceNode = isNodeChoiceNode;
    exports.isNodeRuleNameNode = isNodeRuleNameNode;
    exports.isNodeQuantifierNode = isNodeQuantifierNode;
    exports.isNodeLookAheadModifierNode = isNodeLookAheadModifierNode;
    exports.ruleNameFromQuantifierNode = ruleNameFromQuantifierNode;
    var _array = require_array3();
    var _ruleNames = require_ruleNames();
    function isNodeChoiceNode(node) {
      var nodeNoChoiceNode = false;
      var nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        var terminalNode = node, terminalNodeContent = terminalNode.getContent();
        nodeNoChoiceNode = terminalNodeContent === "|";
      }
      return nodeNoChoiceNode;
    }
    function isNodeRuleNameNode(node) {
      var nodeRuleNameNode = false;
      var nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
      if (nodeNonTerminalNode) {
        var nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
        nodeRuleNameNode = nonTerminalNodeRuleName === _ruleNames.RuleNameRuleName;
      }
      return nodeRuleNameNode;
    }
    function isNodeQuantifierNode(node) {
      var nodeQuantifierNode = false;
      var nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        var nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameQuantifierRuleName = ruleName === _ruleNames.QuantifierRuleName;
        nodeQuantifierNode = ruleNameQuantifierRuleName;
      }
      return nodeQuantifierNode;
    }
    function isNodeLookAheadModifierNode(node) {
      var nodeLookAheadModifierNode = false;
      var nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        var nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameLookAheadModifierRuleName = ruleName === _ruleNames.LookAheadModifierRuleName;
        nodeLookAheadModifierNode = ruleNameLookAheadModifierRuleName;
      }
      return nodeLookAheadModifierNode;
    }
    function ruleNameFromQuantifierNode(quantifierNode) {
      var nonTerminalNode;
      nonTerminalNode = quantifierNode;
      var childNodes = nonTerminalNode.getChildNodes(), firstChildNode = (0, _array).first(childNodes);
      nonTerminalNode = firstChildNode;
      var ruleName = nonTerminalNode.getRuleName();
      return ruleName;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/part.js
  var require_part2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _optionalPart = _interopRequireDefault2(require_optionalPart());
    var _oneOrMoreParts = _interopRequireDefault2(require_oneOrMoreParts());
    var _zeroOrMoreParts = _interopRequireDefault2(require_zeroOrMoreParts());
    var _array = require_array3();
    var _bnf = require_bnf2();
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var PartBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(PartBNFNode2, NonTerminalNode);
      var _super = _createSuper(PartBNFNode2);
      function PartBNFNode2() {
        _classCallCheck(this, PartBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(PartBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = partFromNodes(nodes);
            return part;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(PartBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return PartBNFNode2;
    }(_nonTerminal.default);
    exports.default = PartBNFNode;
    function partFromNodes(nodes) {
      var part = null;
      var nodesLength = nodes.length;
      if (nodesLength === 1) {
        var node = nodes.pop(), lookAhead = false;
        part = node.generatePart(lookAhead);
      } else {
        var lastNodeQuantifierNode = isLastNodeQuantifierNode(nodes);
        if (lastNodeQuantifierNode) {
          var node1 = nodes.pop(), quantifierNode = node1;
          part = partFromNodes(nodes);
          var ruleName = (0, _bnf).ruleNameFromQuantifierNode(quantifierNode), collectionOfPartsPart = collectionOfPartsPartFromPartAndRuleName(part, ruleName);
          part = collectionOfPartsPart;
        } else {
          nodes.shift();
          part = partFromNodes(nodes);
        }
      }
      return part;
    }
    function isLastNodeQuantifierNode(nodes) {
      var lastNode = (0, _array).last(nodes), lastNodeQuantifierNode = (0, _bnf).isNodeQuantifierNode(lastNode);
      return lastNodeQuantifierNode;
    }
    function collectionOfPartsPartFromPartAndRuleName(part, ruleName) {
      var collectionOfPartsPart;
      switch (ruleName) {
        case _ruleNames.OptionalQuantifierRuleName:
          var optionalPartPart = new _optionalPart.default(part);
          collectionOfPartsPart = optionalPartPart;
          break;
        case _ruleNames.OneOrMoreQuantifierRuleName:
          var oneOrMorePartsPart = new _oneOrMoreParts.default(part);
          collectionOfPartsPart = oneOrMorePartsPart;
          break;
        case _ruleNames.ZeroOrMoreQuantifierRuleName:
          var zeroOrMorePartsPart = new _zeroOrMoreParts.default(part);
          collectionOfPartsPart = zeroOrMorePartsPart;
          break;
      }
      return collectionOfPartsPart;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/ruleName.js
  var require_ruleName2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal2());
    var _constants = require_constants4();
    var _partTypes = require_partTypes();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ellipsis = _occamLexers.specialSymbols.ellipsis;
    var RuleNamePart = /* @__PURE__ */ function(NonTerminalPart) {
      _inherits(RuleNamePart2, NonTerminalPart);
      var _super = _createSuper(RuleNamePart2);
      function RuleNamePart2(ruleName) {
        var lookAhead = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        _classCallCheck(this, RuleNamePart2);
        var _this;
        var type = _partTypes.RuleNamePartType;
        _this = _super.call(this, type);
        _this.ruleName = ruleName;
        _this.lookAhead = lookAhead;
        return _this;
      }
      _createClass(RuleNamePart2, [
        {
          key: "getRuleName",
          value: function getRuleName() {
            return this.ruleName;
          }
        },
        {
          key: "isLookAhead",
          value: function isLookAhead() {
            return this.lookAhead;
          }
        },
        {
          key: "isRuleNamePart",
          value: function isRuleNamePart() {
            var ruleNamePart = true;
            return ruleNamePart;
          }
        },
        {
          key: "setLookAhead",
          value: function setLookAhead(lookAhead) {
            this.lookAhead = lookAhead;
          }
        },
        {
          key: "findRule",
          value: function findRule(state) {
            var ruleMap = state.getRuleMap(), rule = ruleMap[this.ruleName] || null;
            return rule;
          }
        },
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var rule = this.findRule(state);
            if (rule === null) {
              parsed = false;
            } else {
              var ruleNode = rule.parse(state, callback);
              parsed = ruleNode !== null;
              if (parsed) {
                nodes.push(ruleNode);
              }
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var lookAheadString = this.lookAhead ? ellipsis : _constants.EMPTY_STRING, string = "".concat(this.ruleName).concat(lookAheadString);
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(RuleNamePart2.prototype), "clone", this).call(this, RuleNamePart2, this.ruleName, this.lookAhead);
          }
        }
      ]);
      return RuleNamePart2;
    }(_nonTerminal.default);
    exports.default = RuleNamePart;
  });

  // node_modules/occam-parsers/lib/definition/ruleName.js
  var require_ruleName3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleNameDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RuleNameDefinition2, Definition);
      var _super = _createSuper(RuleNameDefinition2);
      function RuleNameDefinition2(ruleName) {
        _classCallCheck(this, RuleNameDefinition2);
        var ruleNameRuleNamePart = new _ruleName.default(ruleName), parts = [
          ruleNameRuleNamePart
        ];
        return _super.call(this, parts);
      }
      return RuleNameDefinition2;
    }(_definition.default);
    exports.default = RuleNameDefinition;
  });

  // node_modules/occam-parsers/lib/definition/partRule/terminal.js
  var require_terminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _zeroOrMoreParts = _interopRequireDefault2(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalPartRuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(TerminalPartRuleDefinition2, Definition);
      var _super = _createSuper(TerminalPartRuleDefinition2);
      function TerminalPartRuleDefinition2() {
        _classCallCheck(this, TerminalPartRuleDefinition2);
        var quantifierRuleName = _ruleNames.QuantifierRuleName, terminalPartRuleName = _ruleNames.TerminalPartRuleName, quantifierRuleNamePart = new _ruleName.default(quantifierRuleName), terminalPartRuleNamePart = new _ruleName.default(terminalPartRuleName), zeroOrMoreQuantifierRuleNamePartsPart = new _zeroOrMoreParts.default(quantifierRuleNamePart), parts = [
          terminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ];
        return _super.call(this, parts);
      }
      return TerminalPartRuleDefinition2;
    }(_definition.default);
    exports.default = TerminalPartRuleDefinition;
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal.js
  var require_nonTerminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _zeroOrMoreParts = _interopRequireDefault2(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NonTerminalPartRuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(NonTerminalPartRuleDefinition2, Definition);
      var _super = _createSuper(NonTerminalPartRuleDefinition2);
      function NonTerminalPartRuleDefinition2() {
        _classCallCheck(this, NonTerminalPartRuleDefinition2);
        var quantifierRuleName = _ruleNames.QuantifierRuleName, nonTerminalPartRuleName = _ruleNames.NonTerminalPartRuleName, quantifierRuleNamePart = new _ruleName.default(quantifierRuleName), nonTerminalPartRuleNamePart = new _ruleName.default(nonTerminalPartRuleName), zeroOrMoreQuantifierRuleNamePartsPart = new _zeroOrMoreParts.default(quantifierRuleNamePart), parts = [
          nonTerminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ];
        return _super.call(this, parts);
      }
      return NonTerminalPartRuleDefinition2;
    }(_definition.default);
    exports.default = NonTerminalPartRuleDefinition;
  });

  // node_modules/occam-parsers/lib/rule/part.js
  var require_part3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _part = _interopRequireDefault2(require_part2());
    var _ruleName = _interopRequireDefault2(require_ruleName3());
    var _terminal = _interopRequireDefault2(require_terminal3());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var PartRule = /* @__PURE__ */ function(Rule) {
      _inherits(PartRule2, Rule);
      var _super = _createSuper(PartRule2);
      function PartRule2() {
        _classCallCheck(this, PartRule2);
        var name = _ruleNames.PartRuleName, terminalPartRuleDefinition = new _terminal.default(), nonTerminalPartRuleDefinition = new _nonTerminal.default(), noWhitespacePartRuleNameDefinition = new _ruleName.default(_ruleNames.NoWhitespacePartRuleName), ambiguous = false, definitions = [
          nonTerminalPartRuleDefinition,
          terminalPartRuleDefinition,
          noWhitespacePartRuleNameDefinition
        ], Node2 = _part.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return PartRule2;
    }(_rule.default);
    exports.default = PartRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/rule.js
  var require_rule3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(RuleBNFNode2, NonTerminalNode);
      var _super = _createSuper(RuleBNFNode2);
      function RuleBNFNode2() {
        _classCallCheck(this, RuleBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(RuleBNFNode2, [
        {
          key: "generateRule",
          value: function generateRule(Rule) {
            var name = this.getName(), ambiguous = this.isAmbiguous(), definitions = this.generateDefinitions(), Node2 = _nonTerminal.default, rule = new Rule(name, ambiguous, definitions, Node2);
            return rule;
          }
        },
        {
          key: "isAmbiguous",
          value: function isAmbiguous() {
            var childNodes = this.getChildNodes(), secondChildNode = (0, _array).second(childNodes), secondChildNodeTerminalNode = secondChildNode.isTerminalNode(), ambiguous = !secondChildNodeTerminalNode;
            return ambiguous;
          }
        },
        {
          key: "getName",
          value: function getName() {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), nameBNFNode = firstChildNode, name = nameBNFNode.getName();
            return name;
          }
        },
        {
          key: "generateDefinitions",
          value: function generateDefinitions() {
            var childNodes = this.getChildNodes(), childNodesLength = childNodes.length, thirdChildNode = (0, _array).third(childNodes), fourthChildNode = (0, _array).fourth(childNodes), definitionsBNFNode = childNodesLength === 4 ? thirdChildNode : fourthChildNode, definitions = definitionsBNFNode.generateDefinitions();
            return definitions;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(RuleBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return RuleBNFNode2;
    }(_nonTerminal.default);
    exports.default = RuleBNFNode;
  });

  // node_modules/occam-parsers/lib/part/terminal/terminalSymbol.js
  var require_terminalSymbol = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _terminal = _interopRequireDefault2(require_terminal());
    var _terminal1 = _interopRequireDefault2(require_terminal2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalSymbolPart = /* @__PURE__ */ function(TerminalPart) {
      _inherits(TerminalSymbolPart2, TerminalPart);
      var _super = _createSuper(TerminalSymbolPart2);
      function TerminalSymbolPart2(content) {
        _classCallCheck(this, TerminalSymbolPart2);
        var _this;
        _this = _super.call(this);
        _this.content = content;
        return _this;
      }
      _createClass(TerminalSymbolPart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var terminalNode = null;
            var savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
            if (significantToken !== null) {
              var content = significantToken.getContent();
              if (content === this.content) {
                terminalNode = _terminal1.default.fromSignificantToken(significantToken);
              }
            }
            parsed = terminalNode !== null;
            if (parsed) {
              nodes.push(terminalNode);
              if (callback !== null) {
                parsed = callback();
                if (!parsed) {
                  nodes.pop();
                }
              }
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var content = this.content.replace(/\\/, "\\\\"), string = '"'.concat(content, '"');
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(TerminalSymbolPart2.prototype), "clone", this).call(this, TerminalSymbolPart2, this.content);
          }
        }
      ]);
      return TerminalSymbolPart2;
    }(_terminal.default);
    exports.default = TerminalSymbolPart;
  });

  // node_modules/occam-parsers/lib/definition/rule.js
  var require_rule4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _optionalPart = _interopRequireDefault2(require_optionalPart());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var separator = _occamLexers.specialSymbols.separator;
    var terminator = _occamLexers.specialSymbols.terminator;
    var RuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RuleDefinition2, Definition);
      var _super = _createSuper(RuleDefinition2);
      function RuleDefinition2() {
        _classCallCheck(this, RuleDefinition2);
        var separatorTerminalSymbolContent = separator, terminatorTerminalSymbolContent = terminator, nameRuleName = _ruleNames.NameRuleName, definitionsRuleName = _ruleNames.DefinitionsRuleName, ambiguousModifierRuleName = _ruleNames.AmbiguousModifierRuleName, ambiguousModifierRuleNamePart = new _ruleName.default(ambiguousModifierRuleName), nameRuleNamePart = new _ruleName.default(nameRuleName), optionalAmbiguousRuleNamePartPart = new _optionalPart.default(ambiguousModifierRuleNamePart), separatorTerminalSymbolPart = new _terminalSymbol.default(separatorTerminalSymbolContent), definitionsRuleNamePart = new _ruleName.default(definitionsRuleName), terminatorTerminalSymbolPart = new _terminalSymbol.default(terminatorTerminalSymbolContent), parts = [
          nameRuleNamePart,
          optionalAmbiguousRuleNamePartPart,
          separatorTerminalSymbolPart,
          definitionsRuleNamePart,
          terminatorTerminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return RuleDefinition2;
    }(_definition.default);
    exports.default = RuleDefinition;
  });

  // node_modules/occam-parsers/lib/rule/rule.js
  var require_rule5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _rule1 = _interopRequireDefault2(require_rule3());
    var _rule2 = _interopRequireDefault2(require_rule4());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleRule = /* @__PURE__ */ function(Rule) {
      _inherits(RuleRule2, Rule);
      var _super = _createSuper(RuleRule2);
      function RuleRule2() {
        _classCallCheck(this, RuleRule2);
        var ruleDefinition = new _rule2.default(), name = _ruleNames.RuleRuleName, ambiguous = false, definitions = [
          ruleDefinition
        ], Node2 = _rule1.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return RuleRule2;
    }(_rule.default);
    exports.default = RuleRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/error.js
  var require_error = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ErrorBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(ErrorBNFNode2, NonTerminalNode);
      var _super = _createSuper(ErrorBNFNode2);
      function ErrorBNFNode2() {
        _classCallCheck(this, ErrorBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(ErrorBNFNode2, null, [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(ErrorBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return ErrorBNFNode2;
    }(_nonTerminal.default);
    exports.default = ErrorBNFNode;
  });

  // node_modules/occam-parsers/lib/part/terminal/wildcard.js
  var require_wildcard = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _terminal = _interopRequireDefault2(require_terminal());
    var _terminal1 = _interopRequireDefault2(require_terminal2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var wildcard = _occamLexers.specialSymbols.wildcard;
    var WildcardPart = /* @__PURE__ */ function(TerminalPart) {
      _inherits(WildcardPart2, TerminalPart);
      var _super = _createSuper(WildcardPart2);
      function WildcardPart2() {
        _classCallCheck(this, WildcardPart2);
        return _super.apply(this, arguments);
      }
      _createClass(WildcardPart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var terminalNode = null;
            var savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
            if (significantToken !== null) {
              terminalNode = _terminal1.default.fromSignificantToken(significantToken);
            }
            parsed = terminalNode !== null;
            if (parsed) {
              nodes.push(terminalNode);
              if (callback !== null) {
                parsed = callback();
                if (!parsed) {
                  nodes.pop();
                }
              }
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var string = wildcard;
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(WildcardPart2.prototype), "clone", this).call(this, WildcardPart2);
          }
        }
      ]);
      return WildcardPart2;
    }(_terminal.default);
    exports.default = WildcardPart;
  });

  // node_modules/occam-parsers/lib/definition/error.js
  var require_error2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _wildcard = _interopRequireDefault2(require_wildcard());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ErrorDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(ErrorDefinition2, Definition);
      var _super = _createSuper(ErrorDefinition2);
      function ErrorDefinition2() {
        _classCallCheck(this, ErrorDefinition2);
        var wildcardPart = new _wildcard.default(), parts = [
          wildcardPart
        ];
        return _super.call(this, parts);
      }
      return ErrorDefinition2;
    }(_definition.default);
    exports.default = ErrorDefinition;
  });

  // node_modules/occam-parsers/lib/rule/error.js
  var require_error3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _error = _interopRequireDefault2(require_error());
    var _error1 = _interopRequireDefault2(require_error2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ErrorRule = /* @__PURE__ */ function(Rule) {
      _inherits(ErrorRule2, Rule);
      var _super = _createSuper(ErrorRule2);
      function ErrorRule2() {
        _classCallCheck(this, ErrorRule2);
        var errorDefinition = new _error1.default(), name = _ruleNames.ErrorRuleName, ambiguous = false, definitions = [
          errorDefinition
        ], Node2 = _error.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return ErrorRule2;
    }(_rule.default);
    exports.default = ErrorRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/document.js
  var require_document2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DocumentBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(DocumentBNFNode2, NonTerminalNode);
      var _super = _createSuper(DocumentBNFNode2);
      function DocumentBNFNode2() {
        _classCallCheck(this, DocumentBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(DocumentBNFNode2, [
        {
          key: "generateRules",
          value: function generateRules(Rule) {
            var childNodes = this.getChildNodes(), ruleNodes1 = childNodes.reduce(function(ruleNodes, childNode) {
              var childNodeNonTerminalNode = childNode.isNonTerminalNode();
              if (childNodeNonTerminalNode) {
                var nonTerminalNode = childNode, ruleName = childNode.getRuleName(), ruleNameRuleRuleName = ruleName === _ruleNames.RuleRuleName, nonTerminalNodeRuleNode = ruleNameRuleRuleName;
                if (nonTerminalNodeRuleNode) {
                  var ruleNode = nonTerminalNode;
                  ruleNodes.push(ruleNode);
                }
              }
              return ruleNodes;
            }, []), rules = ruleNodes1.map(function(ruleNode) {
              var rule = ruleNode.generateRule(Rule);
              return rule;
            });
            return rules;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(DocumentBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return DocumentBNFNode2;
    }(_nonTerminal.default);
    exports.default = DocumentBNFNode;
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/choiceOfParts.js
  var require_choiceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal2());
    var _partTypes = require_partTypes();
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ChoiceOfPartsPart = /* @__PURE__ */ function(NonTerminalPart) {
      _inherits(ChoiceOfPartsPart2, NonTerminalPart);
      var _super = _createSuper(ChoiceOfPartsPart2);
      function ChoiceOfPartsPart2(parts) {
        _classCallCheck(this, ChoiceOfPartsPart2);
        var _this;
        var type = _partTypes.ChoiceOfPartsPartType;
        _this = _super.call(this, type);
        _this.parts = parts;
        return _this;
      }
      _createClass(ChoiceOfPartsPart2, [
        {
          key: "getParts",
          value: function getParts() {
            return this.parts;
          }
        },
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            this.parts.some(function(part) {
              parsed = part.parse(nodes, state, callback);
              if (parsed) {
                return true;
              }
            });
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var partsString1 = this.parts.reduce(function(partsString, part) {
              var partString = part.asString();
              if (partsString === null) {
                partsString = partString;
              } else {
                partsString = "".concat(partsString, " | ").concat(partString);
              }
              return partsString;
            }, null), string = "( ".concat(partsString1, " )");
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(ChoiceOfPartsPart2.prototype), "clone", this).call(this, ChoiceOfPartsPart2, this.parts);
          }
        }
      ], [
        {
          key: "fromNodes",
          value: function fromNodes(nodes) {
            var allButFirstAndLastNodes = (0, _array).allButFirstAndLast(nodes);
            nodes = allButFirstAndLastNodes;
            var evenNodes = (0, _array).even(nodes);
            nodes = evenNodes;
            var lookAhead = false, parts = nodes.map(function(node) {
              var part = node.generatePart(lookAhead);
              return part;
            }), choiceOfPartsPart = new ChoiceOfPartsPart2(parts);
            return choiceOfPartsPart;
          }
        }
      ]);
      return ChoiceOfPartsPart2;
    }(_nonTerminal.default);
    exports.default = ChoiceOfPartsPart;
  });

  // node_modules/occam-parsers/lib/definition/document.js
  var require_document3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _choiceOfParts = _interopRequireDefault2(require_choiceOfParts());
    var _oneOrMoreParts = _interopRequireDefault2(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DocumentDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(DocumentDefinition2, Definition);
      var _super = _createSuper(DocumentDefinition2);
      function DocumentDefinition2() {
        _classCallCheck(this, DocumentDefinition2);
        var ruleRuleName = _ruleNames.RuleRuleName, errorRuleName = _ruleNames.ErrorRuleName, ruleRuleNamePart = new _ruleName.default(ruleRuleName), errorRuleNamePart = new _ruleName.default(errorRuleName), ruleRuleNameAndErrorRuleNameParts = [
          ruleRuleNamePart,
          errorRuleNamePart
        ], choiceOfRuleRuleNameAndErrorRuleNamePartsPart = new _choiceOfParts.default(ruleRuleNameAndErrorRuleNameParts), oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart = new _oneOrMoreParts.default(choiceOfRuleRuleNameAndErrorRuleNamePartsPart), parts = [
          oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart
        ];
        return _super.call(this, parts);
      }
      return DocumentDefinition2;
    }(_definition.default);
    exports.default = DocumentDefinition;
  });

  // node_modules/occam-parsers/lib/rule/document.js
  var require_document4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _document = _interopRequireDefault2(require_document2());
    var _document1 = _interopRequireDefault2(require_document3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DocumentRule = /* @__PURE__ */ function(Rule) {
      _inherits(DocumentRule2, Rule);
      var _super = _createSuper(DocumentRule2);
      function DocumentRule2() {
        _classCallCheck(this, DocumentRule2);
        var documentDefinition = new _document1.default(), name = _ruleNames.DocumentRuleName, ambiguous = false, definitions = [
          documentDefinition
        ], Node2 = _document.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return DocumentRule2;
    }(_rule.default);
    exports.default = DocumentRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/ruleName.js
  var require_ruleName4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleNameBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(RuleNameBNFNode2, NonTerminalNode);
      var _super = _createSuper(RuleNameBNFNode2);
      function RuleNameBNFNode2() {
        _classCallCheck(this, RuleNameBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(RuleNameBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var ruleName = this.getRuleName(), ruleNamePart = new _ruleName.default(ruleName, lookAhead);
            return ruleNamePart;
          }
        },
        {
          key: "getRuleName",
          value: function getRuleName() {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), ruleName = terminalNodeContent;
            return ruleName;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(RuleNameBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return RuleNameBNFNode2;
    }(_nonTerminal.default);
    exports.default = RuleNameBNFNode;
  });

  // node_modules/occam-parsers/lib/rule/ruleName.js
  var require_ruleName5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _name = _interopRequireDefault2(require_name3());
    var _ruleName = _interopRequireDefault2(require_ruleName4());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleNameRule = /* @__PURE__ */ function(Rule) {
      _inherits(RuleNameRule2, Rule);
      var _super = _createSuper(RuleNameRule2);
      function RuleNameRule2() {
        _classCallCheck(this, RuleNameRule2);
        var nameDefinition = new _name.default(), name = _ruleNames.RuleNameRuleName, ambiguous = false, definitions = [
          nameDefinition
        ], Node2 = _ruleName.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return RuleNameRule2;
    }(_rule.default);
    exports.default = RuleNameRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/wildcard.js
  var require_wildcard2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _wildcard = _interopRequireDefault2(require_wildcard());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var WildcardBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(WildcardBNFNode2, NonTerminalNode);
      var _super = _createSuper(WildcardBNFNode2);
      function WildcardBNFNode2() {
        _classCallCheck(this, WildcardBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(WildcardBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var wildcardPart = new _wildcard.default();
            return wildcardPart;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(WildcardBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return WildcardBNFNode2;
    }(_nonTerminal.default);
    exports.default = WildcardBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/terminalSymbol.js
  var require_terminalSymbol2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalSymbolDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(TerminalSymbolDefinition2, Definition);
      var _super = _createSuper(TerminalSymbolDefinition2);
      function TerminalSymbolDefinition2(content) {
        _classCallCheck(this, TerminalSymbolDefinition2);
        var terminalSymbolPart = new _terminalSymbol.default(content), parts = [
          terminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return TerminalSymbolDefinition2;
    }(_definition.default);
    exports.default = TerminalSymbolDefinition;
  });

  // node_modules/occam-parsers/lib/rule/wildcard.js
  var require_wildcard3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _wildcard = _interopRequireDefault2(require_wildcard2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var wildcard = _occamLexers.specialSymbols.wildcard;
    var WildcardRule = /* @__PURE__ */ function(Rule) {
      _inherits(WildcardRule2, Rule);
      var _super = _createSuper(WildcardRule2);
      function WildcardRule2() {
        _classCallCheck(this, WildcardRule2);
        var wildcardTerminalSymbolContent = wildcard, wildcardTerminalSymbolDefinition = new _terminalSymbol.default(wildcardTerminalSymbolContent), name = _ruleNames.WildcardRuleName, ambiguous = false, definitions = [
          wildcardTerminalSymbolDefinition
        ], Node2 = _wildcard.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return WildcardRule2;
    }(_rule.default);
    exports.default = WildcardRule;
  });

  // node_modules/occam-parsers/lib/parseTree/endOfLineNode.js
  var require_endOfLineNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _verticalBranch = _interopRequireDefault2(require_verticalBranch());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var END_OF_LINE = _occamLexers.specialSymbols.END_OF_LINE;
    var EndOfLineNodeParseTree = /* @__PURE__ */ function(VerticalBranchParseTree) {
      _inherits(EndOfLineNodeParseTree2, VerticalBranchParseTree);
      var _super = _createSuper(EndOfLineNodeParseTree2);
      function EndOfLineNodeParseTree2() {
        _classCallCheck(this, EndOfLineNodeParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineNodeParseTree2, null, [
        {
          key: "fromNothing",
          value: function fromNothing() {
            var string = END_OF_LINE, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EndOfLineNodeParseTree2, string, verticalBranchPosition);
            terminalNodeParseTree.appendToTop(verticalBranchParseTree);
            var endOfLineNodeParseTree = terminalNodeParseTree;
            return endOfLineNodeParseTree;
          }
        }
      ]);
      return EndOfLineNodeParseTree2;
    }(_verticalBranch.default);
    exports.default = EndOfLineNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/terminal/endOfLine.js
  var require_endOfLine5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _terminal = _interopRequireDefault2(require_terminal2());
    var _endOfLineNode = _interopRequireDefault2(require_endOfLineNode());
    var _constants = require_constants4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfLineBNFNode = /* @__PURE__ */ function(TerminalNode) {
      _inherits(EndOfLineBNFNode2, TerminalNode);
      var _super = _createSuper(EndOfLineBNFNode2);
      function EndOfLineBNFNode2() {
        _classCallCheck(this, EndOfLineBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineBNFNode2, [
        {
          key: "getContent",
          value: function getContent() {
            var content = _constants.EMPTY_STRING;
            return content;
          }
        },
        {
          key: "asParseTree",
          value: function asParseTree(tokens) {
            var endOfLineNodeParseTree = _endOfLineNode.default.fromNothing(), parseTree = endOfLineNodeParseTree;
            return parseTree;
          }
        }
      ], [
        {
          key: "fromSignificantToken",
          value: function fromSignificantToken(significantToken) {
            return _terminal.default.fromSignificantToken(EndOfLineBNFNode2, significantToken);
          }
        }
      ]);
      return EndOfLineBNFNode2;
    }(_terminal.default);
    exports.default = EndOfLineBNFNode;
  });

  // node_modules/occam-parsers/lib/part/terminal/endOfLine.js
  var require_endOfLine6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _terminal = _interopRequireDefault2(require_terminal());
    var _endOfLine = _interopRequireDefault2(require_endOfLine5());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var END_OF_LINE = _occamLexers.specialSymbols.END_OF_LINE;
    var EndOfLinePart = /* @__PURE__ */ function(TerminalPart) {
      _inherits(EndOfLinePart2, TerminalPart);
      var _super = _createSuper(EndOfLinePart2);
      function EndOfLinePart2() {
        _classCallCheck(this, EndOfLinePart2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLinePart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var endOfLineBNFNode = null;
            var savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
            if (significantToken !== null) {
              var significantTokenEndOfLineToken = significantToken.isEndOfLineToken();
              if (significantTokenEndOfLineToken) {
                endOfLineBNFNode = _endOfLine.default.fromSignificantToken(significantToken);
              }
            }
            parsed = endOfLineBNFNode !== null;
            if (parsed) {
              nodes.push(endOfLineBNFNode);
              if (callback !== null) {
                parsed = callback();
                if (!parsed) {
                  nodes.pop();
                }
              }
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var string = END_OF_LINE;
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(EndOfLinePart2.prototype), "clone", this).call(this, EndOfLinePart2);
          }
        }
      ]);
      return EndOfLinePart2;
    }(_terminal.default);
    exports.default = EndOfLinePart;
  });

  // node_modules/occam-parsers/lib/node/bnf/endOfLine.js
  var require_endOfLine7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _endOfLine = _interopRequireDefault2(require_endOfLine6());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var EndOfLineBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(EndOfLineBNFNode2, NonTerminalNode);
      var _super = _createSuper(EndOfLineBNFNode2);
      function EndOfLineBNFNode2() {
        _classCallCheck(this, EndOfLineBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(EndOfLineBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var endOfLinePart = new _endOfLine.default();
            return endOfLinePart;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(EndOfLineBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return EndOfLineBNFNode2;
    }(_nonTerminal.default);
    exports.default = EndOfLineBNFNode;
  });

  // node_modules/occam-parsers/lib/rule/endOfLine.js
  var require_endOfLine8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _endOfLine = _interopRequireDefault2(require_endOfLine7());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var END_OF_LINE = _occamLexers.specialSymbols.END_OF_LINE;
    var EndOfLineRule = /* @__PURE__ */ function(Rule) {
      _inherits(EndOfLineRule2, Rule);
      var _super = _createSuper(EndOfLineRule2);
      function EndOfLineRule2() {
        _classCallCheck(this, EndOfLineRule2);
        var endOfLineTerminalSymbolContent = END_OF_LINE, endOfLineTerminalSymbolDefinition = new _terminalSymbol.default(endOfLineTerminalSymbolContent), name = _ruleNames.EndOfLineRuleName, ambiguous = false, definitions = [
          endOfLineTerminalSymbolDefinition
        ], Node2 = _endOfLine.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return EndOfLineRule2;
    }(_rule.default);
    exports.default = EndOfLineRule;
  });

  // node_modules/occam-parsers/lib/rule/quantifier.js
  var require_quantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _part = _interopRequireDefault2(require_part2());
    var _ruleName = _interopRequireDefault2(require_ruleName3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var QuantifierRule = /* @__PURE__ */ function(Rule) {
      _inherits(QuantifierRule2, Rule);
      var _super = _createSuper(QuantifierRule2);
      function QuantifierRule2() {
        _classCallCheck(this, QuantifierRule2);
        var name = _ruleNames.QuantifierRuleName, optionalQuantifierRuleName = _ruleNames.OptionalQuantifierRuleName, oneOrMoreQuantifierRuleName = _ruleNames.OneOrMoreQuantifierRuleName, zeroOrMoreQuantifierRuleName = _ruleNames.ZeroOrMoreQuantifierRuleName, optionalQuantifierRuleNameDefinition = new _ruleName.default(optionalQuantifierRuleName), oneOrMoreQuantifierRuleNameDefinition = new _ruleName.default(oneOrMoreQuantifierRuleName), zeroOrMoreQuantifierRuleNameDefinition = new _ruleName.default(zeroOrMoreQuantifierRuleName), ambiguous = false, definitions = [
          optionalQuantifierRuleNameDefinition,
          oneOrMoreQuantifierRuleNameDefinition,
          zeroOrMoreQuantifierRuleNameDefinition
        ], Node2 = _part.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return QuantifierRule2;
    }(_rule.default);
    exports.default = QuantifierRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/definition.js
  var require_definition2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DefinitionBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(DefinitionBNFNode2, NonTerminalNode);
      var _super = _createSuper(DefinitionBNFNode2);
      function DefinitionBNFNode2() {
        _classCallCheck(this, DefinitionBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(DefinitionBNFNode2, [
        {
          key: "generateDefinition",
          value: function generateDefinition() {
            var childNodes = this.getChildNodes(), partNodes = childNodes, lookAhead = false, parts = partNodes.map(function(partNode) {
              var part = partNode.generatePart(lookAhead);
              return part;
            }), definition = new _definition.default(parts);
            return definition;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(DefinitionBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return DefinitionBNFNode2;
    }(_nonTerminal.default);
    exports.default = DefinitionBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/definition.js
  var require_definition3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _oneOrMoreParts = _interopRequireDefault2(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DefinitionDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(DefinitionDefinition2, Definition);
      var _super = _createSuper(DefinitionDefinition2);
      function DefinitionDefinition2() {
        _classCallCheck(this, DefinitionDefinition2);
        var partRuleName = _ruleNames.PartRuleName, partRuleNamePart = new _ruleName.default(partRuleName), oneOrMoreRuleNamePartsPart = new _oneOrMoreParts.default(partRuleNamePart), parts = [
          oneOrMoreRuleNamePartsPart
        ];
        return _super.call(this, parts);
      }
      return DefinitionDefinition2;
    }(_definition.default);
    exports.default = DefinitionDefinition;
  });

  // node_modules/occam-parsers/lib/rule/definition.js
  var require_definition4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _definition = _interopRequireDefault2(require_definition2());
    var _definition1 = _interopRequireDefault2(require_definition3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DefinitionRule = /* @__PURE__ */ function(Rule) {
      _inherits(DefinitionRule2, Rule);
      var _super = _createSuper(DefinitionRule2);
      function DefinitionRule2() {
        _classCallCheck(this, DefinitionRule2);
        var name = _ruleNames.DefinitionRuleName, definitionDefinition = new _definition1.default(), ambiguous = false, definitions = [
          definitionDefinition
        ], Node2 = _definition.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return DefinitionRule2;
    }(_rule.default);
    exports.default = DefinitionRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/definitions.js
  var require_definitions = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DefinitionsBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(DefinitionsBNFNode2, NonTerminalNode);
      var _super = _createSuper(DefinitionsBNFNode2);
      function DefinitionsBNFNode2() {
        _classCallCheck(this, DefinitionsBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(DefinitionsBNFNode2, [
        {
          key: "generateDefinitions",
          value: function generateDefinitions() {
            var childNodes = this.getChildNodes(), evenChildNodes = (0, _array).even(childNodes), definitionBNFNodes = evenChildNodes, definitions = definitionBNFNodes.map(function(definitionBNFNode) {
              var definition = definitionBNFNode.generateDefinition();
              return definition;
            });
            return definitions;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(DefinitionsBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return DefinitionsBNFNode2;
    }(_nonTerminal.default);
    exports.default = DefinitionsBNFNode;
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/sequenceOfParts.js
  var require_sequenceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal2());
    var _array = require_array3();
    var _lookAhead = require_lookAhead();
    var _partTypes = require_partTypes();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SequenceOfPartsPart = /* @__PURE__ */ function(NonTerminalPart) {
      _inherits(SequenceOfPartsPart2, NonTerminalPart);
      var _super = _createSuper(SequenceOfPartsPart2);
      function SequenceOfPartsPart2(parts) {
        _classCallCheck(this, SequenceOfPartsPart2);
        var _this;
        var type = _partTypes.SequenceOfPartsPartType;
        _this = _super.call(this, type);
        _this.parts = parts;
        return _this;
      }
      _createClass(SequenceOfPartsPart2, [
        {
          key: "getParts",
          value: function getParts() {
            return this.parts;
          }
        },
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var savedIndex = state.getSavedIndex(), partsNodes = [], index = 0;
            parsed = (0, _lookAhead).parseParts(this.parts, partsNodes, index, state, callback);
            if (parsed) {
              (0, _array).push(nodes, partsNodes);
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var partsString1 = this.parts.reduce(function(partsString, part) {
              var partString = part.asString();
              if (partsString === null) {
                partsString = partString;
              } else {
                partsString = "".concat(partsString, " ").concat(partString);
              }
              return partsString;
            }, null), string = "( ".concat(partsString1, " )");
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(SequenceOfPartsPart2.prototype), "clone", this).call(this, SequenceOfPartsPart2, this.parts);
          }
        }
      ], [
        {
          key: "fromNodes",
          value: function fromNodes(nodes) {
            var allButFirstAndLastNodes = (0, _array).allButFirstAndLast(nodes);
            nodes = allButFirstAndLastNodes;
            var lookAhead = false, parts = nodes.map(function(node) {
              var part = node.generatePart(lookAhead);
              return part;
            }), sequenceOfPartsPart = new SequenceOfPartsPart2(parts);
            return sequenceOfPartsPart;
          }
        }
      ]);
      return SequenceOfPartsPart2;
    }(_nonTerminal.default);
    exports.default = SequenceOfPartsPart;
  });

  // node_modules/occam-parsers/lib/definition/definitions.js
  var require_definitions2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    var _zeroOrMoreParts = _interopRequireDefault2(require_zeroOrMoreParts());
    var _sequenceOfParts = _interopRequireDefault2(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var verticalBar = _occamLexers.specialSymbols.verticalBar;
    var DefinitionsDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(DefinitionsDefinition2, Definition);
      var _super = _createSuper(DefinitionsDefinition2);
      function DefinitionsDefinition2() {
        _classCallCheck(this, DefinitionsDefinition2);
        var definitionRuleName = _ruleNames.DefinitionRuleName, verticalBarTerminalSymbolContent = verticalBar, definitionRuleNamePart = new _ruleName.default(definitionRuleName), verticalBarTerminalSymbolPart = new _terminalSymbol.default(verticalBarTerminalSymbolContent), verticalBarTerminalSymbolThenDefinitionRuleNameParts = [
          verticalBarTerminalSymbolPart,
          definitionRuleNamePart
        ], sequenceOfPartsPart = new _sequenceOfParts.default(verticalBarTerminalSymbolThenDefinitionRuleNameParts), zeroOrMoreSequenceOfPartsPart = new _zeroOrMoreParts.default(sequenceOfPartsPart), parts = [
          definitionRuleNamePart,
          zeroOrMoreSequenceOfPartsPart
        ];
        return _super.call(this, parts);
      }
      return DefinitionsDefinition2;
    }(_definition.default);
    exports.default = DefinitionsDefinition;
  });

  // node_modules/occam-parsers/lib/rule/definitions.js
  var require_definitions3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _definitions = _interopRequireDefault2(require_definitions());
    var _definitions1 = _interopRequireDefault2(require_definitions2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DefinitionsRule = /* @__PURE__ */ function(Rule) {
      _inherits(DefinitionsRule2, Rule);
      var _super = _createSuper(DefinitionsRule2);
      function DefinitionsRule2() {
        _classCallCheck(this, DefinitionsRule2);
        var definitionsDefinition = new _definitions1.default(), name = _ruleNames.DefinitionsRuleName, ambiguous = false, definitions = [
          definitionsDefinition
        ], Node2 = _definitions.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return DefinitionsRule2;
    }(_rule.default);
    exports.default = DefinitionsRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/part/terminal.js
  var require_terminal4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalPartBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(TerminalPartBNFNode2, NonTerminalNode);
      var _super = _createSuper(TerminalPartBNFNode2);
      function TerminalPartBNFNode2() {
        _classCallCheck(this, TerminalPartBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(TerminalPartBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), node = firstChildNode, part = node.generatePart(lookAhead);
            return part;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(TerminalPartBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return TerminalPartBNFNode2;
    }(_nonTerminal.default);
    exports.default = TerminalPartBNFNode;
  });

  // node_modules/occam-parsers/lib/rule/terminalPart.js
  var require_terminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _terminal = _interopRequireDefault2(require_terminal4());
    var _ruleName = _interopRequireDefault2(require_ruleName3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalPartRule = /* @__PURE__ */ function(Rule) {
      _inherits(TerminalPartRule2, Rule);
      var _super = _createSuper(TerminalPartRule2);
      function TerminalPartRule2() {
        _classCallCheck(this, TerminalPartRule2);
        var name = _ruleNames.TerminalPartRuleName, wildcardRuleName = _ruleNames.WildcardRuleName, endOfLineRuleName = _ruleNames.EndOfLineRuleName, terminalSymbolRuleName = _ruleNames.TerminalSymbolRuleName, regularExpressionRuleName = _ruleNames.RegularExpressionRuleName, significantTokenTypeRuleName = _ruleNames.SignificantTokenTypeRuleName, wildcardRuleNameDefinition = new _ruleName.default(wildcardRuleName), endOfLineRuleNameDefinition = new _ruleName.default(endOfLineRuleName), terminalSymbolRuleNameDefinition = new _ruleName.default(terminalSymbolRuleName), regularExpressionRuleNameDefinition = new _ruleName.default(regularExpressionRuleName), significantTokenTypeRuleNameDefinition = new _ruleName.default(significantTokenTypeRuleName), ambiguous = false, definitions = [
          significantTokenTypeRuleNameDefinition,
          regularExpressionRuleNameDefinition,
          terminalSymbolRuleNameDefinition,
          endOfLineRuleNameDefinition,
          wildcardRuleNameDefinition
        ], Node2 = _terminal.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return TerminalPartRule2;
    }(_rule.default);
    exports.default = TerminalPartRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/choiceOfParts.js
  var require_choiceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _choiceOfParts = _interopRequireDefault2(require_choiceOfParts());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ChoiceOfPartsBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(ChoiceOfPartsBNFNode2, NonTerminalNode);
      var _super = _createSuper(ChoiceOfPartsBNFNode2);
      function ChoiceOfPartsBNFNode2() {
        _classCallCheck(this, ChoiceOfPartsBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(ChoiceOfPartsBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = _choiceOfParts.default.fromNodes(nodes);
            return part;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(ChoiceOfPartsBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return ChoiceOfPartsBNFNode2;
    }(_nonTerminal.default);
    exports.default = ChoiceOfPartsBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/choiceOfParts.js
  var require_choiceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _oneOrMoreParts = _interopRequireDefault2(require_oneOrMoreParts());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    var _sequenceOfParts = _interopRequireDefault2(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var verticalBar = _occamLexers.specialSymbols.verticalBar;
    var openBracket = _occamLexers.specialSymbols.openBracket;
    var closeBracket = _occamLexers.specialSymbols.closeBracket;
    var ChoiceOfPartsDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(ChoiceOfPartsDefinition2, Definition);
      var _super = _createSuper(ChoiceOfPartsDefinition2);
      function ChoiceOfPartsDefinition2() {
        _classCallCheck(this, ChoiceOfPartsDefinition2);
        var partRuleName = _ruleNames.PartRuleName, verticalBarTerminalSymbolContent = verticalBar, openBracketTerminalSymbolContent = openBracket, closeBracketTerminalSymbolContent = closeBracket, partRuleNamePart = new _ruleName.default(partRuleName), verticalBarTerminalSymbolPart = new _terminalSymbol.default(verticalBarTerminalSymbolContent), openBracketTerminalSymbolPart = new _terminalSymbol.default(openBracketTerminalSymbolContent), closeBracketTerminalSymbolPart = new _terminalSymbol.default(closeBracketTerminalSymbolContent), verticalBarTerminalSymbolThenPartRuleNameParts = [
          verticalBarTerminalSymbolPart,
          partRuleNamePart
        ], sequenceOfPartsPart = new _sequenceOfParts.default(verticalBarTerminalSymbolThenPartRuleNameParts), oneOrMoreSequenceOfPartsPart = new _oneOrMoreParts.default(sequenceOfPartsPart), parts = [
          openBracketTerminalSymbolPart,
          partRuleNamePart,
          oneOrMoreSequenceOfPartsPart,
          closeBracketTerminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return ChoiceOfPartsDefinition2;
    }(_definition.default);
    exports.default = ChoiceOfPartsDefinition;
  });

  // node_modules/occam-parsers/lib/rule/choiceOfParts.js
  var require_choiceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _choiceOfParts = _interopRequireDefault2(require_choiceOfParts2());
    var _choiceOfParts1 = _interopRequireDefault2(require_choiceOfParts3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ChoiceOfPartsRule = /* @__PURE__ */ function(Rule) {
      _inherits(ChoiceOfPartsRule2, Rule);
      var _super = _createSuper(ChoiceOfPartsRule2);
      function ChoiceOfPartsRule2() {
        _classCallCheck(this, ChoiceOfPartsRule2);
        var name = _ruleNames.ChoiceOfPartsRuleName, choiceOfPartsDefinition = new _choiceOfParts1.default(), ambiguous = false, definitions = [
          choiceOfPartsDefinition
        ], Node2 = _choiceOfParts.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return ChoiceOfPartsRule2;
    }(_rule.default);
    exports.default = ChoiceOfPartsRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/terminalSymbol.js
  var require_terminalSymbol3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var TerminalSymbolBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(TerminalSymbolBNFNode2, NonTerminalNode);
      var _super = _createSuper(TerminalSymbolBNFNode2);
      function TerminalSymbolBNFNode2() {
        _classCallCheck(this, TerminalSymbolBNFNode2);
        var _this;
        _this = _super.apply(this, arguments);
        _defineProperty(_assertThisInitialized(_this), "regularExpression", /^"((?:\\.|[^"\\])*)"$/);
        return _this;
      }
      _createClass(TerminalSymbolBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var content = this.getContent(), terminalSymbolPart = new _terminalSymbol.default(content);
            return terminalSymbolPart;
          }
        },
        {
          key: "getContent",
          value: function getContent() {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = (0, _array).second(matches), content = secondMatch.replace(/\\\\/g, "\\").replace(/\\"/g, '"');
            return content;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(TerminalSymbolBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return TerminalSymbolBNFNode2;
    }(_nonTerminal.default);
    exports.default = TerminalSymbolBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/significantTokenType.js
  var require_significantTokenType2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SignificantTokenTypeDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(SignificantTokenTypeDefinition2, Definition);
      var _super = _createSuper(SignificantTokenTypeDefinition2);
      function SignificantTokenTypeDefinition2(significantTokenType) {
        _classCallCheck(this, SignificantTokenTypeDefinition2);
        var significantTokenTypePart = new _significantTokenType.default(significantTokenType), parts = [
          significantTokenTypePart
        ];
        return _super.call(this, parts);
      }
      return SignificantTokenTypeDefinition2;
    }(_definition.default);
    exports.default = SignificantTokenTypeDefinition;
  });

  // node_modules/occam-parsers/lib/rule/terminalSymbol.js
  var require_terminalSymbol4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol3());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var stringLiteralType = _occamLexers.types.stringLiteralType;
    var TerminalSymbolRule = /* @__PURE__ */ function(Rule) {
      _inherits(TerminalSymbolRule2, Rule);
      var _super = _createSuper(TerminalSymbolRule2);
      function TerminalSymbolRule2() {
        _classCallCheck(this, TerminalSymbolRule2);
        var stringLiteralSignificantTokenType = stringLiteralType, stringLiteralSignificantTokenTypeDefinition = new _significantTokenType.default(stringLiteralSignificantTokenType), name = _ruleNames.TerminalSymbolRuleName, ambiguous = false, definitions = [
          stringLiteralSignificantTokenTypeDefinition
        ], Node2 = _terminalSymbol.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return TerminalSymbolRule2;
    }(_rule.default);
    exports.default = TerminalSymbolRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/part/nonTerminal.js
  var require_nonTerminal4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NonTerminalPartBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(NonTerminalPartBNFNode2, NonTerminalNode);
      var _super = _createSuper(NonTerminalPartBNFNode2);
      function NonTerminalPartBNFNode2() {
        _classCallCheck(this, NonTerminalPartBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(NonTerminalPartBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = partFromNodes(nodes, lookAhead);
            return part;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(NonTerminalPartBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return NonTerminalPartBNFNode2;
    }(_nonTerminal.default);
    exports.default = NonTerminalPartBNFNode;
    function partFromNodes(nodes, lookAhead) {
      var part = null;
      var nodesLength = nodes.length;
      if (nodesLength === 1) {
        var node = nodes.pop();
        part = node.generatePart(lookAhead);
      } else {
        nodes.pop();
        lookAhead = true;
        part = partFromNodes(nodes, lookAhead);
      }
      return part;
    }
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal/ruleName.js
  var require_ruleName6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _optionalPart = _interopRequireDefault2(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleNameNonTerminalPartRuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RuleNameNonTerminalPartRuleDefinition2, Definition);
      var _super = _createSuper(RuleNameNonTerminalPartRuleDefinition2);
      function RuleNameNonTerminalPartRuleDefinition2() {
        _classCallCheck(this, RuleNameNonTerminalPartRuleDefinition2);
        var ruleNameRuleName = _ruleNames.RuleNameRuleName, lookAheadModifierRuleName = _ruleNames.LookAheadModifierRuleName, ruleNameRuleNamePart = new _ruleName.default(ruleNameRuleName), lookAheadModifierRuleNamePart = new _ruleName.default(lookAheadModifierRuleName), optionalLookAheadRuleNamePartPart = new _optionalPart.default(lookAheadModifierRuleNamePart), parts = [
          ruleNameRuleNamePart,
          optionalLookAheadRuleNamePartPart
        ];
        return _super.call(this, parts);
      }
      return RuleNameNonTerminalPartRuleDefinition2;
    }(_definition.default);
    exports.default = RuleNameNonTerminalPartRuleDefinition;
  });

  // node_modules/occam-parsers/lib/rule/nonTerminalPart.js
  var require_nonTerminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _ruleName = _interopRequireDefault2(require_ruleName3());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal4());
    var _ruleName1 = _interopRequireDefault2(require_ruleName6());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NonTerminalPartRule = /* @__PURE__ */ function(Rule) {
      _inherits(NonTerminalPartRule2, Rule);
      var _super = _createSuper(NonTerminalPartRule2);
      function NonTerminalPartRule2() {
        _classCallCheck(this, NonTerminalPartRule2);
        var name = _ruleNames.NonTerminalPartRuleName, choiceOfPartsRuleName = _ruleNames.ChoiceOfPartsRuleName, sequenceOfPartsRuleName = _ruleNames.SequenceOfPartsRuleName, choiceOfPartsRuleNameDefinition = new _ruleName.default(choiceOfPartsRuleName), sequenceOfPartsRuleNameDefinition = new _ruleName.default(sequenceOfPartsRuleName), ruleNameNonTerminalPartRuleDefinition = new _ruleName1.default(), ambiguous = false, definitions = [
          choiceOfPartsRuleNameDefinition,
          sequenceOfPartsRuleNameDefinition,
          ruleNameNonTerminalPartRuleDefinition
        ], Node2 = _nonTerminal.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return NonTerminalPartRule2;
    }(_rule.default);
    exports.default = NonTerminalPartRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/sequenceOfParts.js
  var require_sequenceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _sequenceOfParts = _interopRequireDefault2(require_sequenceOfParts());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SequenceOfPartsBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(SequenceOfPartsBNFNode2, NonTerminalNode);
      var _super = _createSuper(SequenceOfPartsBNFNode2);
      function SequenceOfPartsBNFNode2() {
        _classCallCheck(this, SequenceOfPartsBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(SequenceOfPartsBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = _sequenceOfParts.default.fromNodes(nodes);
            return part;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(SequenceOfPartsBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return SequenceOfPartsBNFNode2;
    }(_nonTerminal.default);
    exports.default = SequenceOfPartsBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/sequenceOfParts.js
  var require_sequenceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    var _oneOrMoreParts = _interopRequireDefault2(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var openBracket = _occamLexers.specialSymbols.openBracket;
    var closeBracket = _occamLexers.specialSymbols.closeBracket;
    var SequenceOfPartsDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(SequenceOfPartsDefinition2, Definition);
      var _super = _createSuper(SequenceOfPartsDefinition2);
      function SequenceOfPartsDefinition2() {
        _classCallCheck(this, SequenceOfPartsDefinition2);
        var partRuleName = _ruleNames.PartRuleName, openBracketTerminalSymbolContent = openBracket, closeBracketTerminalSymbolContent = closeBracket, partRuleNamePart = new _ruleName.default(partRuleName), openBracketTerminalSymbolPart = new _terminalSymbol.default(openBracketTerminalSymbolContent), closeBracketTerminalSymbolPart = new _terminalSymbol.default(closeBracketTerminalSymbolContent), oneOrMorePartRuleNamePartsPart = new _oneOrMoreParts.default(partRuleNamePart), parts = [
          openBracketTerminalSymbolPart,
          partRuleNamePart,
          oneOrMorePartRuleNamePartsPart,
          closeBracketTerminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return SequenceOfPartsDefinition2;
    }(_definition.default);
    exports.default = SequenceOfPartsDefinition;
  });

  // node_modules/occam-parsers/lib/rule/sequenceOfParts.js
  var require_sequenceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _sequenceOfParts = _interopRequireDefault2(require_sequenceOfParts2());
    var _sequenceOfParts1 = _interopRequireDefault2(require_sequenceOfParts3());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SequenceOfPartsRule = /* @__PURE__ */ function(Rule) {
      _inherits(SequenceOfPartsRule2, Rule);
      var _super = _createSuper(SequenceOfPartsRule2);
      function SequenceOfPartsRule2() {
        _classCallCheck(this, SequenceOfPartsRule2);
        var name = _ruleNames.SequenceOfPartsRuleName, sequenceOfPartsDefinition = new _sequenceOfParts1.default(), ambiguous = false, definitions = [
          sequenceOfPartsDefinition
        ], Node2 = _sequenceOfParts.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return SequenceOfPartsRule2;
    }(_rule.default);
    exports.default = SequenceOfPartsRule;
  });

  // node_modules/occam-parsers/lib/parseTree/noWhitespaceNode.js
  var require_noWhitespaceNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _verticalBranch = _interopRequireDefault2(require_verticalBranch());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NO_WHITESPACE = _occamLexers.specialSymbols.NO_WHITESPACE;
    var NoWhitespaceNodeParseTree = /* @__PURE__ */ function(VerticalBranchParseTree) {
      _inherits(NoWhitespaceNodeParseTree2, VerticalBranchParseTree);
      var _super = _createSuper(NoWhitespaceNodeParseTree2);
      function NoWhitespaceNodeParseTree2() {
        _classCallCheck(this, NoWhitespaceNodeParseTree2);
        return _super.apply(this, arguments);
      }
      _createClass(NoWhitespaceNodeParseTree2, null, [
        {
          key: "fromNothing",
          value: function fromNothing() {
            var string = NO_WHITESPACE, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(NoWhitespaceNodeParseTree2, string, verticalBranchPosition);
            terminalNodeParseTree.appendToTop(verticalBranchParseTree);
            var noWhitespaceNodeParseTree = terminalNodeParseTree;
            return noWhitespaceNodeParseTree;
          }
        }
      ]);
      return NoWhitespaceNodeParseTree2;
    }(_verticalBranch.default);
    exports.default = NoWhitespaceNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/terminal/noWhitespace.js
  var require_noWhitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _terminal = _interopRequireDefault2(require_terminal2());
    var _noWhitespaceNode = _interopRequireDefault2(require_noWhitespaceNode());
    var _constants = require_constants4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NoWhitespaceNode = /* @__PURE__ */ function(TerminalNode) {
      _inherits(NoWhitespaceNode2, TerminalNode);
      var _super = _createSuper(NoWhitespaceNode2);
      function NoWhitespaceNode2() {
        _classCallCheck(this, NoWhitespaceNode2);
        return _super.apply(this, arguments);
      }
      _createClass(NoWhitespaceNode2, [
        {
          key: "getType",
          value: function getType() {
            var type = null;
            return type;
          }
        },
        {
          key: "getContent",
          value: function getContent() {
            var content = _constants.EMPTY_STRING;
            return content;
          }
        },
        {
          key: "isNoWhitespaceNode",
          value: function isNoWhitespaceNode() {
            var noWhitespaceNode = true;
            return noWhitespaceNode;
          }
        },
        {
          key: "asParseTree",
          value: function asParseTree(tokens) {
            var noWhitespaceNodeParseTree = _noWhitespaceNode.default.fromNothing(), parseTree = noWhitespaceNodeParseTree;
            return parseTree;
          }
        }
      ], [
        {
          key: "fromNothing",
          value: function fromNothing() {
            var significantToken = null, noWhitespaceNode = _terminal.default.fromSignificantToken(NoWhitespaceNode2, significantToken);
            return noWhitespaceNode;
          }
        }
      ]);
      return NoWhitespaceNode2;
    }(_terminal.default);
    exports.default = NoWhitespaceNode;
  });

  // node_modules/occam-parsers/lib/part/terminal/noWhitespace.js
  var require_noWhitespace2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _terminal = _interopRequireDefault2(require_terminal());
    var _noWhitespace = _interopRequireDefault2(require_noWhitespace());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NO_WHITESPACE = _occamLexers.specialSymbols.NO_WHITESPACE;
    var NoWhitespacePart = /* @__PURE__ */ function(TerminalPart) {
      _inherits(NoWhitespacePart2, TerminalPart);
      var _super = _createSuper(NoWhitespacePart2);
      function NoWhitespacePart2() {
        _classCallCheck(this, NoWhitespacePart2);
        return _super.apply(this, arguments);
      }
      _createClass(NoWhitespacePart2, [
        {
          key: "isNoWhitespacePart",
          value: function isNoWhitespacePart() {
            var noWhitespacePart = true;
            return noWhitespacePart;
          }
        },
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var noWhitespaceNode = null;
            var savedIndex = state.getSavedIndex(), nextTokenWhitespaceToken = state.isNextTokenWhitespaceToken();
            if (!nextTokenWhitespaceToken) {
              noWhitespaceNode = _noWhitespace.default.fromNothing();
            }
            parsed = noWhitespaceNode !== null;
            if (parsed) {
              nodes.push(noWhitespaceNode);
              if (callback !== null) {
                parsed = callback();
                if (!parsed) {
                  nodes.pop();
                }
              }
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var string = NO_WHITESPACE;
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(NoWhitespacePart2.prototype), "clone", this).call(this, NoWhitespacePart2);
          }
        }
      ]);
      return NoWhitespacePart2;
    }(_terminal.default);
    exports.default = NoWhitespacePart;
  });

  // node_modules/occam-parsers/lib/node/bnf/noWhitespacePart.js
  var require_noWhitespacePart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _noWhitespace = _interopRequireDefault2(require_noWhitespace2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NoWhitespacePartBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(NoWhitespacePartBNFNode2, NonTerminalNode);
      var _super = _createSuper(NoWhitespacePartBNFNode2);
      function NoWhitespacePartBNFNode2() {
        _classCallCheck(this, NoWhitespacePartBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(NoWhitespacePartBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var noWhitespacePart = new _noWhitespace.default();
            return noWhitespacePart;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(NoWhitespacePartBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return NoWhitespacePartBNFNode2;
    }(_nonTerminal.default);
    exports.default = NoWhitespacePartBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/noWhitespacePart.js
  var require_noWhitespacePart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NO_WHITESPACE = _occamLexers.specialSymbols.NO_WHITESPACE;
    var NoWhitespacePartDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(NoWhitespacePartDefinition2, Definition);
      var _super = _createSuper(NoWhitespacePartDefinition2);
      function NoWhitespacePartDefinition2() {
        _classCallCheck(this, NoWhitespacePartDefinition2);
        var content = NO_WHITESPACE, terminalSymbolPart = new _terminalSymbol.default(content), parts = [
          terminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return NoWhitespacePartDefinition2;
    }(_definition.default);
    exports.default = NoWhitespacePartDefinition;
  });

  // node_modules/occam-parsers/lib/rule/noWhitespacePart.js
  var require_noWhitespacePart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _noWhitespacePart = _interopRequireDefault2(require_noWhitespacePart());
    var _noWhitespacePart1 = _interopRequireDefault2(require_noWhitespacePart2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var NoWhitespacePartRule = /* @__PURE__ */ function(Rule) {
      _inherits(NoWhitespacePartRule2, Rule);
      var _super = _createSuper(NoWhitespacePartRule2);
      function NoWhitespacePartRule2() {
        _classCallCheck(this, NoWhitespacePartRule2);
        var noWhitespacePartDefinition = new _noWhitespacePart1.default(), name = _ruleNames.NoWhitespacePartRuleName, ambiguous = false, definitions = [
          noWhitespacePartDefinition
        ], Node2 = _noWhitespacePart.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return NoWhitespacePartRule2;
    }(_rule.default);
    exports.default = NoWhitespacePartRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/modifier.js
  var require_modifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ModifierBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(ModifierBNFNode2, NonTerminalNode);
      var _super = _createSuper(ModifierBNFNode2);
      function ModifierBNFNode2() {
        _classCallCheck(this, ModifierBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(ModifierBNFNode2, null, [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(ModifierBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return ModifierBNFNode2;
    }(_nonTerminal.default);
    exports.default = ModifierBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/lookAheadModifierRule.js
  var require_lookAheadModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _noWhitespace = _interopRequireDefault2(require_noWhitespace2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ellipsis = _occamLexers.specialSymbols.ellipsis;
    var LookAheadModifierRuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(LookAheadModifierRuleDefinition2, Definition);
      var _super = _createSuper(LookAheadModifierRuleDefinition2);
      function LookAheadModifierRuleDefinition2() {
        _classCallCheck(this, LookAheadModifierRuleDefinition2);
        var content = ellipsis, noWhitespacePart = new _noWhitespace.default(), terminalSymbolPart = new _terminalSymbol.default(content), parts = [
          noWhitespacePart,
          terminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return LookAheadModifierRuleDefinition2;
    }(_definition.default);
    exports.default = LookAheadModifierRuleDefinition;
  });

  // node_modules/occam-parsers/lib/rule/lookAheadModifier.js
  var require_lookAheadModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _modifier = _interopRequireDefault2(require_modifier());
    var _lookAheadModifierRule = _interopRequireDefault2(require_lookAheadModifierRule());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var LookAheadModifierRule = /* @__PURE__ */ function(Rule) {
      _inherits(LookAheadModifierRule2, Rule);
      var _super = _createSuper(LookAheadModifierRule2);
      function LookAheadModifierRule2() {
        _classCallCheck(this, LookAheadModifierRule2);
        var name = _ruleNames.LookAheadModifierRuleName, lookAheadModifierRuleDefinition = new _lookAheadModifierRule.default(), ambiguous = false, definitions = [
          lookAheadModifierRuleDefinition
        ], Node2 = _modifier.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return LookAheadModifierRule2;
    }(_rule.default);
    exports.default = LookAheadModifierRule;
  });

  // node_modules/occam-parsers/lib/definition/ambiguousModifierRule.js
  var require_ambiguousModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _definition = _interopRequireDefault2(require_definition());
    var _noWhitespace = _interopRequireDefault2(require_noWhitespace2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var exclamationMark = _occamLexers.specialSymbols.exclamationMark;
    var AmbiguousModifierRuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(AmbiguousModifierRuleDefinition2, Definition);
      var _super = _createSuper(AmbiguousModifierRuleDefinition2);
      function AmbiguousModifierRuleDefinition2() {
        _classCallCheck(this, AmbiguousModifierRuleDefinition2);
        var content = exclamationMark, noWhitespacePart = new _noWhitespace.default(), terminalSymbolPart = new _terminalSymbol.default(content), parts = [
          noWhitespacePart,
          terminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return AmbiguousModifierRuleDefinition2;
    }(_definition.default);
    exports.default = AmbiguousModifierRuleDefinition;
  });

  // node_modules/occam-parsers/lib/rule/ambiguousModifier.js
  var require_ambiguousModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rule = _interopRequireDefault2(require_rule2());
    var _modifier = _interopRequireDefault2(require_modifier());
    var _ambiguousModifierRule = _interopRequireDefault2(require_ambiguousModifierRule());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var AmbiguousModifierRule = /* @__PURE__ */ function(Rule) {
      _inherits(AmbiguousModifierRule2, Rule);
      var _super = _createSuper(AmbiguousModifierRule2);
      function AmbiguousModifierRule2() {
        _classCallCheck(this, AmbiguousModifierRule2);
        var name = _ruleNames.AmbiguousModifierRuleName, ambiguousModifierRuleDefinition = new _ambiguousModifierRule.default(), ambiguous = false, definitions = [
          ambiguousModifierRuleDefinition
        ], Node2 = _modifier.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return AmbiguousModifierRule2;
    }(_rule.default);
    exports.default = AmbiguousModifierRule;
  });

  // node_modules/occam-parsers/lib/part/terminal/regularExpression.js
  var require_regularExpression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _terminal = _interopRequireDefault2(require_terminal());
    var _terminal1 = _interopRequireDefault2(require_terminal2());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RegularExpressionPart = /* @__PURE__ */ function(TerminalPart) {
      _inherits(RegularExpressionPart2, TerminalPart);
      var _super = _createSuper(RegularExpressionPart2);
      function RegularExpressionPart2(regularExpression) {
        _classCallCheck(this, RegularExpressionPart2);
        var _this;
        _this = _super.call(this);
        _this.regularExpression = regularExpression;
        return _this;
      }
      _createClass(RegularExpressionPart2, [
        {
          key: "parse",
          value: function parse(nodes, state, callback) {
            var parsed;
            var terminalNode = null;
            var savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
            if (significantToken !== null) {
              var content = significantToken.getContent(), matches = content.match(this.regularExpression);
              if (matches !== null) {
                var firstMatch = (0, _array).first(matches);
                if (firstMatch === content) {
                  terminalNode = _terminal1.default.fromSignificantToken(significantToken);
                }
              }
            }
            parsed = terminalNode !== null;
            if (parsed) {
              nodes.push(terminalNode);
              if (callback !== null) {
                parsed = callback();
                if (!parsed) {
                  nodes.pop();
                }
              }
            }
            if (!parsed) {
              state.backtrack(savedIndex);
            }
            return parsed;
          }
        },
        {
          key: "asString",
          value: function asString() {
            var regularExpressionString = this.regularExpression.toString(), string = regularExpressionString;
            return string;
          }
        },
        {
          key: "clone",
          value: function clone() {
            return _get(_getPrototypeOf(RegularExpressionPart2.prototype), "clone", this).call(this, RegularExpressionPart2, this.regularExpression);
          }
        }
      ]);
      return RegularExpressionPart2;
    }(_terminal.default);
    exports.default = RegularExpressionPart;
  });

  // node_modules/occam-parsers/lib/node/bnf/regularExpression.js
  var require_regularExpression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _regularExpression = _interopRequireDefault2(require_regularExpression2());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RegularExpressionBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(RegularExpressionBNFNode2, NonTerminalNode);
      var _super = _createSuper(RegularExpressionBNFNode2);
      function RegularExpressionBNFNode2() {
        _classCallCheck(this, RegularExpressionBNFNode2);
        var _this;
        _this = _super.apply(this, arguments);
        _defineProperty(_assertThisInitialized(_this), "regularExpression", /^\/((?:\\.|[^\/])*)\/$/);
        return _this;
      }
      _createClass(RegularExpressionBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var regularExpression = this.getRegularExpression(), regularExpressionPart = new _regularExpression.default(regularExpression);
            return regularExpressionPart;
          }
        },
        {
          key: "getRegularExpression",
          value: function getRegularExpression() {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = (0, _array).second(matches), pattern = secondMatch, regularExpression = new RegExp(pattern);
            return regularExpression;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(RegularExpressionBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return RegularExpressionBNFNode2;
    }(_nonTerminal.default);
    exports.default = RegularExpressionBNFNode;
  });

  // node_modules/occam-parsers/lib/rule/regularExpression.js
  var require_regularExpression4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _regularExpression = _interopRequireDefault2(require_regularExpression3());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var regularExpressionType = _occamLexers.types.regularExpressionType;
    var RegularExpressionRule = /* @__PURE__ */ function(Rule) {
      _inherits(RegularExpressionRule2, Rule);
      var _super = _createSuper(RegularExpressionRule2);
      function RegularExpressionRule2() {
        _classCallCheck(this, RegularExpressionRule2);
        var regularExpressionSignificantTokenType = regularExpressionType, regularExpressionSignificantTokenTypeDefinition = new _significantTokenType.default(regularExpressionSignificantTokenType), name = _ruleNames.RegularExpressionRuleName, ambiguous = false, definitions = [
          regularExpressionSignificantTokenTypeDefinition
        ], Node2 = _regularExpression.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return RegularExpressionRule2;
    }(_rule.default);
    exports.default = RegularExpressionRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/quantifier.js
  var require_quantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var QuantifierBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(QuantifierBNFNode2, NonTerminalNode);
      var _super = _createSuper(QuantifierBNFNode2);
      function QuantifierBNFNode2() {
        _classCallCheck(this, QuantifierBNFNode2);
        return _super.apply(this, arguments);
      }
      _createClass(QuantifierBNFNode2, null, [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(QuantifierBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return QuantifierBNFNode2;
    }(_nonTerminal.default);
    exports.default = QuantifierBNFNode;
  });

  // node_modules/occam-parsers/lib/definition/quantifierRule.js
  var require_quantifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _definition = _interopRequireDefault2(require_definition());
    var _noWhitespace = _interopRequireDefault2(require_noWhitespace2());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var QuantifierRuleDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(QuantifierRuleDefinition2, Definition);
      var _super = _createSuper(QuantifierRuleDefinition2);
      function QuantifierRuleDefinition2(terminalSymbolContent) {
        _classCallCheck(this, QuantifierRuleDefinition2);
        var content = terminalSymbolContent, noWhitespacePart = new _noWhitespace.default(), terminalSymbolPart = new _terminalSymbol.default(content), parts = [
          noWhitespacePart,
          terminalSymbolPart
        ];
        return _super.call(this, parts);
      }
      return QuantifierRuleDefinition2;
    }(_definition.default);
    exports.default = QuantifierRuleDefinition;
  });

  // node_modules/occam-parsers/lib/rule/optionalQuantifier.js
  var require_optionalQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _quantifier = _interopRequireDefault2(require_quantifier2());
    var _quantifierRule = _interopRequireDefault2(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var questionMark = _occamLexers.specialSymbols.questionMark;
    var OptionalQuantifierRule = /* @__PURE__ */ function(Rule) {
      _inherits(OptionalQuantifierRule2, Rule);
      var _super = _createSuper(OptionalQuantifierRule2);
      function OptionalQuantifierRule2() {
        _classCallCheck(this, OptionalQuantifierRule2);
        var name = _ruleNames.OptionalQuantifierRuleName, optionalQuantifierTerminalSymbolContent = questionMark, optionalQuantifierRuleDefinition = new _quantifierRule.default(optionalQuantifierTerminalSymbolContent), ambiguous = false, definitions = [
          optionalQuantifierRuleDefinition
        ], Node2 = _quantifier.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return OptionalQuantifierRule2;
    }(_rule.default);
    exports.default = OptionalQuantifierRule;
  });

  // node_modules/occam-parsers/lib/rule/oneOrMoreQuantifier.js
  var require_oneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _quantifier = _interopRequireDefault2(require_quantifier2());
    var _quantifierRule = _interopRequireDefault2(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var plus = _occamLexers.specialSymbols.plus;
    var OneOrMoreQuantifierRule = /* @__PURE__ */ function(Rule) {
      _inherits(OneOrMoreQuantifierRule2, Rule);
      var _super = _createSuper(OneOrMoreQuantifierRule2);
      function OneOrMoreQuantifierRule2() {
        _classCallCheck(this, OneOrMoreQuantifierRule2);
        var name = _ruleNames.OneOrMoreQuantifierRuleName, oneOrMoreQuantifierTerminalSymbolContent = plus, oneOrMoreQuantifierRuleDefinition = new _quantifierRule.default(oneOrMoreQuantifierTerminalSymbolContent), ambiguous = false, definitions = [
          oneOrMoreQuantifierRuleDefinition
        ], Node2 = _quantifier.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return OneOrMoreQuantifierRule2;
    }(_rule.default);
    exports.default = OneOrMoreQuantifierRule;
  });

  // node_modules/occam-parsers/lib/rule/zeroOrMoreQuantifier.js
  var require_zeroOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _quantifier = _interopRequireDefault2(require_quantifier2());
    var _quantifierRule = _interopRequireDefault2(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var asterisk = _occamLexers.specialSymbols.asterisk;
    var ZeroOrMoreQuantifierRule = /* @__PURE__ */ function(Rule) {
      _inherits(ZeroOrMoreQuantifierRule2, Rule);
      var _super = _createSuper(ZeroOrMoreQuantifierRule2);
      function ZeroOrMoreQuantifierRule2() {
        _classCallCheck(this, ZeroOrMoreQuantifierRule2);
        var name = _ruleNames.ZeroOrMoreQuantifierRuleName, zeroOrMoreQuantifierTerminalSymbolContent = asterisk, zeroOrMoreQuantifierRuleDefinition = new _quantifierRule.default(zeroOrMoreQuantifierTerminalSymbolContent), ambiguous = false, definitions = [
          zeroOrMoreQuantifierRuleDefinition
        ], Node2 = _quantifier.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return ZeroOrMoreQuantifierRule2;
    }(_rule.default);
    exports.default = ZeroOrMoreQuantifierRule;
  });

  // node_modules/occam-parsers/lib/node/bnf/significantTokenType.js
  var require_significantTokenType3 = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType());
    var _array = require_array3();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var SignificantTokenTypeBNFNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(SignificantTokenTypeBNFNode2, NonTerminalNode);
      var _super = _createSuper(SignificantTokenTypeBNFNode2);
      function SignificantTokenTypeBNFNode2() {
        _classCallCheck(this, SignificantTokenTypeBNFNode2);
        var _this;
        _this = _super.apply(this, arguments);
        _defineProperty(_assertThisInitialized(_this), "regularExpression", /^\[([^\]]+)]$/);
        return _this;
      }
      _createClass(SignificantTokenTypeBNFNode2, [
        {
          key: "generatePart",
          value: function generatePart(lookAhead) {
            var significantTokenType = this.getSignificantTokenType(), significantTokenTypePart = new _significantTokenType.default(significantTokenType);
            return significantTokenTypePart;
          }
        },
        {
          key: "getSignificantTokenType",
          value: function getSignificantTokenType() {
            var childNodes = this.getChildNodes(), firstChildNode = (0, _array).first(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = (0, _array).second(matches), significantTokenType = secondMatch;
            return significantTokenType;
          }
        }
      ], [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _nonTerminal.default.fromRuleNameAndChildNodes(SignificantTokenTypeBNFNode2, ruleName, childNodes);
          }
        }
      ]);
      return SignificantTokenTypeBNFNode2;
    }(_nonTerminal.default);
    exports.default = SignificantTokenTypeBNFNode;
    module.exports = SignificantTokenTypeBNFNode;
  });

  // node_modules/occam-parsers/lib/rule/significantTokenType.js
  var require_significantTokenType4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamLexers = require_lib3();
    var _rule = _interopRequireDefault2(require_rule2());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType3());
    var _significantTokenType1 = _interopRequireDefault2(require_significantTokenType2());
    var _ruleNames = require_ruleNames();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var typeType = _occamLexers.types.typeType;
    var SignificantTokenTypeRule = /* @__PURE__ */ function(Rule) {
      _inherits(SignificantTokenTypeRule2, Rule);
      var _super = _createSuper(SignificantTokenTypeRule2);
      function SignificantTokenTypeRule2() {
        _classCallCheck(this, SignificantTokenTypeRule2);
        var typeSignificantTokenType = typeType, typeSignificantTokenTypeDefinition = new _significantTokenType1.default(typeSignificantTokenType), name = _ruleNames.SignificantTokenTypeRuleName, ambiguous = false, definitions = [
          typeSignificantTokenTypeDefinition
        ], Node2 = _significantTokenType.default;
        return _super.call(this, name, ambiguous, definitions, Node2);
      }
      return SignificantTokenTypeRule2;
    }(_rule.default);
    exports.default = SignificantTokenTypeRule;
  });

  // node_modules/occam-parsers/lib/utilities/rules.js
  var require_rules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ruleMapFromRules = ruleMapFromRules;
    exports.startRuleFromRules = startRuleFromRules;
    var _array = require_array3();
    function ruleMapFromRules(rules) {
      var ruleMap = {};
      rules.forEach(function(rule) {
        var ruleName = rule.getName();
        ruleMap[ruleName] = rule;
      });
      return ruleMap;
    }
    function startRuleFromRules(rules) {
      var firstRule = (0, _array).first(rules), startRule = firstRule;
      return startRule;
    }
  });

  // node_modules/occam-parsers/lib/bnf/parser.js
  var require_parser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bnf = _interopRequireDefault2(require_bnf());
    var _rule = _interopRequireDefault2(require_rule2());
    var _state = _interopRequireDefault2(require_state2());
    var _name = _interopRequireDefault2(require_name4());
    var _part = _interopRequireDefault2(require_part3());
    var _rule1 = _interopRequireDefault2(require_rule5());
    var _error = _interopRequireDefault2(require_error3());
    var _document = _interopRequireDefault2(require_document4());
    var _ruleName = _interopRequireDefault2(require_ruleName5());
    var _wildcard = _interopRequireDefault2(require_wildcard3());
    var _endOfLine = _interopRequireDefault2(require_endOfLine8());
    var _quantifier = _interopRequireDefault2(require_quantifier());
    var _definition = _interopRequireDefault2(require_definition4());
    var _definitions = _interopRequireDefault2(require_definitions3());
    var _terminalPart = _interopRequireDefault2(require_terminalPart());
    var _choiceOfParts = _interopRequireDefault2(require_choiceOfParts4());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol4());
    var _nonTerminalPart = _interopRequireDefault2(require_nonTerminalPart());
    var _sequenceOfParts = _interopRequireDefault2(require_sequenceOfParts4());
    var _noWhitespacePart = _interopRequireDefault2(require_noWhitespacePart3());
    var _lookAheadModifier = _interopRequireDefault2(require_lookAheadModifier());
    var _ambiguousModifier = _interopRequireDefault2(require_ambiguousModifier());
    var _regularExpression = _interopRequireDefault2(require_regularExpression4());
    var _optionalQuantifier = _interopRequireDefault2(require_optionalQuantifier());
    var _oneOrMoreQuantifier = _interopRequireDefault2(require_oneOrMoreQuantifier());
    var _zeroOrMoreQuantifier = _interopRequireDefault2(require_zeroOrMoreQuantifier());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType4());
    var _rules = require_rules();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BNFParser = /* @__PURE__ */ function() {
      function BNFParser2(startRule, ruleMap) {
        _classCallCheck(this, BNFParser2);
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      _createClass(BNFParser2, [
        {
          key: "getStartRule",
          value: function getStartRule() {
            return this.startRule;
          }
        },
        {
          key: "getRuleMap",
          value: function getRuleMap() {
            return this.ruleMap;
          }
        },
        {
          key: "parse",
          value: function parse(tokens) {
            var rule = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startRule;
            var state = _state.default.fromTokensAndRuleMap(tokens, this.ruleMap), callback = null, ruleNode = rule.parse(state, callback), node = ruleNode;
            return node;
          }
        },
        {
          key: "rulesFromTokens",
          value: function rulesFromTokens(tokens) {
            var rules;
            var node = this.parse(tokens);
            if (node === null) {
              throw new Error("There is no node.");
            }
            rules = node.generateRules(_rule.default);
            var rulesLength = rules.length;
            if (rulesLength === 0) {
              throw new Error("There are no rules.");
            }
            return rules;
          }
        }
      ], [
        {
          key: "fromNothing",
          value: function fromNothing() {
            var nameRule = new _name.default(), partRule = new _part.default(), ruleRule = new _rule1.default(), errorRule = new _error.default(), documentRule = new _document.default(), ruleNameRule = new _ruleName.default(), wildcardRule = new _wildcard.default(), endOfLineRule = new _endOfLine.default(), quantifierRule = new _quantifier.default(), definitionRule = new _definition.default(), definitionsRule = new _definitions.default(), terminalPartRule = new _terminalPart.default(), choiceOfPartsRule = new _choiceOfParts.default(), terminalSymbolRule = new _terminalSymbol.default(), nonTerminalPartRule = new _nonTerminalPart.default(), sequenceOfPartsRule = new _sequenceOfParts.default(), noWhitespacePartRule = new _noWhitespacePart.default(), regularExpressionRule = new _regularExpression.default(), lookAheadModifierRule = new _lookAheadModifier.default(), ambiguousModifierRule = new _ambiguousModifier.default(), optionalQuantifierRule = new _optionalQuantifier.default(), oneOrMoreQuantifierRule = new _oneOrMoreQuantifier.default(), zeroOrMoreQuantifierRule = new _zeroOrMoreQuantifier.default(), significantTokenTypeRule = new _significantTokenType.default();
            var rules = [
              documentRule,
              ruleRule,
              nameRule,
              definitionsRule,
              definitionRule,
              partRule,
              nonTerminalPartRule,
              terminalPartRule,
              noWhitespacePartRule,
              sequenceOfPartsRule,
              choiceOfPartsRule,
              ruleNameRule,
              significantTokenTypeRule,
              regularExpressionRule,
              terminalSymbolRule,
              endOfLineRule,
              wildcardRule,
              quantifierRule,
              ambiguousModifierRule,
              lookAheadModifierRule,
              optionalQuantifierRule,
              oneOrMoreQuantifierRule,
              zeroOrMoreQuantifierRule,
              errorRule
            ];
            var startRule = (0, _rules).startRuleFromRules(rules), ruleMap = (0, _rules).ruleMapFromRules(rules), bnfParser = new BNFParser2(startRule, ruleMap);
            return bnfParser;
          }
        }
      ]);
      return BNFParser2;
    }();
    exports.default = BNFParser;
    _defineProperty(BNFParser, "bnf", _bnf.default);
  });

  // node_modules/occam-parsers/lib/basic/bnf.js
  var require_bnf3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bnf = '\n\n  expression   ::= expression_ operator expression expression~*\n\n                 | expression_\n\n                 ;\n\n  operator     ::= "+"\n\n                 | "-"\n\n                 | "/"\n\n                 | "*"\n\n                 ;\n\n  term         ::= /\\d+/ ;\n\n  expression_  ::= "(" expression ")"\n\n                 | term\n\n                 ;\n\n  expression~  ::= operator expression ;\n  \n';
    var _default = bnf;
    exports.default = _default;
  });

  // node_modules/occam-parsers/lib/utilities/parser.js
  var require_parser2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rulesFromBNF = rulesFromBNF;
    exports.parserFromRules = parserFromRules;
    var _occamLexers = require_lib3();
    var _parser = _interopRequireDefault2(require_parser());
    var _rules = require_rules();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var bnfLexer = _occamLexers.BNFLexer.fromNothing();
    var bnfParser = _parser.default.fromNothing();
    function rulesFromBNF(bnf) {
      var tokens = bnfLexer.tokensFromBNF(bnf), rules = bnfParser.rulesFromTokens(tokens);
      return rules;
    }
    function parserFromRules(Class, rules) {
      var startRule = (0, _rules).startRuleFromRules(rules), ruleMap = (0, _rules).ruleMapFromRules(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
  });

  // node_modules/occam-parsers/lib/common/parser.js
  var require_parser3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _state = _interopRequireDefault2(require_state2());
    var _parser = require_parser2();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CommonParser = /* @__PURE__ */ function() {
      function CommonParser2(startRule, ruleMap) {
        _classCallCheck(this, CommonParser2);
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      _createClass(CommonParser2, [
        {
          key: "getStartRule",
          value: function getStartRule() {
            return this.startRule;
          }
        },
        {
          key: "getRuleMap",
          value: function getRuleMap() {
            return this.ruleMap;
          }
        },
        {
          key: "parse",
          value: function parse(tokens) {
            var rule = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startRule;
            var state = _state.default.fromTokensAndRuleMap(tokens, this.ruleMap), callback = null, ruleNode = rule.parse(state, callback), node = ruleNode;
            return node;
          }
        }
      ], [
        {
          key: "fromNothing",
          value: function fromNothing(Class) {
            var bnf = Class.bnf, rules = (0, _parser).rulesFromBNF(bnf), parser = (0, _parser).parserFromRules(Class, rules);
            return parser;
          }
        },
        {
          key: "fromBNF",
          value: function fromBNF(Class, bnf) {
            var rules = (0, _parser).rulesFromBNF(bnf), parser = (0, _parser).parserFromRules(Class, rules);
            return parser;
          }
        },
        {
          key: "fromRules",
          value: function fromRules(Class, rules) {
            var parser = (0, _parser).parserFromRules(Class, rules);
            return parser;
          }
        }
      ]);
      return CommonParser2;
    }();
    exports.default = CommonParser;
  });

  // node_modules/occam-parsers/lib/basic/parser.js
  var require_parser4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bnf = _interopRequireDefault2(require_bnf3());
    var _parser = _interopRequireDefault2(require_parser3());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var BasicParser = /* @__PURE__ */ function(CommonParser) {
      _inherits(BasicParser2, CommonParser);
      var _super = _createSuper(BasicParser2);
      function BasicParser2() {
        _classCallCheck(this, BasicParser2);
        return _super.apply(this, arguments);
      }
      _createClass(BasicParser2, null, [
        {
          key: "fromNothing",
          value: function fromNothing() {
            return _parser.default.fromNothing(BasicParser2);
          }
        },
        {
          key: "fromBNF",
          value: function fromBNF(bnf) {
            return _parser.default.fromBNF(BasicParser2, bnf);
          }
        },
        {
          key: "fromRules",
          value: function fromRules(rules) {
            return _parser.default.fromRules(BasicParser2, rules);
          }
        }
      ]);
      return BasicParser2;
    }(_parser.default);
    exports.default = BasicParser;
    _defineProperty(BasicParser, "bnf", _bnf.default);
  });

  // node_modules/occam-parsers/lib/parts.js
  var require_parts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _wildcard = _interopRequireDefault2(require_wildcard());
    var _endOfLine = _interopRequireDefault2(require_endOfLine6());
    var _terminalSymbol = _interopRequireDefault2(require_terminalSymbol());
    var _regularExpression = _interopRequireDefault2(require_regularExpression2());
    var _significantTokenType = _interopRequireDefault2(require_significantTokenType());
    var _ruleName = _interopRequireDefault2(require_ruleName2());
    var _optionalPart = _interopRequireDefault2(require_optionalPart());
    var _zeroOrMoreParts = _interopRequireDefault2(require_zeroOrMoreParts());
    var _oneOrMoreParts = _interopRequireDefault2(require_oneOrMoreParts());
    var _sequenceOfParts = _interopRequireDefault2(require_sequenceOfParts());
    var _choiceOfParts = _interopRequireDefault2(require_choiceOfParts());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = {
      WildcardPart: _wildcard.default,
      EndOfLinePart: _endOfLine.default,
      TerminalSymbolPart: _terminalSymbol.default,
      RegularExpressionPart: _regularExpression.default,
      SignificantTokenTypePart: _significantTokenType.default,
      RuleNamePart: _ruleName.default,
      OptionalPartPart: _optionalPart.default,
      ZeroOrMorePartsPart: _zeroOrMoreParts.default,
      OneOrMorePartsPart: _oneOrMoreParts.default,
      SequenceOfPartsPart: _sequenceOfParts.default,
      ChoiceOfPartsPart: _choiceOfParts.default
    };
    exports.default = _default;
  });

  // node_modules/occam-parsers/lib/index.js
  var require_lib4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "BNFParser", {
      enumerable: true,
      get: function() {
        return _parser.default;
      }
    });
    Object.defineProperty(exports, "BasicParser", {
      enumerable: true,
      get: function() {
        return _parser1.default;
      }
    });
    Object.defineProperty(exports, "CommonParser", {
      enumerable: true,
      get: function() {
        return _parser2.default;
      }
    });
    Object.defineProperty(exports, "Rule", {
      enumerable: true,
      get: function() {
        return _rule.default;
      }
    });
    Object.defineProperty(exports, "Parts", {
      enumerable: true,
      get: function() {
        return _parts.default;
      }
    });
    Object.defineProperty(exports, "partTypes", {
      enumerable: true,
      get: function() {
        return _partTypes.default;
      }
    });
    Object.defineProperty(exports, "Definition", {
      enumerable: true,
      get: function() {
        return _definition.default;
      }
    });
    Object.defineProperty(exports, "TerminalNode", {
      enumerable: true,
      get: function() {
        return _terminal.default;
      }
    });
    Object.defineProperty(exports, "NonTerminalNode", {
      enumerable: true,
      get: function() {
        return _nonTerminal.default;
      }
    });
    var _parser = _interopRequireDefault2(require_parser());
    var _parser1 = _interopRequireDefault2(require_parser4());
    var _parser2 = _interopRequireDefault2(require_parser3());
    var _rule = _interopRequireDefault2(require_rule2());
    var _parts = _interopRequireDefault2(require_parts());
    var _partTypes = _interopRequireDefault2(require_partTypes());
    var _definition = _interopRequireDefault2(require_definition());
    var _terminal = _interopRequireDefault2(require_terminal2());
    var _nonTerminal = _interopRequireDefault2(require_nonTerminal());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/bnf.js
  var require_bnf4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bnf = '\n\n\n\n    stylesheet                 ::= ( media | ruleSet | declaration | error )+ ;\n\n\n\n\n\n    media                      ::= "@media" mediaQueries "{" ( ruleSet | declaration )* "}" ;\n                                                              \n                                                              \n    mediaQueries               ::=  mediaQuery ( "," mediaQuery )* ;\n                                                              \n                                                              \n    mediaQuery                 ::=  "not"? ( "only"? mediaType "and" )? mediaExpression ( "and" mediaExpression )* ;\n\n\n    mediaType                  ::=  "all" | "print" | "screen" | "speech" ;\n                                                              \n                                                              \n    mediaExpression            ::=  "(" [identifier] ( ":" expression )? ")" ;\n\n\n\n\n\n    ruleSet                    ::=  selectors "{" declaration* "}" ;\n    \n    \n    selectors                  ::=  selector ( "," selector )* ;\n\n\n    selector                   ::=  ( class | pseudoClass | pseudoElement | attribute )+ ;\n\n\n\n\n\n    declaration                ::=  property ":" expression ( "," expression )* priority? ";" ;\n\n\n    class                      ::=  "."<NO_WHITESPACE>[identifier] parenthesisedSelector? ;\n\n\n    pseudoClass                ::=  ":"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;\n\n\n    pseudoElement              ::=  "::"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;\n\n\n    parenthesisedSelector      ::=  <NO_WHITESPACE>"(" selector <NO_WHITESPACE>")" ;\n\n\n    attribute                  ::=  "["\n\n                                       [identifier]\n\n                                       (\n\n                                         ( "=" | "~=" | "|=" )\n\n                                         ( [identifier] | [string-literal] )\n\n                                       )?\n\n                                    "]"\n\n                                 ;\n\n\n    property                   ::=  [identifier] ;\n\n\n    expression                 ::=  term ( ","? term )* ;\n\n\n    priority                   ::=  "!important" ;\n\n\n\n\n\n    term                       ::=  [unary-operator]?\n                                                       \n                                      (\n                                                       \n                                        ( [percentage] | [frequency] | [fraction] | [length] | [angle] | [rems] | [ems] | [time] | [number] )\n                                                       \n                                        |\n                                                       \n                                        uri\n                                                       \n                                        |\n                                                       \n                                        function\n                                                       \n                                        |\n                                                       \n                                        [string-literal]+\n                                                       \n                                        |\n                                                       \n                                        [identifier]\n                                                       \n                                        |\n                                                       \n                                        [colour]\n                                                       \n                                      )\n                                                       \n                                   ;\n\n\n    uri                        ::=  "url"<NO_WHITESPACE>"(" [string-literal] ")" ;\n\n\n    function                   ::=  [identifier]<NO_WHITESPACE>"(" expression ")" ;\n\n\n\n\n\n    error                      ::=  . ;\n\n\n\n';
    var _default = bnf;
    exports.default = _default;
  });

  // node_modules/with-style/lib/css/parser.js
  var require_parser5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _bnf = _interopRequireDefault2(require_bnf4());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var CSSParser = /* @__PURE__ */ function(CommonParser) {
      _inherits(CSSParser2, CommonParser);
      var _super = _createSuper(CSSParser2);
      function CSSParser2() {
        _classCallCheck(this, CSSParser2);
        return _super.apply(this, arguments);
      }
      _createClass(CSSParser2, null, [
        {
          key: "fromNothing",
          value: function fromNothing() {
            return _occamParsers.CommonParser.fromNothing(CSSParser2);
          }
        },
        {
          key: "fromBNF",
          value: function fromBNF(bnf) {
            return _occamParsers.CommonParser.fromBNF(CSSParser2, bnf);
          }
        },
        {
          key: "fromRules",
          value: function fromRules(rules) {
            return _occamParsers.CommonParser.fromRules(CSSParser2, rules);
          }
        }
      ]);
      return CSSParser2;
    }(_occamParsers.CommonParser);
    _defineProperty(CSSParser, "bnf", _bnf.default);
    exports.default = CSSParser;
  });

  // node_modules/occam-dom/lib/utilities/array.js
  var require_array4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.trim = trim;
    exports.includes = includes;
    exports.fifth = exports.fourth = exports.third = exports.second = exports.push = exports.clear = void 0;
    var _necessary = require_browser();
    var clear = _necessary.arrayUtilities.clear;
    var push = _necessary.arrayUtilities.push;
    var second = _necessary.arrayUtilities.second;
    var third = _necessary.arrayUtilities.third;
    var fourth = _necessary.arrayUtilities.fourth;
    var fifth = _necessary.arrayUtilities.fifth;
    exports.clear = clear;
    exports.push = push;
    exports.second = second;
    exports.third = third;
    exports.fourth = fourth;
    exports.fifth = fifth;
    function trim(array, startIndex, endIndex) {
      var start, deleteCount;
      if (endIndex !== Infinity) {
        start = endIndex + 1;
        array.splice(start);
      }
      start = 0;
      deleteCount = startIndex;
      array.splice(start, deleteCount);
    }
    function includes(array) {
      for (var _len = arguments.length, elements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        elements[_key - 1] = arguments[_key];
      }
      return elements.some(function(element) {
        return array.includes(element);
      });
    }
  });

  // node_modules/occam-dom/lib/spread.js
  var require_spread = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _array = require_array4();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var EXCLAMATION_MARK_CHARACTER = _necessary.characters.EXCLAMATION_MARK_CHARACTER;
    var Spread = /* @__PURE__ */ function() {
      function Spread2(startIndex, endIndex, unique) {
        _classCallCheck(this, Spread2);
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.unique = unique;
      }
      _createClass(Spread2, [
        {
          key: "adjustNodes",
          value: function adjustNodes(nodes) {
            if (this.unique) {
              var nodesLength = nodes.length;
              if (nodesLength > 1) {
                (0, _array).clear(nodes);
              }
            } else {
              (0, _array).trim(nodes, this.startIndex, this.endIndex);
            }
          }
        }
      ], [
        {
          key: "fromSpreadExpression",
          value: function fromSpreadExpression(spreadExpression) {
            var startIndex = 0, endIndex = Infinity, unique = false;
            if (spreadExpression !== null) {
              if (spreadExpression === EXCLAMATION_MARK_CHARACTER) {
                unique = true;
              } else {
                var regExp = /\[(\d+)?(\.\.\.)?(\d+)?]/, matches = spreadExpression.match(regExp), secondMatch = (0, _array).second(matches), thirdMatch = (0, _array).third(matches), fourthMatch = (0, _array).fourth(matches);
                if (secondMatch !== void 0) {
                  startIndex = parseInt(secondMatch);
                  if (thirdMatch === void 0) {
                    endIndex = startIndex;
                  }
                }
                if (fourthMatch !== void 0) {
                  endIndex = parseInt(fourthMatch);
                  if (thirdMatch === void 0) {
                    startIndex = endIndex;
                  }
                }
              }
            }
            var spread = new Spread2(startIndex, endIndex, unique);
            return spread;
          }
        }
      ]);
      return Spread2;
    }();
    exports.default = Spread;
  });

  // node_modules/occam-dom/lib/query.js
  var require_query = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _spread = _interopRequireDefault2(require_spread());
    var _array = require_array4();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var WILDCARD_CHARACTER = _necessary.characters.WILDCARD_CHARACTER;
    var Query = /* @__PURE__ */ function() {
      function Query2(ruleNames, types, spread, subQuery, maximumDepth, infiniteDescent, intermediateNodes) {
        _classCallCheck(this, Query2);
        this.ruleNames = ruleNames;
        this.types = types;
        this.spread = spread;
        this.subQuery = subQuery;
        this.maximumDepth = maximumDepth;
        this.infiniteDescent = infiniteDescent;
        this.intermediateNodes = intermediateNodes;
      }
      _createClass(Query2, [
        {
          key: "execute",
          value: function execute(node) {
            var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, maximumDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.maximumDepth;
            var nodes = [];
            this.clear();
            this.find(node, depth, maximumDepth);
            this.apply(nodes, depth, maximumDepth);
            return nodes;
          }
        },
        {
          key: "clear",
          value: function clear() {
            (0, _array).clear(this.intermediateNodes);
          }
        },
        {
          key: "find",
          value: function find(node, depth, maximumDepth) {
            if (depth > maximumDepth) {
              return;
            }
            var nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
            var found;
            if (nodeTerminalNode) {
              var terminalNode = node, type = terminalNode.getType();
              found = (0, _array).includes(this.types, type, WILDCARD_CHARACTER);
            }
            if (nodeNonTerminalNode) {
              var nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName();
              found = (0, _array).includes(this.ruleNames, ruleName, WILDCARD_CHARACTER);
            }
            if (found) {
              var intermediateNode = node;
              this.intermediateNodes.push(intermediateNode);
            }
            if (this.infiniteDescent) {
              if (nodeNonTerminalNode) {
                var _this = this;
                depth++;
                var nonTerminalNode1 = node, childNodes = nonTerminalNode1.getChildNodes();
                childNodes.forEach(function(childNode) {
                  return _this.find(childNode, depth, maximumDepth);
                });
              }
            }
          }
        },
        {
          key: "apply",
          value: function apply(nodes, depth, maximumDepth) {
            this.spread.adjustNodes(this.intermediateNodes);
            if (this.subQuery === null) {
              (0, _array).push(nodes, this.intermediateNodes);
            } else {
              var _this = this;
              this.intermediateNodes.forEach(function(intermediateNode) {
                var intermediateNodeNonTerminalNode = intermediateNode.isNonTerminalNode();
                if (intermediateNodeNonTerminalNode) {
                  var _this1 = _this;
                  depth++;
                  var nonTerminalNode = intermediateNode, childNodes = nonTerminalNode.getChildNodes();
                  _this.subQuery.clear();
                  childNodes.forEach(function(childNode) {
                    return _this1.subQuery.find(childNode, depth, maximumDepth);
                  });
                  _this.subQuery.apply(nodes, depth, maximumDepth);
                }
              });
            }
          }
        }
      ], [
        {
          key: "fromSubExpressionAndTypes",
          value: function fromSubExpressionAndTypes(subExpresion, types) {
            var query = null;
            if (subExpresion !== null) {
              var typesLength = types.length;
              if (typesLength === 0) {
                var expression = subExpresion;
                query = Query2.fromExpression(expression);
              }
            }
            return query;
          }
        },
        {
          key: "fromExpression",
          value: function fromExpression(expression) {
            var maximumDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
            var regExp = /^\/(\/)?([^/\[!]+)(\[[^\]]+]|!)?(\/.*)?$/, matches = expression.match(regExp), secondMatch = (0, _array).second(matches), thirdMatch = (0, _array).third(matches), fourthMatch = (0, _array).fourth(matches), fifthMatch = (0, _array).fifth(matches), selectors = thirdMatch.split("|"), subExpression = fifthMatch || null, spreadExpression = fourthMatch || null, types = typesFromSelectors(selectors), ruleNames = ruleNamesFromSelectorsAndTypes(selectors, types), spread = _spread.default.fromSpreadExpression(spreadExpression), subQuery = Query2.fromSubExpressionAndTypes(subExpression, types), infiniteDescent = secondMatch === "/", intermediateNodes = [], query = new Query2(ruleNames, types, spread, subQuery, maximumDepth, infiniteDescent, intermediateNodes);
            return query;
          }
        }
      ]);
      return Query2;
    }();
    exports.default = Query;
    function typesFromSelectors(selectors) {
      var types = [];
      selectors.forEach(function(selector) {
        var selectorTypeSelector = isSelectorTypeSelector(selector);
        if (selectorTypeSelector) {
          var type = selector.substring(1);
          types.push(type);
        }
      });
      return types;
    }
    function isSelectorTypeSelector(selector) {
      return /^@/.test(selector);
    }
    function ruleNamesFromSelectors(selectors) {
      return selectors.filter(isSelectorRuleNameSelector);
    }
    function isSelectorRuleNameSelector(selector) {
      return /^[^@]/.test(selector);
    }
    function ruleNamesFromSelectorsAndTypes(selectors, types) {
      var ruleNames = [];
      var typesLength = types.length;
      if (typesLength === 0) {
        ruleNames = ruleNamesFromSelectors(selectors);
      }
      return ruleNames;
    }
  });

  // node_modules/occam-dom/lib/utilities/query.js
  var require_query2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.queryByClass = queryByClass;
    exports.queryByClasses = queryByClasses;
    exports.queryByExpression = queryByExpression;
    exports.default = void 0;
    var _query = _interopRequireDefault2(require_query());
    function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function queryByClass(node, Class) {
      var nodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (_instanceof(node, Class)) {
        nodes.push(node);
      }
      var nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        var childNodes = node.getChildNodes();
        childNodes.forEach(function(childNode) {
          return queryByClass(childNode, Class, nodes);
        });
      }
      return nodes;
    }
    function queryByClasses(node, Classes) {
      var nodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      Classes.some(function(Class) {
        if (_instanceof(node, Class)) {
          nodes.push(node);
          return true;
        }
      });
      var nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        var childNodes = node.getChildNodes();
        childNodes.forEach(function(childNode) {
          return queryByClasses(childNode, Classes, nodes);
        });
      }
      return nodes;
    }
    function queryByExpression(node, expression, maximumDepth) {
      var query = _query.default.fromExpression(expression, maximumDepth), nodes = query.execute(node);
      return nodes;
    }
    var _default = {
      queryByClass,
      queryByClasses,
      queryByExpression
    };
    exports.default = _default;
  });

  // node_modules/occam-dom/lib/index.js
  var require_lib5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Query", {
      enumerable: true,
      get: function() {
        return _query.default;
      }
    });
    Object.defineProperty(exports, "queryUtilities", {
      enumerable: true,
      get: function() {
        return _query1.default;
      }
    });
    var _query = _interopRequireDefault2(require_query());
    var _query1 = _interopRequireDefault2(require_query2());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/constants.js
  var require_constants5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CLASS_NAME_LENGTH = exports.EMPTY_STRING = exports.FOUR_SPACES = exports.TWO_SPACES = exports.CHARACTERS = exports.STYLE = exports.HEAD = void 0;
    var HEAD = "head";
    exports.HEAD = HEAD;
    var STYLE = "style";
    exports.STYLE = STYLE;
    var CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    exports.CHARACTERS = CHARACTERS;
    var TWO_SPACES = "  ";
    exports.TWO_SPACES = TWO_SPACES;
    var FOUR_SPACES = "    ";
    exports.FOUR_SPACES = FOUR_SPACES;
    var EMPTY_STRING = "";
    exports.EMPTY_STRING = EMPTY_STRING;
    var CLASS_NAME_LENGTH = 6;
    exports.CLASS_NAME_LENGTH = CLASS_NAME_LENGTH;
  });

  // node_modules/with-style/lib/utilities/content.js
  var require_content2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contentFromQueryNodeAndTokens = contentFromQueryNodeAndTokens;
    var _necessary = require_browser();
    var _constants = require_constants5();
    var first = _necessary.arrayUtilities.first;
    function contentFromQueryNodeAndTokens(query, node, tokens) {
      var nodes = query.execute(node), firstNode = first(nodes);
      node = firstNode;
      var content = contentFromNodeAndTokens(node, tokens);
      return content;
    }
    function contentFromNodeAndTokens(node, tokens) {
      var firstSignificantToken = node.getFirstSignificantToken(), lastSignificantToken = node.getLastSignificantToken(), firstToken = firstSignificantToken, lastToken = lastSignificantToken, firstTokenIndex = tokens.indexOf(firstToken), lastTokenIndex = tokens.indexOf(lastToken);
      var content = _constants.EMPTY_STRING;
      for (var index = firstTokenIndex; index <= lastTokenIndex; index++) {
        var token = tokens[index], tokenContent = token.getContent();
        content += tokenContent;
      }
      return content;
    }
  });

  // node_modules/with-style/lib/style/declaration.js
  var require_declaration = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamDom = require_lib5();
    var _content = require_content2();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var propertyQuery = _occamDom.Query.fromExpression("/*/property");
    var expressionQuery = _occamDom.Query.fromExpression("/*/expression");
    var Declaration = /* @__PURE__ */ function() {
      function Declaration2(property, expression) {
        _classCallCheck(this, Declaration2);
        this.property = property;
        this.expression = expression;
      }
      _createClass(Declaration2, [
        {
          key: "getProperty",
          value: function getProperty() {
            return this.property;
          }
        },
        {
          key: "getExpression",
          value: function getExpression() {
            return this.expression;
          }
        },
        {
          key: "checkMatches",
          value: function checkMatches(declarations) {
            var _this = this;
            var matches = declarations.some(function(declaration) {
              var property = declaration.getProperty(), propertiesMatch = property === _this.property;
              if (propertiesMatch) {
                return true;
              }
            });
            return matches;
          }
        },
        {
          key: "asCSS",
          value: function asCSS(indent, last) {
            var css = last ? "".concat(indent).concat(this.property, ": ").concat(this.expression, ";") : "".concat(indent).concat(this.property, ": ").concat(this.expression, ";\n");
            return css;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node, tokens) {
            var propertyContent = (0, _content).contentFromQueryNodeAndTokens(propertyQuery, node, tokens), expressionContent = (0, _content).contentFromQueryNodeAndTokens(expressionQuery, node, tokens), property = propertyContent, expression = expressionContent, declaration = new Declaration2(property, expression);
            return declaration;
          }
        }
      ]);
      return Declaration2;
    }();
    exports.default = Declaration;
  });

  // node_modules/with-style/lib/style/declarations.js
  var require_declarations = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamDom = require_lib5();
    var _declaration = _interopRequireDefault2(require_declaration());
    var _constants = require_constants5();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var declarationQuery = _occamDom.Query.fromExpression("/*/declaration");
    var Declarations = /* @__PURE__ */ function() {
      function Declarations2(array) {
        _classCallCheck(this, Declarations2);
        this.array = array;
      }
      _createClass(Declarations2, [
        {
          key: "forwardsForEach",
          value: function forwardsForEach(callback) {
            var length = this.array.length, firstIndex = 0, lastIndex = length - 1;
            for (var index = firstIndex; index <= lastIndex; index++) {
              var declaration = this.array[index];
              callback(declaration, index);
            }
          }
        },
        {
          key: "backwardsForEach",
          value: function backwardsForEach(callback) {
            var length = this.array.length, firstIndex = 0, lastIndex = length - 1;
            for (var index = lastIndex; index >= firstIndex; index--) {
              var declaration = this.array[index];
              callback(declaration, index);
            }
          }
        },
        {
          key: "unshift",
          value: function unshift(declarations) {
            var _this = this;
            declarations.backwardsForEach(function(declaration) {
              var matches = declaration.checkMatches(_this.array);
              if (!matches) {
                _this.array.unshift(declaration);
              }
            });
          }
        },
        {
          key: "asCSS",
          value: function asCSS(className, indent) {
            if (indent === void 0) {
              indent = className;
              className = null;
            }
            var css = _constants.EMPTY_STRING;
            var length = this.array.length;
            if (length > 0) {
              var lastIndex = length - 1, declarationsCSS1 = this.array.reduce(function(declarationsCSS, declaration, index) {
                var last = index === lastIndex, declarationCSS = declaration.asCSS(indent, last);
                declarationsCSS += declarationCSS;
                return declarationsCSS;
              }, _constants.EMPTY_STRING);
              if (className === null) {
                css = declarationsCSS1;
              } else {
                css = ".".concat(className, " {\n").concat(declarationsCSS1, "\n}\n\n");
              }
            }
            return css;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node1, tokens) {
            var declarationNodes = declarationQuery.execute(node1), array = declarationNodes.map(function(declarationNode) {
              var node = declarationNode, declaration = _declaration.default.fromNodeAndTokens(node, tokens);
              return declaration;
            }), declarations = new Declarations2(array);
            return declarations;
          }
        }
      ]);
      return Declarations2;
    }();
    exports.default = Declarations;
  });

  // node_modules/with-style/lib/style/ruleSet.js
  var require_ruleSet = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamDom = require_lib5();
    var _declarations = _interopRequireDefault2(require_declarations());
    var _constants = require_constants5();
    var _content = require_content2();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var selectorsQuery = _occamDom.Query.fromExpression("//selectors");
    var RuleSet = /* @__PURE__ */ function() {
      function RuleSet2(selectors, declarations) {
        _classCallCheck(this, RuleSet2);
        this.selectors = selectors;
        this.declarations = declarations;
      }
      _createClass(RuleSet2, [
        {
          key: "getSelectors",
          value: function getSelectors() {
            return this.selectors;
          }
        },
        {
          key: "getDeclarations",
          value: function getDeclarations() {
            return this.declarations;
          }
        },
        {
          key: "unshift",
          value: function unshift(ruleSet) {
            var declarations = ruleSet.getDeclarations();
            this.declarations.unshift(declarations);
          }
        },
        {
          key: "findMatchingRuleSet",
          value: function findMatchingRuleSet(ruleSets) {
            var _this = this;
            var matchingRuleSet = ruleSets.find(function(ruleSet) {
              var selectors = ruleSet.getSelectors(), selectorsMatch = selectors === _this.selectors, ruleSetsMatch = selectorsMatch;
              if (ruleSetsMatch) {
                return true;
              }
            }) || null;
            return matchingRuleSet;
          }
        },
        {
          key: "asCSS",
          value: function asCSS(className, indent) {
            var css = _constants.EMPTY_STRING;
            var declarationsCSS = this.declarations.asCSS("  ".concat(indent));
            if (declarationsCSS !== _constants.EMPTY_STRING) {
              css = "".concat(indent, ".").concat(className).concat(this.selectors, " {\n").concat(declarationsCSS, "\n").concat(indent, "}\n\n");
            }
            return css;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node, tokens) {
            var selectors = selectorsFromNodeAndTokens(node, tokens), declarations = _declarations.default.fromNodeAndTokens(node, tokens), media = new RuleSet2(selectors, declarations);
            return media;
          }
        }
      ]);
      return RuleSet2;
    }();
    exports.default = RuleSet;
    function selectorsFromNodeAndTokens(node, tokens) {
      var selectorsNodeContent = (0, _content).contentFromQueryNodeAndTokens(selectorsQuery, node, tokens), selectors = "".concat(selectorsNodeContent);
      return selectors;
    }
  });

  // node_modules/with-style/lib/style/ruleSets.js
  var require_ruleSets = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamDom = require_lib5();
    var _ruleSet = _interopRequireDefault2(require_ruleSet());
    var _constants = require_constants5();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ruleSetQuery = _occamDom.Query.fromExpression("/*/ruleSet");
    var RuleSets = /* @__PURE__ */ function() {
      function RuleSets2(array) {
        _classCallCheck(this, RuleSets2);
        this.array = array;
      }
      _createClass(RuleSets2, [
        {
          key: "unshift",
          value: function unshift(ruleSets) {
            var _this = this;
            ruleSets.forEach(function(ruleSet) {
              var matchingRuleSet = ruleSet.findMatchingRuleSet(_this.array);
              matchingRuleSet === null ? _this.array.unshift(ruleSet) : matchingRuleSet.unshift(ruleSet);
            });
          }
        },
        {
          key: "forEach",
          value: function forEach(callback) {
            this.array.forEach(callback);
          }
        },
        {
          key: "asCSS",
          value: function asCSS(className, indent) {
            var css1 = this.array.reduce(function(css, ruleSet) {
              var ruleSetCSS = ruleSet.asCSS(className, indent);
              css += ruleSetCSS;
              return css;
            }, _constants.EMPTY_STRING);
            return css1;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node1, tokens) {
            var ruleSetNodes = ruleSetQuery.execute(node1), array = ruleSetNodes.map(function(ruleSetNode) {
              var node = ruleSetNode, ruleSet = _ruleSet.default.fromNodeAndTokens(node, tokens);
              return ruleSet;
            }), ruleSets = new RuleSets2(array);
            return ruleSets;
          }
        }
      ]);
      return RuleSets2;
    }();
    exports.default = RuleSets;
  });

  // node_modules/with-style/lib/style/media.js
  var require_media = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamDom = require_lib5();
    var _ruleSets = _interopRequireDefault2(require_ruleSets());
    var _declarations = _interopRequireDefault2(require_declarations());
    var _constants = require_constants5();
    var _content = require_content2();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var mediaQueriesQuery = _occamDom.Query.fromExpression("/media/mediaQueries");
    var Media = /* @__PURE__ */ function() {
      function Media2(mediaQueries, declarations, ruleSets) {
        _classCallCheck(this, Media2);
        this.mediaQueries = mediaQueries;
        this.declarations = declarations;
        this.ruleSets = ruleSets;
      }
      _createClass(Media2, [
        {
          key: "getMediaQueries",
          value: function getMediaQueries() {
            return this.mediaQueries;
          }
        },
        {
          key: "getDeclarations",
          value: function getDeclarations() {
            return this.declarations;
          }
        },
        {
          key: "getRuleSets",
          value: function getRuleSets() {
            return this.ruleSets;
          }
        },
        {
          key: "asCSS",
          value: function asCSS(className) {
            var css = "";
            var ruleSetsCSS = this.ruleSets.asCSS(className, _constants.TWO_SPACES), declarationsCSS = this.declarations.asCSS(className, _constants.FOUR_SPACES);
            if (ruleSetsCSS !== null || declarationsCSS !== null) {
              css = "@media ".concat(this.mediaQueries, " {\n").concat(declarationsCSS).concat(ruleSetsCSS, "\n}\n\n");
            }
            return css;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node, tokens) {
            var mediaQueries = mediaQueriesFromNodeAndTokens(node, tokens), declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), media = new Media2(mediaQueries, declarations, ruleSets);
            return media;
          }
        }
      ]);
      return Media2;
    }();
    exports.default = Media;
    function mediaQueriesFromNodeAndTokens(node, tokens) {
      var mediaQueriesNodeContent = (0, _content).contentFromQueryNodeAndTokens(mediaQueriesQuery, node, tokens), mediaQueries = "".concat(mediaQueriesNodeContent);
      return mediaQueries;
    }
  });

  // node_modules/with-style/lib/style/medias.js
  var require_medias = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamDom = require_lib5();
    var _media = _interopRequireDefault2(require_media());
    var _constants = require_constants5();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var mediaQuery = _occamDom.Query.fromExpression("/stylesheet/media");
    var Medias = /* @__PURE__ */ function() {
      function Medias2(array) {
        _classCallCheck(this, Medias2);
        this.array = array;
      }
      _createClass(Medias2, [
        {
          key: "unshift",
          value: function unshift(medias) {
            var _this = this;
            medias.forEach(function(media) {
              _this.array.unshift(media);
            });
          }
        },
        {
          key: "forEach",
          value: function forEach(callback) {
            this.array.forEach(callback);
          }
        },
        {
          key: "asCSS",
          value: function asCSS(className) {
            var css1 = this.array.reduce(function(css, media) {
              var mediaCSS = media.asCSS(className);
              css += mediaCSS;
              return css;
            }, _constants.EMPTY_STRING);
            return css1;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node1, tokens) {
            var mediaNodes = mediaQuery.execute(node1), array = mediaNodes.map(function(mediaNode) {
              var node = mediaNode, media = _media.default.fromNodeAndTokens(node, tokens);
              return media;
            }), medias = new Medias2(array);
            return medias;
          }
        }
      ]);
      return Medias2;
    }();
    exports.default = Medias;
  });

  // node_modules/with-style/lib/style.js
  var require_style = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _medias = _interopRequireDefault2(require_medias());
    var _ruleSets = _interopRequireDefault2(require_ruleSets());
    var _declarations = _interopRequireDefault2(require_declarations());
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Style = /* @__PURE__ */ function() {
      function Style2(declarations, ruleSets, medias) {
        _classCallCheck(this, Style2);
        this.declarations = declarations;
        this.ruleSets = ruleSets;
        this.medias = medias;
      }
      _createClass(Style2, [
        {
          key: "getDeclarations",
          value: function getDeclarations() {
            return this.declarations;
          }
        },
        {
          key: "getRuleSets",
          value: function getRuleSets() {
            return this.ruleSets;
          }
        },
        {
          key: "getMedias",
          value: function getMedias() {
            return this.medias;
          }
        },
        {
          key: "extends",
          value: function _extends(superStyle) {
            var declarations = superStyle.getDeclarations(), ruleSets = superStyle.getRuleSets(), medias = superStyle.getMedias();
            this.unshift(declarations, ruleSets, medias);
          }
        },
        {
          key: "unshift",
          value: function unshift(declarations, ruleSets, medias) {
            this.declarations.unshift(declarations);
            this.ruleSets.unshift(ruleSets);
            this.medias.unshift(medias);
          }
        },
        {
          key: "asCSS",
          value: function asCSS(className) {
            var declarationsCSS = this.declarations.asCSS(className, "  "), ruleSetsCSS = this.ruleSets.asCSS(className, ""), mediasCSS = this.medias.asCSS(className), css = "".concat(declarationsCSS).concat(ruleSetsCSS).concat(mediasCSS);
            return css;
          }
        }
      ], [
        {
          key: "fromNodeAndTokens",
          value: function fromNodeAndTokens(node, tokens) {
            var declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), medias = _medias.default.fromNodeAndTokens(node, tokens), style = new Style2(declarations, ruleSets, medias);
            return style;
          }
        }
      ]);
      return Style2;
    }();
    exports.default = Style;
  });

  // node_modules/with-style/lib/utilities/styles.js
  var require_styles = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _style = _interopRequireDefault2(require_style());
    var _lexer = _interopRequireDefault2(require_lexer4());
    var _parser = _interopRequireDefault2(require_parser5());
    var _constants = require_constants5();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var cssLexer = _lexer.default.fromNothing();
    var cssParser = _parser.default.fromNothing();
    if (!globalThis.styleMap) {
      globalThis.styleMap = {};
    }
    var styleMap = globalThis.styleMap;
    function renderStyle(style) {
      var headDOMElement = document.querySelector(_constants.HEAD), styleDOMElement = document.createElement(_constants.STYLE), innerHTML = "\n        \n".concat(style);
      Object.assign(styleDOMElement, {
        innerHTML
      });
      headDOMElement.appendChild(styleDOMElement);
    }
    function renderStyles2() {
      var stylesCSS = retrieveStylesCSS(), style = stylesCSS;
      renderStyle(style);
    }
    function generateStyle(args, className) {
      var superStyle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var strings = args.shift(), content1 = strings.reduce(function(content, string, index) {
        var arg = args[index];
        content = arg !== void 0 ? "".concat(content).concat(string).concat(arg) : "".concat(content).concat(string);
        return content;
      }, _constants.EMPTY_STRING), tokens = cssLexer.tokenise(content1), node = cssParser.parse(tokens), style = _style.default.fromNodeAndTokens(node, tokens);
      if (superStyle !== null) {
        style.extends(superStyle);
      }
      styleMap[className] = style;
    }
    function retrieveStyle(className) {
      var style = styleMap[className] || null;
      return style;
    }
    var _default = {
      renderStyle,
      renderStyles: renderStyles2,
      generateStyle,
      retrieveStyle
    };
    exports.default = _default;
    function retrieveStylesCSS() {
      var classNames = Object.keys(styleMap), stylesCSS1 = classNames.reduce(function(stylesCSS, className) {
        var style = retrieveStyle(className), styleCSS = style.asCSS(className);
        stylesCSS += styleCSS;
        return stylesCSS;
      }, _constants.EMPTY_STRING);
      return stylesCSS1;
    }
  });

  // node_modules/with-style/lib/utilities/className.js
  var require_className = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.generateClassName = generateClassName;
    exports.retrieveClassName = retrieveClassName;
    exports.default = void 0;
    var _constants = require_constants5();
    var length = _constants.CLASS_NAME_LENGTH;
    var characters = _constants.CHARACTERS;
    var charactersLength = characters.length;
    var classNames = [];
    function generateClassName() {
      var className = _constants.EMPTY_STRING;
      for (var count = 0; count < length; count++) {
        var index = Math.floor(Math.random() * charactersLength), character = characters[index];
        className += character;
      }
      var classNamesIncludesClassName = classNames.includes(className);
      if (!classNamesIncludesClassName) {
        classNames.push(className);
      } else {
        className = generateClassName();
      }
      return className;
    }
    function retrieveClassName(element) {
      var className = (element.reactFunction || element.reactComponent.constructor).className;
      return className;
    }
    var _default = {
      generateClassName,
      retrieveClassName
    };
    exports.default = _default;
  });

  // node_modules/with-style/lib/index.js
  var require_lib6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "tagNames", {
      enumerable: true,
      get: function() {
        return _tagNames.default;
      }
    });
    Object.defineProperty(exports, "CSSLexer", {
      enumerable: true,
      get: function() {
        return _lexer.default;
      }
    });
    Object.defineProperty(exports, "CSSParser", {
      enumerable: true,
      get: function() {
        return _parser.default;
      }
    });
    Object.defineProperty(exports, "stylesUtilities", {
      enumerable: true,
      get: function() {
        return _styles.default;
      }
    });
    Object.defineProperty(exports, "classNameUtilities", {
      enumerable: true,
      get: function() {
        return _className.default;
      }
    });
    var _tagNames = _interopRequireDefault2(require_tagNames());
    var _lexer = _interopRequireDefault2(require_lexer4());
    var _parser = _interopRequireDefault2(require_parser5());
    var _styles = _interopRequireDefault2(require_styles());
    var _className = _interopRequireDefault2(require_className());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-with-style/lib/utilities/class.js
  var require_class = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isClass = isClass;
    var _easy2 = require_lib();
    function isClass(argument) {
      return isSubclassOf(argument, _easy2.Element);
    }
    function isSubclassOf(argument, Class) {
      var subclass = false;
      if (argument.name === Class.name) {
        subclass = true;
      } else {
        argument = Object.getPrototypeOf(argument);
        if (argument !== null) {
          subclass = isSubclassOf(argument, Class);
        }
      }
      return subclass;
    }
  });

  // node_modules/easy-with-style/lib/constants.js
  var require_constants6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CLASS_NAME = void 0;
    var CLASS_NAME = "className";
    exports.CLASS_NAME = CLASS_NAME;
  });

  // node_modules/easy-with-style/lib/withStyle.js
  var require_withStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easy2 = require_lib();
    var _withStyle = require_lib6();
    var _class = require_class();
    var _constants = require_constants6();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var generateClassName = _withStyle.classNameUtilities.generateClassName;
    var renderStyle = _withStyle.stylesUtilities.renderStyle;
    var renderStyles2 = _withStyle.stylesUtilities.renderStyles;
    var generateStyle = _withStyle.stylesUtilities.generateStyle;
    var retrieveStyle = _withStyle.stylesUtilities.retrieveStyle;
    function withStyle(ClassOrFunction) {
      return function() {
        var args = Array.prototype.slice.call(arguments);
        var _className = ClassOrFunction.className, className = _className === void 0 ? null : _className;
        var superStyle = retrieveStyle(className);
        className = generateClassName();
        generateStyle(args, className, superStyle);
        var ClassOrFunctionClass = (0, _class).isClass(ClassOrFunction);
        if (ClassOrFunctionClass) {
          var Class1 = ClassOrFunction;
          ClassOrFunction = /* @__PURE__ */ function(Class) {
            _inherits(_class1, Class);
            var _super = _createSuper(_class1);
            function _class1() {
              _classCallCheck(this, _class1);
              return _super.apply(this, arguments);
            }
            _createClass(_class1, null, [
              {
                key: "fromClass",
                value: function fromClass(_Class, properties) {
                  for (var _len = arguments.length, remainingArguments = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    remainingArguments[_key - 2] = arguments[_key];
                  }
                  var _$_Class;
                  properties = appendClassNameToProperties(className, properties);
                  return (_$_Class = Class1).fromClass.apply(_$_Class, [
                    _Class,
                    properties
                  ].concat(_toConsumableArray(remainingArguments)));
                }
              }
            ]);
            return _class1;
          }(Class1);
        } else {
          var Function2 = ClassOrFunction;
          ClassOrFunction = function(properties) {
            properties = appendClassNameToProperties(className, properties);
            return Function2(properties);
          };
        }
        Object.assign(ClassOrFunction, {
          className
        });
        return ClassOrFunction;
      };
    }
    Object.assign(withStyle, {
      renderStyle,
      renderStyles: renderStyles2
    });
    var _default = withStyle;
    exports.default = _default;
    _withStyle.tagNames.forEach(function(tagName) {
      Object.defineProperty(withStyle, tagName, {
        get: function() {
          return function() {
            var args = Array.prototype.slice.call(arguments), className = generateClassName();
            generateStyle(args, className);
            var Function2 = function(properties) {
              properties = appendClassNameToProperties(className, properties);
              return _easy2.React.createElement(tagName, properties);
            };
            Object.assign(Function2, {
              className
            });
            return Function2;
          };
        }
      });
    });
    function appendClassNameToProperties(className, properties) {
      properties = properties.hasOwnProperty(_constants.CLASS_NAME) ? properties : _objectSpread({}, properties, {
        className
      });
      return properties;
    }
  });

  // node_modules/easy-with-style/lib/index.js
  var require_lib7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _withStyle = _interopRequireDefault2(require_withStyle());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = _withStyle.default;
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/options.js
  var require_options = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ESCAPE_KEY_STOPS_DRAGGING_OPTION = void 0;
    var ESCAPE_KEY_STOPS_DRAGGING_OPTION = "ESCAPE_KEY_STOPS_DRAGGING";
    exports.ESCAPE_KEY_STOPS_DRAGGING_OPTION = ESCAPE_KEY_STOPS_DRAGGING_OPTION;
    var _default = {
      ESCAPE_KEY_STOPS_DRAGGING_OPTION
    };
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/row.js
  var require_row = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  display: flex;\n  flex-grow: 1;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var RowDiv = /* @__PURE__ */ function(Element) {
      _inherits(RowDiv2, Element);
      var _super = _createSuper(RowDiv2);
      function RowDiv2() {
        _classCallCheck(this, RowDiv2);
        return _super.apply(this, arguments);
      }
      return RowDiv2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(RowDiv, "tagName", "div");
    _defineProperty(RowDiv, "defaultProperties", {
      className: "row"
    });
    var _default = (0, _easyWithStyle2).default(RowDiv)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/rows.js
  var require_rows = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  display: flex;\n  flex-grow: 1;\n  flex-direction: column;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var RowsDiv = /* @__PURE__ */ function(Element) {
      _inherits(RowsDiv2, Element);
      var _super = _createSuper(RowsDiv2);
      function RowsDiv2() {
        _classCallCheck(this, RowsDiv2);
        return _super.apply(this, arguments);
      }
      return RowsDiv2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(RowsDiv, "tagName", "div");
    _defineProperty(RowsDiv, "defaultProperties", {
      className: "rows"
    });
    var _default = (0, _easyWithStyle2).default(RowsDiv)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/column.js
  var require_column = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  display: flex;\n  flex-grow: 1;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var ColumnDiv = /* @__PURE__ */ function(Element) {
      _inherits(ColumnDiv2, Element);
      var _super = _createSuper(ColumnDiv2);
      function ColumnDiv2() {
        _classCallCheck(this, ColumnDiv2);
        return _super.apply(this, arguments);
      }
      return ColumnDiv2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(ColumnDiv, "tagName", "div");
    _defineProperty(ColumnDiv, "defaultProperties", {
      className: "column"
    });
    var _default = (0, _easyWithStyle2).default(ColumnDiv)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/columns.js
  var require_columns = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  display: flex;\n  flex-grow: 1;\n  flex-direction: row;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var ColumnsDiv = /* @__PURE__ */ function(Element) {
      _inherits(ColumnsDiv2, Element);
      var _super = _createSuper(ColumnsDiv2);
      function ColumnsDiv2() {
        _classCallCheck(this, ColumnsDiv2);
        return _super.apply(this, arguments);
      }
      return ColumnsDiv2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(ColumnsDiv, "tagName", "div");
    _defineProperty(ColumnsDiv, "defaultProperties", {
      className: "columns"
    });
    var _default = (0, _easyWithStyle2).default(ColumnsDiv)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/sizeable.js
  var require_sizeable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  display: flex;\n  \n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var SizeableDiv = /* @__PURE__ */ function(Element) {
      _inherits(SizeableDiv2, Element);
      var _super = _createSuper(SizeableDiv2);
      function SizeableDiv2() {
        _classCallCheck(this, SizeableDiv2);
        return _super.apply(this, arguments);
      }
      return SizeableDiv2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(SizeableDiv, "tagName", "div");
    _defineProperty(SizeableDiv, "defaultProperties", {
      className: "sizeable"
    });
    var _default = (0, _easyWithStyle2).default(SizeableDiv)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/constants.js
  var require_constants7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ESCAPE_KEY_CODE = exports.ROW_RESIZE = exports.COL_RESIZE = exports.CURSOR = exports.AUTO = void 0;
    var AUTO = "auto";
    exports.AUTO = AUTO;
    var CURSOR = "cursor";
    exports.CURSOR = CURSOR;
    var COL_RESIZE = "col-resize";
    exports.COL_RESIZE = COL_RESIZE;
    var ROW_RESIZE = "row-resize";
    exports.ROW_RESIZE = ROW_RESIZE;
    var ESCAPE_KEY_CODE = 27;
    exports.ESCAPE_KEY_CODE = ESCAPE_KEY_CODE;
  });

  // node_modules/easy-layout/lib/cursor.js
  var require_cursor = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.columnResizeCursor = columnResizeCursor;
    exports.rowResizeCursor = rowResizeCursor;
    exports.resetCursor = resetCursor;
    var _easy2 = require_lib();
    var _constants = require_constants7();
    var body2 = new _easy2.Body();
    var previousCursor;
    function columnResizeCursor() {
      var currentCursor = getCurrentCursor();
      if (currentCursor !== _constants.COL_RESIZE) {
        previousCursor = currentCursor;
        setCursor(_constants.COL_RESIZE);
      }
    }
    function rowResizeCursor() {
      var currentCursor = getCurrentCursor();
      if (currentCursor !== _constants.ROW_RESIZE) {
        previousCursor = currentCursor;
        setCursor(_constants.ROW_RESIZE);
      }
    }
    function resetCursor() {
      setCursor(previousCursor);
    }
    function setCursor(cursor) {
      var css = {
        cursor
      };
      body2.css(css);
    }
    function getCurrentCursor() {
      var currentCursor = body2.css(_constants.CURSOR) || _constants.AUTO;
      return currentCursor;
    }
  });

  // node_modules/easy-layout/lib/div/splitter.js
  var require_splitter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    var _sizeable = _interopRequireDefault2(require_sizeable());
    var _cursor = require_cursor();
    var _constants = require_constants7();
    var _options = require_options();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  flex-shrink: 0;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var BLUR_EVENT_TYPE = _easy2.eventTypes.BLUR_EVENT_TYPE;
    var DRAG_EVENT_TYPE = _easy2.eventTypes.DRAG_EVENT_TYPE;
    var MOUSEUP_EVENT_TYPE = _easy2.eventTypes.MOUSEUP_EVENT_TYPE;
    var STOP_DRAG_EVENT_TYPE = _easy2.eventTypes.STOP_DRAG_EVENT_TYPE;
    var START_DRAG_EVENT_TYPE = _easy2.eventTypes.START_DRAG_EVENT_TYPE;
    var SplitterDiv = /* @__PURE__ */ function(Element) {
      _inherits(SplitterDiv2, Element);
      var _super = _createSuper(SplitterDiv2);
      function SplitterDiv2(selector, options) {
        _classCallCheck(this, SplitterDiv2);
        var _this;
        _this = _super.call(this, selector);
        _this.options = options;
        return _this;
      }
      _createClass(SplitterDiv2, [
        {
          key: "isOptionPresent",
          value: function isOptionPresent(option) {
            var optionPresent = !!this.options[option];
            return optionPresent;
          }
        },
        {
          key: "setOptions",
          value: function setOptions(options) {
            this.options = options;
          }
        },
        {
          key: "setOption",
          value: function setOption(option) {
            this.options[option] = true;
          }
        },
        {
          key: "unsetOption",
          value: function unsetOption(option) {
            delete this.options[option];
          }
        },
        {
          key: "onDrag",
          value: function onDrag(dragHandler, element) {
            var eventType = DRAG_EVENT_TYPE, handler = dragHandler;
            this.addEventListener(eventType, handler, element);
          }
        },
        {
          key: "offDrag",
          value: function offDrag(dragHandler, element) {
            var eventType = DRAG_EVENT_TYPE, handler = dragHandler;
            this.removeEventListener(eventType, handler, element);
          }
        },
        {
          key: "onStopDrag",
          value: function onStopDrag(stopDragHandler, element) {
            var eventType = STOP_DRAG_EVENT_TYPE, handler = stopDragHandler;
            this.addEventListener(eventType, handler, element);
          }
        },
        {
          key: "offStopDrag",
          value: function offStopDrag(stopDragHandler, element) {
            var eventType = STOP_DRAG_EVENT_TYPE, handler = stopDragHandler;
            this.removeEventListener(eventType, handler, element);
          }
        },
        {
          key: "onStartDrag",
          value: function onStartDrag(stopDragHandler, element) {
            var eventType = START_DRAG_EVENT_TYPE, handler = stopDragHandler;
            this.addEventListener(eventType, handler, element);
          }
        },
        {
          key: "offStartDrag",
          value: function offStartDrag(stopDragHandler, element) {
            var eventType = START_DRAG_EVENT_TYPE, handler = stopDragHandler;
            this.removeEventListener(eventType, handler, element);
          }
        },
        {
          key: "callHandlers",
          value: function callHandlers(eventType) {
            for (var _len = arguments.length, remainingArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              remainingArguments[_key - 1] = arguments[_key];
            }
            var _this = this;
            var eventListeners = this.findEventListeners(eventType);
            eventListeners.forEach(function(eventListener) {
              var _handler;
              var handler = eventListener.handler, handlerElement = eventListener.element, element = _this;
              (_handler = handler).call.apply(_handler, [
                handlerElement
              ].concat(_toConsumableArray(remainingArguments), [
                element
              ]));
            });
          }
        },
        {
          key: "enable",
          value: function enable() {
            this.removeClass("disabled");
          }
        },
        {
          key: "disable",
          value: function disable() {
            this.addClass("disabled");
          }
        },
        {
          key: "isDisabled",
          value: function isDisabled() {
            var disabled = this.hasClass("disabled");
            return disabled;
          }
        },
        {
          key: "isDragging",
          value: function isDragging() {
            var dragging = this.hasClass("dragging");
            return dragging;
          }
        },
        {
          key: "getDirection",
          value: function getDirection() {
            var direction;
            var nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement();
            if (_instanceof(nextSiblingElement, _sizeable.default)) {
              direction = 1;
            }
            if (_instanceof(previousSiblingElement, _sizeable.default)) {
              direction = -1;
            }
            return direction;
          }
        },
        {
          key: "getSizeableDiv",
          value: function getSizeableDiv() {
            var sizeableDiv;
            var nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement();
            if (_instanceof(nextSiblingElement, _sizeable.default)) {
              sizeableDiv = nextSiblingElement;
            }
            if (_instanceof(previousSiblingElement, _sizeable.default)) {
              sizeableDiv = previousSiblingElement;
            }
            return sizeableDiv;
          }
        },
        {
          key: "startDrag",
          value: function startDrag() {
            var eventType = START_DRAG_EVENT_TYPE, escapeKeyStopsDraggingOptionPresent = this.isOptionPresent(_options.ESCAPE_KEY_STOPS_DRAGGING_OPTION);
            if (escapeKeyStopsDraggingOptionPresent) {
              _easy2.window.onKeyDown(this.keyDownHandler, this);
            }
            this.addClass("dragging");
            this.callHandlers(eventType);
          }
        },
        {
          key: "stopDrag",
          value: function stopDrag() {
            var eventType = STOP_DRAG_EVENT_TYPE, escapeKeyStopsDraggingOptionPresent = this.isOptionPresent(_options.ESCAPE_KEY_STOPS_DRAGGING_OPTION);
            if (escapeKeyStopsDraggingOptionPresent) {
              _easy2.window.offKeyDown(this.keyDownHandler, this);
            }
            this.removeClass("dragging");
            this.callHandlers(eventType);
          }
        },
        {
          key: "mouseUpHandler",
          value: function mouseUpHandler(event, element) {
            var disabled = this.isDisabled();
            if (!disabled) {
              var dragging = this.isDragging();
              if (dragging) {
                this.stopDrag();
              }
              (0, _cursor).resetCursor();
            }
          }
        },
        {
          key: "mouseOutHandler",
          value: function mouseOutHandler(event, element) {
            var disabled = this.isDisabled();
            if (!disabled) {
              var dragging = this.isDragging();
              if (!dragging) {
                (0, _cursor).resetCursor();
              }
            }
          }
        },
        {
          key: "keyDownHandler",
          value: function keyDownHandler(event, element) {
            var keyCode = event.keyCode;
            if (keyCode === _constants.ESCAPE_KEY_CODE) {
              var dragging = this.isDragging();
              if (dragging) {
                this.stopDrag();
              }
              (0, _cursor).resetCursor();
            }
          }
        },
        {
          key: "didMount",
          value: function didMount() {
            var _properties = this.properties, onDrag = _properties.onDrag, onStopDrag = _properties.onStopDrag, onStartDrag = _properties.onStartDrag, disabled = _properties.disabled, dragHandler = onDrag, stopDragHandler = onStopDrag, startDragHandler = onStartDrag;
            disabled === true ? this.disable() : this.enable();
            dragHandler && this.onDrag(dragHandler);
            stopDragHandler && this.onStopDrag(stopDragHandler);
            startDragHandler && this.onStartDrag(startDragHandler);
            _easy2.window.on("".concat(BLUR_EVENT_TYPE, " ").concat(MOUSEUP_EVENT_TYPE), this.mouseUpHandler, this);
            _easy2.window.onMouseMove(this.mouseMoveHandler, this);
            this.onMouseDown(this.mouseDownHandler, this);
            this.onMouseOver(this.mouseOverHandler, this);
            this.onMouseOut(this.mouseOutHandler, this);
          }
        },
        {
          key: "willUnmount",
          value: function willUnmount() {
            var _properties = this.properties, onDrag = _properties.onDrag, onStopDrag = _properties.onStopDrag, onStartDrag = _properties.onStartDrag, dragHandler = onDrag, stopDragHandler = onStopDrag, startDragHandler = onStartDrag;
            dragHandler && this.offDrag(dragHandler);
            stopDragHandler && this.offStopDrag(stopDragHandler);
            startDragHandler && this.offStartDrag(startDragHandler);
            _easy2.window.off("".concat(BLUR_EVENT_TYPE, " ").concat(MOUSEUP_EVENT_TYPE), this.mouseUpHandler, this);
            _easy2.window.offMouseMove(this.mouseMoveHandler, this);
            this.offMouseDown(this.mouseDownHandler, this);
            this.offMouseOver(this.mouseOverHandler, this);
            this.offMouseOut(this.mouseOutHandler, this);
          }
        },
        {
          key: "initialise",
          value: function initialise() {
            this.setInitialState();
          }
        }
      ], [
        {
          key: "fromClass",
          value: function fromClass(Class, properties) {
            var _options1 = properties.options, options = _options1 === void 0 ? {} : _options1, splitterDiv = _easy2.Element.fromClass(Class, properties, options);
            return splitterDiv;
          }
        }
      ]);
      return SplitterDiv2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(SplitterDiv, "tagName", "div");
    _defineProperty(SplitterDiv, "defaultProperties", {
      className: "splitter"
    });
    _defineProperty(SplitterDiv, "ignoredProperties", [
      "onDrag",
      "options",
      "disabled",
      "onStopDrag",
      "onStartDrag"
    ]);
    var _default = (0, _easyWithStyle2).default(SplitterDiv)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/splitter/vertical.js
  var require_vertical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    var _splitter = _interopRequireDefault2(require_splitter());
    var _cursor = require_cursor();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  width: 1rem;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var DRAG_EVENT_TYPE = _easy2.eventTypes.DRAG_EVENT_TYPE;
    var VerticalSplitter = /* @__PURE__ */ function(Splitter) {
      _inherits(VerticalSplitter2, Splitter);
      var _super = _createSuper(VerticalSplitter2);
      function VerticalSplitter2() {
        _classCallCheck(this, VerticalSplitter2);
        return _super.apply(this, arguments);
      }
      _createClass(VerticalSplitter2, [
        {
          key: "mouseOverHandler",
          value: function mouseOverHandler(event, element) {
            var disabled = this.isDisabled();
            if (!disabled) {
              (0, _cursor).columnResizeCursor();
            }
          }
        },
        {
          key: "mouseMoveHandler",
          value: function mouseMoveHandler(event, element) {
            var pageX = event.pageX, mouseLeft = pageX, disabled = this.isDisabled();
            if (!disabled) {
              var dragging = this.isDragging();
              if (dragging) {
                var direction = this.getDirection(), sizeableDiv = this.getSizeableDiv();
                var previousMouseLeft = this.getPreviousMouseLeft(), previousSizeableDivWidth = this.getPreviousSizeableDivWidth(), relativeMouseLeft = mouseLeft - previousMouseLeft;
                var sizeableDivWidth = previousSizeableDivWidth - direction * relativeMouseLeft;
                var width = sizeableDivWidth, eventType = DRAG_EVENT_TYPE;
                sizeableDiv.setWidth(width);
                sizeableDivWidth = sizeableDiv.getWidth();
                this.callHandlers(eventType, sizeableDivWidth);
              }
            }
          }
        },
        {
          key: "mouseDownHandler",
          value: function mouseDownHandler(event, element) {
            var pageX = event.pageX, mouseLeft = pageX, disabled = this.isDisabled();
            if (!disabled) {
              var dragging = this.isDragging(), sizeableDiv = this.getSizeableDiv(), previousMouseLeft = mouseLeft, sizeableDivWidth = sizeableDiv.getWidth(), previousSizeableDivWidth = sizeableDivWidth;
              this.setPreviousMouseLeft(previousMouseLeft);
              this.setPreviousSizeableDivWidth(previousSizeableDivWidth);
              (0, _cursor).columnResizeCursor();
              if (!dragging) {
                this.startDrag();
              }
            }
          }
        },
        {
          key: "getPreviousMouseLeft",
          value: function getPreviousMouseLeft() {
            var state = this.getState(), previousMouseLeft = state.previousMouseLeft;
            return previousMouseLeft;
          }
        },
        {
          key: "getPreviousSizeableDivWidth",
          value: function getPreviousSizeableDivWidth() {
            var state = this.getState(), previousSizeableDivWidth = state.previousSizeableDivWidth;
            return previousSizeableDivWidth;
          }
        },
        {
          key: "setPreviousMouseLeft",
          value: function setPreviousMouseLeft(previousMouseLeft) {
            this.updateState({
              previousMouseLeft
            });
          }
        },
        {
          key: "setPreviousSizeableDivWidth",
          value: function setPreviousSizeableDivWidth(previousSizeableDivWidth) {
            this.updateState({
              previousSizeableDivWidth
            });
          }
        },
        {
          key: "setInitialState",
          value: function setInitialState() {
            var previousMouseLeft = null, previousSizeableDivWidth = null;
            this.setState({
              previousMouseLeft,
              previousSizeableDivWidth
            });
          }
        }
      ]);
      return VerticalSplitter2;
    }(_splitter.default);
    _defineProperty(VerticalSplitter, "defaultProperties", {
      className: "vertical"
    });
    var _default = (0, _easyWithStyle2).default(VerticalSplitter)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/div/splitter/horizontal.js
  var require_horizontal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    var _splitter = _interopRequireDefault2(require_splitter());
    var _cursor = require_cursor();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  height: 1rem;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var DRAG_EVENT_TYPE = _easy2.eventTypes.DRAG_EVENT_TYPE;
    var HorizontalSplitter = /* @__PURE__ */ function(Splitter) {
      _inherits(HorizontalSplitter2, Splitter);
      var _super = _createSuper(HorizontalSplitter2);
      function HorizontalSplitter2() {
        _classCallCheck(this, HorizontalSplitter2);
        return _super.apply(this, arguments);
      }
      _createClass(HorizontalSplitter2, [
        {
          key: "mouseOverHandler",
          value: function mouseOverHandler(event, element) {
            var disabled = this.isDisabled();
            if (!disabled) {
              (0, _cursor).rowResizeCursor();
            }
          }
        },
        {
          key: "mouseMoveHandler",
          value: function mouseMoveHandler(event, element) {
            var pageY = event.pageY, mouseTop = pageY, disabled = this.isDisabled();
            if (!disabled) {
              var dragging = this.isDragging();
              if (dragging) {
                var direction = this.getDirection(), sizeableDiv = this.getSizeableDiv();
                var previousMouseTop = this.getPreviousMouseTop(), previousSizeableDivHeight = this.getPreviousSizeableDivHeight(), relativeMouseTop = mouseTop - previousMouseTop;
                var sizeableDivHeight = previousSizeableDivHeight - direction * relativeMouseTop;
                var height = sizeableDivHeight, eventType = DRAG_EVENT_TYPE;
                sizeableDiv.setHeight(height);
                sizeableDivHeight = sizeableDiv.getHeight();
                this.callHandlers(eventType, sizeableDivHeight);
              }
            }
          }
        },
        {
          key: "mouseDownHandler",
          value: function mouseDownHandler(event, element) {
            var pageY = event.pageY, mouseTop = pageY, disabled = this.isDisabled();
            if (!disabled) {
              var dragging = this.isDragging(), sizeableDiv = this.getSizeableDiv(), previousMouseTop = mouseTop, sizeableDivHeight = sizeableDiv.getHeight(), previousSizeableDivHeight = sizeableDivHeight;
              this.setPreviousMouseTop(previousMouseTop);
              this.setPreviousSizeableDivHeight(previousSizeableDivHeight);
              (0, _cursor).rowResizeCursor();
              if (!dragging) {
                this.startDrag();
              }
            }
          }
        },
        {
          key: "getPreviousMouseTop",
          value: function getPreviousMouseTop() {
            var state = this.getState(), previousMouseTop = state.previousMouseTop;
            return previousMouseTop;
          }
        },
        {
          key: "getPreviousSizeableDivHeight",
          value: function getPreviousSizeableDivHeight() {
            var state = this.getState(), previousSizeableDivHeight = state.previousSizeableDivHeight;
            return previousSizeableDivHeight;
          }
        },
        {
          key: "setPreviousMouseTop",
          value: function setPreviousMouseTop(previousMouseTop) {
            this.updateState({
              previousMouseTop
            });
          }
        },
        {
          key: "setPreviousSizeableDivHeight",
          value: function setPreviousSizeableDivHeight(previousSizeableDivHeight) {
            this.updateState({
              previousSizeableDivHeight
            });
          }
        },
        {
          key: "setInitialState",
          value: function setInitialState() {
            var previousMouseTop = null, previousSizeableDivHeight = null;
            this.setState({
              previousMouseTop,
              previousSizeableDivHeight
            });
          }
        }
      ]);
      return HorizontalSplitter2;
    }(_splitter.default);
    _defineProperty(HorizontalSplitter, "defaultProperties", {
      className: "horizontal"
    });
    var _default = (0, _easyWithStyle2).default(HorizontalSplitter)(_templateObject());
    exports.default = _default;
  });

  // node_modules/easy-layout/lib/index.js
  var require_lib8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "options", {
      enumerable: true,
      get: function() {
        return _options.default;
      }
    });
    Object.defineProperty(exports, "RowDiv", {
      enumerable: true,
      get: function() {
        return _row.default;
      }
    });
    Object.defineProperty(exports, "RowsDiv", {
      enumerable: true,
      get: function() {
        return _rows.default;
      }
    });
    Object.defineProperty(exports, "ColumnDiv", {
      enumerable: true,
      get: function() {
        return _column.default;
      }
    });
    Object.defineProperty(exports, "ColumnsDiv", {
      enumerable: true,
      get: function() {
        return _columns.default;
      }
    });
    Object.defineProperty(exports, "SplitterDiv", {
      enumerable: true,
      get: function() {
        return _splitter.default;
      }
    });
    Object.defineProperty(exports, "SizeableDiv", {
      enumerable: true,
      get: function() {
        return _sizeable.default;
      }
    });
    Object.defineProperty(exports, "VerticalSplitterDiv", {
      enumerable: true,
      get: function() {
        return _vertical.default;
      }
    });
    Object.defineProperty(exports, "HorizontalSplitterDiv", {
      enumerable: true,
      get: function() {
        return _horizontal.default;
      }
    });
    var _options = _interopRequireDefault2(require_options());
    var _row = _interopRequireDefault2(require_row());
    var _rows = _interopRequireDefault2(require_rows());
    var _column = _interopRequireDefault2(require_column());
    var _columns = _interopRequireDefault2(require_columns());
    var _splitter = _interopRequireDefault2(require_splitter());
    var _sizeable = _interopRequireDefault2(require_sizeable());
    var _vertical = _interopRequireDefault2(require_vertical());
    var _horizontal = _interopRequireDefault2(require_horizontal());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/utilities/class.js
  var require_class2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isInstanceOf = isInstanceOf;
    function isInstanceOf(instance, Class) {
      var constructor = instance.constructor;
      if (constructor) {
        if (constructor.name === Class.name) {
          return true;
        } else {
          var prototype = Object.getPrototypeOf(constructor);
          return isPrototypeInstanceOf(prototype, Class);
        }
      }
      return false;
    }
    function isPrototypeInstanceOf(prototype, Class) {
      if (prototype) {
        if (prototype.name === Class.name) {
          return true;
        } else {
          prototype = Object.getPrototypeOf(prototype);
          return isPrototypeInstanceOf(prototype, Class);
        }
      }
      return false;
    }
  });

  // lib/utilities/ruleName.js
  var require_ruleName7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reducedRuleNameFromRuleName = reducedRuleNameFromRuleName;
    exports.repeatedRuleNameFromRuleName = repeatedRuleNameFromRuleName;
    exports.ruleNameFromReducedRuleName = ruleNameFromReducedRuleName;
    exports.checkReducedRuleNameMatchesRuleName = checkReducedRuleNameMatchesRuleName;
    function reducedRuleNameFromRuleName(ruleName) {
      var reducedRuleName = "".concat(ruleName, "_");
      return reducedRuleName;
    }
    function repeatedRuleNameFromRuleName(ruleName) {
      var repeatedRuleName = "".concat(ruleName, "~");
      return repeatedRuleName;
    }
    function ruleNameFromReducedRuleName(reducedRuleName) {
      var ruleName = reducedRuleName.replace(/_$/, "");
      return ruleName;
    }
    function checkReducedRuleNameMatchesRuleName(reducedRuleName, ruleName) {
      var ruleNameA = ruleName;
      ruleName = ruleNameFromReducedRuleName(reducedRuleName);
      var ruleNameB = ruleName;
      var reducedRuleNameMatchesRuleName = ruleNameA === ruleNameB;
      return reducedRuleNameMatchesRuleName;
    }
  });

  // lib/utilities/rule.js
  var require_rule6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reducedRuleFromRule = reducedRuleFromRule;
    exports.repeatedRuleFromRule = repeatedRuleFromRule;
    exports.rewrittenRuleFromRule = rewrittenRuleFromRule;
    var _class = require_class2();
    var _ruleName = require_ruleName7();
    function reducedRuleFromRule(rule, ruleMap, ReducedRule) {
      var ruleName = rule.getName(), reducedRuleName = (0, _ruleName).reducedRuleNameFromRuleName(ruleName);
      var reducedRule = ruleMap[reducedRuleName] || null;
      if (reducedRule === null) {
        reducedRule = ReducedRule.fromRule(rule);
        ruleMap[reducedRuleName] = reducedRule;
      }
      return reducedRule;
    }
    function repeatedRuleFromRule(rule, ruleMap, RepeatedRule) {
      var ruleName = rule.getName(), repeatedRuleName = (0, _ruleName).repeatedRuleNameFromRuleName(ruleName);
      var repeatedRule = ruleMap[repeatedRuleName] || null;
      if (repeatedRule === null) {
        repeatedRule = RepeatedRule.fromRule(rule);
        ruleMap[repeatedRuleName] = repeatedRule;
      }
      return repeatedRule;
    }
    function rewrittenRuleFromRule(rule, ruleMap, RewrittenRule) {
      var rewrittenRule;
      var ruleRewrittenRule = (0, _class).isInstanceOf(rule, RewrittenRule);
      if (ruleRewrittenRule) {
        rewrittenRule = rule;
      } else {
        rewrittenRule = RewrittenRule.fromRule(rule);
        var replacedRule = rule, replacementRule = rewrittenRule;
        replaceRule(replacedRule, replacementRule, ruleMap);
      }
      return rewrittenRule;
    }
    function replaceRule(replacedRule, replacementRule, ruleMap) {
      var replacedRuleName = replacedRule.getName(), replacementRuleName = replacementRule.getName();
      delete ruleMap[replacedRuleName];
      ruleMap[replacementRuleName] = replacementRule;
    }
  });

  // lib/types.js
  var require_types2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.IMPLICITLY_LEFT_RECURSIVE_TYPE = exports.INDIRECTLY_LEFT_RECURSIVE_TYPE = exports.DIRECTLY_LEFT_RECURSIVE_TYPE = exports.LEFT_RECURSIVE_TYPE = exports.RECURSIVE_TYPE = void 0;
    var RECURSIVE_TYPE = "RECURSIVE_TYPE";
    exports.RECURSIVE_TYPE = RECURSIVE_TYPE;
    var LEFT_RECURSIVE_TYPE = "LEFT_RECURSIVE_TYPE";
    exports.LEFT_RECURSIVE_TYPE = LEFT_RECURSIVE_TYPE;
    var DIRECTLY_LEFT_RECURSIVE_TYPE = "DIRECTLY_LEFT_RECURSIVE_TYPE";
    exports.DIRECTLY_LEFT_RECURSIVE_TYPE = DIRECTLY_LEFT_RECURSIVE_TYPE;
    var INDIRECTLY_LEFT_RECURSIVE_TYPE = "INDIRECTLY_LEFT_RECURSIVE_TYPE";
    exports.INDIRECTLY_LEFT_RECURSIVE_TYPE = INDIRECTLY_LEFT_RECURSIVE_TYPE;
    var IMPLICITLY_LEFT_RECURSIVE_TYPE = "IMPLICITLY_LEFT_RECURSIVE_TYPE";
    exports.IMPLICITLY_LEFT_RECURSIVE_TYPE = IMPLICITLY_LEFT_RECURSIVE_TYPE;
  });

  // lib/utilities/recursivePart.js
  var require_recursivePart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.recursiveRuleNamesFromPart = recursiveRuleNamesFromPart;
    exports.leftRecursiveRuleNamesFromPart = leftRecursiveRuleNamesFromPart;
    var _occamParsers = require_lib4();
    var _necessary = require_browser();
    var first = _necessary.arrayUtilities.first;
    var RuleNamePartType = _occamParsers.partTypes.RuleNamePartType;
    var OptionalPartPartType = _occamParsers.partTypes.OptionalPartPartType;
    var SequenceOfPartsPartType = _occamParsers.partTypes.SequenceOfPartsPartType;
    var ChoiceOfPartsPartType = _occamParsers.partTypes.ChoiceOfPartsPartType;
    var OneOrMorePartsPartType = _occamParsers.partTypes.OneOrMorePartsPartType;
    var ZeroOrMorePartsPartType = _occamParsers.partTypes.ZeroOrMorePartsPartType;
    function recursiveRuleNamesFromPart(part1, recursiveRuleNames) {
      var partNonTerminalPart = part1.isNonTerminalPart();
      if (partNonTerminalPart) {
        var type = part1.getType();
        switch (type) {
          case RuleNamePartType:
            {
              var ruleNamePart = part1, ruleName = ruleNamePart.getRuleName(), recursiveRuleNamesIncludesRuleName = recursiveRuleNames.includes(ruleName);
              if (!recursiveRuleNamesIncludesRuleName) {
                var recursiveRuleName = ruleName;
                recursiveRuleNames.push(recursiveRuleName);
              }
            }
            break;
          case OptionalPartPartType:
            {
              var optionalPartPart = part1;
              part1 = optionalPartPart.getPart();
              recursiveRuleNamesFromPart(part1, recursiveRuleNames);
            }
            break;
          case OneOrMorePartsPartType:
            {
              var oneOrMorePartsPart = part1;
              part1 = oneOrMorePartsPart.getPart();
              recursiveRuleNamesFromPart(part1, recursiveRuleNames);
            }
            break;
          case ZeroOrMorePartsPartType:
            {
              var zeroOrMorePartsPart = part1;
              part1 = zeroOrMorePartsPart.getPart();
              recursiveRuleNamesFromPart(part1, recursiveRuleNames);
            }
            break;
          case SequenceOfPartsPartType:
            {
              var sequenceOfPartsPart = part1, parts = sequenceOfPartsPart.getParts();
              parts.forEach(function(part) {
                return recursiveRuleNamesFromPart(part, recursiveRuleNames);
              });
            }
            break;
          case ChoiceOfPartsPartType:
            {
              var choiceOfPartsPart = part1, parts1 = choiceOfPartsPart.getParts();
              parts1.forEach(function(part) {
                return recursiveRuleNamesFromPart(part, recursiveRuleNames);
              });
            }
            break;
        }
      }
    }
    function leftRecursiveRuleNamesFromPart(part2, leftRecursiveRuleNames) {
      var partNonTerminalPart = part2.isNonTerminalPart();
      if (partNonTerminalPart) {
        var type = part2.getType();
        switch (type) {
          case RuleNamePartType:
            {
              var ruleNamePart = part2, ruleName = ruleNamePart.getRuleName(), leftRecursiveRuleNamesIncludesRuleName = leftRecursiveRuleNames.includes(ruleName);
              if (!leftRecursiveRuleNamesIncludesRuleName) {
                var leftRecursiveRuleName = ruleName;
                leftRecursiveRuleNames.push(leftRecursiveRuleName);
              }
            }
            break;
          case OptionalPartPartType:
            {
              var optionalPartPart = part2;
              part2 = optionalPartPart.getPart();
              leftRecursiveRuleNamesFromPart(part2, leftRecursiveRuleNames);
            }
            break;
          case OneOrMorePartsPartType:
            {
              var oneOrMorePartsPart = part2;
              part2 = oneOrMorePartsPart.getPart();
              leftRecursiveRuleNamesFromPart(part2, leftRecursiveRuleNames);
            }
            break;
          case ZeroOrMorePartsPartType:
            {
              var zeroOrMorePartsPart = part2;
              part2 = zeroOrMorePartsPart.getPart();
              leftRecursiveRuleNamesFromPart(part2, leftRecursiveRuleNames);
            }
            break;
          case SequenceOfPartsPartType:
            {
              var sequenceOfPartsPart = part2, parts = sequenceOfPartsPart.getParts(), firstPart = first(parts);
              part2 = firstPart;
              leftRecursiveRuleNamesFromPart(part2, leftRecursiveRuleNames);
            }
            break;
          case ChoiceOfPartsPartType:
            {
              var choiceOfPartsPart = part2, parts2 = choiceOfPartsPart.getParts();
              parts2.forEach(function(part) {
                return leftRecursiveRuleNamesFromPart(part, leftRecursiveRuleNames);
              });
            }
            break;
        }
      }
    }
  });

  // lib/utilities/definition.js
  var require_definition5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDefinitionUnary = isDefinitionUnary;
    exports.isDefinitionComplex = isDefinitionComplex;
    exports.isDefinitionLookAhead = isDefinitionLookAhead;
    exports.recursiveRuleNamesFromDefinition = recursiveRuleNamesFromDefinition;
    exports.leftRecursiveRuleNamesFromDefinition = leftRecursiveRuleNamesFromDefinition;
    var _occamParsers = require_lib4();
    var _necessary = require_browser();
    var _recursivePart = require_recursivePart();
    var first = _necessary.arrayUtilities.first;
    var RuleNamePartType = _occamParsers.partTypes.RuleNamePartType;
    function isDefinitionUnary(definition) {
      var parts = definition.getParts(), partsLength = parts.length, definitionUnary = partsLength === 1;
      return definitionUnary;
    }
    function isDefinitionComplex(definition) {
      var parts = definition.getParts(), firstPart = first(parts), firstPartType = firstPart.getType(), firstPartTypeRuleNamePartType = firstPartType === RuleNamePartType, firstPartRuleNamePart = firstPartTypeRuleNamePartType, definitionComplex = !firstPartRuleNamePart;
      return definitionComplex;
    }
    function isDefinitionLookAhead(definition) {
      var lookAhead = false;
      var parts = definition.getParts(), firstPart = first(parts), firstPartType = firstPart.getType(), firstPartTypeRuleNamePartType = firstPartType === RuleNamePartType, firstPartRuleNamePart = firstPartTypeRuleNamePartType;
      if (firstPartRuleNamePart) {
        var ruleNamePart = firstPart;
        lookAhead = ruleNamePart.isLookAhead();
      }
      return lookAhead;
    }
    function recursiveRuleNamesFromDefinition(definition) {
      var recursiveRuleNames = [], parts = definition.getParts();
      parts.forEach(function(part) {
        (0, _recursivePart).recursiveRuleNamesFromPart(part, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function leftRecursiveRuleNamesFromDefinition(definition) {
      var leftRecursiveRuleNames = [], parts = definition.getParts(), firstPart = first(parts), part = firstPart;
      (0, _recursivePart).leftRecursiveRuleNamesFromPart(part, leftRecursiveRuleNames);
      return leftRecursiveRuleNames;
    }
  });

  // lib/definition/recursive.js
  var require_recursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _rule = require_rule6();
    var _types = require_types2();
    var _definition = require_definition5();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RecursiveDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RecursiveDefinition2, Definition);
      var _super = _createSuper(RecursiveDefinition2);
      function RecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames) {
        _classCallCheck(this, RecursiveDefinition2);
        var _this;
        _this = _super.call(this, parts);
        _this.type = type;
        _this.ruleName = ruleName;
        _this.definition = definition;
        _this.recursiveRuleNames = recursiveRuleNames;
        return _this;
      }
      _createClass(RecursiveDefinition2, [
        {
          key: "getType",
          value: function getType() {
            return this.type;
          }
        },
        {
          key: "getRuleName",
          value: function getRuleName() {
            return this.ruleName;
          }
        },
        {
          key: "getDefinition",
          value: function getDefinition() {
            return this.definition;
          }
        },
        {
          key: "getRecursiveRuleNames",
          value: function getRecursiveRuleNames() {
            return this.recursiveRuleNames;
          }
        },
        {
          key: "replace",
          value: function replace(ruleMap) {
            var rule = ruleMap[this.ruleName] || null, replacedDefinition = this.definition, replacementDefinition = this;
            rule.replaceDefinition(replacedDefinition, replacementDefinition);
          }
        }
      ], [
        {
          key: "fromRuleNameAndDefinition",
          value: function fromRuleNameAndDefinition(ruleName, definition) {
            var recursiveDefinition = null;
            var type = _types.RECURSIVE_TYPE, parts = definition.getParts(), recursiveRuleNames = (0, _definition).recursiveRuleNamesFromDefinition(definition), recursiveRuleNamesLength = recursiveRuleNames.length, definitionRecursiveDefinition = recursiveRuleNamesLength > 0;
            if (definitionRecursiveDefinition) {
              recursiveDefinition = new RecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames);
            }
            return recursiveDefinition;
          }
        }
      ]);
      return RecursiveDefinition2;
    }(_occamParsers.Definition);
    exports.default = RecursiveDefinition;
  });

  // lib/definition/leftRecursive.js
  var require_leftRecursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _recursive = _interopRequireDefault2(require_recursive());
    var _types = require_types2();
    var _definition = require_definition5();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var LeftRecursiveDefinition = /* @__PURE__ */ function(RecursiveDefinition) {
      _inherits(LeftRecursiveDefinition2, RecursiveDefinition);
      var _super = _createSuper(LeftRecursiveDefinition2);
      function LeftRecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames) {
        _classCallCheck(this, LeftRecursiveDefinition2);
        var _this;
        _this = _super.call(this, type, parts, ruleName, definition, recursiveRuleNames);
        _this.leftRecursiveRuleNames = leftRecursiveRuleNames;
        return _this;
      }
      _createClass(LeftRecursiveDefinition2, [
        {
          key: "getLeftRecursiveRuleNames",
          value: function getLeftRecursiveRuleNames() {
            return this.leftRecursiveRuleNames;
          }
        },
        {
          key: "rewrite",
          value: function rewrite(ruleMap) {
          }
        }
      ], [
        {
          key: "fromRuleNameAndDefinition",
          value: function fromRuleNameAndDefinition(ruleName, definition) {
            var leftRecursiveDefinition2 = null;
            var leftRecursiveRuleNames = (0, _definition).leftRecursiveRuleNamesFromDefinition(definition), leftRecursiveRuleNamesLength = leftRecursiveRuleNames.length, definitionLeftRecursive = leftRecursiveRuleNamesLength > 0;
            if (definitionLeftRecursive) {
              var type = _types.LEFT_RECURSIVE_TYPE, parts = definition.getParts(), recursiveRuleNames = (0, _definition).recursiveRuleNamesFromDefinition(definition);
              leftRecursiveDefinition2 = new LeftRecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames);
            }
            return leftRecursiveDefinition2;
          }
        }
      ]);
      return LeftRecursiveDefinition2;
    }(_recursive.default);
    exports.default = LeftRecursiveDefinition;
  });

  // lib/node/reduced.js
  var require_reduced = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ReducedNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(ReducedNode2, NonTerminalNode);
      var _super = _createSuper(ReducedNode2);
      function ReducedNode2() {
        _classCallCheck(this, ReducedNode2);
        return _super.apply(this, arguments);
      }
      _createClass(ReducedNode2, null, [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _occamParsers.NonTerminalNode.fromRuleNameAndChildNodes(ReducedNode2, ruleName, childNodes);
          }
        }
      ]);
      return ReducedNode2;
    }(_occamParsers.NonTerminalNode);
    exports.default = ReducedNode;
  });

  // lib/rule/reduced.js
  var require_reduced2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _reduced = _interopRequireDefault2(require_reduced());
    var _recursive = _interopRequireDefault2(require_recursive());
    var _class = require_class2();
    var _ruleName = require_ruleName7();
    var _types = require_types2();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ReducedRule = /* @__PURE__ */ function(Rule) {
      _inherits(ReducedRule2, Rule);
      var _super = _createSuper(ReducedRule2);
      function ReducedRule2() {
        _classCallCheck(this, ReducedRule2);
        return _super.apply(this, arguments);
      }
      _createClass(ReducedRule2, [
        {
          key: "isEmpty",
          value: function isEmpty() {
            var definitionsLength = this.definitions.length, empty = definitionsLength === 0;
            return empty;
          }
        }
      ], [
        {
          key: "fromRule",
          value: function fromRule(rule) {
            var definitions = rule.getDefinitions();
            var ruleName = rule.getName(), reducedRuleName = (0, _ruleName).reducedRuleNameFromRuleName(ruleName);
            definitions = definitions.filter(function(definition) {
              var keep = true;
              var definitionRecursiveDefinition = (0, _class).isInstanceOf(definition, _recursive.default);
              if (definitionRecursiveDefinition) {
                var recursiveDefinition = definition, type = recursiveDefinition.getType();
                keep = type !== _types.DIRECTLY_LEFT_RECURSIVE_TYPE && type !== _types.INDIRECTLY_LEFT_RECURSIVE_TYPE && type !== _types.IMPLICITLY_LEFT_RECURSIVE_TYPE;
              }
              return keep;
            });
            var name = reducedRuleName, ambiguous = false, NonTerminalNode = _reduced.default, reducedRule = new ReducedRule2(name, ambiguous, definitions, NonTerminalNode);
            return reducedRule;
          }
        }
      ]);
      return ReducedRule2;
    }(_occamParsers.Rule);
    exports.default = ReducedRule;
  });

  // lib/node/repeated.js
  var require_repeated = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RepeatedNode = /* @__PURE__ */ function(NonTerminalNode) {
      _inherits(RepeatedNode2, NonTerminalNode);
      var _super = _createSuper(RepeatedNode2);
      function RepeatedNode2() {
        _classCallCheck(this, RepeatedNode2);
        return _super.apply(this, arguments);
      }
      _createClass(RepeatedNode2, null, [
        {
          key: "fromRuleNameAndChildNodes",
          value: function fromRuleNameAndChildNodes(ruleName, childNodes) {
            return _occamParsers.NonTerminalNode.fromRuleNameAndChildNodes(RepeatedNode2, ruleName, childNodes);
          }
        }
      ]);
      return RepeatedNode2;
    }(_occamParsers.NonTerminalNode);
    exports.default = RepeatedNode;
  });

  // lib/rule/repeated.js
  var require_repeated2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _repeated = _interopRequireDefault2(require_repeated());
    var _ruleName = require_ruleName7();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RepeatedRule = /* @__PURE__ */ function(Rule) {
      _inherits(RepeatedRule2, Rule);
      var _super = _createSuper(RepeatedRule2);
      function RepeatedRule2() {
        _classCallCheck(this, RepeatedRule2);
        return _super.apply(this, arguments);
      }
      _createClass(RepeatedRule2, null, [
        {
          key: "fromRule",
          value: function fromRule(rule) {
            var ruleName = rule.getName(), repeatedRuleName = (0, _ruleName).repeatedRuleNameFromRuleName(ruleName), name = repeatedRuleName, ambiguous = false, definitions = [], NonTerminalNode = _repeated.default, repeatedRule = new RepeatedRule2(name, ambiguous, definitions, NonTerminalNode);
            return repeatedRule;
          }
        }
      ]);
      return RepeatedRule2;
    }(_occamParsers.Rule);
    exports.default = RepeatedRule;
  });

  // lib/utilities/part.js
  var require_part4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ruleNamePartFromRuleName = ruleNamePartFromRuleName;
    exports.zeroOrMoreRuleNamePartPartFromRuleName = zeroOrMoreRuleNamePartPartFromRuleName;
    var _occamParsers = require_lib4();
    var RuleNamePart = _occamParsers.Parts.RuleNamePart;
    var ZeroOrMorePartsPart = _occamParsers.Parts.ZeroOrMorePartsPart;
    function ruleNamePartFromRuleName(ruleName) {
      var lookAhead = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var ruleNamePart = new RuleNamePart(ruleName, lookAhead);
      return ruleNamePart;
    }
    function zeroOrMoreRuleNamePartPartFromRuleName(ruleName) {
      var ruleNamePart = ruleNamePartFromRuleName(ruleName), zeroOrMoreRuleNamePartPart = new ZeroOrMorePartsPart(ruleNamePart);
      return zeroOrMoreRuleNamePartPart;
    }
  });

  // lib/definition/ruleName.js
  var require_ruleName8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _part = require_part4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RuleNameDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RuleNameDefinition2, Definition);
      var _super = _createSuper(RuleNameDefinition2);
      function RuleNameDefinition2() {
        _classCallCheck(this, RuleNameDefinition2);
        return _super.apply(this, arguments);
      }
      _createClass(RuleNameDefinition2, null, [
        {
          key: "fromRuleName",
          value: function fromRuleName(ruleName) {
            var ruleNamePart = (0, _part).ruleNamePartFromRuleName(ruleName), parts = [
              ruleNamePart
            ], ruleNameDefinition = new RuleNameDefinition2(parts);
            return ruleNameDefinition;
          }
        }
      ]);
      return RuleNameDefinition2;
    }(_occamParsers.Definition);
    exports.default = RuleNameDefinition;
  });

  // lib/rule/rewritten.js
  var require_rewritten = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _ruleName = _interopRequireDefault2(require_ruleName8());
    var _recursive = _interopRequireDefault2(require_recursive());
    var _class = require_class2();
    var _ruleName1 = require_ruleName7();
    var _types = require_types2();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RewrittenRule = /* @__PURE__ */ function(Rule) {
      _inherits(RewrittenRule2, Rule);
      var _super = _createSuper(RewrittenRule2);
      function RewrittenRule2() {
        _classCallCheck(this, RewrittenRule2);
        return _super.apply(this, arguments);
      }
      _createClass(RewrittenRule2, null, [
        {
          key: "fromRule",
          value: function fromRule(rule) {
            var definitions = rule.getDefinitions();
            var ruleName = rule.getName(), reducedRuleName = (0, _ruleName1).reducedRuleNameFromRuleName(ruleName), reducedRuleNameDefinition = _ruleName.default.fromRuleName(reducedRuleName);
            definitions = definitions.filter(function(definition) {
              var keep = false;
              var definitionRecursiveDefinition = (0, _class).isInstanceOf(definition, _recursive.default);
              if (definitionRecursiveDefinition) {
                var recursiveDefinition = definition, type = recursiveDefinition.getType();
                keep = type === _types.DIRECTLY_LEFT_RECURSIVE_TYPE || type === _types.INDIRECTLY_LEFT_RECURSIVE_TYPE || type === _types.IMPLICITLY_LEFT_RECURSIVE_TYPE;
              }
              return keep;
            });
            definitions = _toConsumableArray(definitions).concat([
              reducedRuleNameDefinition
            ]);
            var name = ruleName, ambiguous = rule.isAmbiguous(), NonTerminalNode = rule.getNonTerminalNode(), rewrittenRule = new RewrittenRule2(name, ambiguous, definitions, NonTerminalNode);
            return rewrittenRule;
          }
        }
      ]);
      return RewrittenRule2;
    }(_occamParsers.Rule);
    exports.default = RewrittenRule;
  });

  // lib/utilities/parts.js
  var require_parts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cloneParts = cloneParts;
    function cloneParts(parts) {
      parts = parts.map(function(part) {
        return part.clone();
      });
      return parts;
    }
  });

  // lib/definition/repeated.js
  var require_repeated3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _parts = require_parts2();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RepeatedDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RepeatedDefinition2, Definition);
      var _super = _createSuper(RepeatedDefinition2);
      function RepeatedDefinition2() {
        _classCallCheck(this, RepeatedDefinition2);
        return _super.apply(this, arguments);
      }
      _createClass(RepeatedDefinition2, null, [
        {
          key: "fromDefinition",
          value: function fromDefinition(definition) {
            var parts = definition.getParts();
            parts = (0, _parts).cloneParts(parts);
            parts.shift();
            var repeatedDefinition = new RepeatedDefinition2(parts);
            return repeatedDefinition;
          }
        }
      ]);
      return RepeatedDefinition2;
    }(_occamParsers.Definition);
    exports.default = RepeatedDefinition;
  });

  // lib/definition/rewritten.js
  var require_rewritten2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _occamParsers = require_lib4();
    var _parts = require_parts2();
    var _definition = require_definition5();
    var _ruleName = require_ruleName7();
    var _part = require_part4();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var RewrittenDefinition = /* @__PURE__ */ function(Definition) {
      _inherits(RewrittenDefinition2, Definition);
      var _super = _createSuper(RewrittenDefinition2);
      function RewrittenDefinition2() {
        _classCallCheck(this, RewrittenDefinition2);
        return _super.apply(this, arguments);
      }
      _createClass(RewrittenDefinition2, null, [
        {
          key: "fromDefinitionAndLeftRecursiveRuleName",
          value: function fromDefinitionAndLeftRecursiveRuleName(definition, leftRecursiveRuleName) {
            var parts = definition.getParts();
            parts = (0, _parts).cloneParts(parts);
            parts.shift();
            var definitionLookAhead = (0, _definition).isDefinitionLookAhead(definition), lookAhead = definitionLookAhead, repeatedRuleName = (0, _ruleName).repeatedRuleNameFromRuleName(leftRecursiveRuleName), reducedLeftRecursiveRuleName = (0, _ruleName).reducedRuleNameFromRuleName(leftRecursiveRuleName), zeroOrMoreRepeatedRuleNamePart = (0, _part).zeroOrMoreRuleNamePartPartFromRuleName(repeatedRuleName), reducedLeftRecursiveRuleNamePart = (0, _part).ruleNamePartFromRuleName(reducedLeftRecursiveRuleName, lookAhead), rewrittenDefinition = new RewrittenDefinition2(parts);
            parts.unshift(reducedLeftRecursiveRuleNamePart);
            parts.push(zeroOrMoreRepeatedRuleNamePart);
            return rewrittenDefinition;
          }
        }
      ]);
      return RewrittenDefinition2;
    }(_occamParsers.Definition);
    exports.default = RewrittenDefinition;
  });

  // lib/definition/leftRecursive/directly.js
  var require_directly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _reduced = _interopRequireDefault2(require_reduced2());
    var _repeated = _interopRequireDefault2(require_repeated2());
    var _rewritten = _interopRequireDefault2(require_rewritten());
    var _repeated1 = _interopRequireDefault2(require_repeated3());
    var _rewritten1 = _interopRequireDefault2(require_rewritten2());
    var _leftRecursive = _interopRequireDefault2(require_leftRecursive());
    var _types = require_types2();
    var _rule = require_rule6();
    var _definition = require_definition5();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DirectlyLeftRecursiveDefinition = /* @__PURE__ */ function(LeftRecursiveDefinition) {
      _inherits(DirectlyLeftRecursiveDefinition2, LeftRecursiveDefinition);
      var _super = _createSuper(DirectlyLeftRecursiveDefinition2);
      function DirectlyLeftRecursiveDefinition2() {
        _classCallCheck(this, DirectlyLeftRecursiveDefinition2);
        return _super.apply(this, arguments);
      }
      _createClass(DirectlyLeftRecursiveDefinition2, [
        {
          key: "rewrite",
          value: function rewrite(ruleMap) {
            var definition = this.getDefinition(), ruleName = this.getRuleName(), rule = ruleMap[ruleName] || null;
            var reducedRule = (0, _rule).reducedRuleFromRule(rule, ruleMap, _reduced.default), reducedRuleEmpty = reducedRule.isEmpty();
            if (reducedRuleEmpty) {
              var definitionString = definition.asString();
              throw new Error("The '".concat(definitionString, "' directly left recursive definition of the '").concat(ruleName, "' rule has no sibling non-left recursive definitions and therefore cannot be rewritten."));
            }
            var leftRecursiveRuleName = ruleName;
            var repeatedRule = (0, _rule).repeatedRuleFromRule(rule, ruleMap, _repeated.default), repeatedDefinition = _repeated1.default.fromDefinition(definition);
            repeatedRule.addDefinition(repeatedDefinition);
            var rewrittenRule = (0, _rule).rewrittenRuleFromRule(rule, ruleMap, _rewritten.default), rewrittenDefinition = _rewritten1.default.fromDefinitionAndLeftRecursiveRuleName(definition, leftRecursiveRuleName), replacementDefinition = this;
            rewrittenRule.replaceDefinition(replacementDefinition, rewrittenDefinition);
          }
        }
      ], [
        {
          key: "fromRuleNameAndDefinition",
          value: function fromRuleNameAndDefinition(ruleName, definition) {
            var directlyLeftRecursiveDefinition = null;
            var leftRecursiveRuleNames = (0, _definition).leftRecursiveRuleNamesFromDefinition(definition), leftRecursiveRuleNamesLength = leftRecursiveRuleNames.length, definitionLeftRecursive = leftRecursiveRuleNamesLength > 0;
            if (definitionLeftRecursive) {
              leftRecursiveRuleNames.some(function(leftRecursiveRuleName) {
                var ruleNameLeftRecursiveRuleName = ruleName === leftRecursiveRuleName;
                if (ruleNameLeftRecursiveRuleName) {
                  var definitionUnary = (0, _definition).isDefinitionUnary(definition);
                  if (definitionUnary) {
                    var definitionString = definition.asString();
                    throw new Error("The '".concat(definitionString, "' directly left recursive definition of the '").concat(ruleName, "' rule is unary and therefore cannot be rewritten."));
                  }
                  var definitionComplex = (0, _definition).isDefinitionComplex(definition);
                  if (definitionComplex) {
                    var definitionString1 = definition.asString();
                    throw new Error("The '".concat(definitionString1, "' directly left recursive definition of the '").concat(ruleName, "' rule is complex and therefore cannot be rewritten."));
                  }
                  var type = _types.DIRECTLY_LEFT_RECURSIVE_TYPE, parts = [], recursiveRuleNames = (0, _definition).recursiveRuleNamesFromDefinition(definition);
                  directlyLeftRecursiveDefinition = new DirectlyLeftRecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames);
                  return true;
                }
              });
            }
            return directlyLeftRecursiveDefinition;
          }
        }
      ]);
      return DirectlyLeftRecursiveDefinition2;
    }(_leftRecursive.default);
    exports.default = DirectlyLeftRecursiveDefinition;
  });

  // lib/definition/leftRecursive/implicitly.js
  var require_implicitly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _leftRecursive = _interopRequireDefault2(require_leftRecursive());
    var _types = require_types2();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var first = _necessary.arrayUtilities.first;
    var ImplicitlyLeftRecursiveDefinition = /* @__PURE__ */ function(LeftRecursiveDefinition) {
      _inherits(ImplicitlyLeftRecursiveDefinition2, LeftRecursiveDefinition);
      var _super = _createSuper(ImplicitlyLeftRecursiveDefinition2);
      function ImplicitlyLeftRecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames, leftRecursiveDefinition2) {
        _classCallCheck(this, ImplicitlyLeftRecursiveDefinition2);
        var _this;
        _this = _super.call(this, type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames);
        _this.leftRecursiveDefinition = leftRecursiveDefinition2;
        return _this;
      }
      _createClass(ImplicitlyLeftRecursiveDefinition2, [
        {
          key: "getLeftRecursiveDefinition",
          value: function getLeftRecursiveDefinition() {
            this.leftRecursiveDefinition = leftRecursiveDefinition;
          }
        },
        {
          key: "replace",
          value: function replace(ruleMap) {
            var rule = ruleMap[this.ruleName] || null, replacedDefinition = this.leftRecursiveDefinition, replacementDefinition = this;
            rule.replaceDefinition(replacedDefinition, replacementDefinition);
          }
        }
      ], [
        {
          key: "fromRuleNameLeftRecursiveRuleNameAndRecursiveDefinitions",
          value: function fromRuleNameLeftRecursiveRuleNameAndRecursiveDefinitions(ruleName, leftRecursiveRuleName, recursiveDefinitions) {
            var implicitlyLeftRecursiveDefinition = null;
            var leftRecursiveDefinition2 = findLeftRecursiveDefinition(ruleName, leftRecursiveRuleName, recursiveDefinitions);
            if (leftRecursiveDefinition2 !== null) {
              var type = _types.IMPLICITLY_LEFT_RECURSIVE_TYPE, parts = leftRecursiveDefinition2.getParts(), _$ruleName = leftRecursiveDefinition2.getRuleName(), definition = null, recursiveRuleNames = leftRecursiveDefinition2.getRecursiveRuleNames(), leftRecursiveRuleNames = leftRecursiveDefinition2.getLeftRecursiveRuleNames();
              implicitlyLeftRecursiveDefinition = new ImplicitlyLeftRecursiveDefinition2(type, parts, _$ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames, leftRecursiveDefinition2);
            }
            return implicitlyLeftRecursiveDefinition;
          }
        }
      ]);
      return ImplicitlyLeftRecursiveDefinition2;
    }(_leftRecursive.default);
    exports.default = ImplicitlyLeftRecursiveDefinition;
    function findLeftRecursiveDefinition(ruleName, leftRecursiveRuleName, recursiveDefinitions) {
      var leftRecursiveDefinition2 = null;
      var leftRecursiveDefinitionsPath = findLeftRecursiveDefinitionsPath(ruleName, leftRecursiveRuleName, recursiveDefinitions);
      if (leftRecursiveDefinitionsPath !== null) {
        var firstLeftRecursiveDefinition = first(leftRecursiveDefinitionsPath);
        leftRecursiveDefinition2 = firstLeftRecursiveDefinition;
      }
      return leftRecursiveDefinition2;
    }
    function findRecursiveDefinitionsPath(ruleName, recursiveRuleName, recursiveDefinitions) {
      var recursiveDefinitionsPath = null;
      recursiveDefinitions.some(function(recursiveDefinition, index) {
        var recursiveDefinitionRuleName = recursiveDefinition.getRuleName(), recursiveDefinitionRuleNameRecursiveRuleName = recursiveDefinitionRuleName === recursiveRuleName;
        if (recursiveDefinitionRuleNameRecursiveRuleName) {
          recursiveDefinitionsPath = recursiveDefinitions.slice(index);
          return true;
        }
      });
      return recursiveDefinitionsPath;
    }
    function findLeftRecursiveDefinitionsPath(ruleName, leftRecursiveRuleName, recursiveDefinitions) {
      var leftRecursiveDefinitionsPath = null;
      var recursiveRuleName = leftRecursiveRuleName, recursiveDefinitionsPath = findRecursiveDefinitionsPath(ruleName, recursiveRuleName, recursiveDefinitions);
      if (recursiveDefinitionsPath !== null) {
        var recursiveDefinitionsPathLeftRecursive = isRecursiveDefinitionsPathLeftRecursive(ruleName, recursiveDefinitionsPath);
        if (recursiveDefinitionsPathLeftRecursive) {
          leftRecursiveDefinitionsPath = recursiveDefinitionsPath;
        }
      }
      return leftRecursiveDefinitionsPath;
    }
    function isRecursiveDefinitionsPathLeftRecursive(ruleName, recursiveDefinitionsPath) {
      var ruleNames = ruleNamesFromRuleNameAndRecursiveDefinitionsPath(ruleName, recursiveDefinitionsPath), recursiveDefinitionsPathLeftRecursive = recursiveDefinitionsPath.every(function(recursiveDefinition, index) {
        var type = recursiveDefinition.getType();
        if (type === _types.LEFT_RECURSIVE_TYPE) {
          var _$ruleName = ruleNames[index], leftRecursiveRuleNames = recursiveDefinition.getLeftRecursiveRuleNames(), leftRecursiveRuleNamesIncludesRuleName = leftRecursiveRuleNames.includes(_$ruleName);
          if (leftRecursiveRuleNamesIncludesRuleName) {
            return true;
          }
        }
      });
      return recursiveDefinitionsPathLeftRecursive;
    }
    function ruleNamesFromRuleNameAndRecursiveDefinitionsPath(ruleName, recursiveDefinitionsPath) {
      var ruleNames = recursiveDefinitionsPath.map(function(recursiveDefinition) {
        return recursiveDefinition.getRuleName();
      });
      ruleNames.push(ruleName);
      var firstRuleName = ruleNames.shift(), lastRuleName = firstRuleName;
      ruleNames.push(lastRuleName);
      return ruleNames;
    }
  });

  // lib/definition/leftRecursive/indirectly.js
  var require_indirectly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _necessary = require_browser();
    var _reduced = _interopRequireDefault2(require_reduced2());
    var _repeated = _interopRequireDefault2(require_repeated2());
    var _rewritten = _interopRequireDefault2(require_rewritten());
    var _repeated1 = _interopRequireDefault2(require_repeated3());
    var _rewritten1 = _interopRequireDefault2(require_rewritten2());
    var _leftRecursive = _interopRequireDefault2(require_leftRecursive());
    var _implicitly = _interopRequireDefault2(require_implicitly());
    var _types = require_types2();
    var _rule = require_rule6();
    var _definition = require_definition5();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var first = _necessary.arrayUtilities.first;
    var IndirectlyLeftRecursiveDefinition = /* @__PURE__ */ function(LeftRecursiveDefinition) {
      _inherits(IndirectlyLeftRecursiveDefinition2, LeftRecursiveDefinition);
      var _super = _createSuper(IndirectlyLeftRecursiveDefinition2);
      function IndirectlyLeftRecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames, implicitlyLeftRecursiveDefinition) {
        _classCallCheck(this, IndirectlyLeftRecursiveDefinition2);
        var _this;
        _this = _super.call(this, type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames);
        _this.implicitlyLeftRecursiveDefinition = implicitlyLeftRecursiveDefinition;
        return _this;
      }
      _createClass(IndirectlyLeftRecursiveDefinition2, [
        {
          key: "getImplicitlyLeftRecursiveDefinition",
          value: function getImplicitlyLeftRecursiveDefinition() {
            return this.implicitlyLeftRecursiveDefinition;
          }
        },
        {
          key: "rewrite",
          value: function rewrite(ruleMap) {
            var definition = this.getDefinition(), ruleName = this.getRuleName(), rule = ruleMap[ruleName] || null;
            var leftRecursiveRuleNames = this.getLeftRecursiveRuleNames(), firstLeftRecursiveRuleName = first(leftRecursiveRuleNames), leftRecursiveRuleName = firstLeftRecursiveRuleName, leftRecursiveRule = ruleMap[leftRecursiveRuleName] || null;
            var reducedRule = (0, _rule).reducedRuleFromRule(leftRecursiveRule, ruleMap, _reduced.default), reducedRuleEmpty = reducedRule.isEmpty();
            if (reducedRuleEmpty) {
              var definitionString = definition.asString(), implicitlyLeftRecursiveDefinition = this.getImplicitlyLeftRecursiveDefinition(), implicitlyLeftRecursiveDefinitionString = implicitlyLeftRecursiveDefinition.asString();
              throw new Error("The '".concat(implicitlyLeftRecursiveDefinitionString, "' implicitly left recursive definition of the '").concat(leftRecursiveRuleName, "' rule has no sibling non-left recursive definitions and therefore the '").concat(definitionString, "' indirectly left recursive definition of the '").concat(ruleName, "' rule cannot be rewritten."));
            }
            var repeatedRule = (0, _rule).repeatedRuleFromRule(leftRecursiveRule, ruleMap, _repeated.default), repeatedDefinition = _repeated1.default.fromDefinition(definition);
            repeatedRule.addDefinition(repeatedDefinition);
            (0, _rule).rewrittenRuleFromRule(leftRecursiveRule, ruleMap, _rewritten.default);
            var rewrittenDefinition = _rewritten1.default.fromDefinitionAndLeftRecursiveRuleName(definition, leftRecursiveRuleName), replacementDefinition = this;
            rule.replaceDefinition(replacementDefinition, rewrittenDefinition);
          }
        }
      ], [
        {
          key: "fromRuleNameDefinitionAndRecursiveDefinitions",
          value: function fromRuleNameDefinitionAndRecursiveDefinitions(ruleName, definition, recursiveDefinitions) {
            var indirectlyLeftRecursiveDefinition = null;
            var leftRecursiveRuleNames = (0, _definition).leftRecursiveRuleNamesFromDefinition(definition), leftRecursiveRuleNamesLength = leftRecursiveRuleNames.length, definitionLeftRecursive = leftRecursiveRuleNamesLength > 0;
            if (definitionLeftRecursive) {
              leftRecursiveRuleNames.some(function(leftRecursiveRuleName) {
                var ruleNameLeftRecursiveRuleName = ruleName === leftRecursiveRuleName;
                if (!ruleNameLeftRecursiveRuleName) {
                  var implicitlyLeftRecursiveDefinition = _implicitly.default.fromRuleNameLeftRecursiveRuleNameAndRecursiveDefinitions(ruleName, leftRecursiveRuleName, recursiveDefinitions);
                  if (implicitlyLeftRecursiveDefinition !== null) {
                    var definitionUnary = (0, _definition).isDefinitionUnary(definition);
                    if (definitionUnary) {
                      var definitionString = definition.asString();
                      throw new Error("The '".concat(definitionString, "' indirectly left recursive definition of the '").concat(ruleName, "' rule is unary and therefore cannot be rewritten."));
                    }
                    var definitionComplex = (0, _definition).isDefinitionComplex(definition);
                    if (definitionComplex) {
                      var definitionString1 = definition.asString();
                      throw new Error("The '".concat(definitionString1, "' indirectly left recursive definition of the '").concat(ruleName, "' rule is complex and therefore cannot be rewritten."));
                    }
                    var type = _types.INDIRECTLY_LEFT_RECURSIVE_TYPE, parts = [], recursiveRuleNames = (0, _definition).recursiveRuleNamesFromDefinition(definition);
                    indirectlyLeftRecursiveDefinition = new IndirectlyLeftRecursiveDefinition2(type, parts, ruleName, definition, recursiveRuleNames, leftRecursiveRuleNames, implicitlyLeftRecursiveDefinition);
                    return true;
                  }
                }
              });
            }
            return indirectlyLeftRecursiveDefinition;
          }
        }
      ]);
      return IndirectlyLeftRecursiveDefinition2;
    }(_leftRecursive.default);
    exports.default = IndirectlyLeftRecursiveDefinition;
  });

  // lib/eliminateLeftRecursion.js
  var require_eliminateLeftRecursion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eliminateLeftRecursion;
    var _recursive = _interopRequireDefault2(require_recursive());
    var _leftRecursive = _interopRequireDefault2(require_leftRecursive());
    var _directly = _interopRequireDefault2(require_directly());
    var _indirectly = _interopRequireDefault2(require_indirectly());
    var _class = require_class2();
    function eliminateLeftRecursion(startRule, ruleMap) {
      var rule = startRule, recursiveDefinitions = [], leftRecursiveDefinitions = [];
      replaceRecursiveDefinitions(rule, recursiveDefinitions, leftRecursiveDefinitions, ruleMap);
      rewriteLeftRecursiveDefinitions(leftRecursiveDefinitions, ruleMap);
      var startRuleName = startRule.getName();
      startRule = ruleMap[startRuleName];
      return startRule;
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function replaceRecursiveDefinition(ruleName, definition, recursiveDefinitions, leftRecursiveDefinitions, ruleMap) {
      var leftRecursiveDefinition2 = _indirectly.default.fromRuleNameDefinitionAndRecursiveDefinitions(ruleName, definition, recursiveDefinitions) || _directly.default.fromRuleNameAndDefinition(ruleName, definition) || _leftRecursive.default.fromRuleNameAndDefinition(ruleName, definition);
      if (leftRecursiveDefinition2 !== null) {
        var leftRecursiveDefinitionIndirectlyLeftRecursiveDefinition = (0, _class).isInstanceOf(leftRecursiveDefinition2, _indirectly.default);
        if (leftRecursiveDefinitionIndirectlyLeftRecursiveDefinition) {
          var indirectlyLeftRecursiveDefinition = leftRecursiveDefinition2, implicitlyLeftRecursiveDefinition = indirectlyLeftRecursiveDefinition.getImplicitlyLeftRecursiveDefinition();
          implicitlyLeftRecursiveDefinition.replace(ruleMap);
        }
        leftRecursiveDefinitions.push(leftRecursiveDefinition2);
      }
      var recursiveDefinition = leftRecursiveDefinition2 !== null ? leftRecursiveDefinition2 : _recursive.default.fromRuleNameAndDefinition(ruleName, definition);
      if (recursiveDefinition !== null) {
        recursiveDefinition.replace(ruleMap);
      }
      return recursiveDefinition;
    }
    function replaceRecursiveDefinitions(rule, recursiveDefinitions, leftRecursiveDefinitions, ruleMap) {
      var ruleName1 = rule.getName(), definitions = rule.getDefinitions();
      definitions.forEach(function(definition) {
        var definitionRecursiveDefinition = (0, _class).isInstanceOf(definition, _recursive.default), recursiveDefinition = definitionRecursiveDefinition ? definition : replaceRecursiveDefinition(ruleName1, definition, recursiveDefinitions, leftRecursiveDefinitions, ruleMap);
        if (recursiveDefinition !== null) {
          var previousRecursiveDefinitions = _toConsumableArray(recursiveDefinitions).concat([
            recursiveDefinition
          ]), previousRecursiveRuleNames = previousRecursiveDefinitions.map(function(previousRecursiveDefinition) {
            return recursiveRuleNameFromRecursiveDefinition(previousRecursiveDefinition);
          }), recursiveRuleNames = recursiveDefinition.getRecursiveRuleNames();
          recursiveRuleNames.forEach(function(recursiveRuleName) {
            var previousRecursiveRuleNamesIncludesRecursiveRuleName = previousRecursiveRuleNames.includes(recursiveRuleName);
            if (!previousRecursiveRuleNamesIncludesRecursiveRuleName) {
              var ruleName = recursiveRuleName, _$rule = ruleMap[ruleName] || null;
              if (_$rule !== null) {
                var _$recursiveDefinitions = previousRecursiveDefinitions;
                replaceRecursiveDefinitions(_$rule, _$recursiveDefinitions, leftRecursiveDefinitions, ruleMap);
              }
            }
          });
        }
      });
    }
    function rewriteLeftRecursiveDefinitions(leftRecursiveDefinitions, ruleMap) {
      leftRecursiveDefinitions.forEach(function(leftRecursiveDefinition2) {
        return leftRecursiveDefinition2.rewrite(ruleMap);
      });
    }
    function recursiveRuleNameFromRecursiveDefinition(recursiveDefinition) {
      var recursiveDefinitionRuleName = recursiveDefinition.getRuleName(), recursiveRuleName = recursiveDefinitionRuleName;
      return recursiveRuleName;
    }
  });

  // lib/removeOrRenameIntermediateNodes.js
  var require_removeOrRenameIntermediateNodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeOrRenameIntermediateNodes;
    var _reduced = _interopRequireDefault2(require_reduced());
    var _repeated = _interopRequireDefault2(require_repeated());
    var _class = require_class2();
    var _ruleName = require_ruleName7();
    function removeOrRenameIntermediateNodes(node) {
      removeOrRenameReducedNodes(node);
      removeRepeatedNodes(node);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function removeRepeatedNodes(node) {
      var nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        var nonTerminalNode = node;
        var childNodes = nonTerminalNode.getChildNodes();
        childNodes = removeRepeatedChildNodes(childNodes);
        nonTerminalNode.setChildNodes(childNodes);
      }
    }
    function removeRepeatedChildNodes(childNodes1) {
      childNodes1 = childNodes1.reduce(function(childNodes, childNode) {
        var childNodeRepeatedNode = (0, _class).isInstanceOf(childNode, _repeated.default);
        if (childNodeRepeatedNode) {
          var childNodeChildNodes = childNode.getChildNodes();
          childNodeChildNodes = removeRepeatedChildNodes(childNodeChildNodes);
          childNodes = childNodes.concat(childNodeChildNodes);
        } else {
          removeRepeatedNodes(childNode);
          childNodes.push(childNode);
        }
        return childNodes;
      }, []);
      return childNodes1;
    }
    function removeOrRenameReducedNodes(node) {
      var nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        var nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName();
        var childNodes = nonTerminalNode.getChildNodes();
        childNodes = removeOrRenameReducedChildNodes(childNodes, ruleName);
        nonTerminalNode.setChildNodes(childNodes);
      }
    }
    function removeOrRenameReducedChildNodes(childNodes2, ruleName) {
      var childNodesLength = childNodes2.length;
      childNodes2 = childNodes2.reduce(function(childNodes, childNode) {
        var childNodeReducedNode = (0, _class).isInstanceOf(childNode, _reduced.default);
        if (childNodeReducedNode) {
          var reducedNode = childNode, reducedNodeRuleName = reducedNode.getRuleName(), reducedRuleName = reducedNodeRuleName, reducedRuleNameMatchesRuleName = (0, _ruleName).checkReducedRuleNameMatchesRuleName(reducedRuleName, ruleName);
          if (reducedRuleNameMatchesRuleName) {
            if (childNodesLength > 1) {
              var _$ruleName = (0, _ruleName).ruleNameFromReducedRuleName(reducedRuleName);
              childNode.setRuleName(_$ruleName);
              removeOrRenameReducedNodes(childNode);
              childNodes.push(childNode);
            } else {
              var childNodeChildNodes = childNode.getChildNodes();
              childNodeChildNodes = removeOrRenameReducedChildNodes(childNodeChildNodes);
              childNodes = childNodes.concat(childNodeChildNodes);
            }
          } else {
            var _$ruleName1 = (0, _ruleName).ruleNameFromReducedRuleName(reducedRuleName);
            childNode.setRuleName(_$ruleName1);
            removeOrRenameReducedNodes(childNode);
            childNodes.push(childNode);
          }
        } else {
          removeOrRenameReducedNodes(childNode);
          childNodes.push(childNode);
        }
        return childNodes;
      }, []);
      return childNodes2;
    }
  });

  // lib/index.js
  var require_lib9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "eliminateLeftRecursion", {
      enumerable: true,
      get: function() {
        return _eliminateLeftRecursion.default;
      }
    });
    Object.defineProperty(exports, "removeOrRenameIntermediateNodes", {
      enumerable: true,
      get: function() {
        return _removeOrRenameIntermediateNodes.default;
      }
    });
    var _eliminateLeftRecursion = _interopRequireDefault2(require_eliminateLeftRecursion());
    var _removeOrRenameIntermediateNodes = _interopRequireDefault2(require_removeOrRenameIntermediateNodes());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/example/paragraph.js
  var require_paragraph = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  margin: 2rem 0 0 0;\n  font-size: 1.7rem;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var Paragraph = _easyWithStyle2.default.p(_templateObject());
    var _default = Paragraph;
    exports.default = _default;
  });

  // lib/example/subHeading.js
  var require_subHeading = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  margin: 1rem 0 0.5rem 0;\n  font-size: 2rem;\n  \n  :first-of-type {\n    margin-top: 0;\n  }\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var SubHeading = _easyWithStyle2.default.h2(_templateObject());
    var _default = SubHeading;
    exports.default = _default;
  });

  // lib/example/div/sizeable.js
  var require_sizeable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easyLayout = require_lib8();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  width: 48rem;\n  min-width: 24rem;\n  \n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var _default = (0, _easyWithStyle2).default(_easyLayout.SizeableDiv)(_templateObject());
    exports.default = _default;
  });

  // lib/example/textarea.js
  var require_textarea2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  border: 1px solid darkgrey;\n  height: 24rem;\n  resize: vertical;\n  padding: 0.25rem;\n  font-size: 1.2rem;\n  white-space: pre;\n  font-family: monospace;\n\n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var _default = (0, _easyWithStyle2).default(_easy2.Textarea)(_templateObject());
    exports.default = _default;
  });

  // lib/example/textarea/bnf.js
  var require_bnf5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _textarea = _interopRequireDefault2(require_textarea2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var BNFTextarea = /* @__PURE__ */ function(Textarea) {
      _inherits(BNFTextarea2, Textarea);
      var _super = _createSuper(BNFTextarea2);
      function BNFTextarea2() {
        _classCallCheck(this, BNFTextarea2);
        return _super.apply(this, arguments);
      }
      _createClass(BNFTextarea2, [
        {
          key: "getBNF",
          value: function getBNF() {
            var value = this.getValue(), bnf = value;
            return bnf;
          }
        },
        {
          key: "setBNF",
          value: function setBNF(bnf) {
            var value = bnf;
            this.setValue(value);
          }
        },
        {
          key: "parentContext",
          value: function parentContext() {
            var getBNF = this.getBNF.bind(this), setBNF = this.setBNF.bind(this);
            return {
              getBNF,
              setBNF
            };
          }
        }
      ]);
      return BNFTextarea2;
    }(_textarea.default);
    exports.default = BNFTextarea;
    _defineProperty(BNFTextarea, "defaultProperties", {
      className: "bnf",
      spellCheck: "false"
    });
  });

  // lib/example/textarea/content.js
  var require_content3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _textarea = _interopRequireDefault2(require_textarea2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ContentTextarea = /* @__PURE__ */ function(Textarea) {
      _inherits(ContentTextarea2, Textarea);
      var _super = _createSuper(ContentTextarea2);
      function ContentTextarea2() {
        _classCallCheck(this, ContentTextarea2);
        return _super.apply(this, arguments);
      }
      _createClass(ContentTextarea2, [
        {
          key: "getContent",
          value: function getContent() {
            var value = this.getValue(), content = value;
            return content;
          }
        },
        {
          key: "setContent",
          value: function setContent(content) {
            var value = content;
            this.setValue(value);
          }
        },
        {
          key: "parentContext",
          value: function parentContext() {
            var getContent = this.getContent.bind(this), setContent = this.setContent.bind(this);
            return {
              getContent,
              setContent
            };
          }
        }
      ]);
      return ContentTextarea2;
    }(_textarea.default);
    exports.default = ContentTextarea;
    _defineProperty(ContentTextarea, "defaultProperties", {
      className: "content",
      spellCheck: "false"
    });
  });

  // lib/example/textarea/parseTree.js
  var require_parseTree2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _textarea = _interopRequireDefault2(require_textarea2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var ParseTreeTextarea = /* @__PURE__ */ function(Textarea) {
      _inherits(ParseTreeTextarea2, Textarea);
      var _super = _createSuper(ParseTreeTextarea2);
      function ParseTreeTextarea2() {
        _classCallCheck(this, ParseTreeTextarea2);
        return _super.apply(this, arguments);
      }
      _createClass(ParseTreeTextarea2, [
        {
          key: "setParseTree",
          value: function setParseTree(parseTree) {
            if (parseTree !== null) {
              parseTree.shiftLine();
              var parseTreeString = parseTree.asString(), value = parseTreeString;
              this.setValue(value);
            } else {
              this.clearParseTree();
            }
          }
        },
        {
          key: "clearParseTree",
          value: function clearParseTree() {
            var value = "";
            this.setValue(value);
          }
        },
        {
          key: "parentContext",
          value: function parentContext() {
            var setParseTree = this.setParseTree.bind(this), clearParseTree = this.clearParseTree.bind(this);
            return {
              setParseTree,
              clearParseTree
            };
          }
        }
      ]);
      return ParseTreeTextarea2;
    }(_textarea.default);
    exports.default = ParseTreeTextarea;
    _defineProperty(ParseTreeTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/input/lexicalPattern.js
  var require_lexicalPattern = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  border: 1px solid darkgrey;\n  padding: 0.25rem;\n  font-size: 1.2rem;\n  font-family: monospace;\n  \n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var LexicalPatternInput = /* @__PURE__ */ function(Input) {
      _inherits(LexicalPatternInput2, Input);
      var _super = _createSuper(LexicalPatternInput2);
      function LexicalPatternInput2() {
        _classCallCheck(this, LexicalPatternInput2);
        return _super.apply(this, arguments);
      }
      _createClass(LexicalPatternInput2, [
        {
          key: "getLexicalPattern",
          value: function getLexicalPattern() {
            var value = this.getValue(), lexicalPattern = value;
            return lexicalPattern;
          }
        },
        {
          key: "setLexicalPattern",
          value: function setLexicalPattern(lexicalPattern) {
            var value = lexicalPattern;
            this.setValue(value);
          }
        },
        {
          key: "parentContext",
          value: function parentContext() {
            var getLexicalPattern = this.getLexicalPattern.bind(this), setLexicalPattern = this.setLexicalPattern.bind(this);
            return {
              getLexicalPattern,
              setLexicalPattern
            };
          }
        }
      ]);
      return LexicalPatternInput2;
    }(_easy2.Input);
    _defineProperty(LexicalPatternInput, "defaultProperties", {
      className: "lexical-pattern",
      spellCheck: "false"
    });
    var _default = (0, _easyWithStyle2).default(LexicalPatternInput)(_templateObject());
    exports.default = _default;
  });

  // lib/example/textarea/adjustedBNF.js
  var require_adjustedBNF = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _textarea = _interopRequireDefault2(require_textarea2());
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var AdjustedBNFTextarea = /* @__PURE__ */ function(Textarea) {
      _inherits(AdjustedBNFTextarea2, Textarea);
      var _super = _createSuper(AdjustedBNFTextarea2);
      function AdjustedBNFTextarea2() {
        _classCallCheck(this, AdjustedBNFTextarea2);
        return _super.apply(this, arguments);
      }
      _createClass(AdjustedBNFTextarea2, [
        {
          key: "getAdjustedBNF",
          value: function getAdjustedBNF() {
            var value = this.getValue(), adjustedBNF = value;
            return adjustedBNF;
          }
        },
        {
          key: "setAdjustedBNF",
          value: function setAdjustedBNF(adjustedBNF) {
            var value = adjustedBNF;
            this.setValue(value);
          }
        },
        {
          key: "clearAdjustedBNF",
          value: function clearAdjustedBNF() {
            var value = "";
            this.setValue(value);
          }
        },
        {
          key: "parentContext",
          value: function parentContext() {
            var getAdjustedBNF = this.getAdjustedBNF.bind(this), setAdjustedBNF = this.setAdjustedBNF.bind(this), clearAdjustedBNF = this.clearAdjustedBNF.bind(this);
            return {
              getAdjustedBNF,
              setAdjustedBNF,
              clearAdjustedBNF
            };
          }
        }
      ]);
      return AdjustedBNFTextarea2;
    }(_textarea.default);
    exports.default = AdjustedBNFTextarea;
    _defineProperty(AdjustedBNFTextarea, "defaultProperties", {
      className: "adjusted-bnf",
      spellCheck: "false",
      readOnly: false
    });
  });

  // lib/example/checkbox/removeOrRenameIntermediateNodes.js
  var require_removeOrRenameIntermediateNodes2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  zoom: 1.5;\n  margin-right: 0.5rem;\n  vertical-align: bottom;\n  \n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var RemoveOrRenameIntermediateNodesCheckbox = /* @__PURE__ */ function(Checkbox) {
      _inherits(RemoveOrRenameIntermediateNodesCheckbox2, Checkbox);
      var _super = _createSuper(RemoveOrRenameIntermediateNodesCheckbox2);
      function RemoveOrRenameIntermediateNodesCheckbox2() {
        _classCallCheck(this, RemoveOrRenameIntermediateNodesCheckbox2);
        return _super.apply(this, arguments);
      }
      _createClass(RemoveOrRenameIntermediateNodesCheckbox2, [
        {
          key: "parentContext",
          value: function parentContext() {
            var isRemoveOrRenameIntermediateNodesCheckboxChecked = this.isChecked.bind(this);
            return {
              isRemoveOrRenameIntermediateNodesCheckboxChecked
            };
          }
        }
      ]);
      return RemoveOrRenameIntermediateNodesCheckbox2;
    }(_easy2.Checkbox);
    _defineProperty(RemoveOrRenameIntermediateNodesCheckbox, "defaultProperties", {
      className: "remove-or-rename-intermediate-nodes",
      spellCheck: "false"
    });
    var _default = (0, _easyWithStyle2).default(RemoveOrRenameIntermediateNodesCheckbox)(_templateObject());
    exports.default = _default;
  });

  // lib/constants.js
  var require_constants8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UNASSIGNED_ENTRY = exports.EMPTY_STRING = void 0;
    var EMPTY_STRING = "";
    exports.EMPTY_STRING = EMPTY_STRING;
    var UNASSIGNED_ENTRY = "^.*$";
    exports.UNASSIGNED_ENTRY = UNASSIGNED_ENTRY;
  });

  // lib/utilities/rules.js
  var require_rules2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rulesAsString = rulesAsString;
    exports.ruleMapFromRules = ruleMapFromRules;
    exports.startRuleFromRules = startRuleFromRules;
    exports.rulesFromStartRuleAndRuleMap = rulesFromStartRuleAndRuleMap;
    var _necessary = require_browser();
    var _constants = require_constants8();
    var first = _necessary.arrayUtilities.first;
    var filter = _necessary.arrayUtilities.filter;
    function rulesAsString(rules, multiLine) {
      var maximumRuleNameLength1 = rules.reduce(function(maximumRuleNameLength, rule) {
        var ruleName = rule.getName(), ruleNameLength = ruleName.length;
        maximumRuleNameLength = Math.max(maximumRuleNameLength, ruleNameLength);
        return maximumRuleNameLength;
      }, 0), rulesString1 = rules.reduce(function(rulesString, rule) {
        var ruleString = rule.asString(maximumRuleNameLength1, multiLine);
        rulesString += ruleString;
        return rulesString;
      }, _constants.EMPTY_STRING).replace(/^\n\n/, _constants.EMPTY_STRING);
      return rulesString1;
    }
    function ruleMapFromRules(rules) {
      var ruleMap = {};
      rules.forEach(function(rule) {
        var ruleName = rule.getName();
        ruleMap[ruleName] = rule;
      });
      return ruleMap;
    }
    function startRuleFromRules(rules) {
      var firstRule = first(rules), startRule = firstRule;
      return startRule;
    }
    function rulesFromStartRuleAndRuleMap(startRule, ruleMap) {
      var rules = Object.values(ruleMap), startRuleName = startRule.getName();
      filter(rules, function(rule) {
        var ruleName = rule.getName();
        if (ruleName !== startRuleName) {
          return true;
        }
      });
      rules.unshift(startRule);
      return rules;
    }
  });

  // lib/utilities/parser.js
  var require_parser6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rulesFromBNF = rulesFromBNF;
    exports.parserFromRules = parserFromRules;
    var _occamLexers = require_lib3();
    var _occamParsers = require_lib4();
    var _rules = require_rules2();
    var _eliminateLeftRecursion = _interopRequireDefault2(require_eliminateLeftRecursion());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var bnfLexer = _occamLexers.BNFLexer.fromNothing();
    var bnfParser = _occamParsers.BNFParser.fromNothing();
    function rulesFromBNF(bnf) {
      var tokens = bnfLexer.tokensFromBNF(bnf), rules = bnfParser.rulesFromTokens(tokens);
      return rules;
    }
    function parserFromRules(Class, rules) {
      var ruleMap = (0, _rules).ruleMapFromRules(rules);
      var startRule = (0, _rules).startRuleFromRules(rules);
      startRule = (0, _eliminateLeftRecursion).default(startRule, ruleMap);
      var parser = new Class(startRule, ruleMap);
      return parser;
    }
  });

  // lib/example/view.js
  var require_view = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _easyWithStyle2 = _interopRequireDefault2(require_lib7());
    var _easy2 = require_lib();
    var _occamLexers = require_lib3();
    var _occamParsers = require_lib4();
    var _easyLayout = require_lib8();
    var _index = require_lib9();
    var _paragraph = _interopRequireDefault2(require_paragraph());
    var _subHeading = _interopRequireDefault2(require_subHeading());
    var _sizeable = _interopRequireDefault2(require_sizeable2());
    var _bnf = _interopRequireDefault2(require_bnf5());
    var _content = _interopRequireDefault2(require_content3());
    var _parseTree = _interopRequireDefault2(require_parseTree2());
    var _lexicalPattern = _interopRequireDefault2(require_lexicalPattern());
    var _adjustedBNF = _interopRequireDefault2(require_adjustedBNF());
    var _removeOrRenameIntermediateNodes = _interopRequireDefault2(require_removeOrRenameIntermediateNodes2());
    var _parser = require_parser6();
    var _constants = require_constants8();
    var _rules = require_rules2();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [
            null
          ];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }
      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }
    var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _templateObject() {
      var data = _taggedTemplateLiteral([
        "\n\n  padding: 1rem;\n  \n"
      ]);
      _templateObject = function _templateObject2() {
        return data;
      };
      return data;
    }
    var View = /* @__PURE__ */ function(Element) {
      _inherits(View2, Element);
      var _super = _createSuper(View2);
      function View2() {
        _classCallCheck(this, View2);
        return _super.apply(this, arguments);
      }
      _createClass(View2, [
        {
          key: "getParseTree",
          value: function getParseTree(startRule, ruleMap) {
            var parseTree = null;
            var lexicalPattern = this.getLexicalPattern(), unassigned = _constants.UNASSIGNED_ENTRY, custom = lexicalPattern, entries = [
              {
                custom
              },
              {
                unassigned
              }
            ], basicLexer = _occamLexers.BasicLexer.fromEntries(entries), basicParser = new _occamParsers.BasicParser(startRule, ruleMap), content = this.getContent(), tokens = basicLexer.tokenise(content), node = basicParser.parse(tokens);
            if (node !== null) {
              var removeOrRenameIntermediateNodesCheckboxChecked = this.isRemoveOrRenameIntermediateNodesCheckboxChecked();
              if (removeOrRenameIntermediateNodesCheckboxChecked) {
                (0, _index).removeOrRenameIntermediateNodes(node);
              }
              parseTree = node.asParseTree(tokens);
            }
            return parseTree;
          }
        },
        {
          key: "keyUpHandler",
          value: function keyUpHandler(event, element) {
            this.changeHandler();
          }
        },
        {
          key: "changeHandler",
          value: function changeHandler(event, element) {
            try {
              var bnf = this.getBNF();
              var rules = (0, _parser).rulesFromBNF(bnf), startRule = (0, _rules).startRuleFromRules(rules);
              var ruleMap = (0, _rules).ruleMapFromRules(rules);
              startRule = (0, _index).eliminateLeftRecursion(startRule, ruleMap);
              rules = (0, _rules).rulesFromStartRuleAndRuleMap(startRule, ruleMap);
              var multiLine = true, parseTree = this.getParseTree(startRule, ruleMap), rulesString = (0, _rules).rulesAsString(rules, multiLine), adjustedBNF = rulesString;
              this.setParseTree(parseTree);
              this.setAdjustedBNF(adjustedBNF);
            } catch (error) {
              console.log(error);
              this.clearParseTree();
              this.clearAdjustedBNF();
            }
          }
        },
        {
          key: "childElements",
          value: function childElements() {
            var keyUpHandler = this.keyUpHandler.bind(this), changeHandler = this.changeHandler.bind(this);
            return [
              /* @__PURE__ */ React.createElement(_easyLayout.ColumnsDiv, null, /* @__PURE__ */ React.createElement(_sizeable.default, null, /* @__PURE__ */ React.createElement(_easyLayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Lexical pattern"), /* @__PURE__ */ React.createElement(_lexicalPattern.default, {
                onKeyUp: keyUpHandler
              }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "BNF"), /* @__PURE__ */ React.createElement(_bnf.default, {
                onKeyUp: keyUpHandler
              }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Adjusted BNF"), /* @__PURE__ */ React.createElement(_adjustedBNF.default, {
                readOnly: true
              }))), /* @__PURE__ */ React.createElement(_easyLayout.VerticalSplitterDiv, null), /* @__PURE__ */ React.createElement(_easyLayout.ColumnDiv, null, /* @__PURE__ */ React.createElement(_easyLayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Content"), /* @__PURE__ */ React.createElement(_content.default, {
                onKeyUp: keyUpHandler
              }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Parse tree"), /* @__PURE__ */ React.createElement(_parseTree.default, null), /* @__PURE__ */ React.createElement(_paragraph.default, null, /* @__PURE__ */ React.createElement(_removeOrRenameIntermediateNodes.default, {
                onChange: changeHandler,
                checked: true
              }), "Remove or rename intermediate nodes"))))
            ];
          }
        },
        {
          key: "initialise",
          value: function initialise() {
            this.assignContext();
            var _constructor = this.constructor, initialBNF = _constructor.initialBNF, initialContent = _constructor.initialContent, initialLexicalPattern = _constructor.initialLexicalPattern, bnf = initialBNF, content = initialContent, lexicalPattern = initialLexicalPattern;
            this.setBNF(bnf);
            this.setContent(content);
            this.setLexicalPattern(lexicalPattern);
            this.keyUpHandler();
          }
        }
      ]);
      return View2;
    }(_wrapNativeSuper(_easy2.Element));
    _defineProperty(View, "initialBNF", '\nexpression    ::= expression operator expression\n\n                | "(" expression ")"\n\n                | term\n\n                ;\n\noperator      ::= "+" | "-" | "/" | "*" ;\n\nterm          ::= /\\d+/ ;\n');
    _defineProperty(View, "initialContent", "(1+2)/3");
    _defineProperty(View, "initialLexicalPattern", "\\d+|.");
    _defineProperty(View, "tagName", "div");
    _defineProperty(View, "defaultProperties", {
      className: "view"
    });
    var _default = (0, _easyWithStyle2).default(View)(_templateObject());
    exports.default = _default;
  });

  // lib/example.js
  "use strict";
  require_lib2();
  var _easyWithStyle = _interopRequireDefault(require_lib7());
  var _easy = require_lib();
  var _view = _interopRequireDefault(require_view());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var renderStyles = _easyWithStyle.default.renderStyles;
  var body = new _easy.Body();
  renderStyles();
  body.mount(/* @__PURE__ */ React.createElement(_view.default, null));
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL29mZnNldC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvYm91bmRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9kb20uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9lbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy90ZXh0RWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL2VsZW1lbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvanN4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9ldmVudFR5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMva2V5LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvY2xpY2suanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zdGF0ZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvY29udGVudFR5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvcmVzaXplLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9tb3VzZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL3Njcm9sbC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvcmVhY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvYm9keS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9saW5rLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvY2hhbmdlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9pbnB1dEVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2lucHV0RWxlbWVudC9pbnB1dC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9idXR0b24uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvc2VsZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2NoZWNrYm94LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9pbnB1dEVsZW1lbnQvdGV4dGFyZWEuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy93aW5kb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3dpbmRvdy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvYnV0dG9ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9qdXh0YXBvc2Uvc3JjL2p1eHRhcG9zZS5qcyIsICJub2RlX21vZHVsZXMvanV4dGFwb3NlL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdGFnTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvbGV2ZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL21ldGhvZHMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvaGVhZGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9rZXlDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9lbmNvZGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY2hhcmFjdGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9zdGF0dXNDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9jb250ZW50VHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvc3RhdHVzTWVzc2FnZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvdXRpbGl0aWVzL2FycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvaHR0cC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvYWpheC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvYXN5bmNocm9ub3VzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2NvbnRlbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9saWIvdG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9saWIvdG9rZW4vc2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3J1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvc3BlY2lhbFN5bWJvbHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvYm5mL2VudHJpZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL3Rva2VuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL2NvbW1vbi9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL3NpZ25pZmljYW50L3JlZ3VsYXJFeHByZXNzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL25vblNpZ25pZmljYW50L2VuZE9mTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL2JuZi9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9iYXNpYy9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvc2luZ2x5UXVvdGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvcHl0aG9uU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9saWIvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9saWIvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2YuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9saWIvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2YvcHl0aG9uU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9saWIvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL2Jhc2ljL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL3NpZ25pZmljYW50L2VuZE9mTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9zaWduaWZpY2FudC9jb21tZW50L2VuZE9mTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvY1N0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvbGliL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL2NTdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL2NTdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL2xpYi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL2Nzcy9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jc3MvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2JuZi9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmYXVsdHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnNlVHJlZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFyc2VUcmVlL3ZlcnRpY2FsQnJhbmNoLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9wYXJzZVRyZWUvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnNlVHJlZS9ob3Jpem9udGFsQnJhbmNoLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9wYXJzZVRyZWUvY2hpbGROb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFyc2VUcmVlL25vblRlcm1pbmFsTm9kZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS9ub25UZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS9ibmYvbmFtZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvdXRpbGl0aWVzL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9sb29rQWhlYWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvdGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnNlVHJlZS90ZXJtaW5hbE5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvdGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vbmFtZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZU5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvbm9uVGVybWluYWwvY29sbGVjdGlvbk9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9wYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL3BhcnRSdWxlL3Rlcm1pbmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL3BhcnRSdWxlL25vblRlcm1pbmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL3J1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvdGVybWluYWwvdGVybWluYWxTeW1ib2wuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9ydWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFydC90ZXJtaW5hbC93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvZGVmaW5pdGlvbi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvZGVmaW5pdGlvbi9kb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9kb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS9ibmYvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL3dpbGRjYXJkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL3Rlcm1pbmFsU3ltYm9sLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL3dpbGRjYXJkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9wYXJzZVRyZWUvZW5kT2ZMaW5lTm9kZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS90ZXJtaW5hbC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvdGVybWluYWwvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL3F1YW50aWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9kZWZpbml0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9kZWZpbml0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vZGVmaW5pdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvZGVmaW5pdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL3BhcnQvdGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvdGVybWluYWxQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9jaG9pY2VPZlBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS9ibmYvdGVybWluYWxTeW1ib2wuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvdGVybWluYWxTeW1ib2wuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL3BhcnQvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvbm9uVGVybWluYWxQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2RlZmluaXRpb24vc2VxdWVuY2VPZlBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL3NlcXVlbmNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFyc2VUcmVlL25vV2hpdGVzcGFjZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvdGVybWluYWwvbm9XaGl0ZXNwYWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9wYXJ0L3Rlcm1pbmFsL25vV2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvbm9kZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvZGVmaW5pdGlvbi9ub1doaXRlc3BhY2VQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL25vV2hpdGVzcGFjZVBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL21vZGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL2xvb2tBaGVhZE1vZGlmaWVyUnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9sb29rQWhlYWRNb2RpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvZGVmaW5pdGlvbi9hbWJpZ3VvdXNNb2RpZmllclJ1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3J1bGUvYW1iaWd1b3VzTW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL3BhcnQvdGVybWluYWwvcmVndWxhckV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL3JlZ3VsYXJFeHByZXNzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9xdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9kZWZpbml0aW9uL3F1YW50aWZpZXJSdWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL29wdGlvbmFsUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9vbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ydWxlL3plcm9Pck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ub2RlL2JuZi9zaWduaWZpY2FudFRva2VuVHlwZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcnVsZS9zaWduaWZpY2FudFRva2VuVHlwZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvdXRpbGl0aWVzL3J1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL2xpYi9ibmYvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9iYXNpYy9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2NvbW1vbi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvbGliL2Jhc2ljL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9saWIvcGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jc3MvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jc3MvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1kb20vbGliL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZG9tL3NyYy9zcHJlYWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWRvbS9zcmMvcXVlcnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWRvbS9zcmMvdXRpbGl0aWVzL3F1ZXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1kb20vc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9kZWNsYXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvZGVjbGFyYXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0cy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvbWVkaWEuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL21lZGlhcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9zdHlsZXMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzc05hbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS13aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktd2l0aC1zdHlsZS9saWIvd2l0aFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvb3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9yb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvcm93cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9jb2x1bW4uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvY29sdW1ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9zaXplYWJsZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2N1cnNvci5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvbGliL2Rpdi9zcGxpdHRlci5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9zcGxpdHRlci92ZXJ0aWNhbC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9zcGxpdHRlci9ob3Jpem9udGFsLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvaW5kZXguanMiLCAic3JjL3V0aWxpdGllcy9jbGFzcy5qcyIsICJzcmMvdXRpbGl0aWVzL3J1bGVOYW1lLmpzIiwgInNyYy91dGlsaXRpZXMvcnVsZS5qcyIsICJzcmMvdHlwZXMuanMiLCAic3JjL3V0aWxpdGllcy9yZWN1cnNpdmVQYXJ0LmpzIiwgInNyYy91dGlsaXRpZXMvZGVmaW5pdGlvbi5qcyIsICJsaWIvZGVmaW5pdGlvbi9yZWN1cnNpdmUuanMiLCAibGliL2RlZmluaXRpb24vbGVmdFJlY3Vyc2l2ZS5qcyIsICJzcmMvbm9kZS9yZWR1Y2VkLmpzIiwgInNyYy9ydWxlL3JlZHVjZWQuanMiLCAic3JjL25vZGUvcmVwZWF0ZWQuanMiLCAic3JjL3J1bGUvcmVwZWF0ZWQuanMiLCAic3JjL3V0aWxpdGllcy9wYXJ0LmpzIiwgInNyYy9kZWZpbml0aW9uL3J1bGVOYW1lLmpzIiwgInNyYy9ydWxlL3Jld3JpdHRlbi5qcyIsICJzcmMvdXRpbGl0aWVzL3BhcnRzLmpzIiwgInNyYy9kZWZpbml0aW9uL3JlcGVhdGVkLmpzIiwgInNyYy9kZWZpbml0aW9uL3Jld3JpdHRlbi5qcyIsICJzcmMvZGVmaW5pdGlvbi9sZWZ0UmVjdXJzaXZlL2RpcmVjdGx5LmpzIiwgImxpYi9kZWZpbml0aW9uL2xlZnRSZWN1cnNpdmUvaW1wbGljaXRseS5qcyIsICJsaWIvZGVmaW5pdGlvbi9sZWZ0UmVjdXJzaXZlL2luZGlyZWN0bHkuanMiLCAic3JjL2VsaW1pbmF0ZUxlZnRSZWN1cnNpb24uanMiLCAic3JjL3JlbW92ZU9yUmVuYW1lSW50ZXJtZWRpYXRlTm9kZXMuanMiLCAic3JjL2luZGV4LmpzIiwgInNyYy9leGFtcGxlL3BhcmFncmFwaC5qcyIsICJzcmMvZXhhbXBsZS9zdWJIZWFkaW5nLmpzIiwgInNyYy9leGFtcGxlL2Rpdi9zaXplYWJsZS5qcyIsICJzcmMvZXhhbXBsZS90ZXh0YXJlYS5qcyIsICJzcmMvZXhhbXBsZS90ZXh0YXJlYS9ibmYuanMiLCAic3JjL2V4YW1wbGUvdGV4dGFyZWEvY29udGVudC5qcyIsICJzcmMvZXhhbXBsZS90ZXh0YXJlYS9wYXJzZVRyZWUuanMiLCAic3JjL2V4YW1wbGUvaW5wdXQvbGV4aWNhbFBhdHRlcm4uanMiLCAic3JjL2V4YW1wbGUvdGV4dGFyZWEvYWRqdXN0ZWRCTkYuanMiLCAic3JjL2V4YW1wbGUvY2hlY2tib3gvcmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlcy5qcyIsICJzcmMvY29uc3RhbnRzLmpzIiwgInNyYy91dGlsaXRpZXMvcnVsZXMuanMiLCAic3JjL3V0aWxpdGllcy9wYXJzZXIuanMiLCAic3JjL2V4YW1wbGUvdmlldy5qcyIsICJzcmMvZXhhbXBsZS5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9mZnNldCB7XG4gIGNvbnN0cnVjdG9yKHRvcCwgbGVmdCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdW5kcyB7XG4gIGNvbnN0cnVjdG9yKHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG5cbiAgZ2V0VG9wKCkge1xuICAgIHJldHVybiB0aGlzLnRvcDtcbiAgfVxuXG4gIGdldExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdDtcbiAgfVxuXG4gIGdldFJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0O1xuICB9XG5cbiAgZ2V0Qm90dG9tKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxuXG4gIGdldFdpZHRoKCkge1xuICAgIGNvbnN0IHdpZHRoID0gKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpO1xuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIGNvbnN0IGhlaWdodCA9ICh0aGlzLmJvdHRvbSAtIHRoaXMudG9wKTtcblxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH1cbiAgXG4gIHNldFRvcCh0b3ApIHtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgfVxuXG4gIHNldExlZnQobGVmdCkge1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gIH1cblxuICBzZXRSaWdodChyaWdodCkge1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgfVxuXG4gIHNldEJvdHRvbShib3R0b20pIHtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgfVxuXG4gIHNoaWZ0KGhvcml6b250YWxPZmZzZXQsIHZlcnRpY2FsT2Zmc2V0KSB7XG4gICAgdGhpcy50b3AgKz0gdmVydGljYWxPZmZzZXQ7XG4gICAgdGhpcy5sZWZ0ICs9IGhvcml6b250YWxPZmZzZXQ7XG4gICAgdGhpcy5yaWdodCArPSBob3Jpem9udGFsT2Zmc2V0O1xuICAgIHRoaXMuYm90dG9tICs9IHZlcnRpY2FsT2Zmc2V0O1xuICB9XG5cbiAgaXNPdmVybGFwcGluZ01vdXNlKG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgICByZXR1cm4gKCAgKHRoaXMudG9wIDw9IG1vdXNlVG9wKVxuICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDw9IG1vdXNlTGVmdClcbiAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBtb3VzZUxlZnQpXG4gICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IG1vdXNlVG9wKSAgKTtcbiAgfVxuXG4gIGFyZU92ZXJsYXBwaW5nKGJvdW5kcykge1xuICAgIHJldHVybiAoICAodGhpcy50b3AgPCBib3VuZHMuYm90dG9tKVxuICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDwgYm91bmRzLnJpZ2h0KVxuICAgICAgICAgICAmJiAodGhpcy5yaWdodCA+IGJvdW5kcy5sZWZ0KVxuICAgICAgICAgICAmJiAodGhpcy5ib3R0b20gPiBib3VuZHMudG9wKSAgKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQm91bmRpbmdDbGllbnRSZWN0KGJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgIGNvbnN0IHdpbmRvd1Njcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCwgLy8vXG4gICAgICAgICAgd2luZG93U2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCwgIC8vL1xuICAgICAgICAgIHRvcCA9IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyB3aW5kb3dTY3JvbGxUb3AsXG4gICAgICAgICAgbGVmdCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgd2luZG93U2Nyb2xsTGVmdCxcbiAgICAgICAgICByaWdodCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5yaWdodCArIHdpbmRvd1Njcm9sbExlZnQsXG4gICAgICAgICAgYm90dG9tID0gYm91bmRpbmdDbGllbnRSZWN0LmJvdHRvbSArIHdpbmRvd1Njcm9sbFRvcCxcbiAgICAgICAgICBib3VuZHMgPSBuZXcgQm91bmRzKHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSk7XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ub3BMZWZ0V2lkdGhBbmRIZWlnaHQodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0LFxuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoLFxuICAgICAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHModG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKTtcblxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEZPUiA9IFwiZm9yXCI7XG5leHBvcnQgY29uc3QgQk9EWSA9IFwiYm9keVwiO1xuZXhwb3J0IGNvbnN0IE5PTkUgPSBcIm5vbmVcIjtcbmV4cG9ydCBjb25zdCBTUEFDRSA9IFwiIFwiO1xuZXhwb3J0IGNvbnN0IENMQVNTID0gXCJjbGFzc1wiO1xuZXhwb3J0IGNvbnN0IFdJRFRIID0gXCJ3aWR0aFwiO1xuZXhwb3J0IGNvbnN0IEJMT0NLID0gXCJibG9ja1wiO1xuZXhwb3J0IGNvbnN0IEhFSUdIVCA9IFwiaGVpZ2h0XCI7XG5leHBvcnQgY29uc3QgT0JKRUNUID0gXCJvYmplY3RcIjtcbmV4cG9ydCBjb25zdCBTVFJJTkcgPSBcInN0cmluZ1wiO1xuZXhwb3J0IGNvbnN0IERJU1BMQVkgPSBcImRpc3BsYXlcIjtcbmV4cG9ydCBjb25zdCBCT09MRUFOID0gXCJib29sZWFuXCI7XG5leHBvcnQgY29uc3QgRElTQUJMRUQgPSBcImRpc2FibGVkXCI7XG5leHBvcnQgY29uc3QgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG5leHBvcnQgY29uc3QgV0lMRENBUkQgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBIVE1MX0ZPUiA9IFwiaHRtbEZvclwiO1xuZXhwb3J0IGNvbnN0IFVOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuZXhwb3J0IGNvbnN0IENMQVNTX05BTUUgPSBcImNsYXNzTmFtZVwiO1xuZXhwb3J0IGNvbnN0IEFCT1VUX0JMQU5LID0gXCJhYm91dDpibGFua1wiO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgU1ZHX05BTUVTUEFDRV9VUkkgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9QUk9QRVJUSUVTID0gXCJkZWZhdWx0UHJvcGVydGllc1wiO1xuZXhwb3J0IGNvbnN0IElHTk9SRURfUFJPUEVSVElFUyA9IFwiaWdub3JlZFByb3BlcnRpZXNcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQk9PTEVBTiB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUodGFyZ2V0LCBzb3VyY2UgPSB7fSkge1xuICB0YXJnZXQgPSB7IC4uLnRhcmdldCB9OyAgLy8vXG5cbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyAgLy8vXG5cbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W25hbWVdLFxuICAgICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW25hbWVdLFxuICAgICAgICAgIHRhcmdldEhhc093blByb3BlcnR5ID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpO1xuXG4gICAgdGFyZ2V0W25hbWVdID0gdGFyZ2V0SGFzT3duUHJvcGVydHkgP1xuICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZhbHVlcyh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU7IC8vL1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmUodGFyZ2V0LCBuYW1lcyA9IFtdKSB7XG4gIHRhcmdldCA9IHsgLi4udGFyZ2V0IH07ICAvLy9cblxuICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0SGFzT3duUHJvcGVydHkgPSB0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSk7XG5cbiAgICBpZiAodGFyZ2V0SGFzT3duUHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbmFtZV07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21iaW5lVmFsdWVzKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuICBjb25zdCB0YXJnZXRWYWx1ZUJvb2xlYW4gPSBpc1ZhbHVlQm9vbGVhbih0YXJnZXRWYWx1ZSksXG4gICAgICAgIHNvdXJjZVZhbHVlQm9vbGVhbiA9IGlzVmFsdWVCb29sZWFuKHNvdXJjZVZhbHVlKSxcbiAgICAgICAgY29tYmluZWRWYWx1ZSA9ICh0YXJnZXRWYWx1ZUJvb2xlYW4gJiYgc291cmNlVmFsdWVCb29sZWFuKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlIDogLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGFyZ2V0VmFsdWV9ICR7c291cmNlVmFsdWV9YDtcblxuICByZXR1cm4gY29tYmluZWRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNWYWx1ZUJvb2xlYW4odmFsdWUpIHtcbiAgY29uc3QgdmFsdWVCb29sZWFuID0gKHR5cGVvZiB2YWx1ZSA9PT0gQk9PTEVBTik7XG5cbiAgcmV0dXJuIHZhbHVlQm9vbGVhbjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7IHJldHVybiBhcnJheVswXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheTEsIGFycmF5MikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheTEsIGFycmF5Mik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnQoYXJyYXkxLCBhcnJheTIsIHRlc3QpIHtcbiAgYXJyYXkxID0gWyAuLi5hcnJheTEgXTsgLy8vXG5cbiAgYXJyYXkyLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheTEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGFycmF5LCBlbGVtZW50KSA9PiB7XG4gICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZWxlbWVudCk7ICAvLy9cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSwgW10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3VhcmFudGVlKGFycmF5T3JFbGVtZW50KSB7XG4gIGFycmF5T3JFbGVtZW50ID0gYXJyYXlPckVsZW1lbnQgfHwgW107XG5cbiAgcmV0dXJuIChhcnJheU9yRWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICBhcnJheU9yRWxlbWVudCA6XG4gICAgICAgICAgICAgIFthcnJheU9yRWxlbWVudF07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NWR1RhZ05hbWUodGFnTmFtZSkge1xuICByZXR1cm4gc3ZnVGFnTmFtZXMuaW5jbHVkZXModGFnTmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NWR0F0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICByZXR1cm4gc3ZnQXR0cmlidXRlTmFtZXMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hUTUxBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcmV0dXJuIGh0bWxBdHRyaWJ1dGVOYW1lcy5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKTtcbn1cblxuY29uc3Qgc3ZnVGFnTmFtZXMgPSBbXG4gICAgICAgIFwiYWx0R2x5cGhcIiwgXCJhbmltYXRlXCIsIFwiYW5pbWF0ZUNvbG9yXCIsIFwiYW5pbWF0ZU1vdGlvblwiLCBcImFuaW1hdGVUcmFuc2Zvcm1cIiwgXCJhbmltYXRpb25cIiwgXCJhdWRpb1wiLFxuICAgICAgICBcImNpcmNsZVwiLCBcImNsaXBQYXRoXCIsIFwiY29sb3ItcHJvZmlsZVwiLCBcImN1cnNvclwiLFxuICAgICAgICBcImRlZnNcIiwgXCJkZXNjXCIsIFwiZGlzY2FyZFwiLFxuICAgICAgICBcImVsbGlwc2VcIixcbiAgICAgICAgXCJmZUJsZW5kXCIsIFwiZmVDb2xvck1hdHJpeFwiLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIiwgXCJmZUNvbXBvc2l0ZVwiLCBcImZlQ29udm9sdmVNYXRyaXhcIiwgXCJmZURpZmZ1c2VMaWdodGluZ1wiLCBcImZlRGlzcGxhY2VtZW50TWFwXCIsIFwiZmVEaXN0YW50TGlnaHRcIiwgXCJmZURyb3BTaGFkb3dcIiwgXCJmZUZsb29kXCIsIFwiZmVGdW5jQVwiLCBcImZlRnVuY0JcIiwgXCJmZUZ1bmNHXCIsIFwiZmVGdW5jUlwiLCBcImZlR2F1c3NpYW5CbHVyXCIsIFwiZmVJbWFnZVwiLCBcImZlTWVyZ2VcIiwgXCJmZU1lcmdlTm9kZVwiLCBcImZlTW9ycGhvbG9neVwiLCBcImZlT2Zmc2V0XCIsIFwiZmVQb2ludExpZ2h0XCIsIFwiZmVTcGVjdWxhckxpZ2h0aW5nXCIsIFwiZmVTcG90TGlnaHRcIiwgXCJmZVRpbGVcIiwgXCJmZVR1cmJ1bGVuY2VcIiwgXCJmaWx0ZXJcIiwgXCJmb250XCIsIFwiZm9udC1mYWNlXCIsIFwiZm9udC1mYWNlLWZvcm1hdFwiLCBcImZvbnQtZmFjZS1uYW1lXCIsIFwiZm9udC1mYWNlLXVyaVwiLCBcImZvcmVpZ25PYmplY3RcIixcbiAgICAgICAgXCJnXCIsIFwiZ2x5cGhcIiwgXCJnbHlwaFJlZlwiLFxuICAgICAgICBcImhhbmRsZXJcIiwgXCJoYXRjaFwiLCBcImhhdGNocGF0aFwiLCBcImhrZXJuXCIsXG4gICAgICAgIFwiaW1hZ2VcIiwgXCJsaW5lXCIsIFwibGluZWFyR3JhZGllbnRcIixcbiAgICAgICAgXCJsaXN0ZW5lclwiLFxuICAgICAgICBcIm1hcmtlclwiLCBcIm1hc2tcIiwgXCJtZXNoXCIsIFwibWVzaGdyYWRpZW50XCIsIFwibWVzaHBhdGNoXCIsIFwibWVzaHJvd1wiLCBcIm1ldGFkYXRhXCIsIFwibWlzc2luZy1nbHlwaFwiLCBcIm1wYXRoXCIsXG4gICAgICAgIFwicGF0aFwiLCBcInBhdHRlcm5cIiwgXCJwb2x5Z29uXCIsIFwicG9seWxpbmVcIiwgXCJwcmVmZXRjaFwiLFxuICAgICAgICBcInJhZGlhbEdyYWRpZW50XCIsIFwicmVjdFwiLFxuICAgICAgICBcInNjcmlwdFwiLCBcInNldFwiLCBcInNvbGlkY29sb3JcIiwgXCJzdG9wXCIsIFwic3R5bGVcIiwgXCJzdmdcIiwgXCJzd2l0Y2hcIiwgXCJzeW1ib2xcIixcbiAgICAgICAgXCJ0YnJlYWtcIiwgXCJ0ZXh0XCIsIFwidGV4dEFyZWFcIiwgXCJ0ZXh0UGF0aFwiLCBcInRpdGxlXCIsIFwidHJlZlwiLCBcInRzcGFuXCIsXG4gICAgICAgIFwidW5rbm93blwiLCBcInVzZVwiLFxuICAgICAgICBcInZpZGVvXCIsIFwidmlld1wiLCBcInZrZXJuXCJcbiAgICAgIF0sXG4gICAgICBzdmdBdHRyaWJ1dGVOYW1lcyA9IFtcbiAgICAgICAgXCJhY2NlbnQtaGVpZ2h0XCIsIFwiYWNjdW11bGF0ZVwiLCBcImFkZGl0aXZlXCIsIFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwiYWxwaGFiZXRpY1wiLCBcImFtcGxpdHVkZVwiLCBcImFyYWJpYy1mb3JtXCIsIFwiYXNjZW50XCIsIFwiYXR0cmlidXRlTmFtZVwiLCBcImF0dHJpYnV0ZVR5cGVcIiwgXCJhemltdXRoXCIsXG4gICAgICAgIFwiYmFuZHdpZHRoXCIsIFwiYmFzZUZyZXF1ZW5jeVwiLCBcImJhc2VQcm9maWxlXCIsIFwiYmFzZWxpbmUtc2hpZnRcIiwgXCJiYm94XCIsIFwiYmVnaW5cIiwgXCJiaWFzXCIsIFwiYnlcIixcbiAgICAgICAgXCJjYWxjTW9kZVwiLCBcImNhcC1oZWlnaHRcIiwgXCJjbGlwXCIsIFwiY2xhc3NOYW1lXCIsIFwiY2xpcC1wYXRoXCIsIFwiY2xpcC1ydWxlXCIsIFwiY2xpcFBhdGhVbml0c1wiLCBcImNvbG9yXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJjb2xvci1yZW5kZXJpbmdcIiwgXCJjb250ZW50U2NyaXB0VHlwZVwiLCBcImNvbnRlbnRTdHlsZVR5cGVcIiwgXCJjcm9zc29yaWdpblwiLCBcImN1cnNvclwiLCBcImN4XCIsIFwiY3lcIixcbiAgICAgICAgXCJkXCIsIFwiZGVmYXVsdEFjdGlvblwiLCBcImRlc2NlbnRcIiwgXCJkaWZmdXNlQ29uc3RhbnRcIiwgXCJkaXJlY3Rpb25cIiwgXCJkaXNwbGF5XCIsIFwiZGl2aXNvclwiLCBcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiZG93bmxvYWRcIiwgXCJkdXJcIiwgXCJkeFwiLCBcImR5XCIsXG4gICAgICAgIFwiZWRnZU1vZGVcIiwgXCJlZGl0YWJsZVwiLCBcImVsZXZhdGlvblwiLCBcImVuYWJsZS1iYWNrZ3JvdW5kXCIsIFwiZW5kXCIsIFwiZXZlbnRcIiwgXCJleHBvbmVudFwiLCBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsIFwiZmlsdGVyXCIsIFwiZmlsdGVyUmVzXCIsIFwiZmlsdGVyVW5pdHNcIiwgXCJmbG9vZC1jb2xvclwiLCBcImZsb29kLW9wYWNpdHlcIiwgXCJmb2N1c0hpZ2hsaWdodFwiLCBcImZvY3VzYWJsZVwiLCBcImZvbnQtZmFtaWx5XCIsIFwiZm9udC1zaXplXCIsIFwiZm9udC1zaXplLWFkanVzdFwiLCBcImZvbnQtc3RyZXRjaFwiLCBcImZvbnQtc3R5bGVcIiwgXCJmb250LXZhcmlhbnRcIiwgXCJmb250LXdlaWdodFwiLCBcImZvcm1hdFwiLCBcImZyXCIsIFwiZnJvbVwiLCBcImZ4XCIsIFwiZnlcIixcbiAgICAgICAgXCJnMVwiLCBcImcyXCIsIFwiZ2x5cGgtbmFtZVwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiLCBcImdseXBoUmVmXCIsIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIiwgXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIFwiaGFuZGxlclwiLCBcImhhbmdpbmdcIiwgXCJoYXRjaENvbnRlbnRVbml0c1wiLCBcImhhdGNoVW5pdHNcIiwgXCJoZWlnaHRcIiwgXCJob3Jpei1hZHYteFwiLCBcImhvcml6LW9yaWdpbi14XCIsIFwiaG9yaXotb3JpZ2luLXlcIiwgXCJocmVmXCIsIFwiaHJlZmxhbmdcIixcbiAgICAgICAgXCJpZFwiLCBcImlkZW9ncmFwaGljXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsIFwiaW5cIiwgXCJpbjJcIiwgXCJpbml0aWFsVmlzaWJpbGl0eVwiLCBcImludGVyY2VwdFwiLFxuICAgICAgICBcImtcIiwgXCJrMVwiLCBcImsyXCIsIFwiazNcIiwgXCJrNFwiLCBcImtlcm5lbE1hdHJpeFwiLCBcImtlcm5lbFVuaXRMZW5ndGhcIiwgXCJrZXJuaW5nXCIsIFwia2V5UG9pbnRzXCIsIFwia2V5U3BsaW5lc1wiLCBcImtleVRpbWVzXCIsXG4gICAgICAgIFwibGVuZ3RoQWRqdXN0XCIsIFwibGV0dGVyLXNwYWNpbmdcIiwgXCJsaWdodGluZy1jb2xvclwiLCBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsIFwibG9jYWxcIixcbiAgICAgICAgXCJtYXJrZXItZW5kXCIsIFwibWFya2VyLW1pZFwiLCBcIm1hcmtlci1zdGFydFwiLCBcIm1hcmtlckhlaWdodFwiLCBcIm1hcmtlclVuaXRzXCIsIFwibWFya2VyV2lkdGhcIiwgXCJtYXNrXCIsIFwibWFza0NvbnRlbnRVbml0c1wiLCBcIm1hc2tVbml0c1wiLCBcIm1hdGhlbWF0aWNhbFwiLCBcIm1heFwiLCBcIm1lZGlhXCIsIFwibWVkaWFDaGFyYWN0ZXJFbmNvZGluZ1wiLCBcIm1lZGlhQ29udGVudEVuY29kaW5nc1wiLCBcIm1lZGlhU2l6ZVwiLCBcIm1lZGlhVGltZVwiLCBcIm1ldGhvZFwiLCBcIm1pblwiLCBcIm1vZGVcIixcbiAgICAgICAgXCJuYW1lXCIsIFwibmF2LWRvd25cIiwgXCJuYXYtZG93bi1sZWZ0XCIsIFwibmF2LWRvd24tcmlnaHRcIiwgXCJuYXYtbGVmdFwiLCBcIm5hdi1uZXh0XCIsIFwibmF2LXByZXZcIiwgXCJuYXYtcmlnaHRcIiwgXCJuYXYtdXBcIiwgXCJuYXYtdXAtbGVmdFwiLCBcIm5hdi11cC1yaWdodFwiLCBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgXCJvYnNlcnZlclwiLCBcIm9mZnNldFwiLCBcIm9wYWNpdHlcIiwgXCJvcGVyYXRvclwiLCBcIm9yZGVyXCIsIFwib3JpZW50XCIsIFwib3JpZW50YXRpb25cIiwgXCJvcmlnaW5cIiwgXCJvdmVyZmxvd1wiLCBcIm92ZXJsYXlcIiwgXCJvdmVybGluZS1wb3NpdGlvblwiLCBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiLFxuICAgICAgICBcInBhbm9zZS0xXCIsIFwicGF0aFwiLCBcInBhdGhMZW5ndGhcIiwgXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsIFwicGF0dGVyblRyYW5zZm9ybVwiLCBcInBhdHRlcm5Vbml0c1wiLCBcInBoYXNlXCIsIFwicGl0Y2hcIiwgXCJwbGF5YmFja09yZGVyXCIsIFwicGxheWJhY2tvcmRlclwiLCBcInBvaW50ZXItZXZlbnRzXCIsIFwicG9pbnRzXCIsIFwicG9pbnRzQXRYXCIsIFwicG9pbnRzQXRZXCIsIFwicG9pbnRzQXRaXCIsIFwicHJlc2VydmVBbHBoYVwiLCBcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJwcmltaXRpdmVVbml0c1wiLCBcInByb3BhZ2F0ZVwiLFxuICAgICAgICBcInJcIiwgXCJyYWRpdXNcIiwgXCJyZWZYXCIsIFwicmVmWVwiLCBcInJlbmRlcmluZy1pbnRlbnRcIiwgXCJyZXBlYXRDb3VudFwiLCBcInJlcGVhdER1clwiLCBcInJlcXVpcmVkRXh0ZW5zaW9uc1wiLCBcInJlcXVpcmVkRmVhdHVyZXNcIiwgXCJyZXF1aXJlZEZvbnRzXCIsIFwicmVxdWlyZWRGb3JtYXRzXCIsIFwicmVzdGFydFwiLCBcInJlc3VsdFwiLCBcInJvdGF0ZVwiLCBcInJ4XCIsIFwicnlcIixcbiAgICAgICAgXCJzY2FsZVwiLCBcInNlZWRcIiwgXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJzaWRlXCIsIFwic2xvcGVcIiwgXCJzbmFwc2hvdFRpbWVcIiwgXCJzcGFjaW5nXCIsIFwic3BlY3VsYXJDb25zdGFudFwiLCBcInNwZWN1bGFyRXhwb25lbnRcIiwgXCJzcHJlYWRNZXRob2RcIiwgXCJzcmNcIiwgXCJzdGFydE9mZnNldFwiLCBcInN0ZERldmlhdGlvblwiLCBcInN0ZW1oXCIsIFwic3RlbXZcIiwgXCJzdGl0Y2hUaWxlc1wiLCBcInN0b3AtY29sb3JcIiwgXCJzdG9wLW9wYWNpdHlcIiwgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCIsIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIiwgXCJzdHJpbmdcIiwgXCJzdHJva2VcIiwgXCJzdHJva2UtZGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgXCJzdHJva2UtbGluZWNhcFwiLCBcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIiwgXCJzdHlsZVwiLCBcInN1cmZhY2VTY2FsZVwiLCBcInN5bmNCZWhhdmlvclwiLCBcInN5bmNCZWhhdmlvckRlZmF1bHRcIiwgXCJzeW5jTWFzdGVyXCIsIFwic3luY1RvbGVyYW5jZVwiLCBcInN5bmNUb2xlcmFuY2VEZWZhdWx0XCIsIFwic3lzdGVtTGFuZ3VhZ2VcIixcbiAgICAgICAgXCJ0YWJsZVZhbHVlc1wiLCBcInRhcmdldFwiLCBcInRhcmdldFhcIiwgXCJ0YXJnZXRZXCIsIFwidGV4dC1hbmNob3JcIiwgXCJ0ZXh0LWRlY29yYXRpb25cIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiLCBcInRleHRMZW5ndGhcIiwgXCJ0aW1lbGluZUJlZ2luXCIsIFwidGltZWxpbmViZWdpblwiLCBcInRpdGxlXCIsIFwidG9cIiwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1CZWhhdmlvclwiLCBcInR5cGVcIixcbiAgICAgICAgXCJ1MVwiLCBcInUyXCIsIFwidW5kZXJsaW5lLXBvc2l0aW9uXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiLCBcInVuaWNvZGVcIiwgXCJ1bmljb2RlLWJpZGlcIiwgXCJ1bmljb2RlLXJhbmdlXCIsIFwidW5pdHMtcGVyLWVtXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCIsIFwidi1oYW5naW5nXCIsIFwidi1pZGVvZ3JhcGhpY1wiLCBcInYtbWF0aGVtYXRpY2FsXCIsIFwidmFsdWVzXCIsIFwidmVyc2lvblwiLCBcInZlcnQtYWR2LXlcIiwgXCJ2ZXJ0LW9yaWdpbi14XCIsIFwidmVydC1vcmlnaW4teVwiLCBcInZpZXdCb3hcIiwgXCJ2aWV3VGFyZ2V0XCIsIFwidmlzaWJpbGl0eVwiLFxuICAgICAgICBcIndpZHRoXCIsIFwid2lkdGhzXCIsIFwid29yZC1zcGFjaW5nXCIsIFwid3JpdGluZy1tb2RlXCIsXG4gICAgICAgIFwieFwiLCBcIngtaGVpZ2h0XCIsIFwieDFcIiwgXCJ4MlwiLCBcInhDaGFubmVsU2VsZWN0b3JcIixcbiAgICAgICAgXCJ5XCIsIFwieTFcIiwgXCJ5MlwiLCBcInlDaGFubmVsU2VsZWN0b3JcIixcbiAgICAgICAgXCJ6XCIsIFwiem9vbUFuZFBhblwiXG4gICAgICBdLFxuICAgICAgaHRtbEF0dHJpYnV0ZU5hbWVzID0gW1xuICAgICAgICBcImFjY2VwdFwiLCBcImFjY2VwdENoYXJzZXRcIiwgXCJhY2Nlc3NLZXlcIiwgXCJhY3Rpb25cIiwgXCJhbGxvd1wiLCBcImFsbG93RnVsbFNjcmVlblwiLCBcImFsbG93VHJhbnNwYXJlbmN5XCIsIFwiYWx0XCIsIFwiYXN5bmNcIiwgXCJhdXRvQ29tcGxldGVcIiwgXCJhdXRvRm9jdXNcIiwgXCJhdXRvUGxheVwiLFxuICAgICAgICBcImNhcHR1cmVcIiwgXCJjZWxsUGFkZGluZ1wiLCBcImNlbGxTcGFjaW5nXCIsIFwiY2hhbGxlbmdlXCIsIFwiY2hhclNldFwiLCBcImNoZWNrZWRcIiwgXCJjaXRlXCIsIFwiY2xhc3NJRFwiLCBcImNsYXNzTmFtZVwiLCBcImNvbFNwYW5cIiwgXCJjb2xzXCIsIFwiY29udGVudFwiLCBcImNvbnRlbnRFZGl0YWJsZVwiLCBcImNvbnRleHRNZW51XCIsIFwiY29udHJvbHNcIiwgXCJjb29yZHNcIiwgXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBcImRhdGFcIiwgXCJkYXRlVGltZVwiLCBcImRlZmF1bHRcIiwgXCJkZWZlclwiLCBcImRpclwiLCBcImRpc2FibGVkXCIsIFwiZG93bmxvYWRcIiwgXCJkcmFnZ2FibGVcIixcbiAgICAgICAgXCJlbmNUeXBlXCIsXG4gICAgICAgIFwiZm9ybVwiLCBcImZvcm1BY3Rpb25cIiwgXCJmb3JtRW5jVHlwZVwiLCBcImZvcm1NZXRob2RcIiwgXCJmb3JtTm9WYWxpZGF0ZVwiLCBcImZvcm1UYXJnZXRcIiwgXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBcImhlYWRlcnNcIiwgXCJoZWlnaHRcIiwgXCJoaWRkZW5cIiwgXCJoaWdoXCIsIFwiaHJlZlwiLCBcImhyZWZMYW5nXCIsIFwiaHRtbEZvclwiLCBcImh0dHBFcXVpdlwiLFxuICAgICAgICBcImljb25cIiwgXCJpZFwiLCBcImlucHV0TW9kZVwiLCBcImludGVncml0eVwiLCBcImlzXCIsXG4gICAgICAgIFwia2V5UGFyYW1zXCIsIFwia2V5VHlwZVwiLCBcImtpbmRcIixcbiAgICAgICAgXCJsYWJlbFwiLCBcImxhbmdcIiwgXCJsaXN0XCIsIFwibG9vcFwiLCBcImxvd1wiLFxuICAgICAgICBcIm1hbmlmZXN0XCIsIFwibWFyZ2luSGVpZ2h0XCIsIFwibWFyZ2luV2lkdGhcIiwgXCJtYXhcIiwgXCJtYXhMZW5ndGhcIiwgXCJtZWRpYVwiLCBcIm1lZGlhR3JvdXBcIiwgXCJtZXRob2RcIiwgXCJtaW5cIiwgXCJtaW5MZW5ndGhcIiwgXCJtdWx0aXBsZVwiLCBcIm11dGVkXCIsXG4gICAgICAgIFwibmFtZVwiLCBcIm5vVmFsaWRhdGVcIiwgXCJub25jZVwiLFxuICAgICAgICBcIm9wZW5cIiwgXCJvcHRpbXVtXCIsXG4gICAgICAgIFwicGF0dGVyblwiLCBcInBsYWNlaG9sZGVyXCIsIFwicG9zdGVyXCIsIFwicHJlbG9hZFwiLCBcInByb2ZpbGVcIixcbiAgICAgICAgXCJyYWRpb0dyb3VwXCIsIFwicmVhZE9ubHlcIiwgXCJyZWxcIiwgXCJyZXF1aXJlZFwiLCBcInJldmVyc2VkXCIsIFwicm9sZVwiLCBcInJvd1NwYW5cIiwgXCJyb3dzXCIsXG4gICAgICAgIFwic2FuZGJveFwiLCBcInNjb3BlXCIsIFwic2NvcGVkXCIsIFwic2Nyb2xsaW5nXCIsIFwic2VhbWxlc3NcIiwgXCJzZWxlY3RlZFwiLCBcInNoYXBlXCIsIFwic2l6ZVwiLCBcInNpemVzXCIsIFwic3BhblwiLCBcInNwZWxsQ2hlY2tcIiwgXCJzcmNcIiwgXCJzcmNEb2NcIiwgXCJzcmNMYW5nXCIsIFwic3JjU2V0XCIsIFwic3RhcnRcIiwgXCJzdGVwXCIsIFwic3R5bGVcIiwgXCJzdW1tYXJ5XCIsXG4gICAgICAgIFwidGFiSW5kZXhcIiwgXCJ0YXJnZXRcIiwgXCJ0aXRsZVwiLCBcInR5cGVcIixcbiAgICAgICAgXCJ1c2VNYXBcIixcbiAgICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgIFwid21vZGVcIixcbiAgICAgICAgXCJ3cmFwXCJcbiAgICAgIF07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHB1c2ggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBXSUxEQ0FSRCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGRvbUVsZW1lbnRzKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnRzV2l0aEVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXMoZG9tRWxlbWVudHMsIChkb21FbGVtZW50KSA9PiAoZG9tRWxlbWVudC5fX2VsZW1lbnRfXyAhPT0gdW5kZWZpbmVkKSksXG4gICAgICAgIGVsZW1lbnRzID0gZG9tRWxlbWVudHNXaXRoRWxlbWVudHMubWFwKChkb21FbGVtZW50KSA9PiBkb21FbGVtZW50Ll9fZWxlbWVudF9fKTtcblxuICByZXR1cm4gZWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGhlaWdodCwgYXNjZW5kYW50RE9NTm9kZXMgPSBbXSkge1xuICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGUgPSBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7ICAvLy9cblxuICAgIGlmIChwYXJlbnRET01Ob2RlICE9PSBudWxsKSB7XG4gICAgICBhc2NlbmRhbnRET01Ob2Rlcy5wdXNoKHBhcmVudERPTU5vZGUpO1xuXG4gICAgICBoZWlnaHQtLTtcblxuICAgICAgYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShwYXJlbnRET01Ob2RlLCBoZWlnaHQsIGFzY2VuZGFudERPTU5vZGVzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXNjZW5kYW50RE9NTm9kZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShkb21Ob2RlLCBkZXB0aCwgZGVzY2VuZGFudERPTU5vZGVzID0gW10pIHtcbiAgaWYgKGRlcHRoID4gMCkge1xuICAgIGNvbnN0IGNoaWxkRE9NTm9kZXMgPSBkb21Ob2RlLmNoaWxkTm9kZXM7ICAvLy9cblxuICAgIHB1c2goZGVzY2VuZGFudERPTU5vZGVzLCBjaGlsZERPTU5vZGVzKTtcblxuICAgIGRlcHRoLS07XG5cbiAgICBjaGlsZERPTU5vZGVzLmZvckVhY2goKGNoaWxkRE9NTm9kZSkgPT4gZGVzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUoY2hpbGRET01Ob2RlLCBkZXB0aCwgZGVzY2VuZGFudERPTU5vZGVzKSk7XG4gIH1cblxuICByZXR1cm4gZGVzY2VuZGFudERPTU5vZGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGRvbU5vZGVzLCBzZWxlY3Rvcikge1xuICBjb25zdCBmaWx0ZXJlZERPTU5vZGVzID0gZmlsdGVyRE9NTm9kZXMoZG9tTm9kZXMsIChkb21Ob2RlKSA9PiBkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKGRvbU5vZGUsIHNlbGVjdG9yKSk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkRE9NTm9kZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKGRvbU5vZGUsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IGRvbU5vZGVUeXBlID0gZG9tTm9kZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKGRvbU5vZGVUeXBlKSB7XG4gICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvbU5vZGU7IC8vL1xuXG4gICAgICByZXR1cm4gZG9tRWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCB0ZXN0KSB7XG4gIGNvbnN0IGZpbHRlcmVkRE9NTm9kZXMgPSBbXSxcbiAgICAgICAgZG9tTm9kZXNMZW5ndGggPSBkb21Ob2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRvbU5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZG9tTm9kZSA9IGRvbU5vZGVzW2luZGV4XSxcbiAgICAgICAgICByZXN1bHQgPSB0ZXN0KGRvbU5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgZmlsdGVyZWRET01Ob2Rlcy5wdXNoKGRvbU5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZERPTU5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFdJTERDQVJEIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG9tTm9kZU1hdGNoZXNTZWxlY3RvciwgZWxlbWVudHNGcm9tRE9NRWxlbWVudHMsIGZpbHRlckRPTU5vZGVzQnlTZWxlY3RvciwgYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZSwgZGVzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2RvbVwiO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnRFbGVtZW50KHNlbGVjdG9yID0gV0lMRENBUkQpIHtcbiAgbGV0IHBhcmVudEVsZW1lbnQgPSBudWxsO1xuXG4gIGNvbnN0IHBhcmVudERPTUVsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICBpZiAocGFyZW50RE9NRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGlmIChwYXJlbnRET01FbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICBjb25zdCBwYXJlbnRET01FbGVtZW50cyA9IFtwYXJlbnRET01FbGVtZW50XSxcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnRzID0gZWxlbWVudHNGcm9tRE9NRWxlbWVudHMocGFyZW50RE9NRWxlbWVudHMpLFxuICAgICAgICAgICAgZmlyc3RQYXJlbnRFbGVtZW50ID0gZmlyc3QocGFyZW50RWxlbWVudHMpO1xuXG4gICAgICBwYXJlbnRFbGVtZW50ID0gZmlyc3RQYXJlbnRFbGVtZW50IHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkRWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBjb25zdCBjaGlsZERPTU5vZGVzID0gdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXMsXG4gICAgICAgIGNoaWxkRE9NRWxlbWVudHMgPSBmaWx0ZXJET01Ob2Rlc0J5U2VsZWN0b3IoY2hpbGRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBjaGlsZEVsZW1lbnRzID0gZWxlbWVudHNGcm9tRE9NRWxlbWVudHMoY2hpbGRET01FbGVtZW50cyk7XG5cbiAgcmV0dXJuIGNoaWxkRWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGdldEFzY2VuZGFudEVsZW1lbnRzKHNlbGVjdG9yID0gV0lMRENBUkQsIG1heGltdW1IZWlnaHQgPSBJbmZpbml0eSkge1xuICBjb25zdCBoZWlnaHQgPSBtYXhpbXVtSGVpZ2h0LCAvLy9cbiAgICAgICAgZG9tTm9kZSA9IHRoaXMuZG9tRWxlbWVudCwgIC8vL1xuICAgICAgICBhc2NlbmRhbnRET01Ob2RlcyA9IGFzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUoZG9tTm9kZSwgaGVpZ2h0KSxcbiAgICAgICAgYXNjZW5kYW50RE9NRWxlbWVudHMgPSBmaWx0ZXJET01Ob2Rlc0J5U2VsZWN0b3IoYXNjZW5kYW50RE9NTm9kZXMsIHNlbGVjdG9yKSxcbiAgICAgICAgYXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhhc2NlbmRhbnRET01FbGVtZW50cyk7XG5cbiAgcmV0dXJuIGFzY2VuZGFudEVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBnZXREZXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bURlcHRoID0gSW5maW5pdHkpIHtcbiAgY29uc3QgZGVwdGggPSBtYXhpbXVtRGVwdGgsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGRlc2NlbmRhbnRET01Ob2RlcyA9IGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoKSxcbiAgICAgICAgZGVzY2VuZGFudERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGRlc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhkZXNjZW5kYW50RE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBkZXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nRWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBuZXh0U2libGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gIGNvbnN0IG5leHRTaWJsaW5nRE9NTm9kZSA9IHRoaXMuZG9tRWxlbWVudC5uZXh0U2libGluZztcblxuICBpZiAoKG5leHRTaWJsaW5nRE9NTm9kZSAhPT0gbnVsbCkgJiYgZG9tTm9kZU1hdGNoZXNTZWxlY3RvcihuZXh0U2libGluZ0RPTU5vZGUsIHNlbGVjdG9yKSkge1xuICAgIG5leHRTaWJsaW5nRWxlbWVudCA9IG5leHRTaWJsaW5nRE9NTm9kZS5fX2VsZW1lbnRfXyB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5leHRTaWJsaW5nRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwcmV2aW91c1NpYmxpbmdET01Ob2RlID0gdGhpcy5kb21FbGVtZW50LnByZXZpb3VzU2libGluZzsgIC8vL1xuXG4gIGlmICgocHJldmlvdXNTaWJsaW5nRE9NTm9kZSAhPT0gbnVsbCkgJiYgZG9tTm9kZU1hdGNoZXNTZWxlY3RvcihwcmV2aW91c1NpYmxpbmdET01Ob2RlLCBzZWxlY3RvcikpIHtcbiAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gcHJldmlvdXNTaWJsaW5nRE9NTm9kZS5fX2VsZW1lbnRfXyB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzU2libGluZ0VsZW1lbnQ7XG59XG5cbmNvbnN0IGVsZW1lbnRNaXhpbnMgPSB7XG4gIGdldFBhcmVudEVsZW1lbnQsXG4gIGdldENoaWxkRWxlbWVudHMsXG4gIGdldEFzY2VuZGFudEVsZW1lbnRzLFxuICBnZXREZXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudE1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE9mZnNldCBmcm9tIFwiLi9vZmZzZXRcIjtcbmltcG9ydCBCb3VuZHMgZnJvbSBcIi4vYm91bmRzXCI7XG5pbXBvcnQgZWxlbWVudE1peGlucyBmcm9tIFwiLi9taXhpbnMvZWxlbWVudFwiO1xuXG5jbGFzcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTsgLy8vXG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuX19lbGVtZW50X18gPSB0aGlzO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLmRvbUVsZW1lbnQubm9kZVZhbHVlLFxuICAgICAgICAgIHRleHQgPSBub2RlVmFsdWU7IC8vL1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBzZXRUZXh0KHRleHQpIHtcbiAgICBjb25zdCBub2RlVmFsdWUgPSB0ZXh0OyAvLy9cblxuICAgIHRoaXMuZG9tRWxlbWVudC5ub2RlVmFsdWUgPSBub2RlVmFsdWU7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy5kb21FbGVtZW50Lm9mZnNldFRvcCwgIC8vL1xuICAgICAgICAgIGxlZnQgPSB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0TGVmdCwgIC8vL1xuICAgICAgICAgIG9mZnNldCA9IG5ldyBPZmZzZXQodG9wLCBsZWZ0KTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBnZXRCb3VuZHMoKSB7XG4gICAgY29uc3QgYm91bmRpbmdDbGllbnRSZWN0ID0gdGhpcy5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kcyA9IEJvdW5kcy5mcm9tQm91bmRpbmdDbGllbnRSZWN0KGJvdW5kaW5nQ2xpZW50UmVjdCk7XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgY29uc3QgY2xpZW50V2lkdGggPSB0aGlzLmRvbUVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGggPSBjbGllbnRXaWR0aDsgIC8vL1xuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIGNvbnN0IGNsaWVudEhlaWdodCA9IHRoaXMuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0ID0gY2xpZW50SGVpZ2h0OyAgLy8vXG5cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9XG5cbiAgcHJlcGVuZFRvKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5wcmVwZW5kKHRoaXMpOyB9XG5cbiAgYXBwZW5kVG8ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LmFwcGVuZCh0aGlzKTsgfVxuXG4gIGFkZFRvKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5hZGQodGhpcyk7IH1cblxuICByZW1vdmVGcm9tKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5yZW1vdmUodGhpcyk7IH1cblxuICBpbnNlcnRCZWZvcmUoc2libGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnRET01Ob2RlID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICAgIHNpYmxpbmdET01FbGVtZW50ID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudDtcblxuICAgIHBhcmVudERPTU5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tRWxlbWVudCwgc2libGluZ0RPTUVsZW1lbnQpO1xuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnRET01Ob2RlID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICAgIHNpYmxpbmdET01FbGVtZW50ID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudDtcblxuICAgIHBhcmVudERPTU5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tRWxlbWVudCwgc2libGluZ0RPTUVsZW1lbnQubmV4dFNpYmxpbmcpOyAgLy8vXG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZSgpO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oVGV4dEVsZW1lbnQucHJvdG90eXBlLCBlbGVtZW50TWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dEVsZW1lbnQ7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0RWxlbWVudCBmcm9tIFwiLi4vdGV4dEVsZW1lbnRcIjtcblxuaW1wb3J0IHsgU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmFsc2V5RWxlbWVudHMoZWxlbWVudHMpIHtcbiAgZWxlbWVudHMgPSBlbGVtZW50cy5yZWR1Y2UoKGVsZW1lbnRzLCBlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gIGVsZW1lbnRzID0gZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiB7ICAvLy9cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFNUUklORykge1xuICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQsICAvLy9cbiAgICAgICAgICAgIHRleHRFbGVtZW50ID0gbmV3IFRleHRFbGVtZW50KHRleHQpO1xuXG4gICAgICBlbGVtZW50ID0gdGV4dEVsZW1lbnQ7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcblxuICByZXR1cm4gZWxlbWVudHM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNvbWJpbmUsIHBydW5lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9vYmplY3RcIjtcbmltcG9ydCB7IGZpcnN0LCBndWFyYW50ZWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBpc0hUTUxBdHRyaWJ1dGVOYW1lLCBpc1NWR0F0dHJpYnV0ZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL25hbWVcIjtcbmltcG9ydCB7IHJlbW92ZUZhbHNleUVsZW1lbnRzLCByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBGT1IsIENMQVNTLCBPQkpFQ1QsIEhUTUxfRk9SLCBDTEFTU19OQU1FLCBCT09MRUFOLCBGVU5DVElPTiwgU1ZHX05BTUVTUEFDRV9VUkkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gY29tYmluZShwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcyk7XG5cbiAgcHJvcGVydGllcyA9IHBydW5lKHRoaXMucHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpOyAvLy9cblxuICBjb25zdCB7IG5hbWVzcGFjZVVSSSB9ID0gdGhpcy5kb21FbGVtZW50LFxuICAgICAgICBzdmcgPSAobmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFX1VSSSksIC8vL1xuICAgICAgICBwcm9wZXJ0aWVzS2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLFxuICAgICAgICBuYW1lcyA9IHByb3BlcnRpZXNLZXlzOyAgLy8vPVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbbmFtZV0sXG4gICAgICAgICAgbmFtZUhhbmRsZXJOYW1lID0gaXNOYW1lSGFuZGxlck5hbWUobmFtZSk7XG5cbiAgICBpZiAobmFtZUhhbmRsZXJOYW1lKSB7XG4gICAgICBhZGRIYW5kbGVyKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZUF0dHJpYnV0ZU5hbWUgPSBpc05hbWVBdHRyaWJ1dGVOYW1lKG5hbWUsIHN2Zyk7XG5cbiAgICAgIGlmIChuYW1lQXR0cmlidXRlTmFtZSkge1xuICAgICAgICBhZGRBdHRyaWJ1dGUodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgY2hpbGRFbGVtZW50cyA9IGNoaWxkRWxlbWVudHNGcm9tRWxlbWVudCh0aGlzKSB8fCBwcm9wZXJ0aWVzLmNoaWxkRWxlbWVudHMsICAvLy9cbiAgICAgICAgY29udGV4dCA9IHt9O1xuXG4gIGNoaWxkRWxlbWVudHMuZm9yRWFjaCgoY2hpbGRFbGVtZW50KSA9PiB7XG4gICAgdXBkYXRlQ29udGV4dChjaGlsZEVsZW1lbnQsIGNvbnRleHQpO1xuXG4gICAgdGhpcy5hZGQoY2hpbGRFbGVtZW50KTtcbiAgfSk7XG5cbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcygpIHtcbiAgcmV0dXJuIHRoaXMucHJvcGVydGllcztcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgcmV0dXJuIHRoaXMuY29udGV4dDtcbn1cblxuZnVuY3Rpb24gYXNzaWduQ29udGV4dChuYW1lcywgdGhlbkRlbGV0ZSkge1xuICBjb25zdCBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBmaXJzdEFyZ3VtZW50ID0gZmlyc3QoYXJndW1lbnRzKTtcblxuICAgIGlmICh0eXBlb2YgZmlyc3RBcmd1bWVudCA9PT0gQk9PTEVBTikge1xuICAgICAgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnRleHQpO1xuXG4gICAgICB0aGVuRGVsZXRlID0gZmlyc3RBcmd1bWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlbkRlbGV0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgIG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb250ZXh0KTtcblxuICAgIHRoZW5EZWxldGUgPSB0cnVlO1xuICB9XG5cbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb250ZXh0W25hbWVdLFxuICAgICAgICAgIHByb3BlcnR5TmFtZSA9IG5hbWUsICAvLy9cbiAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpO1xuXG4gICAgaWYgKHRoZW5EZWxldGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRbbmFtZV07XG4gICAgfVxuICB9LCBbXSk7XG59XG5cbmNvbnN0IGpzeE1peGlucyA9IHtcbiAgYXBwbHlQcm9wZXJ0aWVzLFxuICBnZXRQcm9wZXJ0aWVzLFxuICBnZXRDb250ZXh0LFxuICBhc3NpZ25Db250ZXh0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBqc3hNaXhpbnM7XG5cbmZ1bmN0aW9uIGNoaWxkRWxlbWVudHNGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gIGxldCBjaGlsZEVsZW1lbnRzID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGVsZW1lbnQuY2hpbGRFbGVtZW50cyA9PT0gRlVOQ1RJT04pIHtcbiAgICBjaGlsZEVsZW1lbnRzID0gZWxlbWVudC5jaGlsZEVsZW1lbnRzLmNhbGwoZWxlbWVudCk7XG5cbiAgICBjaGlsZEVsZW1lbnRzID0gZ3VhcmFudGVlKGNoaWxkRWxlbWVudHMpO1xuXG4gICAgY2hpbGRFbGVtZW50cyA9IHJlbW92ZUZhbHNleUVsZW1lbnRzKGNoaWxkRWxlbWVudHMpO1xuXG4gICAgY2hpbGRFbGVtZW50cyA9IHJlcGxhY2VTdHJpbmdzV2l0aFRleHRFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZEVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGNoaWxkRWxlbWVudCwgY29udGV4dCkge1xuICBjb25zdCBwYXJlbnRDb250ZXh0ID0gKHR5cGVvZiBjaGlsZEVsZW1lbnQucGFyZW50Q29udGV4dCA9PT0gRlVOQ1RJT04pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFbGVtZW50LnBhcmVudENvbnRleHQoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFbGVtZW50LmNvbnRleHQ7IC8vL1xuXG4gIE9iamVjdC5hc3NpZ24oY29udGV4dCwgcGFyZW50Q29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgZXZlbnRUeXBlID0gbmFtZS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgLy8vXG4gICAgICAgIGhhbmRsZXIgPSB2YWx1ZTsgIC8vL1xuXG4gIGVsZW1lbnQub24oZXZlbnRUeXBlLCBoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChuYW1lID09PSBDTEFTU19OQU1FKSB7XG4gICAgbmFtZSA9IENMQVNTO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IEhUTUxfRk9SKSB7XG4gICAgbmFtZSA9IEZPUjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IE9CSkVDVCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgZWxlbWVudC5kb21FbGVtZW50W25hbWVdW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gQk9PTEVBTikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBuYW1lOyAvLy9cblxuICAgICAgZWxlbWVudC5hZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOYW1lSGFuZGxlck5hbWUobmFtZSkge1xuICByZXR1cm4gL15vbi8udGVzdChuYW1lKTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpIHtcbiAgcmV0dXJuIHN2ZyA/IGlzU1ZHQXR0cmlidXRlTmFtZShuYW1lKSA6IGlzSFRNTEF0dHJpYnV0ZU5hbWUobmFtZSlcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE9QRU5fRVZFTlRfVFlQRSA9IFwib3BlblwiO1xuZXhwb3J0IGNvbnN0IE1PVkVfRVZFTlRfVFlQRSA9IFwibW92ZVwiO1xuZXhwb3J0IGNvbnN0IEJMVVJfRVZFTlRfVFlQRSA9IFwiYmx1clwiO1xuZXhwb3J0IGNvbnN0IERSQUdfRVZFTlRfVFlQRSA9IFwiZHJhZ1wiO1xuZXhwb3J0IGNvbnN0IERST1BfRVZFTlRfVFlQRSA9IFwiZHJvcFwiO1xuZXhwb3J0IGNvbnN0IFdIRUVMX0VWRU5UX1RZUEUgPSBcIndoZWVsXCI7XG5leHBvcnQgY29uc3QgSU5QVVRfRVZFTlRfVFlQRSA9IFwiaW5wdXRcIjtcbmV4cG9ydCBjb25zdCBGT0NVU19FVkVOVF9UWVBFID0gXCJmb2N1c1wiO1xuZXhwb3J0IGNvbnN0IENMSUNLX0VWRU5UX1RZUEUgPSBcImNsaWNrXCI7XG5leHBvcnQgY29uc3QgS0VZVVBfRVZFTlRfVFlQRSA9IFwia2V5dXBcIjtcbmV4cG9ydCBjb25zdCBSRU1PVkVfRVZFTlRfVFlQRSA9IFwicmVtb3ZlXCI7XG5leHBvcnQgY29uc3QgQ0hBTkdFX0VWRU5UX1RZUEUgPSBcImNoYW5nZVwiO1xuZXhwb3J0IGNvbnN0IFJFU0laRV9FVkVOVF9UWVBFID0gXCJyZXNpemVcIjtcbmV4cG9ydCBjb25zdCBTQ1JPTExfRVZFTlRfVFlQRSA9IFwic2Nyb2xsXCI7XG5leHBvcnQgY29uc3QgS0VZRE9XTl9FVkVOVF9UWVBFID0gXCJrZXlkb3duXCI7XG5leHBvcnQgY29uc3QgTU9VU0VVUF9FVkVOVF9UWVBFID0gXCJtb3VzZXVwXCI7XG5leHBvcnQgY29uc3QgQVVYQ0xJQ0tfRVZFTlRfVFlQRSA9IFwiYXV4Y2xpY2tcIjtcbmV4cG9ydCBjb25zdCBEUkFHX09VVF9FVkVOVF9UWVBFID0gXCJkcmFnb3V0XCI7XG5leHBvcnQgY29uc3QgTU9VU0VPVVRfRVZFTlRfVFlQRSA9IFwibW91c2VvdXRcIjtcbmV4cG9ydCBjb25zdCBEQkxDTElDS19FVkVOVF9UWVBFID0gXCJkYmxjbGlja1wiO1xuZXhwb3J0IGNvbnN0IE1PVVNFT1ZFUl9FVkVOVF9UWVBFID0gXCJtb3VzZW92ZXJcIjtcbmV4cG9ydCBjb25zdCBNT1VTRURPV05fRVZFTlRfVFlQRSA9IFwibW91c2Vkb3duXCI7XG5leHBvcnQgY29uc3QgTU9VU0VNT1ZFX0VWRU5UX1RZUEUgPSBcIm1vdXNlbW92ZVwiO1xuZXhwb3J0IGNvbnN0IERSQUdfT1ZFUl9FVkVOVF9UWVBFID0gXCJkcmFnb3ZlclwiO1xuZXhwb3J0IGNvbnN0IFNUT1BfRFJBR19FVkVOVF9UWVBFID0gXCJzdG9wZHJhZ1wiO1xuZXhwb3J0IGNvbnN0IFNUQVJUX0RSQUdfRVZFTlRfVFlQRSA9IFwic3RhcnRkcmFnXCI7XG5leHBvcnQgY29uc3QgQ09OVEVYVE1FTlVfRVZFTlRfVFlQRSA9IFwiY29udGV4dG1lbnVcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBPUEVOX0VWRU5UX1RZUEUsXG4gIE1PVkVfRVZFTlRfVFlQRSxcbiAgQkxVUl9FVkVOVF9UWVBFLFxuICBEUkFHX0VWRU5UX1RZUEUsXG4gIERST1BfRVZFTlRfVFlQRSxcbiAgV0hFRUxfRVZFTlRfVFlQRSxcbiAgSU5QVVRfRVZFTlRfVFlQRSxcbiAgRk9DVVNfRVZFTlRfVFlQRSxcbiAgQ0xJQ0tfRVZFTlRfVFlQRSxcbiAgS0VZVVBfRVZFTlRfVFlQRSxcbiAgUkVNT1ZFX0VWRU5UX1RZUEUsXG4gIENIQU5HRV9FVkVOVF9UWVBFLFxuICBSRVNJWkVfRVZFTlRfVFlQRSxcbiAgU0NST0xMX0VWRU5UX1RZUEUsXG4gIEtFWURPV05fRVZFTlRfVFlQRSxcbiAgTU9VU0VVUF9FVkVOVF9UWVBFLFxuICBBVVhDTElDS19FVkVOVF9UWVBFLFxuICBEUkFHX09VVF9FVkVOVF9UWVBFLFxuICBNT1VTRU9VVF9FVkVOVF9UWVBFLFxuICBEQkxDTElDS19FVkVOVF9UWVBFLFxuICBNT1VTRU9WRVJfRVZFTlRfVFlQRSxcbiAgTU9VU0VET1dOX0VWRU5UX1RZUEUsXG4gIE1PVVNFTU9WRV9FVkVOVF9UWVBFLFxuICBEUkFHX09WRVJfRVZFTlRfVFlQRSxcbiAgU1RPUF9EUkFHX0VWRU5UX1RZUEUsXG4gIFNUQVJUX0RSQUdfRVZFTlRfVFlQRSxcbiAgQ09OVEVYVE1FTlVfRVZFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgS0VZVVBfRVZFTlRfVFlQRSwgS0VZRE9XTl9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25LZXlVcChrZXlVcEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbihLRVlVUF9FVkVOVF9UWVBFLCBrZXlVcEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZktleVVwKGtleVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZihLRVlVUF9FVkVOVF9UWVBFLCBrZXlVcEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uS2V5RG93bihrZXlEb3duSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uKEtFWURPV05fRVZFTlRfVFlQRSwga2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoS0VZRE9XTl9FVkVOVF9UWVBFLCBrZXlEb3duSGFuZGxlciwgZWxlbWVudCk7IH1cblxuY29uc3Qga2V5TWl4aW5zID0ge1xuICBvbktleVVwLFxuICBvZmZLZXlVcCxcbiAgb25LZXlEb3duLFxuICBvZmZLZXlEb3duXG59O1xuXG5leHBvcnQgZGVmYXVsdCBrZXlNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENMSUNLX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbkNsaWNrKGNsaWNrSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uKENMSUNLX0VWRU5UX1RZUEUsIGNsaWNrSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ2xpY2soY2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmKENMSUNLX0VWRU5UX1RZUEUsIGNsaWNrSGFuZGxlciwgZWxlbWVudCk7IH1cblxuY29uc3QgY2xpY2tNaXhpbnMgPSB7XG4gIG9uQ2xpY2ssXG4gIG9mZkNsaWNrXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGlja01peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlO1xufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgc3RhdGUpO1xufVxuXG5jb25zdCBzdGF0ZU1peGlucyA9IHtcbiAgZ2V0U3RhdGUsXG4gIHNldFN0YXRlLFxuICB1cGRhdGVTdGF0ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3RhdGVNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBURVhUX0hUTUxfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWxcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUkVTSVpFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgT0JKRUNULCBBQk9VVF9CTEFOSyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFRFWFRfSFRNTF9DT05URU5UX1RZUEUgfSBmcm9tIFwiLi4vY29udGVudFR5cGVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBvblJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub24oUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBvZmZSZXNpemUocmVzaXplSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZihSRVNJWkVfRVZFTlRfVFlQRSwgcmVzaXplSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gYWRkUmVzaXplT2JqZWN0KCkge1xuICBjb25zdCByZXNpemVPYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KE9CSkVDVCksXG4gICAgICAgIHN0eWxlID0gYGRpc3BsYXk6IGJsb2NrOyBcbiAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlOyBcbiAgICAgICAgICAgICAgICAgdG9wOiAwOyBcbiAgICAgICAgICAgICAgICAgbGVmdDogMDsgXG4gICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTsgXG4gICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlOyBcbiAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsgXG4gICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lOyBcbiAgICAgICAgICAgICAgICAgei1pbmRleDogLTE7YCxcbiAgICAgICAgZGF0YSA9IEFCT1VUX0JMQU5LLFxuICAgICAgICB0eXBlID0gVEVYVF9IVE1MX0NPTlRFTlRfVFlQRTtcblxuICByZXNpemVPYmplY3Quc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgc3R5bGUpO1xuXG4gIHJlc2l6ZU9iamVjdC5kYXRhID0gZGF0YTtcblxuICByZXNpemVPYmplY3QudHlwZSA9IHR5cGU7XG5cbiAgdGhpcy5fX3Jlc2l6ZU9iamVjdF9fID0gcmVzaXplT2JqZWN0O1xuXG4gIHJlc2l6ZU9iamVjdC5vbmxvYWQgPSAoKSA9PiByZXNpemVPYmplY3RMb2FkSGFuZGxlcih0aGlzKTtcblxuICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQocmVzaXplT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplT2JqZWN0KCkge1xuICBjb25zdCByZXNpemVPYmplY3QgPSB0aGlzLl9fcmVzaXplT2JqZWN0X18sXG4gICAgICAgIG9iamVjdFdpbmRvdyA9IHJlc2l6ZU9iamVjdC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7ICAvLy9cblxuICBvYmplY3RXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihSRVNJWkVfRVZFTlRfVFlQRSwgcmVzaXplRXZlbnRMaXN0ZW5lcik7XG5cbiAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUNoaWxkKHJlc2l6ZU9iamVjdCk7XG5cbiAgZGVsZXRlIHRoaXMuX19yZXNpemVPYmplY3RfXztcbn1cblxuY29uc3QgcmVzaXplTWl4aW5zID0ge1xuICBvblJlc2l6ZSxcbiAgb2ZmUmVzaXplLFxuICBhZGRSZXNpemVPYmplY3QsXG4gIHJlbW92ZVJlc2l6ZU9iamVjdFxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVzaXplTWl4aW5zO1xuXG5mdW5jdGlvbiByZXNpemVPYmplY3RMb2FkSGFuZGxlcihlbGVtZW50KSB7XG4gIGNvbnN0IHJlc2l6ZU9iamVjdCA9IGVsZW1lbnQuX19yZXNpemVPYmplY3RfXyxcbiAgICAgICAgcmVzaXplT2JqZWN0V2luZG93ID0gcmVzaXplT2JqZWN0LmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldzsgIC8vL1xuXG4gIHJlc2l6ZU9iamVjdFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJFU0laRV9FVkVOVF9UWVBFLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IGVsZW1lbnQuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKTtcblxuICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHJlc2l6ZUV2ZW50TGlzdGVuZXIpID0+IHJlc2l6ZUV2ZW50TGlzdGVuZXIoZXZlbnQpKTtcbiAgfSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNQQUNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgUkVTSVpFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgcmVtb3ZlUmVzaXplT2JqZWN0IH0gZnJvbSBcIi4uL21peGlucy9yZXNpemVcIjtcblxuZnVuY3Rpb24gb24oZXZlbnRUeXBlcywgaGFuZGxlciwgZWxlbWVudCA9IHRoaXMpIHtcbiAgZXZlbnRUeXBlcyA9IGV2ZW50VHlwZXMuc3BsaXQoU1BBQ0UpO1xuXG4gIGV2ZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gUkVTSVpFX0VWRU5UX1RZUEUpIHtcbiAgICAgIGNvbnN0IHJlc2l6ZUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kRXZlbnRMaXN0ZW5lcnMoUkVTSVpFX0VWRU5UX1RZUEUpLFxuICAgICAgICAgICAgcmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPSByZXNpemVFdmVudExpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIGlmIChyZXNpemVFdmVudExpc3RlbmVyc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkZFJlc2l6ZU9iamVjdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgZXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmYoZXZlbnRUeXBlcywgaGFuZGxlciwgZWxlbWVudCA9IHRoaXMpIHtcbiAgZXZlbnRUeXBlcyA9IGV2ZW50VHlwZXMuc3BsaXQoU1BBQ0UpO1xuXG4gIGV2ZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcblxuICAgIGlmIChldmVudFR5cGUgPT09IFJFU0laRV9FVkVOVF9UWVBFKSB7XG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlUmVzaXplT2JqZWN0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gIH1cblxuICBjb25zdCBldmVudExpc3RlbmVyID0gdGhpcy5jcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG5cbiAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGV2ZW50TGlzdGVuZXIpO1xuXG4gIHJldHVybiBldmVudExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdGhpcy5maW5kRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpLFxuICAgICAgICBpbmRleCA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihldmVudExpc3RlbmVyKSxcbiAgICAgICAgc3RhcnQgPSBpbmRleCwgIC8vL1xuICAgICAgICBkZWxldGVDb3VudCA9IDE7XG5cbiAgdGhpcy5ldmVudExpc3RlbmVycy5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KTtcblxuICBpZiAodGhpcy5ldmVudExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVycztcbiAgfVxuXG4gIHJldHVybiBldmVudExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBmaW5kRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZmluZCgoZXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgIGlmICgoZXZlbnRMaXN0ZW5lci5lbGVtZW50ID09PSBlbGVtZW50KSAmJiAoZXZlbnRMaXN0ZW5lci5oYW5kbGVyID09PSBoYW5kbGVyKSAmJiAoZXZlbnRMaXN0ZW5lci5ldmVudFR5cGUgPT09IGV2ZW50VHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGZpbmRFdmVudExpc3RlbmVycyhldmVudFR5cGUpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBbXTtcblxuICBpZiAodGhpcy5ldmVudExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgICBjb25zdCBmb3VuZCA9IChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKTtcblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGxldCBldmVudExpc3RlbmVyO1xuXG4gIGNvbnN0IGhhbmRsZXJFbGVtZW50ID0gZWxlbWVudDsgLy8vXG5cbiAgZXZlbnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oZXZlbnRMaXN0ZW5lciwge1xuICAgIGVsZW1lbnQsXG4gICAgaGFuZGxlcixcbiAgICBldmVudFR5cGVcbiAgfSk7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmNvbnN0IGV2ZW50TWl4aW5zID0ge1xuICBvbixcbiAgb2ZmLFxuICBhZGRFdmVudExpc3RlbmVyLFxuICByZW1vdmVFdmVudExpc3RlbmVyLFxuICBjcmVhdGVFdmVudExpc3RlbmVyLFxuICBmaW5kRXZlbnRMaXN0ZW5lcixcbiAgZmluZEV2ZW50TGlzdGVuZXJzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBldmVudE1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTU9VU0VVUF9FVkVOVF9UWVBFLFxuICAgICAgICAgTU9VU0VPVVRfRVZFTlRfVFlQRSxcbiAgICAgICAgIE1PVVNFRE9XTl9FVkVOVF9UWVBFLFxuICAgICAgICAgTU9VU0VPVkVSX0VWRU5UX1RZUEUsXG4gICAgICAgICBNT1VTRU1PVkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uKE1PVVNFVVBfRVZFTlRfVFlQRSwgbW91c2VVcEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlVXAobW91c2VVcEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoTU9VU0VVUF9FVkVOVF9UWVBFLCBtb3VzZVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb25Nb3VzZU91dChtb3VzZU91dEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbihNT1VTRU9VVF9FVkVOVF9UWVBFLCBtb3VzZU91dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZihNT1VTRU9VVF9FVkVOVF9UWVBFLCBtb3VzZU91dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VEb3duKG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbihNT1VTRURPV05fRVZFTlRfVFlQRSwgbW91c2VEb3duSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VEb3duKG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbihNT1VTRU9WRVJfRVZFTlRfVFlQRSwgbW91c2VPdmVySGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoTU9VU0VPVkVSX0VWRU5UX1RZUEUsIG1vdXNlT3ZlckhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbihNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoTU9VU0VNT1ZFX0VWRU5UX1RZUEUsIG1vdXNlTW92ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmNvbnN0IG1vdXNlTWl4aW5zID0ge1xuICBvbk1vdXNlVXAsXG4gIG9mZk1vdXNlVXAsXG4gIG9uTW91c2VPdXQsXG4gIG9mZk1vdXNlT3V0LFxuICBvbk1vdXNlRG93bixcbiAgb2ZmTW91c2VEb3duLFxuICBvbk1vdXNlT3ZlcixcbiAgb2ZmTW91c2VPdmVyLFxuICBvbk1vdXNlTW92ZSxcbiAgb2ZmTW91c2VNb3ZlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtb3VzZU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgU0NST0xMX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvblNjcm9sbChzY3JvbGxIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub24oU0NST0xMX0VWRU5UX1RZUEUsIHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlNjcm9sbChzY3JvbGxIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmKFNDUk9MTF9FVkVOVF9UWVBFLCBzY3JvbGxIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsVG9wOyB9XG5cbmZ1bmN0aW9uIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsTGVmdDsgfVxuXG5mdW5jdGlvbiBzZXRTY3JvbGxUb3Aoc2Nyb2xsVG9wKSB7IHRoaXMuZG9tRWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7IH1cblxuZnVuY3Rpb24gc2V0U2Nyb2xsTGVmdChzY3JvbGxMZWZ0KSB7IHRoaXMuZG9tRWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDsgfVxuXG5jb25zdCBzY3JvbGxNaXhpbnMgPSB7XG4gIG9uU2Nyb2xsLFxuICBvZmZTY3JvbGwsXG4gIGdldFNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsTGVmdCxcbiAgc2V0U2Nyb2xsVG9wLFxuICBzZXRTY3JvbGxMZWZ0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzY3JvbGxNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBPZmZzZXQgZnJvbSBcIi4vb2Zmc2V0XCI7XG5pbXBvcnQgQm91bmRzIGZyb20gXCIuL2JvdW5kc1wiO1xuaW1wb3J0IGpzeE1peGlucyBmcm9tIFwiLi9taXhpbnMvanN4XCI7XG5pbXBvcnQga2V5TWl4aW5zIGZyb20gXCIuL21peGlucy9rZXlcIjtcbmltcG9ydCBjbGlja01peGlucyBmcm9tIFwiLi9taXhpbnMvY2xpY2tcIjtcbmltcG9ydCBzdGF0ZU1peGlucyBmcm9tIFwiLi9taXhpbnMvc3RhdGVcIjtcbmltcG9ydCBldmVudE1peGlucyBmcm9tIFwiLi9taXhpbnMvZXZlbnRcIjtcbmltcG9ydCBtb3VzZU1peGlucyBmcm9tIFwiLi9taXhpbnMvbW91c2VcIjtcbmltcG9ydCByZXNpemVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3Jlc2l6ZVwiO1xuaW1wb3J0IHNjcm9sbE1peGlucyBmcm9tIFwiLi9taXhpbnMvc2Nyb2xsXCI7XG5pbXBvcnQgZWxlbWVudE1peGlucyBmcm9tIFwiLi9taXhpbnMvZWxlbWVudFwiO1xuXG5pbXBvcnQgeyBjb21iaW5lIH0gZnJvbSBcIi4vdXRpbGl0aWVzL29iamVjdFwiO1xuaW1wb3J0IHsgaXNTVkdUYWdOYW1lIH0gZnJvbSBcIi4vdXRpbGl0aWVzL25hbWVcIjtcbmltcG9ydCB7IGZpcnN0LCBhdWdtZW50IH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBOT05FLFxuICAgICAgICAgQkxPQ0ssXG4gICAgICAgICBXSURUSCxcbiAgICAgICAgIFNUUklORyxcbiAgICAgICAgIEhFSUdIVCxcbiAgICAgICAgIERJU1BMQVksXG4gICAgICAgICBESVNBQkxFRCxcbiAgICAgICAgIEVNUFRZX1NUUklORyxcbiAgICAgICAgIFNWR19OQU1FU1BBQ0VfVVJJLFxuICAgICAgICAgREVGQVVMVF9QUk9QRVJUSUVTLFxuICAgICAgICAgSUdOT1JFRF9QUk9QRVJUSUVTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rvcikge1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudC5fX2VsZW1lbnRfXyA9IHRoaXM7IC8vL1xuICAgIH1cbiAgfVxuXG4gIGdldERPTUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudDtcbiAgfVxuXG4gIGdldE9mZnNldCgpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0VG9wLCAgLy8vXG4gICAgICAgICAgbGVmdCA9IHRoaXMuZG9tRWxlbWVudC5vZmZzZXRMZWZ0LCAgLy8vXG4gICAgICAgICAgb2Zmc2V0ID0gbmV3IE9mZnNldCh0b3AsIGxlZnQpO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIGdldEJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgYm91bmRzID0gQm91bmRzLmZyb21Cb3VuZGluZ0NsaWVudFJlY3QoYm91bmRpbmdDbGllbnRSZWN0KTtcblxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cblxuICBnZXRXaWR0aChpbmNsdWRlQm9yZGVyID0gdHJ1ZSkge1xuICAgIGNvbnN0IHdpZHRoID0gaW5jbHVkZUJvcmRlciA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRXaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LmNsaWVudFdpZHRoO1xuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICB3aWR0aCA9IGAke3dpZHRofXB4YDsgLy8vXG5cbiAgICB0aGlzLnN0eWxlKFdJRFRILCB3aWR0aCk7XG4gIH1cblxuICBnZXRIZWlnaHQoaW5jbHVkZUJvcmRlciA9IHRydWUpIHtcbiAgICBjb25zdCBoZWlnaHQgPSBpbmNsdWRlQm9yZGVyID9cbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRIZWlnaHQgOlxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuXG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBgJHtoZWlnaHR9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoSEVJR0hULCBoZWlnaHQpO1xuICB9XG5cbiAgaGFzQXR0cmlidXRlKG5hbWUpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZSk7IH1cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfVxuXG4gIGNsZWFyQXR0cmlidXRlKG5hbWUpIHsgdGhpcy5kb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIGFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7IH1cblxuICByZW1vdmVBdHRyaWJ1dGUobmFtZSkgeyB0aGlzLmNsZWFyQXR0cmlidXRlKG5hbWUpOyB9XG5cbiAgc2V0Q2xhc3MoY2xhc3NOYW1lKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7IH1cblxuICBhZGRDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTsgfVxuXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkgeyB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpOyB9XG5cbiAgdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7IH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTsgfVxuXG4gIGNsZWFyQ2xhc3NlcygpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTmFtZSA9IEVNUFRZX1NUUklORzsgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIGFwcGVuZFRvKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5hcHBlbmQodGhpcyk7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgcmVtb3ZlRnJvbShwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucmVtb3ZlKHRoaXMpOyB9XG5cbiAgaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgICBzaWJsaW5nRE9NRWxlbWVudCA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQ7XG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgICBzaWJsaW5nRE9NRWxlbWVudCA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQ7XG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50Lm5leHRTaWJsaW5nKTsgIC8vL1xuICB9XG5cbiAgcHJlcGVuZChlbGVtZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZG9tRWxlbWVudCxcbiAgICAgICAgICBmaXJzdENoaWxkRE9NRWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudC5maXJzdENoaWxkO1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZShkb21FbGVtZW50LCBmaXJzdENoaWxkRE9NRWxlbWVudCk7XG4gIH1cblxuICBhcHBlbmQoZWxlbWVudCkge1xuICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBlbGVtZW50LmRvbUVsZW1lbnQ7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGRvbUVsZW1lbnQsIG51bGwpOyAvLy9cbiAgfVxuXG4gIGFkZChlbGVtZW50KSB7IHRoaXMuYXBwZW5kKGVsZW1lbnQpOyB9XG5cbiAgcmVtb3ZlKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZG9tRWxlbWVudDtcblxuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUNoaWxkKGRvbUVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgbW91bnQoZWxlbWVudCkge1xuICAgIGNvbnN0IGRlc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnQuZ2V0RGVzY2VuZGFudEVsZW1lbnRzKCksXG4gICAgICAgICAgZWxlbWVudHMgPSBbXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgLi4uZGVzY2VuZGFudEVsZW1lbnRzXG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuYWRkKGVsZW1lbnQpO1xuXG4gICAgZWxlbWVudHMucmV2ZXJzZSgpOyAvLy9cblxuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IChlbGVtZW50LmRpZE1vdW50ICYmIGVsZW1lbnQuZGlkTW91bnQoKSkpOyAgLy8vXG4gIH1cblxuICB1bm1vdW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50LmdldERlc2NlbmRhbnRFbGVtZW50cygpLFxuICAgICAgICAgIGVsZW1lbnRzID0gW1xuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIC4uLmRlc2NlbmRhbnRFbGVtZW50c1xuICAgICAgICAgIF07XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiAoZWxlbWVudC53aWxsVW5tb3VudCAmJiBlbGVtZW50LndpbGxVbm1vdW50KCkpKTsgIC8vL1xuXG4gICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gIH1cblxuICBzaG93KGRpc3BsYXlTdHlsZSA9IEJMT0NLKSB7IHRoaXMuZGlzcGxheShkaXNwbGF5U3R5bGUpOyB9XG5cbiAgaGlkZSgpIHsgdGhpcy5zdHlsZShESVNQTEFZLCBOT05FKTsgfVxuXG4gIGRpc3BsYXkoZGlzcGxheSkgeyB0aGlzLnN0eWxlKERJU1BMQVksIGRpc3BsYXkpOyB9XG5cbiAgZW5hYmxlKCkgeyB0aGlzLmNsZWFyQXR0cmlidXRlKERJU0FCTEVEKTsgfVxuXG4gIGRpc2FibGUoKSB7IHRoaXMuc2V0QXR0cmlidXRlKERJU0FCTEVELCBESVNBQkxFRCk7IH1cblxuICBpc0VuYWJsZWQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKSxcbiAgICAgICAgICBlbmFibGVkID0gIWRpc2FibGVkO1xuXG4gICAgcmV0dXJuIGVuYWJsZWQ7XG4gIH1cblxuICBpc0Rpc2FibGVkKCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5oYXNBdHRyaWJ1dGUoRElTQUJMRUQpO1xuXG4gICAgcmV0dXJuIGRpc2FibGVkO1xuICB9XG4gIFxuICBpc0Rpc3BsYXllZCgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5jc3MoRElTUExBWSksXG4gICAgICAgICAgZGlzcGxheWVkID0gKGRpc3BsYXkgIT09IE5PTkUpO1xuICAgIFxuICAgIHJldHVybiBkaXNwbGF5ZWQ7XG4gIH1cblxuICBpc1Nob3dpbmcoKSB7XG4gICAgY29uc3QgZGlzcGxheWVkID0gdGhpcy5pc0Rpc3BsYXllZCgpLFxuICAgICAgICAgIHNob3dpbmcgPSBkaXNwbGF5ZWQ7ICAvLy9cblxuICAgIHJldHVybiBzaG93aW5nO1xuICB9XG5cbiAgaXNIaWRkZW4oKSB7XG4gICAgY29uc3QgZGlzcGxheWVkID0gdGhpcy5pc0Rpc3BsYXllZCgpLFxuICAgICAgICAgIGhpZGRlbiA9ICFkaXNwbGF5ZWQ7XG5cbiAgICByZXR1cm4gaGlkZGVuO1xuICB9XG5cbiAgc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kb21FbGVtZW50LnN0eWxlW25hbWVdO1xuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgaHRtbChodG1sKSB7XG4gICAgaWYgKGh0bWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaW5uZXJIVE1MID0gdGhpcy5kb21FbGVtZW50LmlubmVySFRNTDtcblxuICAgICAgaHRtbCA9IGlubmVySFRNTDsgLy8vXG5cbiAgICAgIHJldHVybiBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbm5lckhUTUwgPSBodG1sOyAvLy9cblxuICAgICAgdGhpcy5kb21FbGVtZW50LmlubmVySFRNTCA9IGlubmVySFRNTFxuICAgIH1cbiAgfVxuXG4gIGNzcyhjc3MpIHtcbiAgICBpZiAoY3NzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZG9tRWxlbWVudCksXG4gICAgICAgICAgICBjc3MgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbXB1dGVkU3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q29tcHV0ZWRTdHlsZSA9IGZpcnN0W2NvbXB1dGVkU3R5bGVdLFxuICAgICAgICAgICAgICBuYW1lID0gZmlyc3RDb21wdXRlZFN0eWxlLCAgLy8vXG4gICAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpOyAvLy9cblxuICAgICAgICBjc3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNzcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjc3MgPT09IFNUUklORykge1xuICAgICAgbGV0IG5hbWUgPSBjc3M7IC8vL1xuXG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpLFxuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSk7IC8vL1xuXG4gICAgICBjc3MgPSB2YWx1ZTsgIC8vL1xuXG4gICAgICByZXR1cm4gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGNzcyk7IC8vL1xuXG4gICAgICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3NzW25hbWVdO1xuXG4gICAgICAgIHRoaXMuc3R5bGUobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICBibHVyKCkgeyB0aGlzLmRvbUVsZW1lbnQuYmx1cigpOyB9XG5cbiAgZm9jdXMoKSB7IHRoaXMuZG9tRWxlbWVudC5mb2N1cygpOyB9XG5cbiAgaGFzRm9jdXMoKSB7XG4gICAgY29uc3QgZm9jdXMgPSAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5kb21FbGVtZW50KTsgIC8vL1xuXG4gICAgcmV0dXJuIGZvY3VzO1xuICB9XG5cbiAgc3RhdGljIGZyb21DbGFzcyhDbGFzcywgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyB0YWdOYW1lIH0gPSBDbGFzcyxcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZyb21UYWdOYW1lKENsYXNzLCB0YWdOYW1lLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpLFxuICAgICAgICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0gZGVmYXVsdFByb3BlcnRpZXNGcm9tQ2xhc3MoQ2xhc3MpLFxuICAgICAgICAgIGlnbm9yZWRQcm9wZXJ0aWVzID0gaWdub3JlZFByb3BlcnRpZXNGcm9tQ2xhc3MoQ2xhc3MpO1xuXG4gICAgZWxlbWVudC5hcHBseVByb3BlcnRpZXMocHJvcGVydGllcywgZGVmYXVsdFByb3BlcnRpZXMsIGlnbm9yZWRQcm9wZXJ0aWVzKTtcblxuICAgIGVsZW1lbnQuaW5pdGlhbGlzZSAmJiBlbGVtZW50LmluaXRpYWxpc2UoKTsgLy8vXG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVGFnTmFtZSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBjb25zdCBDbGFzcyA9IEVsZW1lbnQsICAvLy9cbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZyb21UYWdOYW1lKENsYXNzLCB0YWdOYW1lLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpLFxuICAgICAgICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0ge30sIC8vL1xuICAgICAgICAgIGlnbm9yZWRQcm9wZXJ0aWVzID0gW107IC8vL1xuXG4gICAgZWxlbWVudC5hcHBseVByb3BlcnRpZXMocHJvcGVydGllcywgZGVmYXVsdFByb3BlcnRpZXMsIGlnbm9yZWRQcm9wZXJ0aWVzKTtcblxuICAgIGVsZW1lbnQuaW5pdGlhbGlzZSAmJiBlbGVtZW50LmluaXRpYWxpc2UoKTsgLy8vXG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBqc3hNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwga2V5TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGNsaWNrTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIHN0YXRlTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGV2ZW50TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIG1vdXNlTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIHJlc2l6ZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzY3JvbGxNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgZWxlbWVudE1peGlucyk7XG5cbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnQ7XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gbnVsbCxcbiAgICAgICAgZWxlbWVudCA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChDbGFzcywgbnVsbCwgc2VsZWN0b3IsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykpO1xuXG4gIGVsZW1lbnQuZG9tRWxlbWVudCA9IGlzU1ZHVGFnTmFtZSh0YWdOYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0VfVVJJLCB0YWdOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gIGVsZW1lbnQuZG9tRWxlbWVudC5fX2VsZW1lbnRfXyA9IGVsZW1lbnQ7IC8vL1xuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhDbGFzcywgZGVmYXVsdFByb3BlcnRpZXMgPSB7fSkge1xuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoREVGQVVMVF9QUk9QRVJUSUVTKSkge1xuICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0gY29tYmluZShkZWZhdWx0UHJvcGVydGllcywgQ2xhc3NbREVGQVVMVF9QUk9QRVJUSUVTXSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTtcblxuICBpZiAoc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0gZGVmYXVsdFByb3BlcnRpZXNGcm9tQ2xhc3Moc3VwZXJDbGFzcywgZGVmYXVsdFByb3BlcnRpZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRQcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBpZ25vcmVkUHJvcGVydGllc0Zyb21DbGFzcyhDbGFzcywgaWdub3JlZFByb3BlcnRpZXMgPSBbXSkge1xuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoSUdOT1JFRF9QUk9QRVJUSUVTKSkge1xuICAgIGlnbm9yZWRQcm9wZXJ0aWVzID0gYXVnbWVudChpZ25vcmVkUHJvcGVydGllcywgQ2xhc3NbSUdOT1JFRF9QUk9QRVJUSUVTXSwgKGlnbm9yZWRQcm9wZXJ0eSkgPT4gIWlnbm9yZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKGlnbm9yZWRQcm9wZXJ0eSkpO1xuICB9XG5cbiAgY29uc3Qgc3VwZXJDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGFzcyk7XG5cbiAgaWYgKHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICBpZ25vcmVkUHJvcGVydGllcyA9IGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKHN1cGVyQ2xhc3MsIGlnbm9yZWRQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHJldHVybiBpZ25vcmVkUHJvcGVydGllcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4vZWxlbWVudFwiO1xuXG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBTVFJJTkcsIEZVTkNUSU9OIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyByZW1vdmVGYWxzZXlFbGVtZW50cywgcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2VsZW1lbnRzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoZmlyc3RBcmd1bWVudCwgcHJvcGVydGllcywgLi4uY2hpbGRFbGVtZW50cykge1xuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgaWYgKGZpcnN0QXJndW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNoaWxkRWxlbWVudHMgPSBzYW5pdGlzZUNoaWxkRWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG5cbiAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjaGlsZEVsZW1lbnRzXG4gICAgfSwgcHJvcGVydGllcyk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAoaXNTdWJjbGFzc09mKGZpcnN0QXJndW1lbnQsIEVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBDbGFzcyA9IGZpcnN0QXJndW1lbnQ7ICAvLy9cblxuICAgICAgZWxlbWVudCA9IENsYXNzLmZyb21DbGFzcyhDbGFzcywgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmd1bWVudCA9PT0gU1RSSU5HKSB7XG4gICAgICBjb25zdCB0YWdOYW1lID0gZmlyc3RBcmd1bWVudDsgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBFbGVtZW50LmZyb21UYWdOYW1lKHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJndW1lbnQgPT09IEZVTkNUSU9OKSB7XG4gICAgICBjb25zdCBlbGVtZW50RnVuY3Rpb24gPSBmaXJzdEFyZ3VtZW50OyAgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50RnVuY3Rpb24ocHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmNvbnN0IFJlYWN0ID0ge1xuICBjcmVhdGVFbGVtZW50XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWFjdDtcblxuZnVuY3Rpb24gc2FuaXRpc2VDaGlsZEVsZW1lbnRzKGNoaWxkRWxlbWVudHMpIHtcbiAgY2hpbGRFbGVtZW50cyA9IGZsYXR0ZW4oY2hpbGRFbGVtZW50cyk7XG5cbiAgY2hpbGRFbGVtZW50cyA9IHJlbW92ZUZhbHNleUVsZW1lbnRzKGNoaWxkRWxlbWVudHMpO1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG5cbiAgcmV0dXJuIGNoaWxkRWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGlzU3ViY2xhc3NPZihhcmd1bWVudCwgQ2xhc3MpIHtcbiAgbGV0IHN1YmNsYXNzT2YgPSBmYWxzZTtcblxuICBpZiAoYXJndW1lbnQubmFtZSA9PT0gQ2xhc3MubmFtZSkgeyAvLy9cbiAgICBzdWJjbGFzc09mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBhcmd1bWVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhcmd1bWVudCk7IC8vL1xuXG4gICAgaWYgKGFyZ3VtZW50KSB7XG4gICAgICBzdWJjbGFzc09mID0gaXNTdWJjbGFzc09mKGFyZ3VtZW50LCBDbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YmNsYXNzT2Y7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5cbmltcG9ydCB7IEJPRFkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvZHkgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3IgPSBCT0RZKSB7XG4gICAgc3VwZXIoc2VsZWN0b3IpO1xuICB9XG5cbiAgc3RhdGljIHRhZ05hbWUgPSBcImJvZHlcIjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluayBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRIUmVmKCkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpOyB9XG5cbiAgc2V0SFJlZihocmVmKSB7IHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgaHJlZik7IH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYVwiO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDSEFOR0VfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlKGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbihDSEFOR0VfRVZFTlRfVFlQRSwgY2hhbmdlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ2hhbmdlKGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoQ0hBTkdFX0VWRU5UX1RZUEUsIGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmNvbnN0IGNoYW5nZU1peGlucyA9IHtcbiAgb25DaGFuZ2UsXG4gIG9mZkNoYW5nZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2hhbmdlTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi9lbGVtZW50XCI7XG5pbXBvcnQgY2hhbmdlTWl4aW5zIGZyb20gXCIuL21peGlucy9jaGFuZ2VcIjtcblxuaW1wb3J0IHsgQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi9ldmVudFR5cGVzXCI7XG5cbmNsYXNzIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBvbkNoYW5nZShjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub24oQ0hBTkdFX0VWRU5UX1RZUEUsIGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbiAgb2ZmQ2hhbmdlKGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmYoQ0hBTkdFX0VWRU5UX1RZUEUsIGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbiAgb25SZXNpemUocmVzaXplSGFuZGxlciwgZWxlbWVudCkge30gLy8vXG5cbiAgb2ZmUmVzaXplKHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpIHt9ICAvLy9cblxuICBnZXRWYWx1ZSgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC52YWx1ZTsgfVxuXG4gIGdldFNlbGVjdGlvblN0YXJ0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNlbGVjdGlvblN0YXJ0OyB9XG5cbiAgZ2V0U2VsZWN0aW9uRW5kKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNlbGVjdGlvbkVuZDsgfVxuICBcbiAgaXNSZWFkT25seSgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5yZWFkT25seTsgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7IHRoaXMuZG9tRWxlbWVudC52YWx1ZSA9IHZhbHVlOyB9XG5cbiAgc2V0U2VsZWN0aW9uU3RhcnQoc2VsZWN0aW9uU3RhcnQpIHsgdGhpcy5kb21FbGVtZW50LnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQ7IH1cblxuICBzZXRTZWxlY3Rpb25FbmQoc2VsZWN0aW9uRW5kKSB7IHRoaXMuZG9tRWxlbWVudC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7IH1cblxuICBzZXRSZWFkT25seShyZWFkT25seSkgeyB0aGlzLmRvbUVsZW1lbnQucmVhZE9ubHkgPSByZWFkT25seTsgfVxuXG4gIHNlbGVjdCgpIHsgdGhpcy5kb21FbGVtZW50LnNlbGVjdCgpOyB9XG59XG5cbk9iamVjdC5hc3NpZ24oSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgY2hhbmdlTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRFbGVtZW50O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgSW5wdXRFbGVtZW50IGZyb20gXCIuLi9pbnB1dEVsZW1lbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBJbnB1dEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiaW5wdXRcIjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uIGV4dGVuZHMgRWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJidXR0b25cIjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBjaGFuZ2VNaXhpbnMgZnJvbSBcIi4uL21peGlucy9jaGFuZ2VcIjtcblxuY2xhc3MgU2VsZWN0IGV4dGVuZHMgRWxlbWVudCB7XG4gIG9uUmVzaXplKHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpIHt9IC8vL1xuXG4gIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7fSAgLy8vXG5cbiAgZ2V0VmFsdWUoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQudmFsdWU7IH1cblxuICBzZXRWYWx1ZSh2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQudmFsdWUgPSB2YWx1ZTsgfVxuXG4gIHN0YXRpYyB0YWdOYW1lID0gXCJzZWxlY3RcIjtcbn1cblxuT2JqZWN0LmFzc2lnbihTZWxlY3QucHJvdG90eXBlLCBjaGFuZ2VNaXhpbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgY2hhbmdlTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvY2hhbmdlXCI7XG5cbmNsYXNzIENoZWNrYm94IGV4dGVuZHMgRWxlbWVudCB7XG4gIGlzQ2hlY2tlZCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jaGVja2VkOyB9XG5cbiAgY2hlY2soY2hlY2tlZCA9IHRydWUpIHsgdGhpcy5kb21FbGVtZW50LmNoZWNrZWQgPSBjaGVja2VkOyB9XG5cbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIHR5cGU6IFwiY2hlY2tib3hcIlxuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKENoZWNrYm94LnByb3RvdHlwZSwgY2hhbmdlTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBJbnB1dEVsZW1lbnQgZnJvbSBcIi4uL2lucHV0RWxlbWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0YXJlYSBleHRlbmRzIElucHV0RWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJ0ZXh0YXJlYVwiO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBvblJlc2l6ZSwgb2ZmUmVzaXplIH0gZnJvbSBcIi4uL21peGlucy9yZXNpemVcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvblJlc2l6ZSxcbiAgb2ZmUmVzaXplXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQga2V5TWl4aW5zIGZyb20gXCIuL21peGlucy9rZXlcIjtcbmltcG9ydCBldmVudE1peGlucyBmcm9tIFwiLi9taXhpbnMvZXZlbnRcIjtcbmltcG9ydCBtb3VzZU1peGlucyBmcm9tIFwiLi9taXhpbnMvbW91c2VcIjtcbmltcG9ydCBjbGlja01peGlucyBmcm9tIFwiLi9taXhpbnMvY2xpY2tcIjtcbmltcG9ydCB3aW5kb3dNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3dpbmRvd1wiO1xuXG5pbXBvcnQgeyBVTkRFRklORUQgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY2xhc3MgV2luZG93IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gd2luZG93OyAvLy9cbiAgfVxuXG4gIGFzc2lnbiguLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kb21FbGVtZW50OyAvLy9cblxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKTtcbiAgfVxuXG4gIGFkZFJlc2l6ZU9iamVjdCgpIHt9IC8vL1xuXG4gIHJlbW92ZVJlc2l6ZU9iamVjdCgpIHt9IC8vL1xuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmlubmVyV2lkdGg7IH0gLy8vXG4gIFxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIZWlnaHQ7IH0gLy8vXG5cbiAgZ2V0U2Nyb2xsVG9wKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnBhZ2VZT2Zmc2V0OyB9ICAvLy9cblxuICBnZXRTY3JvbGxMZWZ0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnBhZ2VYT2Zmc2V0OyB9IC8vL1xufVxuXG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGV2ZW50TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihXaW5kb3cucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIHdpbmRvd01peGlucyk7XG5cbmV4cG9ydCBkZWZhdWx0ICh0eXBlb2Ygd2luZG93ID09PSBVTkRFRklORUQpID8gdW5kZWZpbmVkIDogbmV3IFdpbmRvdygpOyAgLy8vXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBMRUZUX01PVVNFX0JVVFRPTiA9IDA7XG5leHBvcnQgY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OID0gMjtcbmV4cG9ydCBjb25zdCBNSURETEVfTU9VU0VfQlVUVE9OID0gMTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBMRUZUX01PVVNFX0JVVFRPTixcbiAgUklHSFRfTU9VU0VfQlVUVE9OLFxuICBNSURETEVfTU9VU0VfQlVUVE9OXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQga2V5TWl4aW5zIGZyb20gXCIuL21peGlucy9rZXlcIjtcbmltcG9ydCBjbGlja01peGlucyBmcm9tIFwiLi9taXhpbnMvY2xpY2tcIjtcbmltcG9ydCBldmVudE1peGlucyBmcm9tIFwiLi9taXhpbnMvZXZlbnRcIjtcbmltcG9ydCBtb3VzZU1peGlucyBmcm9tIFwiLi9taXhpbnMvbW91c2VcIjtcblxuaW1wb3J0IHsgVU5ERUZJTkVEIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQ7IC8vL1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0ICh0eXBlb2YgZG9jdW1lbnQgPT09IFVOREVGSU5FRCkgPyB1bmRlZmluZWQgOiBuZXcgRG9jdW1lbnQoKTsgIC8vL1xuXG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwga2V5TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRG9jdW1lbnQucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwgZXZlbnRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihEb2N1bWVudC5wcm90b3R5cGUsIG1vdXNlTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFjdCB9IGZyb20gXCIuL3JlYWN0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJvdW5kcyB9IGZyb20gXCIuL2JvdW5kc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXRcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCb2R5IH0gZnJvbSBcIi4vZWxlbWVudC9ib2R5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmsgfSBmcm9tIFwiLi9lbGVtZW50L2xpbmtcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5wdXQgfSBmcm9tIFwiLi9pbnB1dEVsZW1lbnQvaW5wdXRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uIH0gZnJvbSBcIi4vZWxlbWVudC9idXR0b25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0IH0gZnJvbSBcIi4vZWxlbWVudC9zZWxlY3RcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tib3ggfSBmcm9tIFwiLi9lbGVtZW50L2NoZWNrYm94XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRhcmVhIH0gZnJvbSBcIi4vaW5wdXRFbGVtZW50L3RleHRhcmVhXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRFbGVtZW50IH0gZnJvbSBcIi4vdGV4dEVsZW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5wdXRFbGVtZW50IH0gZnJvbSBcIi4vaW5wdXRFbGVtZW50XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2luZG93IH0gZnJvbSBcIi4vd2luZG93XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJ1dHRvbnMgfSBmcm9tIFwiLi9idXR0b25zXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRvY3VtZW50IH0gZnJvbSBcIi4vZG9jdW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRUeXBlcyB9IGZyb20gXCIuL2V2ZW50VHlwZXNcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUmVhY3QsIHdpbmRvdyB9IGZyb20gXCJlYXN5XCI7XG5cbndpbmRvdy5hc3NpZ24oe1xuICBSZWFjdFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcIi4vanV4dGFwb3NlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHRhZ05hbWVzID0gW1xuICBcImFcIiwgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFzaWRlXCIsIFwiYXVkaW9cIixcbiAgXCJiXCIsIFwiYmFzZVwiLCBcImJkaVwiLCBcImJkb1wiLCBcImJsb2NrcXVvdGVcIiwgXCJib2R5XCIsIFwiYnJcIiwgXCJidXR0b25cIixcbiAgXCJjYW52YXNcIiwgXCJjYXB0aW9uXCIsIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJjb2xcIiwgXCJjb2xncm91cFwiLFxuICBcImRhdGFcIiwgXCJkYXRhbGlzdFwiLCBcImRkXCIsIFwiZGVsXCIsIFwiZGV0YWlsc1wiLCBcImRmblwiLCBcImRpYWxvZ1wiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImVtYmVkXCIsIFwiZmllbGRzZXRcIiwgXCJmaWdjYXB0aW9uXCIsIFwiZmlndXJlXCIsIFwiZm9vdGVyXCIsIFwiZm9ybVwiLFxuICBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcImhlYWRcIiwgXCJoZWFkZXJcIiwgXCJoclwiLCBcImh0bWxcIixcbiAgXCJpXCIsIFwiaWZyYW1lXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibGlua1wiLFxuICBcIm1haW5cIiwgXCJtYXBcIiwgXCJtYXJrXCIsIFwibWV0YVwiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwibm9zY3JpcHRcIixcbiAgXCJvYmplY3RcIiwgXCJvbFwiLCBcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwib3V0cHV0XCIsXG4gIFwicFwiLCBcInBhcmFtXCIsIFwicGljdHVyZVwiLCBcInByZVwiLCBcInByb2dyZXNzXCIsXG4gIFwicVwiLCBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsXG4gIFwic1wiLCBcInNhbXBcIiwgXCJzY3JpcHRcIiwgXCJzZWN0aW9uXCIsIFwic2VsZWN0XCIsIFwic21hbGxcIiwgXCJzb3VyY2VcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3R5bGVcIiwgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsIFwic3VwXCIsIFwic3ZnXCIsXG4gIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGVtcGxhdGVcIiwgXCJ0ZXh0YXJlYVwiLCBcInRmb290XCIsIFwidGhcIiwgXCJ0aGVhZFwiLCBcInRpbWVcIiwgXCJ0aXRsZVwiLCBcInRyXCIsIFwidHJhY2tcIixcbiAgXCJ1XCIsIFwidWxcIixcbiAgXCJ2YXJcIiwgXCJ2aWRlb1wiLFxuICBcIndiclwiXG5dO1xuXG5leHBvcnQgZGVmYXVsdCB0YWdOYW1lcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRSQUNFX0xFVkVMID0gXCJ0cmFjZVwiO1xuZXhwb3J0IGNvbnN0IERFQlVHX0xFVkVMID0gXCJkZWJ1Z1wiO1xuZXhwb3J0IGNvbnN0IElORk9fTEVWRUwgPSBcImluZm9cIjtcbmV4cG9ydCBjb25zdCBXQVJOSU5HX0xFVkVMID0gXCJ3YXJuaW5nXCI7XG5leHBvcnQgY29uc3QgRVJST1JfTEVWRUwgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgRkFUQUxfTEVWRUwgPSBcImZhdGFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTCxcbiAgRkFUQUxfTEVWRUxcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBHRVRfTUVUSE9EID0gXCJHRVRcIjtcbmV4cG9ydCBjb25zdCBQT1NUX01FVEhPRCA9IFwiUE9TVFwiO1xuZXhwb3J0IGNvbnN0IFBBVENIX01FVEhPRCA9IFwiUEFUQ0hcIjtcbmV4cG9ydCBjb25zdCBERUxFVEVfTUVUSE9EID0gXCJERUxFVEVcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05TX01FVEhPRCA9IFwiT1BUSU9OU1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEdFVF9NRVRIT0QsXG4gIFBPU1RfTUVUSE9ELFxuICBQQVRDSF9NRVRIT0QsXG4gIERFTEVURV9NRVRIT0QsXG4gIE9QVElPTlNfTUVUSE9EXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgUFJBR01BX0hFQURFUiA9IFwicHJhZ21hXCI7XG5leHBvcnQgY29uc3QgQUNDRVBUX0hFQURFUiA9IFwiYWNjZXB0XCI7XG5leHBvcnQgY29uc3QgTE9DQVRJT05fSEVBREVSID0gXCJsb2NhdGlvblwiO1xuZXhwb3J0IGNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gXCJ1c2VyLWFnZW50XCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9IFwiY29udGVudC10eXBlXCI7XG5leHBvcnQgY29uc3QgQVVUSE9SSVpBVElPTl9IRUFERVIgPSBcImF1dGhvcml6YXRpb25cIjtcbmV4cG9ydCBjb25zdCBDQUNIRV9DT05UUk9MX0hFQURFUiA9IFwiY2FjaGUtY29udHJvbFwiO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfTEVOR1RIX0hFQURFUiA9IFwiY29udGVudC1sZW5ndGhcIjtcbmV4cG9ydCBjb25zdCBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIgPSBcInRyYW5zZmVyLWVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9ESVNQT1NJVElPTl9IRUFERVIgPSBcImNvbnRlbnQtZGlzcG9zaXRpb25cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1vcmlnaW5cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUiA9IFwiYWNjZXNzLWNvbnRyb2wtYWxsb3ctbWV0aG9kc1wiO1xuZXhwb3J0IGNvbnN0IEFDQ0VTU19DT05UUk9MX0FMTE9XX0hFQURFUlNfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzXCI7XG5leHBvcnQgY29uc3QgQUNDRVNTX0NPTlRST0xfUkVRVUVTVF9NRVRIT0RfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSQUdNQV9IRUFERVIsXG4gIEFDQ0VQVF9IRUFERVIsXG4gIExPQ0FUSU9OX0hFQURFUixcbiAgVVNFUl9BR0VOVF9IRUFERVIsXG4gIENPTlRFTlRfVFlQRV9IRUFERVIsXG4gIEFVVEhPUklaQVRJT05fSEVBREVSLFxuICBDQUNIRV9DT05UUk9MX0hFQURFUixcbiAgQ09OVEVOVF9MRU5HVEhfSEVBREVSLFxuICBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIsXG4gIENPTlRFTlRfRElTUE9TSVRJT05fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUixcbiAgQUNDRVNTX0NPTlRST0xfQUxMT1dfSEVBREVSU19IRUFERVIsXG4gIEFDQ0VTU19DT05UUk9MX1JFUVVFU1RfTUVUSE9EX0hFQURFUlxufTsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBTSElGVF9LRVlfQ09ERSA9IDE2O1xuZXhwb3J0IGNvbnN0IEVTQ0FQRV9LRVlDT0RFID0gMjc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgU0hJRlRfS0VZX0NPREUsXG4gIEVTQ0FQRV9LRVlDT0RFXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgVVRGOF9FTkNPRElORyA9IFwidXRmOFwiO1xuZXhwb3J0IGNvbnN0IFVURl84X0VOQ09ESU5HID0gXCJ1dGYtOFwiO1xuZXhwb3J0IGNvbnN0IEJBU0U2NF9FTkNPRElORyA9IFwiYmFzZTY0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVVRGOF9FTkNPRElORyxcbiAgVVRGXzhfRU5DT0RJTkcsXG4gIEJBU0U2NF9FTkNPRElOR1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEVUWF9DSEFSQUNURVIgPSBcIlxcdTAwMDNcIjtcbmV4cG9ydCBjb25zdCBCQVJfQ0hBUkFDVEVSID0gXCJ8XCI7XG5leHBvcnQgY29uc3QgREFTSF9DSEFSQUNURVIgPSBcIi1cIjtcbmV4cG9ydCBjb25zdCBTUEFDRV9DSEFSQUNURVIgPSBcIiBcIjtcbmV4cG9ydCBjb25zdCBDT01NQV9DSEFSQUNURVIgPSBcIixcIjtcbmV4cG9ydCBjb25zdCBDT0xPTl9DSEFSQUNURVIgPSBcIjpcIjtcbmV4cG9ydCBjb25zdCBQRVJJT0RfQ0hBUkFDVEVSID0gXCIuXCI7XG5leHBvcnQgY29uc3QgQ1RSTF9DX0NIQVJBQ1RFUiA9IFwiXkNcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBCQUNLVElDS19ERUxJTUlURVIgPSBcImBcIjtcbmV4cG9ydCBjb25zdCBORVdfTElORV9DSEFSQUNURVIgPSBcIlxcblwiO1xuZXhwb3J0IGNvbnN0IEJBQ0tTUEFDRV9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG5leHBvcnQgY29uc3QgQU1QRVJTQU5EX0NIQVJBQ1RFUiA9IFwiJlwiO1xuZXhwb3J0IGNvbnN0IExFU1NfVEhBTl9DSEFSQUNURVIgPSBcIiZsdDtcIjtcbmV4cG9ydCBjb25zdCBHUkVBVEVSX1RIQU5fQ0hBUkFDVEVSID0gXCImZ3Q7XCI7XG5leHBvcnQgY29uc3QgRk9SV0FSRF9TTEFTSF9DSEFSQUNURVIgPSBcIi9cIjtcbmV4cG9ydCBjb25zdCBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSID0gXCJcXHJcIjtcbmV4cG9ydCBjb25zdCBFWENMQU1BVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiIVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEVUWF9DSEFSQUNURVIsXG4gIEJBUl9DSEFSQUNURVIsXG4gIERBU0hfQ0hBUkFDVEVSLFxuICBTUEFDRV9DSEFSQUNURVIsXG4gIENPTU1BX0NIQVJBQ1RFUixcbiAgQ09MT05fQ0hBUkFDVEVSLFxuICBQRVJJT0RfQ0hBUkFDVEVSLFxuICBDVFJMX0NfQ0hBUkFDVEVSLFxuICBXSUxEQ0FSRF9DSEFSQUNURVIsXG4gIEJBQ0tUSUNLX0RFTElNSVRFUixcbiAgTkVXX0xJTkVfQ0hBUkFDVEVSLFxuICBBTVBFUlNBTkRfQ0hBUkFDVEVSLFxuICBCQUNLU1BBQ0VfQ0hBUkFDVEVSLFxuICBMRVNTX1RIQU5fQ0hBUkFDVEVSLFxuICBHUkVBVEVSX1RIQU5fQ0hBUkFDVEVSLFxuICBGT1JXQVJEX1NMQVNIX0NIQVJBQ1RFUixcbiAgQ0FSUklBR0VfUkVUVVJOX0NIQVJBQ1RFUixcbiAgRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVJcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBaRVJPXzBfU1RBVFVTX0NPREUgPSAwO1xuZXhwb3J0IGNvbnN0IE9LXzIwMF9TVEFUVVNfQ09ERSA9IDIwMDtcbmV4cG9ydCBjb25zdCBGT1VORF8zMDJfU1RBVFVTX0NPREUgPSAzMDI7XG5leHBvcnQgY29uc3QgQ1JFQVRFRF8yMDFfU1RBVFVTX0NPREUgPSAyMDE7XG5leHBvcnQgY29uc3QgU0VFX09USEVSXzMwM19TVEFUVVNfQ09ERSA9IDMwMztcbmV4cG9ydCBjb25zdCBGT1JCSURERU5fNDAzX1NUQVRVU19DT0RFID0gNDAzO1xuZXhwb3J0IGNvbnN0IE5PVF9GT1VORF80MDRfU1RBVFVTX0NPREUgPSA0MDQ7XG5leHBvcnQgY29uc3QgTk9fQ09OVEVOVF8yMDRfU1RBVFVTX0NPREUgPSAyMDQ7XG5leHBvcnQgY29uc3QgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19DT0RFID0gNTAyO1xuZXhwb3J0IGNvbnN0IEJBRF9SRVFVRVNUXzQwMF9TVEFUVVNfQ09ERSA9IDQwMDtcbmV4cG9ydCBjb25zdCBVTkFVVEhPUklTRURfNDAxX1NUQVRVU19DT0RFID0gNDAxO1xuZXhwb3J0IGNvbnN0IFRPT19NQU5ZX1JFUVVFU1RTXzQyOV9TVEFUVVNfQ09ERSA9IDQyOTtcbmV4cG9ydCBjb25zdCBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19DT0RFID0gNTAwO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFpFUk9fMF9TVEFUVVNfQ09ERSxcbiAgT0tfMjAwX1NUQVRVU19DT0RFLFxuICBGT1VORF8zMDJfU1RBVFVTX0NPREUsXG4gIENSRUFURURfMjAxX1NUQVRVU19DT0RFLFxuICBTRUVfT1RIRVJfMzAzX1NUQVRVU19DT0RFLFxuICBGT1JCSURERU5fNDAzX1NUQVRVU19DT0RFLFxuICBOT1RfRk9VTkRfNDA0X1NUQVRVU19DT0RFLFxuICBOT19DT05URU5UXzIwNF9TVEFUVVNfQ09ERSxcbiAgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19DT0RFLFxuICBCQURfUkVRVUVTVF80MDBfU1RBVFVTX0NPREUsXG4gIFVOQVVUSE9SSVNFRF80MDFfU1RBVFVTX0NPREUsXG4gIFRPT19NQU5ZX1JFUVVFU1RTXzQyOV9TVEFUVVNfQ09ERSxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SXzUwMF9TVEFUVVNfQ09ERVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRFWFRfSFRNTF9DT05URU5UX1RZUEUgPSBcInRleHQvaHRtbFwiO1xuZXhwb3J0IGNvbnN0IFRFWFRfUExBSU5fQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L3BsYWluXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbmV4cG9ydCBjb25zdCBBUFBMSUNBVElPTl9YX1dXV19GT1JNX0VOQ09ERURfQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmV4cG9ydCBjb25zdCBURVhUX0hUTUxfQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUgPSBcInRleHQvaHRtbDsgY2hhcnNldD11dGYtOFwiO1xuZXhwb3J0IGNvbnN0IFRFWFRfUExBSU5fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUgPSBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIjtcbmV4cG9ydCBjb25zdCBBUFBMSUNBVElPTl9KU09OX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fWF9XV1dfRk9STV9FTkNPREVEX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLThcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBURVhUX0hUTUxfQ09OVEVOVF9UWVBFLFxuICBURVhUX1BMQUlOX0NPTlRFTlRfVFlQRSxcbiAgQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIFRFWFRfSFRNTF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSxcbiAgVEVYVF9QTEFJTl9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSxcbiAgQVBQTElDQVRJT05fWF9XV1dfRk9STV9FTkNPREVEX0NPTlRFTlRfVFlQRSxcbiAgQVBQTElDQVRJT05fWF9XV1dfRk9STV9FTkNPREVEX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgT0tfMjAwX1NUQVRVU19NRVNTQUdFID0gXCJPS1wiO1xuZXhwb3J0IGNvbnN0IEZPVU5EXzMwMl9TVEFUVVNfTUVTU0FHRSA9IFwiRm91bmRcIjtcbmV4cG9ydCBjb25zdCBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSA9IFwiQ3JlYXRlZFwiO1xuZXhwb3J0IGNvbnN0IFNFRV9PVEhFUl8zMDNfU1RBVFVTX01FU1NBR0UgPSBcIlNlZSBvdGhlclwiO1xuZXhwb3J0IGNvbnN0IEZPUkJJRERFTl80MDNfU1RBVFVTX01FU1NBR0UgPSBcIkZvcmJpZGRlblwiO1xuZXhwb3J0IGNvbnN0IE5PVF9GT1VORF80MDRfU1RBVFVTX01FU1NBR0UgPSBcIk5vdCBmb3VuZFwiO1xuZXhwb3J0IGNvbnN0IE5PX0NPTlRFTlRfMjA0X1NUQVRVU19NRVNTQUdFID0gXCJObyBjb250ZW50XCI7XG5leHBvcnQgY29uc3QgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19NRVNTQUdFID0gXCJCYWQgZ2F0ZXdheVwiO1xuZXhwb3J0IGNvbnN0IEJBRF9SRVFVRVNUXzQwMF9TVEFUVVNfTUVTU0FHRSA9IFwiQmFkIHJlcXVlc3RcIjtcbmV4cG9ydCBjb25zdCBVTkFVVEhPUklTRURfNDAxX1NUQVRVU19NRVNTQUdFID0gXCJVbmF1dGhvcmlzZWRcIjtcbmV4cG9ydCBjb25zdCBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX01FU1NBR0UgPSBcIlRvbyBtYW55IHJlcXVlc3RzXCI7XG5leHBvcnQgY29uc3QgSU5URVJOQUxfU0VSVkVSX0VSUk9SXzUwMF9TVEFUVVNfTUVTU0FHRSA9IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgT0tfMjAwX1NUQVRVU19NRVNTQUdFLFxuICBGT1VORF8zMDJfU1RBVFVTX01FU1NBR0UsXG4gIENSRUFURURfMjAxX1NUQVRVU19NRVNTQUdFLFxuICBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFLFxuICBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFLFxuICBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFLFxuICBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSxcbiAgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19NRVNTQUdFLFxuICBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UsXG4gIFVOQVVUSE9SSVNFRF80MDFfU1RBVFVTX01FU1NBR0UsXG4gIFRPT19NQU5ZX1JFUVVFU1RTXzQyOV9TVEFUVVNfTUVTU0FHRSxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SXzUwMF9TVEFUVVNfTUVTU0FHRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7IHJldHVybiBhcnJheVswXTt9XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmQoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzFdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB0aGlyZChhcnJheSkgeyByZXR1cm4gYXJyYXlbMl07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvdXJ0aChhcnJheSkgeyByZXR1cm4gYXJyYXlbM107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpZnRoKGFycmF5KSB7IHJldHVybiBhcnJheVs0XTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlmdGhMYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSA1XTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZm91cnRoTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gNF07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gM107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDJdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCwgMSk7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDEpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZShhcnJheS5sZW5ndGggLSAxKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbnQoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDAsIGFycmF5Lmxlbmd0aCAtIDEpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoKGFycmF5MSwgYXJyYXkyKSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFycmF5MSwgYXJyYXkyKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zaGlmdChhcnJheTEsIGFycmF5MikgeyBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShhcnJheTEsIGFycmF5Mik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChhcnJheTEsIGVsZW1lbnRPckFycmF5Mikge1xuICBjb25zdCBhcnJheTIgPSAoZWxlbWVudE9yQXJyYXkyIGluc3RhbmNlb2YgQXJyYXkpID9cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE9yQXJyYXkyIDpcbiAgICAgICAgICAgICAgICAgICAgIFtlbGVtZW50T3JBcnJheTJdO1xuICBcbiAgcHVzaChhcnJheTEsIGFycmF5Mik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihhcnJheSkge1xuICBjb25zdCBzdGFydCA9IDA7XG4gIFxuICByZXR1cm4gYXJyYXkuc3BsaWNlKHN0YXJ0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoYXJyYXkxLCBhcnJheTIpIHtcbiAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICBkZWxldGVDb3VudCA9IGFycmF5Mi5sZW5ndGg7ICAvLy9cbiAgXG4gIHNwbGljZShhcnJheTEsIHN0YXJ0LCBkZWxldGVDb3VudCwgYXJyYXkyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKGFycmF5MSwgYXJyYXkyKSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFycmF5MSwgYXJyYXkyKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaWNlKGFycmF5MSwgc3RhcnQsIGRlbGV0ZUNvdW50ID0gSW5maW5pdHksIGFycmF5MiA9IFtdKSB7XG4gIGNvbnN0IGFyZ3MgPSBbc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5hcnJheTJdLFxuICAgICAgICBkZWxldGVkSXRlbXNBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoYXJyYXkxLCBhcmdzKTtcblxuICByZXR1cm4gZGVsZXRlZEl0ZW1zQXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlKGFycmF5LCBlbGVtZW50LCB0ZXN0KSB7XG4gIGxldCBzdGFydDtcbiAgXG4gIGNvbnN0IGZvdW5kID0gYXJyYXkuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSB0ZXN0KGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIHN0YXJ0ID0gaW5kZXg7ICAvLy9cbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgXG4gIGlmIChmb3VuZCkge1xuICAgIGNvbnN0IGRlbGV0ZUNvdW50ID0gMTtcblxuICAgIGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyKGFycmF5LCB0ZXN0KSB7XG4gIGNvbnN0IGZpbHRlcmVkRWxlbWVudHMgPSBbXTtcbiAgXG4gIGJhY2t3YXJkc0ZvckVhY2goYXJyYXksIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IHRlc3QoZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKCFwYXNzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMSxcbiAgICAgICAgICAgIGRlbGV0ZWRFbGVtZW50cyA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpLFxuICAgICAgICAgICAgZmlyc3REZWxldGVkRWxlbWVudCA9IGZpcnN0KGRlbGV0ZWRFbGVtZW50cyk7XG4gICAgICBcbiAgICAgIGZpbHRlcmVkRWxlbWVudHMudW5zaGlmdChmaXJzdERlbGV0ZWRFbGVtZW50KTsgIC8vL1xuICAgIH1cbiAgfSk7XG4gIFxuICByZXR1cm4gZmlsdGVyZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoYXJyYXksIHRlc3QpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICBmb3J3YXJkc0ZvckVhY2goYXJyYXksIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IHRlc3QoZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lKGFycmF5LCB0ZXN0KSB7XG4gIGxldCBwcnVuZWRFbGVtZW50ID0gdW5kZWZpbmVkO1xuICBcbiAgYXJyYXkuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSB0ZXN0KGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgICAgICBkZWxldGVDb3VudCA9IDEsXG4gICAgICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSxcbiAgICAgICAgICAgIGZpcnN0RGVsZXRlZEVsZW1lbnQgPSBmaXJzdChkZWxldGVkRWxlbWVudHMpO1xuICAgICAgXG4gICAgICBwcnVuZWRFbGVtZW50ID0gZmlyc3REZWxldGVkRWxlbWVudDsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIHBydW5lZEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaChhcnJheSwgZWxlbWVudCwgdGVzdCkge1xuICBjb25zdCBmb3VuZCA9IGFycmF5LnNvbWUoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgYXJyYXkucHVzaChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnQoYXJyYXkxLCBhcnJheTIsIHRlc3QpIHtcbiAgYXJyYXkyLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheTEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGUoYXJyYXksIGFycmF5MSwgYXJyYXkyLCB0ZXN0KSB7XG4gIGFycmF5LmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBwYXNzZWQgP1xuICAgICAgYXJyYXkxLnB1c2goZWxlbWVudCkgOlxuICAgICAgICBhcnJheTIucHVzaChlbGVtZW50KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc1NvbWUoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuICAgIFxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkc1NvbWUoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc0V2ZXJ5KGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSBhcnJheUxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc1JlZHVjZShhcnJheSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cbiAgZm9yd2FyZHNGb3JFYWNoKGFycmF5LCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCBlbGVtZW50LCBpbmRleCk7XG4gIH0pO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkc1JlZHVjZShhcnJheSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cbiAgYmFja3dhcmRzRm9yRWFjaChhcnJheSwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9KTtcblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc0ZvckVhY2goYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkc0ZvckVhY2goYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgIGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpcnN0LFxuICBzZWNvbmQsXG4gIHRoaXJkLFxuICBmb3VydGgsXG4gIGZpZnRoLFxuICBmaWZ0aExhc3QsXG4gIGZvdXJ0aExhc3QsXG4gIHRoaXJkTGFzdCxcbiAgc2Vjb25kTGFzdCxcbiAgZmlyc3RMYXN0LFxuICBsYXN0LFxuICBoZWFkLFxuICB0YWlsLFxuICBiYWNrLFxuICBmcm9udCxcbiAgcHVzaCxcbiAgdW5zaGlmdCxcbiAgY29uY2F0LFxuICBjbGVhcixcbiAgY29weSxcbiAgbWVyZ2UsXG4gIHNwbGljZSxcbiAgcmVwbGFjZSxcbiAgZmlsdGVyLFxuICBmaW5kLFxuICBwcnVuZSxcbiAgcGF0Y2gsXG4gIGF1Z21lbnQsXG4gIHNlcGFyYXRlLFxuICBmb3J3YXJkc1NvbWUsXG4gIGJhY2t3YXJkc1NvbWUsXG4gIGZvcndhcmRzRXZlcnksXG4gIGJhY2t3YXJkc0V2ZXJ5LFxuICBmb3J3YXJkc1JlZHVjZSxcbiAgYmFja3dhcmRzUmVkdWNlLFxuICBmb3J3YXJkc0ZvckVhY2gsXG4gIGJhY2t3YXJkc0ZvckVhY2hcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBEQVRBID0gXCJkYXRhXCI7XG5leHBvcnQgY29uc3QgRVJST1IgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgU1RSSU5HID0gXCJzdHJpbmdcIjtcbmV4cG9ydCBjb25zdCBOVU1CRVIgPSBcIm51bWJlclwiO1xuZXhwb3J0IGNvbnN0IEJPT0xFQU4gPSBcImJvb2xlYW5cIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUID0gXCJkZWZhdWx0XCI7XG5leHBvcnQgY29uc3QgRU5WSVJPTk1FTlQgPSBcIkVOVklST05NRU5UXCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc2Vjb25kIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQ09MT05fQ0hBUkFDVEVSLCBBTVBFUlNBTkRfQ0hBUkFDVEVSIH0gZnJvbSBcIi4uL2NoYXJhY3RlcnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJ3cml0ZShoZWFkZXJzLCBuYW1lLCB2YWx1ZSkge1xuICBjb25zdCBsb3dlckNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBleGlzdGluZ05hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycyksICAvLy9cbiAgICAgICAgZXhpc3RpbmdOYW1lID0gZXhpc3RpbmdOYW1lcy5maW5kKChleGlzdGluZ05hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0xvd2VyQ2FzZU5hbWUgPSBleGlzdGluZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIGlmIChleGlzdGluZ0xvd2VyQ2FzZU5hbWUgPT09IGxvd2VyQ2FzZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoZXhpc3RpbmdOYW1lICE9PSBudWxsKSB7XG4gICAgaGVhZGVyc1tleGlzdGluZ05hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZGVyd3JpdGUoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgZXhpc3RpbmdOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLCAgLy8vXG4gICAgICAgIGV4aXN0aW5nTmFtZSA9IGV4aXN0aW5nTmFtZXMuZmluZCgoZXhpc3RpbmdOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdMb3dlckNhc2VOYW1lID0gZXhpc3RpbmdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAoZXhpc3RpbmdMb3dlckNhc2VOYW1lID09PSBsb3dlckNhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IG51bGw7XG5cbiAgaWYgKGV4aXN0aW5nTmFtZSA9PT0gbnVsbCkge1xuICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9ydEZyb21Ib3N0KGhvc3QpIHtcbiAgbGV0IHBvcnQ7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goL15odHRwcz86XFwvXFwvKFteXFwvXSspLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpLFxuICAgICAgICBpbmRleCA9IHNlY29uZE1hdGNoLmluZGV4T2YoQ09MT05fQ0hBUkFDVEVSKTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgY29uc3Qgc2VjdXJlID0gc2VjdXJlRnJvbUhvc3QoaG9zdCk7XG5cbiAgICBwb3J0ID0gc2VjdXJlID8gNDQzIDogODA7IC8vL1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXggKyAxLFxuICAgICAgICAgIHBvcnRTdHJpbmcgPSBzZWNvbmRNYXRjaC5zdWJzdHJpbmcoc3RhcnQpO1xuXG4gICAgcG9ydCA9IE51bWJlcihwb3J0U3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBwb3J0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VjdXJlRnJvbUhvc3QoaG9zdCkge1xuICBjb25zdCBzZWN1cmUgPSAvXmh0dHBzOlxcL1xcLy8udGVzdChob3N0KTtcblxuICByZXR1cm4gc2VjdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaG9zdG5hbWVGcm9tSG9zdChob3N0KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKC9eaHR0cHM/OlxcL1xcLyhbXjpcXC9dKykvKSxcbiAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyksXG4gICAgICAgIGhvc3RuYW1lID0gc2Vjb25kTWF0Y2g7IC8vL1xuXG4gIHJldHVybiBob3N0bmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5U3RyaW5nRnJvbVF1ZXJ5KHF1ZXJ5KSB7XG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMocXVlcnkpLFxuICAgICAgICBuYW1lc0xlbmd0aCA9IG5hbWVzLmxlbmd0aCxcbiAgICAgICAgbGFzdEluZGV4ID0gbmFtZXNMZW5ndGggLSAxLFxuICAgICAgICBxdWVyeVN0cmluZyA9IG5hbWVzLnJlZHVjZSgocXVlcnlTdHJpbmcsIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVtuYW1lXSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkTmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpLFxuICAgICAgICAgICAgICAgIGFtcGVyc2FuZE9yTm90aGluZyA9IChpbmRleCAhPT0gbGFzdEluZGV4KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBTVBFUlNBTkRfQ0hBUkFDVEVSIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HO1xuICBcbiAgICAgICAgICBxdWVyeVN0cmluZyArPSBgJHtlbmNvZGVkTmFtZX09JHtlbmNvZGVkVmFsdWV9JHthbXBlcnNhbmRPck5vdGhpbmd9YDtcbiAgXG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICAgICAgICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBxdWVyeVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybEZyb21Ib3N0VVJJQW5kUXVlcnkoaG9zdCwgdXJpLCBxdWVyeSkge1xuICBjb25zdCBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nRnJvbVF1ZXJ5KHF1ZXJ5KSxcbiAgICAgICAgdXJsID0gKHF1ZXJ5U3RyaW5nID09PSBFTVBUWV9TVFJJTkcpID9cbiAgICAgICAgICAgICAgICBgJHtob3N0fSR7dXJpfWAgOlxuICAgICAgICAgICAgICAgICAgYCR7aG9zdH0ke3VyaX0/JHtxdWVyeVN0cmluZ31gO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb3ZlcndyaXRlLFxuICB1bmRlcndyaXRlLFxuICBwb3J0RnJvbUhvc3QsXG4gIHNlY3VyZUZyb21Ib3N0LFxuICBob3N0bmFtZUZyb21Ib3N0LFxuICBxdWVyeVN0cmluZ0Zyb21RdWVyeSxcbiAgdXJsRnJvbUhvc3RVUklBbmRRdWVyeVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgR0VUX01FVEhPRCwgUE9TVF9NRVRIT0QgfSBmcm9tIFwiLi4vbWV0aG9kc1wiO1xuaW1wb3J0IHsgQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUgfSBmcm9tIFwiLi4vY29udGVudFR5cGVzXCI7XG5pbXBvcnQgeyBBQ0NFUFRfSEVBREVSLCBDT05URU5UX1RZUEVfSEVBREVSIH0gZnJvbSBcIi4uL2hlYWRlcnNcIjtcbmltcG9ydCB7IHVuZGVyd3JpdGUsIHVybEZyb21Ib3N0VVJJQW5kUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2h0dHBcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldChob3N0LCB1cmksIHF1ZXJ5LCBoZWFkZXJzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gR0VUX01FVEhPRCxcbiAgICAgICAgYWNjZXB0ID0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUsXG4gICAgICAgIGNvbnRlbnQgPSBudWxsO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICByZXF1ZXN0KGhvc3QsIHVyaSwgcXVlcnksIG1ldGhvZCwgaGVhZGVycywgY29udGVudCwgY2FsbGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdChob3N0LCB1cmksIHF1ZXJ5LCBoZWFkZXJzLCBjb250ZW50LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGxiYWNrID0gY29udGVudDtcbiAgICBjb250ZW50ID0gaGVhZGVycztcbiAgICBoZWFkZXJzID0ge307XG4gIH1cblxuICBjb25zdCBtZXRob2QgPSBQT1NUX01FVEhPRCxcbiAgICAgICAgYWNjZXB0ID0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEU7XG5cbiAgdW5kZXJ3cml0ZUFjY2VwdEhlYWRlcihoZWFkZXJzLCBhY2NlcHQpO1xuXG4gIHVuZGVyd3JpdGVDb250ZW50VHlwZUhlYWRlcihoZWFkZXJzLCBjb250ZW50VHlwZSk7XG5cbiAgcmVxdWVzdChob3N0LCB1cmksIHF1ZXJ5LCBtZXRob2QsIGhlYWRlcnMsIGNvbnRlbnQsIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBoZWFkZXJzLCBjb250ZW50LCBjYWxsYmFjaykge1xuICBjb25zdCB1cmwgPSB1cmxGcm9tSG9zdFVSSUFuZFF1ZXJ5KGhvc3QsIHVyaSwgcXVlcnkpLFxuICAgICAgICBhY2NlcHQgPSBoZWFkZXJzW0FDQ0VQVF9IRUFERVJdIHx8IG51bGwsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gaGVhZGVyc1tDT05URU5UX1RZUEVfSEVBREVSXSB8fCBudWxsLFxuICAgICAgICB4bWxIdHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIGlmIChjb250ZW50VHlwZSA9PT0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUpIHtcbiAgICBjb25zdCBqc29uID0gY29udGVudCwgIC8vL1xuICAgICAgICAgIGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShqc29uKTtcblxuICAgIGNvbnRlbnQgPSBqc29uU3RyaW5nOyAgLy8vXG4gIH1cblxuICB4bWxIdHRwUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgY29uc3QgeyByZWFkeVN0YXRlLCBzdGF0dXMsIHJlc3BvbnNlIH0gPSB4bWxIdHRwUmVxdWVzdCxcbiAgICAgICAgICBzdGF0dXNDb2RlID0gc3RhdHVzO1xuXG4gICAgaWYgKHJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgbGV0IGNvbnRlbnQgPSByZXNwb25zZTtcblxuICAgICAgaWYgKGFjY2VwdCA9PT0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gY29udGVudCwgIC8vL1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuXG4gICAgICAgICAgY29udGVudCA9IGpzb247ICAvLy9cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhjb250ZW50LCBzdGF0dXNDb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgeG1sSHR0cFJlcXVlc3Qub3BlbihtZXRob2QsIHVybCk7XG5cbiAgaWYgKGFjY2VwdCAhPT0gbnVsbCkge1xuICAgIHhtbEh0dHBSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoQUNDRVBUX0hFQURFUiwgYWNjZXB0KTtcbiAgfVxuXG4gIGlmIChjb250ZW50VHlwZSAhPT0gbnVsbCkge1xuICAgIHhtbEh0dHBSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoQ09OVEVOVF9UWVBFX0hFQURFUiwgY29udGVudFR5cGUpO1xuICB9XG5cbiAgKGNvbnRlbnQgIT09IG51bGwpID9cbiAgICB4bWxIdHRwUmVxdWVzdC5zZW5kKGNvbnRlbnQpIDpcbiAgICAgIHhtbEh0dHBSZXF1ZXN0LnNlbmQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQsXG4gIHBvc3QsXG4gIHJlcXVlc3Rcbn1cblxuZnVuY3Rpb24gdW5kZXJ3cml0ZUFjY2VwdEhlYWRlcihoZWFkZXJzLCBhY2NlcHQpIHtcbiAgY29uc3QgbmFtZSA9IEFDQ0VQVF9IRUFERVIsICAvLy9cbiAgICAgICAgdmFsdWUgPSBhY2NlcHQ7IC8vL1xuXG4gIHVuZGVyd3JpdGUoaGVhZGVycywgbmFtZSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1bmRlcndyaXRlQ29udGVudFR5cGVIZWFkZXIoaGVhZGVycywgY29udGVudFRZcGUpIHtcbiAgY29uc3QgbmFtZSA9IENPTlRFTlRfVFlQRV9IRUFERVIsICAvLy9cbiAgICAgICAgdmFsdWUgPSBjb250ZW50VFlwZTsgLy8vXG5cbiAgdW5kZXJ3cml0ZShoZWFkZXJzLCBuYW1lLCB2YWx1ZSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQsIGxhc3QgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhOYW1lKHBhdGgpIHtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIEVNUFRZX1NUUklORykucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7IC8vL1xuXG4gIGNvbnN0IHBhdGhOYW1lID0gKC9cXC8vLnRlc3QocGF0aCkgPT09IGZhbHNlKTtcblxuICByZXR1cm4gcGF0aE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhUb3Btb3N0TmFtZShwYXRoKSB7XG4gIGNvbnN0IHBhdGhOYW1lID0gaXNQYXRoTmFtZShwYXRoKSxcbiAgICAgICAgcGF0aEFic29sdXRlUGF0aCA9IGlzUGF0aEFic29sdXRlUGF0aChwYXRoKSxcbiAgICAgICAgcGF0aFRvcG1vc3ROYW1lID0gKHBhdGhOYW1lICYmIHBhdGhBYnNvbHV0ZVBhdGgpO1xuXG4gIHJldHVybiBwYXRoVG9wbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhSZWxhdGl2ZVBhdGgocGF0aCkge1xuICBjb25zdCBwYXRoUmVsYXRpdmVQYXRoID0gIS9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoUmVsYXRpdmVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXRoQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgY29uc3QgcGF0aEFic29sdXRlUGF0aCA9IC9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoQWJzb2x1dGVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoKHRvcG1vc3ROYW1lLCBhYnNvbHV0ZVBhdGgpIHtcbiAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXiR7dG9wbW9zdE5hbWV9KD86XFxcXC8uKyk/JGApLFxuICAgICAgICB0b3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoID0gcmVnRXhwLnRlc3QoYWJzb2x1dGVQYXRoKTtcblxuICByZXR1cm4gdG9wbW9zdE5hbWVJbkFic29sdXRlUGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVBhdGhzKHBhdGgsIHJlbGF0aXZlUGF0aCkge1xuICBsZXQgY29tYmluZWRQYXRoID0gbnVsbDtcblxuICBjb25zdCBwYXRoTmFtZXMgPSBwYXRoLnNwbGl0KC9cXC8vKSxcbiAgICAgICAgcmVsYXRpdmVQYXRoTmFtZXMgPSByZWxhdGl2ZVBhdGguc3BsaXQoL1xcLy8pO1xuXG4gIGxldCBsYXN0UGF0aE5hbWUsXG4gICAgICBmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPSBmaXJzdChyZWxhdGl2ZVBhdGhOYW1lcyk7XG5cbiAgaWYgKGZpcnN0UmVsYXRpdmVQYXRoTmFtZSA9PT0gXCIuXCIpIHtcbiAgICByZWxhdGl2ZVBhdGhOYW1lcy5zaGlmdCgpO1xuICB9XG5cbiAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICBsYXN0UGF0aE5hbWUgPSBsYXN0KHBhdGhOYW1lcyk7XG5cbiAgd2hpbGUgKChmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPT09IFwiLi5cIikgJiYgKGxhc3RQYXRoTmFtZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHJlbGF0aXZlUGF0aE5hbWVzLnNoaWZ0KCk7XG4gICAgcGF0aE5hbWVzLnBvcCgpO1xuXG4gICAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICAgIGxhc3RQYXRoTmFtZSA9IGxhc3QocGF0aE5hbWVzKTtcbiAgfVxuXG4gIGlmIChsYXN0UGF0aE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbWJpbmVkUGF0aE5hbWVzID0gW10uY29uY2F0KHBhdGhOYW1lcykuY29uY2F0KHJlbGF0aXZlUGF0aE5hbWVzKTtcblxuICAgIGNvbWJpbmVkUGF0aCA9IGNvbWJpbmVkUGF0aE5hbWVzLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkUGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoKSB7XG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCBFTVBUWV9TVFJJTkcpOyAgLy8vXG5cbiAgY29uc3QgY29uY2F0ZW5hdGVkUGF0aCA9IGAke3BhdGh9LyR7cmVsYXRpdmVQYXRofWA7XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZFBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IGJvdHRvbW1vc3ROYW1lID0gbnVsbDtcblxuICBjb25zdCBtYXRjaGVzID0gcGF0aC5tYXRjaCgvXi4qXFwvKFteXFwvXStcXC8/KSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgYm90dG9tbW9zdE5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGJvdHRvbW1vc3ROYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4rKVxcL1teXFwvXStcXC8/JC8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgdG9wbW9zdERpcmVjdG9yeVBhdGggPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aChwYXRoKSB7XG4gIGxldCB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL14oW15cXC9dKylcXC8uKyQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWUgPSBudWxsO1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4qKVxcL1teXFwvXStcXC8/JC8pO1xuXG4gIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBwYXRoV2l0aG91dEJvdHRvbW1vc3ROYW1lID0gc2Vjb25kTWF0Y2g7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL15bXlxcL10rXFwvKC4rKSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IHNlY29uZE1hdGNoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0VG9wbW9zdERpcmVjdG9yeU5hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNQYXRoTmFtZSxcbiAgaXNQYXRoVG9wbW9zdE5hbWUsXG4gIGlzUGF0aFJlbGF0aXZlUGF0aCxcbiAgaXNQYXRoQWJzb2x1dGVQYXRoLFxuICBpc1RvcG1vc3ROYW1lSW5BYnNvbHV0ZVBhdGgsXG4gIGNvbWJpbmVQYXRocyxcbiAgY29uY2F0ZW5hdGVQYXRocyxcbiAgYm90dG9tbW9zdE5hbWVGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aCxcbiAgcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoLFxuICBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gd2hpbHN0KG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGxldCBjb3VudCA9IC0xO1xyXG5cclxuICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgY291bnQrKztcclxuXHJcbiAgICBjb25zdCBpbmRleCA9IGNvdW50LCAgLy8vXHJcbiAgICAgICAgICB0ZXJtaW5hdGUgPSBvcGVyYXRpb24obmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChhcnJheSwgb3BlcmF0aW9uLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyAgLy8vXHJcblxyXG4gIGxldCBjb3VudCA9IC0xO1xyXG5cclxuICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgY291bnQrKztcclxuXHJcbiAgICBjb25zdCB0ZXJtaW5hdGUgPSAoY291bnQgPT09IGxlbmd0aCk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xyXG4gICAgICBkb25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBpbmRleCA9IGNvdW50LCAgLy8vXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBhcnJheVtpbmRleF07XHJcblxyXG4gICAgICBvcGVyYXRpb24oZWxlbWVudCwgbmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVuY2Uob3BlcmF0aW9ucywgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IG9wZXJhdGlvbnMubGVuZ3RoOyAgLy8vXHJcblxyXG4gIGxldCBjb3VudCA9IC0xO1xyXG5cclxuICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgY291bnQrKztcclxuXHJcbiAgICBjb25zdCB0ZXJtaW5hdGUgPSAoY291bnQgPT09IGxlbmd0aCk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xyXG4gICAgICBkb25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBpbmRleCA9IGNvdW50LCAgLy8vXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50dWFsbHkob3BlcmF0aW9ucywgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IG9wZXJhdGlvbnMubGVuZ3RoOyAgLy8vXHJcblxyXG4gIGxldCBjb3VudCA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9wZXJhdGlvbnMuZm9yRWFjaCgob3BlcmF0aW9uLCBpbmRleCkgPT4ge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdGVkbHkob3BlcmF0aW9uLCBsZW5ndGgsIGRvbmUsIGNvbnRleHQpIHtcclxuICBsZXQgY291bnQgPSAwO1xyXG5cclxuICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgY291bnQrKztcclxuXHJcbiAgICBjb25zdCB0ZXJtaW5hdGUgPSAoY291bnQgPT09IGxlbmd0aCk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xyXG4gICAgICBkb25lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICBvcGVyYXRpb24obmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRm9yRWFjaChhcnJheSwgb3BlcmF0aW9uLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyAgLy8vXHJcblxyXG4gIGxldCBjb3VudCA9IC0xO1xyXG5cclxuICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgY291bnQrKztcclxuXHJcbiAgICBjb25zdCB0ZXJtaW5hdGUgPSAoY291bnQgPT09IGxlbmd0aCk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xyXG4gICAgICBkb25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBpbmRleCA9IGNvdW50LCAgLy8vXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBhcnJheVtpbmRleF07XHJcblxyXG4gICAgICBvcGVyYXRpb24oZWxlbWVudCwgbmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzRm9yRWFjaChhcnJheSwgb3BlcmF0aW9uLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyAgLy8vXHJcblxyXG4gIGxldCBjb3VudCA9IGxlbmd0aDtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50LS07XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSAtMSk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xyXG4gICAgICBkb25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBpbmRleCA9IGNvdW50LCAgLy8vXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBhcnJheVtpbmRleF07XHJcblxyXG4gICAgICBvcGVyYXRpb24oZWxlbWVudCwgbmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgd2hpbHN0LFxyXG4gIGZvckVhY2gsXHJcbiAgc2VxdWVuY2UsXHJcbiAgZXZlbnR1YWxseSxcclxuICByZXBlYXRlZGx5LFxyXG4gIGZvcndhcmRzRm9yRWFjaCxcclxuICBiYWNrd2FyZHNGb3JFYWNoXHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXZlbHMgfSBmcm9tIFwiLi9sZXZlbHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWV0aG9kcyB9IGZyb20gXCIuL21ldGhvZHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaGVhZGVycyB9IGZyb20gXCIuL2hlYWRlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMga2V5Q29kZXMgfSBmcm9tIFwiLi9rZXlDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbmNvZGluZ3MgfSBmcm9tIFwiLi9lbmNvZGluZ3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2hhcmFjdGVycyB9IGZyb20gXCIuL2NoYXJhY3RlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzQ29kZXMgfSBmcm9tIFwiLi9zdGF0dXNDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb250ZW50VHlwZXMgfSBmcm9tIFwiLi9jb250ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzTWVzc2FnZXMgfSBmcm9tIFwiLi9zdGF0dXNNZXNzYWdlc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGFqYXhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYWpheFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcGF0aFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBodHRwVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2h0dHBcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcclxuXHJcbmNvbnN0IHsgTEVTU19USEFOX0NIQVJBQ1RFUiwgQU1QRVJTQU5EX0NIQVJBQ1RFUiwgR1JFQVRFUl9USEFOX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGlzZUNvbnRlbnQoY29udGVudCkge1xyXG4gIGNvbnN0IHNhbml0aXNlZENvbnRlbnQgPSBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJi8sIEFNUEVSU0FORF9DSEFSQUNURVIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC8sIExFU1NfVEhBTl9DSEFSQUNURVIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi8sIEdSRUFURVJfVEhBTl9DSEFSQUNURVIpO1xyXG5cclxuICByZXR1cm4gc2FuaXRpc2VkQ29udGVudDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCB0eXBlVHlwZSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IG5hbWVUeXBlID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgY29tbWVudFR5cGUgPSBcImNvbW1lbnRcIjtcbmV4cG9ydCBjb25zdCBlbmRPZkxpbmVUeXBlID0gXCJlbmQtb2YtbGluZVwiO1xuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2VUeXBlID0gXCJ3aGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3Qgc3RyaW5nTGl0ZXJhbFR5cGUgPSBcInN0cmluZy1saXRlcmFsXCI7XG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lQ29tbWVudFR5cGUgPSBgJHtlbmRPZkxpbmVUeXBlfSAke2NvbW1lbnRUeXBlfWA7XG5leHBvcnQgY29uc3Qgc2luZ2xlTGluZUNvbW1lbnRUeXBlID0gYHNpbmdsZS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCByZWd1bGFyRXhwcmVzc2lvblR5cGUgPSBcInJlZ3VsYXItZXhwcmVzc2lvblwiO1xuZXhwb3J0IGNvbnN0IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgPSBgZW5kLW9mLW11bHRpLWxpbmUgJHtjb21tZW50VHlwZX1gO1xuZXhwb3J0IGNvbnN0IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZSA9IGBzdGFydC1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlID0gYG1pZGRsZS1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB0eXBlVHlwZSxcbiAgbmFtZVR5cGUsXG4gIGNvbW1lbnRUeXBlLFxuICBlbmRPZkxpbmVUeXBlLFxuICB3aGl0ZXNwYWNlVHlwZSxcbiAgc3RyaW5nTGl0ZXJhbFR5cGUsXG4gIGVuZE9mTGluZUNvbW1lbnRUeXBlLFxuICBzaW5nbGVMaW5lQ29tbWVudFR5cGUsXG4gIHJlZ3VsYXJFeHByZXNzaW9uVHlwZSxcbiAgZW5kT2ZNdWx0aUxpbmVDb21tZW50VHlwZSxcbiAgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlLFxuICBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9uZWNlc3NhcnkgPSByZXF1aXJlKFwibmVjZXNzYXJ5XCIpO1xudmFyIF9jb250ZW50ID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzL2NvbnRlbnRcIik7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgdmFyIGEgPSBbXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxudmFyIGZpcnN0ID0gX25lY2Vzc2FyeS5hcnJheVV0aWxpdGllcy5maXJzdDtcbnZhciBUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVG9rZW4odHlwZSwgY29udGVudCwgaW5uZXJIVE1MLCBzaWduaWZpY2FudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9rZW4pO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgICAgICAgdGhpcy5zaWduaWZpY2FudCA9IHNpZ25pZmljYW50O1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoVG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFR5cGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRDb250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0SW5uZXJIVE1MXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5uZXJIVE1MKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldENvbnRlbnRMZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzU2lnbmlmaWNhbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NpZ25pZmljYW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25pZmljYW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNDb21tZW50VG9rZW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NvbW1lbnRUb2tlbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUluY2x1ZGVzQ29tbWVudFR5cGUgPSB0aGlzLnR5cGUuaW5jbHVkZXMoX3R5cGVzLmNvbW1lbnRUeXBlKSwgY29tbWVudFRva2VuID0gdHlwZUluY2x1ZGVzQ29tbWVudFR5cGU7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc0VuZE9mTGluZVRva2VuXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbmRPZkxpbmVUb2tlbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUVuZE9mTGluZVR5cGUgPSB0aGlzLnR5cGUuaW5jbHVkZXMoX3R5cGVzLmVuZE9mTGluZVR5cGUpLCBlbmRPZkxpbmVUb2tlbiA9IHR5cGVFbmRPZkxpbmVUeXBlOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kT2ZMaW5lVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc1doaXRlc3BhY2VUb2tlblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzV2hpdGVzcGFjZVRva2VuKCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlV2hpdGVzcGFjZVR5cGUgPSB0aGlzLnR5cGUgPT09IF90eXBlcy53aGl0ZXNwYWNlVHlwZSwgd2hpdGVzcGFjZVRva2VuID0gdHlwZVdoaXRlc3BhY2VUeXBlOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gd2hpdGVzcGFjZVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNFcXVhbFRvXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbFRvKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVxdWFsVG9Ub2tlbiA9IHRoaXMgPT09IHRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbFRvVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0b2tlbi5nZXRUeXBlKCksIGNvbnRlbnQgPSB0b2tlbi5nZXRDb250ZW50KCksIHNpZ25pZmljYW50ID0gdG9rZW4uaXNTaWduaWZpY2FudCgpLCBtYXRjaGVzID0gdGhpcy50eXBlID09PSB0eXBlICYmIHRoaXMuY29udGVudCA9PT0gY29udGVudCAmJiB0aGlzLnNpZ25pZmljYW50ID09PSBzaWduaWZpY2FudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzSFRNTFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzSFRNTCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy50eXBlLCBodG1sID0gXCI8c3BhbiBjbGFzcz1cXFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCJcXFwiPlwiKS5jb25jYXQodGhpcy5pbm5lckhUTUwsIFwiPC9zcGFuPlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBzaWduaWZpY2FudCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmluZ0FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuID4gNCA/IF9sZW4gLSA0IDogMCksIF9rZXkgPSA0OyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzW19rZXkgLSA0XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiAhPT0gZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTsgLy8vXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRUeXBlKCksIHNhbml0aXNlZENvbnRlbnQgPSAoMCwgX2NvbnRlbnQpLnNhbml0aXNlQ29udGVudChjb250ZW50KSwgaW5uZXJIVE1MID0gc2FuaXRpc2VkQ29udGVudDsgLy8vXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gX2NvbnN0cnVjdChDbGFzcywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudFxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVtYWluaW5nQXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50LCBzaWduaWZpY2FudCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmluZ0FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgcmVndWxhckV4cHJlc3Npb24gPSBDbGFzcy5yZWd1bGFyRXhwcmVzc2lvbiwgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2gocmVndWxhckV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG1hdGNoZXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0TWF0Y2ggPSBmaXJzdChtYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmaXJzdE1hdGNoOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IENsYXNzLnR5cGUsIHNhbml0aXNlZENvbnRlbnQgPSAoMCwgX2NvbnRlbnQpLnNhbml0aXNlQ29udGVudChjb250ZW50KSwgaW5uZXJIVE1MID0gc2FuaXRpc2VkQ29udGVudDsgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBfY29uc3RydWN0KENsYXNzLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVtYWluaW5nQXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQsIHNpZ25pZmljYW50KSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVtYWluaW5nQXJndW1lbnRzID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdBcmd1bWVudHNbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IENsYXNzLnR5cGUsIHNhbml0aXNlZENvbnRlbnQgPSAoMCwgX2NvbnRlbnQpLnNhbml0aXNlQ29udGVudChjb250ZW50KSwgaW5uZXJIVE1MID0gc2FuaXRpc2VkQ29udGVudCwgdG9rZW4gPSBfY29uc3RydWN0KENsYXNzLCBbXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnRcbiAgICAgICAgICAgICAgICBdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVtYWluaW5nQXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50QW5kVHlwZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50QW5kVHlwZShDbGFzcywgY29udGVudCwgdHlwZSwgc2lnbmlmaWNhbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZW1haW5pbmdBcmd1bWVudHMgPSBuZXcgQXJyYXkoX2xlbiA+IDQgPyBfbGVuIC0gNCA6IDApLCBfa2V5ID0gNDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0FyZ3VtZW50c1tfa2V5IC0gNF0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzYW5pdGlzZWRDb250ZW50ID0gKDAsIF9jb250ZW50KS5zYW5pdGlzZUNvbnRlbnQoY29udGVudCksIGlubmVySFRNTCA9IHNhbml0aXNlZENvbnRlbnQsIHRva2VuID0gX2NvbnN0cnVjdChDbGFzcywgW1xuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50XG4gICAgICAgICAgICAgICAgXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlbWFpbmluZ0FyZ3VtZW50cykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gVG9rZW47XG59KCk7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTkwYjJ0bGJpNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUhzZ1lYSnlZWGxWZEdsc2FYUnBaWE1nZlNCbWNtOXRJRndpYm1WalpYTnpZWEo1WENJN1hHNWNibWx0Y0c5eWRDQjdJSE5oYm1sMGFYTmxRMjl1ZEdWdWRDQjlJR1p5YjIwZ1hDSXVMM1YwYVd4cGRHbGxjeTlqYjI1MFpXNTBYQ0k3WEc1cGJYQnZjblFnZXlCamIyMXRaVzUwVkhsd1pTd2daVzVrVDJaTWFXNWxWSGx3WlN3Z2QyaHBkR1Z6Y0dGalpWUjVjR1VnZlNCbWNtOXRJRndpTGk5MGVYQmxjMXdpTzF4dVhHNWpiMjV6ZENCN0lHWnBjbk4wSUgwZ1BTQmhjbkpoZVZWMGFXeHBkR2xsY3p0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVkc5clpXNGdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaDBlWEJsTENCamIyNTBaVzUwTENCcGJtNWxja2hVVFV3c0lITnBaMjVwWm1sallXNTBLU0I3WEc0Z0lDQWdkR2hwY3k1MGVYQmxJRDBnZEhsd1pUdGNiaUFnSUNCMGFHbHpMbU52Ym5SbGJuUWdQU0JqYjI1MFpXNTBPMXh1SUNBZ0lIUm9hWE11YVc1dVpYSklWRTFNSUQwZ2FXNXVaWEpJVkUxTU8xeHVJQ0FnSUhSb2FYTXVjMmxuYm1sbWFXTmhiblFnUFNCemFXZHVhV1pwWTJGdWREdGNiaUFnZlZ4dVhHNGdJR2RsZEZSNWNHVW9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11ZEhsd1pUdGNiaUFnZlZ4dVhHNGdJR2RsZEVOdmJuUmxiblFvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVkyOXVkR1Z1ZER0Y2JpQWdmVnh1SUNCY2JpQWdaMlYwU1c1dVpYSklWRTFNS0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxtbHVibVZ5U0ZSTlREdGNiaUFnZlZ4dVhHNGdJR2RsZEVOdmJuUmxiblJNWlc1bmRHZ29LU0I3WEc0Z0lDQWdZMjl1YzNRZ1kyOXVkR1Z1ZEV4bGJtZDBhQ0E5SUhSb2FYTXVZMjl1ZEdWdWRDNXNaVzVuZEdnN1hHNWNiaUFnSUNCeVpYUjFjbTRnWTI5dWRHVnVkRXhsYm1kMGFEdGNiaUFnZlZ4dVhHNGdJR2x6VTJsbmJtbG1hV05oYm5Rb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjMmxuYm1sbWFXTmhiblE3WEc0Z0lIMWNiaUFnWEc0Z0lHbHpRMjl0YldWdWRGUnZhMlZ1S0NrZ2UxeHVJQ0FnSUdOdmJuTjBJSFI1Y0dWSmJtTnNkV1JsYzBOdmJXMWxiblJVZVhCbElEMGdkR2hwY3k1MGVYQmxMbWx1WTJ4MVpHVnpLR052YlcxbGJuUlVlWEJsS1N4Y2JpQWdJQ0FnSUNBZ0lDQmpiMjF0Wlc1MFZHOXJaVzRnUFNCMGVYQmxTVzVqYkhWa1pYTkRiMjF0Wlc1MFZIbHdaVHNnTHk4dlhHNWNiaUFnSUNCeVpYUjFjbTRnWTI5dGJXVnVkRlJ2YTJWdU8xeHVJQ0I5WEc1Y2JpQWdhWE5GYm1SUFpreHBibVZVYjJ0bGJpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCMGVYQmxSVzVrVDJaTWFXNWxWSGx3WlNBOUlDaDBhR2x6TG5SNWNHVXVhVzVqYkhWa1pYTW9aVzVrVDJaTWFXNWxWSGx3WlNrcExGeHVJQ0FnSUNBZ0lDQWdJR1Z1WkU5bVRHbHVaVlJ2YTJWdUlEMGdkSGx3WlVWdVpFOW1UR2x1WlZSNWNHVTdJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJR1Z1WkU5bVRHbHVaVlJ2YTJWdU8xeHVJQ0I5WEc1Y2JpQWdhWE5YYUdsMFpYTndZV05sVkc5clpXNG9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2RIbHdaVmRvYVhSbGMzQmhZMlZVZVhCbElEMGdLSFJvYVhNdWRIbHdaU0E5UFQwZ2QyaHBkR1Z6Y0dGalpWUjVjR1VwTEZ4dUlDQWdJQ0FnSUNBZ0lIZG9hWFJsYzNCaFkyVlViMnRsYmlBOUlIUjVjR1ZYYUdsMFpYTndZV05sVkhsd1pUc2dMeTh2WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkMmhwZEdWemNHRmpaVlJ2YTJWdU8xeHVJQ0I5WEc1Y2JpQWdhWE5GY1hWaGJGUnZLSFJ2YTJWdUtTQjdYRzRnSUNBZ1kyOXVjM1FnWlhGMVlXeFViMVJ2YTJWdUlEMGdLSFJvYVhNZ1BUMDlJSFJ2YTJWdUtUdGNibHh1SUNBZ0lISmxkSFZ5YmlCbGNYVmhiRlJ2Vkc5clpXNDdYRzRnSUgxY2JseHVJQ0J0WVhSamFDaDBiMnRsYmlrZ2UxeHVJQ0FnSUdOdmJuTjBJSFI1Y0dVZ1BTQjBiMnRsYmk1blpYUlVlWEJsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdWdWRDQTlJSFJ2YTJWdUxtZGxkRU52Ym5SbGJuUW9LU3hjYmlBZ0lDQWdJQ0FnSUNCemFXZHVhV1pwWTJGdWRDQTlJSFJ2YTJWdUxtbHpVMmxuYm1sbWFXTmhiblFvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnRZWFJqYUdWeklEMGdLQ2gwYUdsekxuUjVjR1VnUFQwOUlIUjVjR1VwSUNZbUlDaDBhR2x6TG1OdmJuUmxiblFnUFQwOUlHTnZiblJsYm5RcElDWW1JQ2gwYUdsekxuTnBaMjVwWm1sallXNTBJRDA5UFNCemFXZHVhV1pwWTJGdWRDa3BPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHMWhkR05vWlhNN1hHNGdJSDFjYmx4dUlDQmhjMGhVVFV3b0tTQjdYRzRnSUNBZ1kyOXVjM1FnWTJ4aGMzTk9ZVzFsSUQwZ2RHaHBjeTUwZVhCbExDQWdMeTh2WEc0Z0lDQWdJQ0FnSUNBZ2FIUnRiQ0E5SUdBOGMzQmhiaUJqYkdGemN6MWNJaVI3WTJ4aGMzTk9ZVzFsZlZ3aVBpUjdkR2hwY3k1cGJtNWxja2hVVFV4OVBDOXpjR0Z1UG1BN1hHNWNiaUFnSUNCeVpYUjFjbTRnYUhSdGJEdGNiaUFnZlZ4dVhHNGdJR05zYjI1bEtFTnNZWE56TENCemRHRnlkRkJ2YzJsMGFXOXVMQ0JsYm1SUWIzTnBkR2x2Yml3Z2MybG5ibWxtYVdOaGJuUXNJQzR1TG5KbGJXRnBibWx1WjBGeVozVnRaVzUwY3lrZ2UxeHVJQ0FnSUd4bGRDQjBiMnRsYmlBOUlHNTFiR3c3WEc1Y2JpQWdJQ0JwWmlBb2MzUmhjblJRYjNOcGRHbHZiaUFoUFQwZ1pXNWtVRzl6YVhScGIyNHBJSHRjYmlBZ0lDQWdJR3hsZENCamIyNTBaVzUwSUQwZ2RHaHBjeTVuWlhSRGIyNTBaVzUwS0NrN1hHNWNiaUFnSUNBZ0lHTnZiblJsYm5RZ1BTQmpiMjUwWlc1MExuTjFZbk4wY21sdVp5aHpkR0Z5ZEZCdmMybDBhVzl1TENCbGJtUlFiM05wZEdsdmJpazdJQ0F2THk5Y2JseHVJQ0FnSUNBZ1kyOXVjM1FnZEhsd1pTQTlJSFJvYVhNdVoyVjBWSGx3WlNncExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYzJGdWFYUnBjMlZrUTI5dWRHVnVkQ0E5SUhOaGJtbDBhWE5sUTI5dWRHVnVkQ2hqYjI1MFpXNTBLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHbHVibVZ5U0ZSTlRDQTlJSE5oYm1sMGFYTmxaRU52Ym5SbGJuUTdJQzh2TDF4dVhHNGdJQ0FnSUNCMGIydGxiaUE5SUc1bGR5QkRiR0Z6Y3loMGVYQmxMQ0JqYjI1MFpXNTBMQ0JwYm01bGNraFVUVXdzSUhOcFoyNXBabWxqWVc1MExDQXVMaTV5WlcxaGFXNXBibWRCY21kMWJXVnVkSE1wTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQjBiMnRsYmp0Y2JpQWdmVnh1WEc0Z0lITjBZWFJwWXlCdFlYUmphQ2hEYkdGemN5d2dZMjl1ZEdWdWRDd2djMmxuYm1sbWFXTmhiblFzSUM0dUxuSmxiV0ZwYm1sdVowRnlaM1Z0Wlc1MGN5a2dlMXh1SUNBZ0lHeGxkQ0IwYjJ0bGJpQTlJRzUxYkd3N1hHNWNiaUFnSUNCamIyNXpkQ0I3SUhKbFozVnNZWEpGZUhCeVpYTnphVzl1SUgwZ1BTQkRiR0Z6Y3l4Y2JpQWdJQ0FnSUNBZ0lDQnRZWFJqYUdWeklEMGdZMjl1ZEdWdWRDNXRZWFJqYUNoeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlrN1hHNWNiaUFnSUNCcFppQW9iV0YwWTJobGN5QWhQVDBnYm5Wc2JDa2dlMXh1SUNBZ0lDQWdZMjl1YzNRZ2V5QnBibVJsZUNCOUlEMGdiV0YwWTJobGN6dGNibHh1SUNBZ0lDQWdhV1lnS0dsdVpHVjRJRDA5UFNBd0tTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElHWnBjbk4wVFdGMFkyZ2dQU0JtYVhKemRDaHRZWFJqYUdWektUdGNibHh1SUNBZ0lDQWdJQ0JqYjI1MFpXNTBJRDBnWm1seWMzUk5ZWFJqYURzZ0x5OHZYRzVjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZMjl1ZEdWdWRFeGxibWQwYUNBOUlHTnZiblJsYm5RdWJHVnVaM1JvTzF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hqYjI1MFpXNTBUR1Z1WjNSb0lENGdNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUhzZ2RIbHdaU0I5SUQwZ1EyeGhjM01zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJGdWFYUnBjMlZrUTI5dWRHVnVkQ0E5SUhOaGJtbDBhWE5sUTI5dWRHVnVkQ2hqYjI1MFpXNTBLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwYm01bGNraFVUVXdnUFNCellXNXBkR2x6WldSRGIyNTBaVzUwT3lBdkx5OWNibHh1SUNBZ0lDQWdJQ0FnSUhSdmEyVnVJRDBnYm1WM0lFTnNZWE56S0hSNWNHVXNJR052Ym5SbGJuUXNJR2x1Ym1WeVNGUk5UQ3dnYzJsbmJtbG1hV05oYm5Rc0lDNHVMbkpsYldGcGJtbHVaMEZ5WjNWdFpXNTBjeWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkRzlyWlc0N1hHNGdJSDFjYmx4dUlDQnpkR0YwYVdNZ1puSnZiVU52Ym5SbGJuUW9RMnhoYzNNc0lHTnZiblJsYm5Rc0lITnBaMjVwWm1sallXNTBMQ0F1TGk1eVpXMWhhVzVwYm1kQmNtZDFiV1Z1ZEhNcElIdGNiaUFnSUNCamIyNXpkQ0I3SUhSNWNHVWdmU0E5SUVOc1lYTnpMRnh1SUNBZ0lDQWdJQ0FnSUhOaGJtbDBhWE5sWkVOdmJuUmxiblFnUFNCellXNXBkR2x6WlVOdmJuUmxiblFvWTI5dWRHVnVkQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2FXNXVaWEpJVkUxTUlEMGdjMkZ1YVhScGMyVmtRMjl1ZEdWdWRDd2dMeTh2WEc0Z0lDQWdJQ0FnSUNBZ2RHOXJaVzRnUFNCdVpYY2dRMnhoYzNNb2RIbHdaU3dnWTI5dWRHVnVkQ3dnYVc1dVpYSklWRTFNTENCemFXZHVhV1pwWTJGdWRDd2dMaTR1Y21WdFlXbHVhVzVuUVhKbmRXMWxiblJ6S1R0Y2JseHVJQ0FnSUhKbGRIVnliaUIwYjJ0bGJqdGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0UTI5dWRHVnVkRUZ1WkZSNWNHVW9RMnhoYzNNc0lHTnZiblJsYm5Rc0lIUjVjR1VzSUhOcFoyNXBabWxqWVc1MExDQXVMaTV5WlcxaGFXNXBibWRCY21kMWJXVnVkSE1wSUh0Y2JpQWdJQ0JqYjI1emRDQnpZVzVwZEdselpXUkRiMjUwWlc1MElEMGdjMkZ1YVhScGMyVkRiMjUwWlc1MEtHTnZiblJsYm5RcExGeHVJQ0FnSUNBZ0lDQWdJR2x1Ym1WeVNGUk5UQ0E5SUhOaGJtbDBhWE5sWkVOdmJuUmxiblFzSUM4dkwxeHVJQ0FnSUNBZ0lDQWdJSFJ2YTJWdUlEMGdibVYzSUVOc1lYTnpLSFI1Y0dVc0lHTnZiblJsYm5Rc0lHbHVibVZ5U0ZSTlRDd2djMmxuYm1sbWFXTmhiblFzSUM0dUxuSmxiV0ZwYm1sdVowRnlaM1Z0Wlc1MGN5azdYRzVjYmlBZ0lDQnlaWFIxY200Z2RHOXJaVzQ3WEc0Z0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5Sm1hWEp6ZENJc0ltRnljbUY1VlhScGJHbDBhV1Z6SWl3aVZHOXJaVzRpTENKMGVYQmxJaXdpWTI5dWRHVnVkQ0lzSW1sdWJtVnlTRlJOVENJc0luTnBaMjVwWm1sallXNTBJaXdpWjJWMFZIbHdaU0lzSW1kbGRFTnZiblJsYm5RaUxDSm5aWFJKYm01bGNraFVUVXdpTENKblpYUkRiMjUwWlc1MFRHVnVaM1JvSWl3aVkyOXVkR1Z1ZEV4bGJtZDBhQ0lzSW14bGJtZDBhQ0lzSW1selUybG5ibWxtYVdOaGJuUWlMQ0pwYzBOdmJXMWxiblJVYjJ0bGJpSXNJblI1Y0dWSmJtTnNkV1JsYzBOdmJXMWxiblJVZVhCbElpd2lhVzVqYkhWa1pYTWlMQ0pqYjIxdFpXNTBWSGx3WlNJc0ltTnZiVzFsYm5SVWIydGxiaUlzSW1selJXNWtUMlpNYVc1bFZHOXJaVzRpTENKMGVYQmxSVzVrVDJaTWFXNWxWSGx3WlNJc0ltVnVaRTltVEdsdVpWUjVjR1VpTENKbGJtUlBaa3hwYm1WVWIydGxiaUlzSW1selYyaHBkR1Z6Y0dGalpWUnZhMlZ1SWl3aWRIbHdaVmRvYVhSbGMzQmhZMlZVZVhCbElpd2lkMmhwZEdWemNHRmpaVlI1Y0dVaUxDSjNhR2wwWlhOd1lXTmxWRzlyWlc0aUxDSnBjMFZ4ZFdGc1ZHOGlMQ0owYjJ0bGJpSXNJbVZ4ZFdGc1ZHOVViMnRsYmlJc0ltMWhkR05vSWl3aWJXRjBZMmhsY3lJc0ltRnpTRlJOVENJc0ltTnNZWE56VG1GdFpTSXNJbWgwYld3aUxDSmpiRzl1WlNJc0lrTnNZWE56SWl3aWMzUmhjblJRYjNOcGRHbHZiaUlzSW1WdVpGQnZjMmwwYVc5dUlpd2ljbVZ0WVdsdWFXNW5RWEpuZFcxbGJuUnpJaXdpYzNWaWMzUnlhVzVuSWl3aWMyRnVhWFJwYzJWa1EyOXVkR1Z1ZENJc0luTmhibWwwYVhObFEyOXVkR1Z1ZENJc0luSmxaM1ZzWVhKRmVIQnlaWE56YVc5dUlpd2lhVzVrWlhnaUxDSm1hWEp6ZEUxaGRHTm9JaXdpWm5KdmJVTnZiblJsYm5RaUxDSm1jbTl0UTI5dWRHVnVkRUZ1WkZSNWNHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZLMElzU1VGQlFTeFZRVUZYTEZkQlFWZ3NWMEZCVnl4RFFVRkJPMEZCUlZZc1NVRkJRU3hSUVVGeFFpeFhRVUZ5UWl4eFFrRkJjVUlzUTBGQlFUdEJRVU5OTEVsQlFVRXNUVUZCVXl4WFFVRlVMRk5CUVZNc1EwRkJRVHM3ZVVSQlRIQkZPM1ZGUVVGQk96czdPenM3T3pzN096czdPenM3TzJkR1FVRkJPenM3T3pzN096dHpRMEZCUVRzN096czdPMmxEUVVGQk96czdhVVZCUVVFN08xTkJRVUU3T3pzN096czdPRVJCUVVFN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPenM3T3pzN095dEVRVUZCT3pzN08wRkJUMEVzU1VGQlRTeEJRVUZGUVN4TFFVRkxMRWRCUVV0RExGVkJRV01zWjBKQlFYaENSQ3hMUVVGTExFRkJRVzFDTEVGQlFVTTdRVUZGYkVJc1NVRkJRU3hCUVVGTlJTeExRVUZMTEdsQ1ExUjJRaXhCUkZOWk8yRkJRVTFCTEV0QlFVc3NRMEZEV2tNc1NVRkJTU3hGUVVGRlF5eFBRVUZQTEVWQlFVVkRMRk5CUVZNc1JVRkJSVU1zVjBGQlZ6dHZRMEZXYmtRN1VVRlhTU3hKUVVGSkxFTkJRVU5JTEVsQlFVa3NSMEZCUjBFc1NVRkJTU3hEUVVGRE8xRkJRMnBDTEVsQlFVa3NRMEZCUTBNc1QwRkJUeXhIUVVGSFFTeFBRVUZQTEVOQlFVTTdVVUZEZGtJc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVkQlFVZEJMRk5CUVZNc1EwRkJRenRSUVVNelFpeEpRVUZKTEVOQlFVTkRMRmRCUVZjc1IwRkJSMEVzVjBGQlZ5eERRVUZET3pzN08xbEJSMnBEUXl4SFFVRlBMRVZCUVZCQkxGTkJRVTg3V1VWcVFsUXNUMFpwUWtWQkxGTkJRVUZCTEU5QlFVOHNSMEZCUnp0blFrRkRVaXhQUVVGUExFbEJRVWtzUTBGQlEwb3NTVUZCU1N4RFFVRkRPMkZCUTJ4Q096czdXVUZGUkVzc1IwRkJWU3hGUVVGV1FTeFpRVUZWTzFsRmNrSmFMRTlHY1VKRlFTeFRRVUZCUVN4VlFVRlZMRWRCUVVjN1owSkJRMWdzVDBGQlR5eEpRVUZKTEVOQlFVTktMRTlCUVU4c1EwRkJRenRoUVVOeVFqczdPMWxCUlVSTExFZEJRVmtzUlVGQldrRXNZMEZCV1R0WlJYcENaQ3hQUm5sQ1JVRXNVMEZCUVVFc1dVRkJXU3hIUVVGSE8yZENRVU5pTEU5QlFVOHNTVUZCU1N4RFFVRkRTaXhUUVVGVExFTkJRVU03WVVGRGRrSTdPenRaUVVWRVN5eEhRVUZuUWl4RlFVRm9Ra0VzYTBKQlFXZENPMWxGTjBKc1FpeFBSalpDUlVFc1UwRkJRVUVzWjBKQlFXZENMRWRCUVVjN1owSkJRMnBDTEVsQlFVMURMR0ZCUVdFc1IwRkJSeXhKUVVGSkxFTkJRVU5RTEU5QlFVOHNRMEZCUTFFc1RVRkJUU3hCUVVGRE8yZENRVVV4UXl4UFFVRlBSQ3hoUVVGaExFTkJRVU03WVVGRGRFSTdPenRaUVVWRVJTeEhRVUZoTEVWQlFXSkJMR1ZCUVdFN1dVVnVRMllzVDBadFEwVkJMRk5CUVVGQkxHRkJRV0VzUjBGQlJ6dG5Ra0ZEWkN4UFFVRlBMRWxCUVVrc1EwRkJRMUFzVjBGQlZ5eERRVUZETzJGQlEzcENPenM3V1VGRlJGRXNSMEZCWXl4RlFVRmtRU3huUWtGQll6dFpSWFpEYUVJc1QwWjFRMFZCTEZOQlFVRkJMR05CUVdNc1IwRkJSenRuUWtGRFppeEpRVUZOUXl4MVFrRkJkVUlzUjBGQlJ5eEpRVUZKTEVOQlFVTmFMRWxCUVVrc1EwRkJRMkVzVVVGQlVTeERRVUZEUXl4TlFVRlhMR0ZCUVVNc1JVRkRla1JETEZsQlFWa3NSMEZCUjBnc2RVSkJRWFZDTEVGQlFVTXNSVUZCUXl4SFFVRkhPMmRDUVVWcVJDeFBRVUZQUnl4WlFVRlpMRU5CUVVNN1lVRkRja0k3T3p0WlFVVkVReXhIUVVGblFpeEZRVUZvUWtFc2EwSkJRV2RDTzFsRk9VTnNRaXhQUmpoRFJVRXNVMEZCUVVFc1owSkJRV2RDTEVkQlFVYzdaMEpCUTJwQ0xFbEJRVTFETEdsQ1FVRnBRaXhIUVVGSkxFbEJRVWtzUTBGQlEycENMRWxCUVVrc1EwRkJRMkVzVVVGQlVTeERRVUZEU3l4TlFVRmhMR1ZCUVVNc1FVRkJReXhGUVVOMlJFTXNZMEZCWXl4SFFVRkhSaXhwUWtGQmFVSXNRVUZCUXl4RlFVRkRMRWRCUVVjN1owSkJSVGRETEU5QlFVOUZMR05CUVdNc1EwRkJRenRoUVVOMlFqczdPMWxCUlVSRExFZEJRV2xDTEVWQlFXcENRU3h0UWtGQmFVSTdXVVZ5Ukc1Q0xFOUdjVVJGUVN4VFFVRkJRU3hwUWtGQmFVSXNSMEZCUnp0blFrRkRiRUlzU1VGQlRVTXNhMEpCUVd0Q0xFZEJRVWtzU1VGQlNTeERRVUZEY2tJc1NVRkJTU3hMUVVGTGMwSXNUVUZCWXl4bFFVRkJMRUZCUVVNc1JVRkRia1JETEdWQlFXVXNSMEZCUjBZc2EwSkJRV3RDTEVGQlFVTXNSVUZCUXl4SFFVRkhPMmRDUVVVdlF5eFBRVUZQUlN4bFFVRmxMRU5CUVVNN1lVRkRlRUk3T3p0WlFVVkVReXhIUVVGVExFVkJRVlJCTEZkQlFWTTdXVVUxUkZnc1QwWTBSRVZCTEZOQlFVRkJMRk5CUVZNc1EwRkJRME1zUzBGQlN5eEZRVUZGTzJkQ1FVTm1MRWxCUVUxRExGbEJRVmtzUjBGQlNTeEpRVUZKTEV0QlFVdEVMRXRCUVVzc1FVRkJReXhCUVVGRE8yZENRVVYwUXl4UFFVRlBReXhaUVVGWkxFTkJRVU03WVVGRGNrSTdPenRaUVVWRVF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVVnNSVkFzVDBaclJVVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwWXNTMEZCU3l4RlFVRkZPMmRDUVVOWUxFbEJRVTE2UWl4SlFVRkpMRWRCUVVkNVFpeExRVUZMTEVOQlFVTnlRaXhQUVVGUExFVkJRVVVzUlVGRGRFSklMRTlCUVU4c1IwRkJSM2RDTEV0QlFVc3NRMEZCUTNCQ0xGVkJRVlVzUlVGQlJTeEZRVU0xUWtZc1YwRkJWeXhIUVVGSGMwSXNTMEZCU3l4RFFVRkRaaXhoUVVGaExFVkJRVVVzUlVGRGJrTnJRaXhQUVVGUExFZEJRVWtzUVVGQlF5eEpRVUZKTEVOQlFVTTFRaXhKUVVGSkxFdEJRVXRCTEVsQlFVa3NTVUZCVFN4SlFVRkpMRU5CUVVORExFOUJRVThzUzBGQlMwRXNUMEZCVHl4SlFVRk5MRWxCUVVrc1EwRkJRMFVzVjBGQlZ5eExRVUZMUVN4WFFVRlhMRUZCUVVNc1FVRkJReXhCUVVGRE8yZENRVVV6Unl4UFFVRlBlVUlzVDBGQlR5eERRVUZETzJGQlEyaENPenM3V1VGRlJFTXNSMEZCVFN4RlFVRk9RU3hSUVVGTk8xbEZNMFZTTEU5R01rVkZRU3hUUVVGQlFTeE5RVUZOTEVkQlFVYzdaMEpCUTFBc1NVRkJUVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXpsQ0xFbEJRVWtzUlVGRGNrSXJRaXhKUVVGSkxFZEJRVWNzUVVGQlF5eG5Ra0ZCWVN4RFFVRm5RaXhOUVVGakxFTkJRVFZDUkN4VFFVRlRMRVZCUVVNc1MwRkJSU3hEUVVGcFFpeERRVUZCTEUxQlFVOHNRMEZCZEVJc1NVRkJTU3hEUVVGRE5VSXNVMEZCVXl4RlFVRkRMRk5CUVU4c1EwRkJReXhCUVVGRE8yZENRVVZ1UlN4UFFVRlBOa0lzU1VGQlNTeERRVUZETzJGQlEySTdPenRaUVVWRVF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVVnNSbEFzVDBaclJrVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwTXNTMEZCU3l4RlFVRkZReXhoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUldoRExGZEJRVmNzUlVGQmVVSTdaMEpCUVhaQ0xFbEJRVUVzU1VGQlFTeEpRVUZ4UWl4SFFVRnlRaXhUUVVGeFFpeERRVUZ5UWl4TlFVRnhRaXhGUVVGeVFpeEJRVUZIYVVNc2EwSkJRV3RDTEVkQlFYSkNMRlZCUVVFc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1IwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQlFTeERRVUZCTEVWQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRVZCUVhKQ0xFbEJRWEZDTEVkQlFYSkNMRWxCUVhGQ0xFVkJRWEpDTEVsQlFYRkNMRVZCUVVFc1EwRkJja0k3YjBKQlFVRXNRVUZCUjBFc2EwSkJRV3RDTEVOQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRWxCUVhKQ0xGTkJRWEZDTEVGQlFYSkNMRU5CUVVFc1NVRkJjVUlzUTBGQlFTeEJSV3hHTjBVc1EwWnJSalpGTzJsQ1FVRkJPMmRDUVVONlJTeEpRVUZKV0N4TFFVRkxMRWRCUVVjc1NVRkJTU3hCUVVGRE8yZENRVVZxUWl4SlFVRkpVeXhoUVVGaExFdEJRVXRETEZkQlFWY3NSVUZCUlR0dlFrRkRha01zU1VGQlNXeERMRTlCUVU4c1IwRkJSeXhKUVVGSkxFTkJRVU5KTEZWQlFWVXNSVUZCUlN4QlFVRkRPMjlDUVVWb1Ewb3NUMEZCVHl4SFFVRkhRU3hQUVVGUExFTkJRVU52UXl4VFFVRlRMRU5CUVVOSUxHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJSU3hIUVVGSE8yOUNRVVUzUkN4SlFVRk5ia01zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUTBrc1QwRkJUeXhGUVVGRkxFVkJRM0pDYTBNc1owSkJRV2RDTEVkQlFVZERMRU5CUVVGQkxFZEJRVUZCTEZGQlFXVXNRVUZCVXl4RFFVRkJMR2xDUVVGU2RFTXNUMEZCVHl4RFFVRkRMRVZCUXpORFF5eFRRVUZUTEVkQlFVZHZReXhuUWtGQlowSXNRVUZCUXl4RlFVRkRMRWRCUVVjN2IwSkJSWFpEWWl4TFFVRkxMRWRCUVVjc1YwRkJTVkVzUzBGQlN5eEZRVUZVTzNkQ1FVRlZha01zU1VGQlNUdDNRa0ZCUlVNc1QwRkJUenQzUWtGQlJVTXNVMEZCVXp0M1FrRkJSVU1zVjBGQlZ6dHhRa0ZCZDBJc1EwRkJka1VzVFVGQmRVVXNRMEZCZEVJc2JVSkJRVWRwUXl4clFrRkJhMElzUTBGQmJFSkJMRU5CUVcxQ0xFTkJRVUVzUTBGQlF6dHBRa0ZEYWtZN1owSkJSVVFzVDBGQlQxZ3NTMEZCU3l4RFFVRkRPMkZCUTJRN096czdXVUZGVFVVc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRmNFZGtMRTlHYjBkRkxGTkJRVTlCTEV0QlFVc3NRMEZCUTAwc1MwRkJTeXhGUVVGRmFFTXNUMEZCVHl4RlFVRkZSU3hYUVVGWExFVkJRWGxDTzJkQ1FVRjJRaXhKUVVGQkxFbEJRVUVzU1VGQmNVSXNSMEZCY2tJc1UwRkJjVUlzUTBGQmNrSXNUVUZCY1VJc1JVRkJja0lzUVVGQlIybERMR3RDUVVGclFpeEhRVUZ5UWl4VlFVRkJMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRWRCUVhKQ0xFbEJRWEZDTEVkQlFYSkNMRU5CUVhGQ0xFbEJRVUVzUTBGQlFTeEZRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeERRVUZ4UWl4RlFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4SlFVRnhRaXhGUVVGeVFpeEpRVUZ4UWl4RlFVRkJMRU5CUVhKQ08yOUNRVUZCTEVGQlFVZEJMR3RDUVVGclFpeERRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeERRVUZ4UWl4SlFVRnlRaXhUUVVGeFFpeEJRVUZ5UWl4RFFVRkJMRWxCUVhGQ0xFTkJRVUVzUVVWd1IycEZMRU5HYjBkcFJUdHBRa0ZCUVR0blFrRkROMFFzU1VGQlNWZ3NTMEZCU3l4SFFVRkhMRWxCUVVrc1FVRkJRenRuUWtGRmFrSXNTVUZCVFN4QlFVRkZaU3hwUWtGQmFVSXNSMEZCUzFBc1MwRkJTeXhEUVVFelFrOHNhVUpCUVdsQ0xFRkJRVlVzUlVGRE4wSmFMRTlCUVU4c1IwRkJSek5DTEU5QlFVOHNRMEZCUXpCQ0xFdEJRVXNzUTBGQlEyRXNhVUpCUVdsQ0xFTkJRVU1zUVVGQlF6dG5Ra0ZGYWtRc1NVRkJTVm9zVDBGQlR5eExRVUZMTEVsQlFVa3NSVUZCUlR0dlFrRkRjRUlzU1VGQlRTeEJRVUZGWVN4TFFVRkxMRWRCUVV0aUxFOUJRVThzUTBGQmFrSmhMRXRCUVVzc1FVRkJXU3hCUVVGRE8yOUNRVVV4UWl4SlFVRkpRU3hMUVVGTExFdEJRVXNzUTBGQlF5eEZRVUZGTzNkQ1FVTm1MRWxCUVUxRExGVkJRVlVzUjBGQlJ6ZERMRXRCUVVzc1EwRkJReXRDTEU5QlFVOHNRMEZCUXl4QlFVRkRPM2RDUVVWc1F6TkNMRTlCUVU4c1IwRkJSM2xETEZWQlFWVXNRMEZCUXl4RFFVRkRMRWRCUVVjN2QwSkJSWHBDTEVsQlFVMXNReXhoUVVGaExFZEJRVWRRTEU5QlFVOHNRMEZCUTFFc1RVRkJUU3hCUVVGRE8zZENRVVZ5UXl4SlFVRkpSQ3hoUVVGaExFZEJRVWNzUTBGQlF5eEZRVUZGT3pSQ1FVTnlRaXhKUVVGTkxFRkJRVVZTTEVsQlFVa3NSMEZCUzJsRExFdEJRVXNzUTBGQlpHcERMRWxCUVVrc1FVRkJWU3hGUVVOb1FuTkRMR2RDUVVGblFpeEhRVUZIUXl4RFFVRkJRU3hIUVVGQlFTeFJRVUZsTEVGQlFWTXNRMEZCUVN4cFFrRkJVblJETEU5QlFVOHNRMEZCUXl4RlFVTXpRME1zVTBGQlV5eEhRVUZIYjBNc1owSkJRV2RDTEVGQlFVTXNSVUZCUXl4SFFVRkhPelJDUVVWMlEySXNTMEZCU3l4SFFVRkhMRmRCUVVsUkxFdEJRVXNzUlVGQlZEdG5RMEZCVldwRExFbEJRVWs3WjBOQlFVVkRMRTlCUVU4N1owTkJRVVZETEZOQlFWTTdaME5CUVVWRExGZEJRVmM3TmtKQlFYZENMRU5CUVhaRkxFMUJRWFZGTEVOQlFYUkNMRzFDUVVGSGFVTXNhMEpCUVd0Q0xFTkJRV3hDUVN4RFFVRnRRaXhEUVVGQkxFTkJRVU03ZVVKQlEycEdPM0ZDUVVOR08ybENRVU5HTzJkQ1FVVkVMRTlCUVU5WUxFdEJRVXNzUTBGQlF6dGhRVU5rT3pzN1dVRkZUV3RDTEVkQlFWY3NSVUZCV0VFc1lVRkJWenRaUldwSmNFSXNUMFpwU1VVc1UwRkJUMEVzVjBGQlZ5eERRVUZEVml4TFFVRkxMRVZCUVVWb1F5eFBRVUZQTEVWQlFVVkZMRmRCUVZjc1JVRkJlVUk3WjBKQlFYWkNMRWxCUVVFc1NVRkJRU3hKUVVGeFFpeEhRVUZ5UWl4VFFVRnhRaXhEUVVGeVFpeE5RVUZ4UWl4RlFVRnlRaXhCUVVGSGFVTXNhMEpCUVd0Q0xFZEJRWEpDTEZWQlFVRXNTVUZCY1VJc1IwRkJja0lzUTBGQmNVSXNSMEZCY2tJc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1NVRkJRU3hEUVVGQkxFVkJRWEpDTEVsQlFYRkNMRWRCUVhKQ0xFTkJRWEZDTEVWQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVsQlFYRkNMRVZCUVhKQ0xFbEJRWEZDTEVWQlFVRXNRMEZCY2tJN2IwSkJRVUVzUVVGQlIwRXNhMEpCUVd0Q0xFTkJRWEpDTEVsQlFYRkNMRWRCUVhKQ0xFTkJRWEZDTEVsQlFYSkNMRk5CUVhGQ0xFRkJRWEpDTEVOQlFVRXNTVUZCY1VJc1EwRkJRU3hCUldwSmRrVXNRMFpwU1hWRk8ybENRVUZCTzJkQ1FVTnVSU3hKUVVGTkxFRkJRVVZ3UXl4SlFVRkpMRWRCUVV0cFF5eExRVUZMTEVOQlFXUnFReXhKUVVGSkxFRkJRVlVzUlVGRGFFSnpReXhuUWtGQlowSXNSMEZCUjBNc1EwRkJRVUVzUjBGQlFVRXNVVUZCWlN4QlFVRlRMRU5CUVVFc2FVSkJRVkowUXl4UFFVRlBMRU5CUVVNc1JVRkRNME5ETEZOQlFWTXNSMEZCUjI5RExHZENRVUZuUWl4RlFVTTFRbUlzUzBGQlN5eEhRVUZITEZkQlFVbFJMRXRCUVVzc1JVRkJWRHR2UWtGQlZXcERMRWxCUVVrN2IwSkJRVVZETEU5QlFVODdiMEpCUVVWRExGTkJRVk03YjBKQlFVVkRMRmRCUVZjN2FVSkJRWGRDTEVOQlFYWkZMRTFCUVhWRkxFTkJRWFJDTEcxQ1FVRkhhVU1zYTBKQlFXdENMRU5CUVd4Q1FTeERRVUZ0UWl4RFFVRkJMRUZCUVVNN1owSkJSWFJHTEU5QlFVOVlMRXRCUVVzc1EwRkJRenRoUVVOa096czdXVUZGVFcxQ0xFZEJRV3RDTEVWQlFXeENRU3h2UWtGQmEwSTdXVVV4U1ROQ0xFOUdNRWxGTEZOQlFVOUJMR3RDUVVGclFpeERRVUZEV0N4TFFVRkxMRVZCUVVWb1F5eFBRVUZQTEVWQlFVVkVMRWxCUVVrc1JVRkJSVWNzVjBGQlZ5eEZRVUY1UWp0blFrRkJka0lzU1VGQlFTeEpRVUZCTEVsQlFYRkNMRWRCUVhKQ0xGTkJRWEZDTEVOQlFYSkNMRTFCUVhGQ0xFVkJRWEpDTEVGQlFVZHBReXhyUWtGQmEwSXNSMEZCY2tJc1ZVRkJRU3hKUVVGeFFpeEhRVUZ5UWl4RFFVRnhRaXhIUVVGeVFpeEpRVUZ4UWl4SFFVRnlRaXhEUVVGeFFpeEpRVUZCTEVOQlFVRXNSVUZCY2tJc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1JVRkJja0lzU1VGQmNVSXNSMEZCY2tJc1NVRkJjVUlzUlVGQmNrSXNTVUZCY1VJc1JVRkJRU3hEUVVGeVFqdHZRa0ZCUVN4QlFVRkhRU3hyUWtGQmEwSXNRMEZCY2tJc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1NVRkJja0lzVTBGQmNVSXNRVUZCY2tJc1EwRkJRU3hKUVVGeFFpeERRVUZCTEVGRk1VbHdSaXhEUmpCSmIwWTdhVUpCUVVFN1owSkJRMmhHTEVsQlFVMUZMR2RDUVVGblFpeEhRVUZIUXl4RFFVRkJRU3hIUVVGQlFTeFJRVUZsTEVGQlFWTXNRMEZCUVN4cFFrRkJVblJETEU5QlFVOHNRMEZCUXl4RlFVTXpRME1zVTBGQlV5eEhRVUZIYjBNc1owSkJRV2RDTEVWQlF6VkNZaXhMUVVGTExFZEJRVWNzVjBGQlNWRXNTMEZCU3l4RlFVRlVPMjlDUVVGVmFrTXNTVUZCU1R0dlFrRkJSVU1zVDBGQlR6dHZRa0ZCUlVNc1UwRkJVenR2UWtGQlJVTXNWMEZCVnp0cFFrRkJkMElzUTBGQmRrVXNUVUZCZFVVc1EwRkJkRUlzYlVKQlFVZHBReXhyUWtGQmEwSXNRMEZCYkVKQkxFTkJRVzFDTEVOQlFVRXNRVUZCUXp0blFrRkZkRVlzVDBGQlQxZ3NTMEZCU3l4RFFVRkRPMkZCUTJRN08wMUJhRXBJT3p0RFFXbEtReXhGUVVGQk8ydENRWGhKYjBJeFFpeExRVUZMTEVGQlZERkNJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF90b2tlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Rva2VuXCIpKTtcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIHNpZ25pZmljYW50ID0gdHJ1ZTtcbnZhciBTaWduaWZpY2FudFRva2VuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihUb2tlbikge1xuICAgIF9pbmhlcml0cyhTaWduaWZpY2FudFRva2VuLCBUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTaWduaWZpY2FudFRva2VuKTtcbiAgICBmdW5jdGlvbiBTaWduaWZpY2FudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFNpZ25pZmljYW50VG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVtYWluaW5nQXJndW1lbnRzID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdBcmd1bWVudHNbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjsgLy8vXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBDbGFzczsgLy8vXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuID0gKF9pbnN0YW5jZSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFNpZ25pZmljYW50VG9rZW4ucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKSkuY2FsbC5hcHBseShfaW5zdGFuY2UsIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudFxuICAgICAgICAgICAgICAgIF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZW1haW5pbmdBcmd1bWVudHMpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVtYWluaW5nQXJndW1lbnRzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdBcmd1bWVudHNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX1Rva2VuO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IENsYXNzOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBTaWduaWZpY2FudFRva2VuOyAvLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpZ25pZmljYW50VG9rZW4gPSAoX1Rva2VuID0gX3Rva2VuLmRlZmF1bHQpLm1hdGNoLmFwcGx5KF9Ub2tlbiwgW1xuICAgICAgICAgICAgICAgICAgICBDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnRcbiAgICAgICAgICAgICAgICBdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVtYWluaW5nQXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChDbGFzcywgY29udGVudCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmluZ0FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9Ub2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBDbGFzczsgLy8vXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuID0gKF9Ub2tlbiA9IF90b2tlbi5kZWZhdWx0KS5mcm9tQ29udGVudC5hcHBseShfVG9rZW4sIFtcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50XG4gICAgICAgICAgICAgICAgXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlbWFpbmluZ0FyZ3VtZW50cykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50QW5kVHlwZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50QW5kVHlwZShDbGFzcywgY29udGVudCwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmluZ0FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9Ub2tlbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBjb250ZW50OyAvLy9cbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IENsYXNzOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBTaWduaWZpY2FudFRva2VuOyAvLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpZ25pZmljYW50VG9rZW4gPSAoX1Rva2VuID0gX3Rva2VuLmRlZmF1bHQpLmZyb21Db250ZW50QW5kVHlwZS5hcHBseShfVG9rZW4sIFtcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50XG4gICAgICAgICAgICAgICAgXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlbWFpbmluZ0FyZ3VtZW50cykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBTaWduaWZpY2FudFRva2VuO1xufShfdG9rZW4uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaWduaWZpY2FudFRva2VuO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkwYjJ0bGJpOXphV2R1YVdacFkyRnVkQzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk5MGIydGxibHdpTzF4dVhHNWpiMjV6ZENCemFXZHVhV1pwWTJGdWRDQTlJSFJ5ZFdVN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUZOcFoyNXBabWxqWVc1MFZHOXJaVzRnWlhoMFpXNWtjeUJVYjJ0bGJpQjdYRzRnSUdOc2IyNWxLRU5zWVhOekxDQnpkR0Z5ZEZCdmMybDBhVzl1TENCbGJtUlFiM05wZEdsdmJpd2dMaTR1Y21WdFlXbHVhVzVuUVhKbmRXMWxiblJ6S1NCN1hHNGdJQ0FnYVdZZ0tHVnVaRkJ2YzJsMGFXOXVJRDA5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBZ0lHVnVaRkJ2YzJsMGFXOXVJRDBnYzNSaGNuUlFiM05wZEdsdmJqc2dJQzh2TDF4dUlDQWdJQ0FnYzNSaGNuUlFiM05wZEdsdmJpQTlJRU5zWVhOek95QWdMeTh2WEc0Z0lDQWdJQ0JEYkdGemN5QTlJRk5wWjI1cFptbGpZVzUwVkc5clpXNDdJQzh2TDF4dUlDQWdJSDFjYmx4dUlDQWdJR052Ym5OMElITnBaMjVwWm1sallXNTBWRzlyWlc0Z1BTQnpkWEJsY2k1amJHOXVaU2hEYkdGemN5d2djM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHNJSE5wWjI1cFptbGpZVzUwTENBdUxpNXlaVzFoYVc1cGJtZEJjbWQxYldWdWRITXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlITnBaMjVwWm1sallXNTBWRzlyWlc0N1hHNGdJSDFjYmx4dUlDQnpkR0YwYVdNZ2JXRjBZMmdvUTJ4aGMzTXNJR052Ym5SbGJuUXNJQzR1TG5KbGJXRnBibWx1WjBGeVozVnRaVzUwY3lrZ2UxeHVJQ0FnSUdsbUlDaGpiMjUwWlc1MElEMDlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0FnSUdOdmJuUmxiblFnUFNCRGJHRnpjenNnSUM4dkwxeHVJQ0FnSUNBZ1EyeGhjM01nUFNCVGFXZHVhV1pwWTJGdWRGUnZhMlZ1T3lBdkx5OWNiaUFnSUNCOVhHNWNiaUFnSUNCamIyNXpkQ0J6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVJRDBnVkc5clpXNHViV0YwWTJnb1EyeGhjM01zSUdOdmJuUmxiblFzSUhOcFoyNXBabWxqWVc1MExDQXVMaTV5WlcxaGFXNXBibWRCY21kMWJXVnVkSE1wTzF4dVhHNGdJQ0FnY21WMGRYSnVJSE5wWjI1cFptbGpZVzUwVkc5clpXNDdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlVOdmJuUmxiblFvUTJ4aGMzTXNJR052Ym5SbGJuUXNJQzR1TG5KbGJXRnBibWx1WjBGeVozVnRaVzUwY3lrZ2UxeHVJQ0FnSUdsbUlDaGpiMjUwWlc1MElEMDlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0FnSUdOdmJuUmxiblFnUFNCRGJHRnpjenNnSUM4dkwxeHVJQ0FnSUNBZ1EyeGhjM01nUFNCVGFXZHVhV1pwWTJGdWRGUnZhMlZ1T3lBdkx5OWNiaUFnSUNCOVhHNWNiaUFnSUNCamIyNXpkQ0J6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVJRDBnVkc5clpXNHVabkp2YlVOdmJuUmxiblFvUTJ4aGMzTXNJR052Ym5SbGJuUXNJSE5wWjI1cFptbGpZVzUwTENBdUxpNXlaVzFoYVc1cGJtZEJjbWQxYldWdWRITXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlITnBaMjVwWm1sallXNTBWRzlyWlc0N1hHNGdJSDFjYmx4dUlDQnpkR0YwYVdNZ1puSnZiVU52Ym5SbGJuUkJibVJVZVhCbEtFTnNZWE56TENCamIyNTBaVzUwTENCMGVYQmxMQ0F1TGk1eVpXMWhhVzVwYm1kQmNtZDFiV1Z1ZEhNcElIdGNiaUFnSUNCcFppQW9kSGx3WlNBOVBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdJQ0IwZVhCbElEMGdZMjl1ZEdWdWREc2dMeTh2WEc0Z0lDQWdJQ0JqYjI1MFpXNTBJRDBnUTJ4aGMzTTdJQ0F2THk5Y2JpQWdJQ0FnSUVOc1lYTnpJRDBnVTJsbmJtbG1hV05oYm5SVWIydGxianNnTHk4dlhHNGdJQ0FnZlZ4dVhHNGdJQ0FnWTI5dWMzUWdjMmxuYm1sbWFXTmhiblJVYjJ0bGJpQTlJRlJ2YTJWdUxtWnliMjFEYjI1MFpXNTBRVzVrVkhsd1pTaERiR0Z6Y3l3Z1kyOXVkR1Z1ZEN3Z2RIbHdaU3dnYzJsbmJtbG1hV05oYm5Rc0lDNHVMbkpsYldGcGJtbHVaMEZ5WjNWdFpXNTBjeWs3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjMmxuYm1sbWFXTmhiblJVYjJ0bGJqdGNiaUFnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSW5OcFoyNXBabWxqWVc1MElpd2lVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbU5zYjI1bElpd2lRMnhoYzNNaUxDSnpkR0Z5ZEZCdmMybDBhVzl1SWl3aVpXNWtVRzl6YVhScGIyNGlMQ0p5WlcxaGFXNXBibWRCY21kMWJXVnVkSE1pTENKMWJtUmxabWx1WldRaUxDSnphV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2liV0YwWTJnaUxDSmpiMjUwWlc1MElpd2lWRzlyWlc0aUxDSm1jbTl0UTI5dWRHVnVkQ0lzSW1aeWIyMURiMjUwWlc1MFFXNWtWSGx3WlNJc0luUjVjR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGYTBJc1NVRkJRU3hOUVVGVkxHdERRVUZXTEZWQlFWVXNSVUZCUVRzN2VVUkJSalZDTzNWRlFVRkJPenM3T3pzN096czdPenM3T3pzN096czdPenM0UkVGQlFUdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdNRUpCUVVFN096czdPenM3T3pzN1UwRkJRVHM3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096czdkME5CUVVFN096czdPenM3T3pzeVFrRkJRVHM3T3pzN096c3JSRUZCUVRzN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVVsQkxFbEJRVTFCTEZkQlFWY3NSMEZCUnl4SlFVRkpMRUZCUVVNN1FVRkZWaXhKUVVGQkxFRkJRVTFETEdkQ1FVRm5RaXhwUWtOT2JFTXNRVVJOV1R0elEwRk9aanM3WVVGTmNVSkJMR2RDUVVGblFqc3JRMEZPY2tNN096czdPMWxCVDBWRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJWQlFMRTlHVDBWQkxGTkJRVUZCTEV0QlFVc3NRMEZCUTBNc1MwRkJTeXhGUVVGRlF5eGhRVUZoTEVWQlFVVkRMRmRCUVZjc1JVRkJlVUk3WjBKQlFYWkNMRWxCUVVFc1NVRkJRU3hKUVVGeFFpeEhRVUZ5UWl4VFFVRnhRaXhEUVVGeVFpeE5RVUZ4UWl4RlFVRnlRaXhCUVVGSFF5eHJRa0ZCYTBJc1IwRkJja0lzVlVGQlFTeEpRVUZ4UWl4SFFVRnlRaXhEUVVGeFFpeEhRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeERRVUZ4UWl4SlFVRkJMRU5CUVVFc1JVRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzUlVGQmNrSXNTVUZCY1VJc1IwRkJja0lzU1VGQmNVSXNSVUZCY2tJc1NVRkJjVUlzUlVGQlFTeERRVUZ5UWp0dlFrRkJRU3hCUVVGSFFTeHJRa0ZCYTBJc1EwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQmNrSXNVMEZCY1VJc1FVRkJja0lzUTBGQlFTeEpRVUZ4UWl4RFFVRkJMRUZGVUdoRkxFTkdUMmRGTzJsQ1FVRkJPMjlDUVU5dVF5eFRRVUZMTzJkQ1FVNDVRaXhKUVVGSlJDeFhRVUZYTEV0QlFVdEZMRk5CUVZNc1JVRkJSVHR2UWtGRE4wSkdMRmRCUVZjc1IwRkJSMFFzWVVGQllTeERRVUZETEVOQlFVVXNSMEZCUnp0dlFrRkRha05CTEdGQlFXRXNSMEZCUjBRc1MwRkJTeXhEUVVGRExFTkJRVVVzUjBGQlJ6dHZRa0ZETTBKQkxFdEJRVXNzUjBGQlIwWXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eEhRVUZITzJsQ1FVTTVRanRuUWtGRlJDeEpRVUZOVHl4blFrRkJaMElzU1VGQlJ5eFRRVUZMTEVkQlFVd3NjVUpCVWxKUUxHZENRVUZuUWl4aFFWRkdReXhQUVVGTExFVkJRVmdzU1VGQlN5eERRVUZCTEdGQlFVd3NVMEZCU3pzN2IwSkJRVTlETEV0QlFVczdiMEpCUVVWRExHRkJRV0U3YjBKQlFVVkRMRmRCUVZjN2IwSkJRVVZNTEZkQlFWYzdlVUpCUVVVc2JVSkJRVWROTEd0Q1FVRnJRaXhEUVVGc1FrRXNSVUZCYlVJc1FVRkJRenRuUWtGRk5VY3NUMEZCVDBVc1owSkJRV2RDTEVOQlFVTTdZVUZEZWtJN096czdXVUZGVFVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRmJrSmtMRTlHYlVKRkxGTkJRVTlCTEV0QlFVc3NRMEZCUTA0c1MwRkJTeXhGUVVGRlR5eFBRVUZQTEVWQlFYbENPMmRDUVVGMlFpeEpRVUZCTEVsQlFVRXNTVUZCY1VJc1IwRkJja0lzVTBGQmNVSXNRMEZCY2tJc1RVRkJjVUlzUlVGQmNrSXNRVUZCUjBvc2EwSkJRV3RDTEVkQlFYSkNMRlZCUVVFc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1IwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQlFTeERRVUZCTEVWQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRVZCUVhKQ0xFbEJRWEZDTEVkQlFYSkNMRWxCUVhGQ0xFVkJRWEpDTEVsQlFYRkNMRVZCUVVFc1EwRkJja0k3YjBKQlFVRXNRVUZCUjBFc2EwSkJRV3RDTEVOQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRWxCUVhKQ0xGTkJRWEZDTEVGQlFYSkNMRU5CUVVFc1NVRkJjVUlzUTBGQlFTeEJSVzVDY0VRc1EwWnRRbTlFTzJsQ1FVRkJPMjlDUVUxMlFrc3NUVUZCU3p0blFrRk1PVUlzU1VGQlNVUXNUMEZCVHl4TFFVRkxTQ3hUUVVGVExFVkJRVVU3YjBKQlEzcENSeXhQUVVGUExFZEJRVWRRTEV0QlFVc3NRMEZCUXl4RFFVRkZMRWRCUVVjN2IwSkJRM0pDUVN4TFFVRkxMRWRCUVVkR0xHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1IwRkJSenRwUWtGRE9VSTdaMEpCUlVRc1NVRkJUVThzWjBKQlFXZENMRWRCUVVkSExFTkJRVUZCTEUxQlFVc3NSMEZCVEVFc1RVRkJTeXhWUVVGRFJpeExRVUZMTEVOQlFWaEZMRXRCUVN0RUxFTkJRUzlFUVN4TlFVRkxMRVZCUVV4Qk8yOUNRVUZaVWl4TFFVRkxPMjlDUVVGRlR5eFBRVUZQTzI5Q1FVRkZWaXhYUVVGWE8ybENRVUYzUWl4RFFVRXZSRmNzVFVGQkswUXNRMEZCZEVJc2JVSkJRVWRNTEd0Q1FVRnJRaXhEUVVGc1FrRXNRMEZCYlVJc1EwRkJRU3hCUVVGRE8yZENRVVY2Uml4UFFVRlBSU3huUWtGQlowSXNRMEZCUXp0aFFVTjZRanM3TzFsQlJVMUpMRWRCUVZjc1JVRkJXRUVzWVVGQlZ6dFpSVGxDY0VJc1QwWTRRa1VzVTBGQlQwRXNWMEZCVnl4RFFVRkRWQ3hMUVVGTExFVkJRVVZQTEU5QlFVOHNSVUZCZVVJN1owSkJRWFpDTEVsQlFVRXNTVUZCUVN4SlFVRnhRaXhIUVVGeVFpeFRRVUZ4UWl4RFFVRnlRaXhOUVVGeFFpeEZRVUZ5UWl4QlFVRkhTaXhyUWtGQmEwSXNSMEZCY2tJc1ZVRkJRU3hKUVVGeFFpeEhRVUZ5UWl4RFFVRnhRaXhIUVVGeVFpeEpRVUZ4UWl4SFFVRnlRaXhEUVVGeFFpeEpRVUZCTEVOQlFVRXNSVUZCY2tJc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1JVRkJja0lzU1VGQmNVSXNSMEZCY2tJc1NVRkJjVUlzUlVGQmNrSXNTVUZCY1VJc1JVRkJRU3hEUVVGeVFqdHZRa0ZCUVN4QlFVRkhRU3hyUWtGQmEwSXNRMEZCY2tJc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1NVRkJja0lzVTBGQmNVSXNRVUZCY2tJc1EwRkJRU3hKUVVGeFFpeERRVUZCTEVGRk9VSXhSQ3hEUmpoQ01FUTdhVUpCUVVFN2IwSkJUVGRDU3l4TlFVRkxPMmRDUVV3NVFpeEpRVUZKUkN4UFFVRlBMRXRCUVV0SUxGTkJRVk1zUlVGQlJUdHZRa0ZEZWtKSExFOUJRVThzUjBGQlIxQXNTMEZCU3l4RFFVRkRMRU5CUVVVc1IwRkJSenR2UWtGRGNrSkJMRXRCUVVzc1IwRkJSMFlzWjBKQlFXZENMRU5CUVVNc1EwRkJReXhIUVVGSE8ybENRVU01UWp0blFrRkZSQ3hKUVVGTlR5eG5Ra0ZCWjBJc1IwRkJSMGNzUTBGQlFVRXNUVUZCU3l4SFFVRk1RU3hOUVVGTExGVkJRVU5ETEZkQlFWY3NRMEZCYWtKRUxFdEJRWEZGTEVOQlFYSkZRU3hOUVVGTExFVkJRVXhCTzI5Q1FVRnJRbElzUzBGQlN6dHZRa0ZCUlU4c1QwRkJUenR2UWtGQlJWWXNWMEZCVnp0cFFrRkJkMElzUTBGQmNrVlhMRTFCUVhGRkxFTkJRWFJDTEcxQ1FVRkhUQ3hyUWtGQmEwSXNRMEZCYkVKQkxFTkJRVzFDTEVOQlFVRXNRVUZCUXp0blFrRkZMMFlzVDBGQlQwVXNaMEpCUVdkQ0xFTkJRVU03WVVGRGVrSTdPenRaUVVWTlN5eEhRVUZyUWl4RlFVRnNRa0VzYjBKQlFXdENPMWxGZWtNelFpeFBSbmxEUlN4VFFVRlBRU3hyUWtGQmEwSXNRMEZCUTFZc1MwRkJTeXhGUVVGRlR5eFBRVUZQTEVWQlFVVkpMRWxCUVVrc1JVRkJlVUk3WjBKQlFYWkNMRWxCUVVFc1NVRkJRU3hKUVVGeFFpeEhRVUZ5UWl4VFFVRnhRaXhEUVVGeVFpeE5RVUZ4UWl4RlFVRnlRaXhCUVVGSFVpeHJRa0ZCYTBJc1IwRkJja0lzVlVGQlFTeEpRVUZ4UWl4SFFVRnlRaXhEUVVGeFFpeEhRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeERRVUZ4UWl4SlFVRkJMRU5CUVVFc1JVRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzUlVGQmNrSXNTVUZCY1VJc1IwRkJja0lzU1VGQmNVSXNSVUZCY2tJc1NVRkJjVUlzUlVGQlFTeERRVUZ5UWp0dlFrRkJRU3hCUVVGSFFTeHJRa0ZCYTBJc1EwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQmNrSXNVMEZCY1VJc1FVRkJja0lzUTBGQlFTeEpRVUZ4UWl4RFFVRkJMRUZGZWtOMlJTeERSbmxEZFVVN2FVSkJRVUU3YjBKQlR6RkRTeXhOUVVGTE8yZENRVTQ1UWl4SlFVRkpSeXhKUVVGSkxFdEJRVXRRTEZOQlFWTXNSVUZCUlR0dlFrRkRkRUpQTEVsQlFVa3NSMEZCUjBvc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ6dHZRa0ZEYmtKQkxFOUJRVThzUjBGQlIxQXNTMEZCU3l4RFFVRkRMRU5CUVVVc1IwRkJSenR2UWtGRGNrSkJMRXRCUVVzc1IwRkJSMFlzWjBKQlFXZENMRU5CUVVNc1EwRkJReXhIUVVGSE8ybENRVU01UWp0blFrRkZSQ3hKUVVGTlR5eG5Ra0ZCWjBJc1IwRkJSMGNzUTBGQlFVRXNUVUZCU3l4SFFVRk1RU3hOUVVGTExGVkJRVU5GTEd0Q1FVRnJRaXhEUVVGNFFrWXNTMEZCYTBZc1EwRkJiRVpCTEUxQlFVc3NSVUZCVEVFN2IwSkJRWGxDVWl4TFFVRkxPMjlDUVVGRlR5eFBRVUZQTzI5Q1FVRkZTU3hKUVVGSk8yOUNRVUZGWkN4WFFVRlhPMmxDUVVGM1FpeERRVUZzUmxjc1RVRkJhMFlzUTBGQmRFSXNiVUpCUVVkTUxHdENRVUZyUWl4RFFVRnNRa0VzUTBGQmJVSXNRMEZCUVN4QlFVRkRPMmRDUVVVMVJ5eFBRVUZQUlN4blFrRkJaMElzUTBGQlF6dGhRVU42UWpzN1RVRnVSRWc3TzBOQmIwUkRMRU5CT1VNMlEwY3NUVUZCU3l4VFFUaERiRVE3YTBKQk9VTnZRbFlzWjBKQlFXZENMRUZCVG5KREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVID0gXCJ1XCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbmVjZXNzYXJ5ID0gcmVxdWlyZShcIm5lY2Vzc2FyeVwiKTtcbnZhciBfc2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Rva2VuL3NpZ25pZmljYW50XCIpKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG52YXIgZmlyc3QgPSBfbmVjZXNzYXJ5LmFycmF5VXRpbGl0aWVzLmZpcnN0O1xudmFyIFJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJ1bGUodHlwZSwgcmVndWxhckV4cHJlc3Npb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJ1bGUpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb247XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhSdWxlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRUeXBlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0UmVndWxhckV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWd1bGFyRXhwcmVzc2lvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWd1bGFyRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2goY29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hlcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RNYXRjaCA9IGZpcnN0KG1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBfc2lnbmlmaWNhbnQuZGVmYXVsdC5mcm9tQ29udGVudEFuZFR5cGUoY29udGVudCwgdGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzRW50cnlcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc0VudHJ5KCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHt9LCByZWd1bGFyRXhwcmVzc2lvblBhdHRlcm4gPSBcIlwiLmNvbmNhdCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBlbnRyeVt0aGlzLnR5cGVdID0gcmVndWxhckV4cHJlc3Npb25QYXR0ZXJuO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Ub2tlblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Ub2tlbihUb2tlbikge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gVG9rZW4udHlwZSwgcmVndWxhckV4cHJlc3Npb24gPSBUb2tlbi5yZWd1bGFyRXhwcmVzc2lvbiwgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21FbnRyeVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FbnRyeShlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeUtleXMgPSBPYmplY3Qua2V5cyhlbnRyeSksIGZpcnN0RW50cnlLZXkgPSBmaXJzdChlbnRyeUtleXMpLCB0eXBlID0gZmlyc3RFbnRyeUtleSwgcmVndWxhckV4cHJlc3Npb25QYXR0ZXJuID0gZW50cnlbdHlwZV0sIHJ1bGUgPSBSdWxlLmZyb21UeXBlQW5kUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tVHlwZUFuZFJlZ3VsYXJFeHByZXNzaW9uUGF0dGVyblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21UeXBlQW5kUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybikge1xuICAgICAgICAgICAgICAgIHZhciB1bmljb2RlID0gaXNVbmljb2RlKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksIGZsYWdzID0gdW5pY29kZSA/IF9jb25zdGFudHMuVSA6IF9jb25zdGFudHMuRU1QVFlfU1RSSU5HLCByZWdFeHAgPSBuZXcgUmVnRXhwKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiwgZmxhZ3MpLCByZWd1bGFyRXhwcmVzc2lvbiA9IHJlZ0V4cCwgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSdWxlO1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUnVsZTtcbmZ1bmN0aW9uIGlzVW5pY29kZShyZWd1bGFyRXhwcmVzc2lvblBhdHRlcm4pIHtcbiAgICB2YXIgdW5pY29kZVJlZ3VsYXJFeHByZXNzaW9uID0gL3V7LywgaW5kZXggPSByZWd1bGFyRXhwcmVzc2lvblBhdHRlcm4uc2VhcmNoKHVuaWNvZGVSZWd1bGFyRXhwcmVzc2lvbiksIHVuaWNvZGUgPSBpbmRleCAhPT0gLTE7XG4gICAgcmV0dXJuIHVuaWNvZGU7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5eWRXeGxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ2V5QmhjbkpoZVZWMGFXeHBkR2xsY3lCOUlHWnliMjBnWENKdVpXTmxjM05oY25sY0lqdGNibHh1YVcxd2IzSjBJRk5wWjI1cFptbGpZVzUwVkc5clpXNGdabkp2YlNCY0lpNHZkRzlyWlc0dmMybG5ibWxtYVdOaGJuUmNJanRjYmx4dWFXMXdiM0owSUhzZ1ZTd2dSVTFRVkZsZlUxUlNTVTVISUgwZ1puSnZiU0JjSWk0dlkyOXVjM1JoYm5SelhDSTdYRzVjYm1OdmJuTjBJSHNnWm1seWMzUWdmU0E5SUdGeWNtRjVWWFJwYkdsMGFXVnpPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlNkV3hsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvZEhsd1pTd2djbVZuZFd4aGNrVjRjSEpsYzNOcGIyNHBJSHRjYmlBZ0lDQjBhR2x6TG5SNWNHVWdQU0IwZVhCbE8xeHVJQ0FnSUhSb2FYTXVjbVZuZFd4aGNrVjRjSEpsYzNOcGIyNGdQU0J5WldkMWJHRnlSWGh3Y21WemMybHZianRjYmlBZ2ZWeHVJQ0JjYmlBZ1oyVjBWSGx3WlNncElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NTBlWEJsTzF4dUlDQjlYRzRnSUZ4dUlDQm5aWFJTWldkMWJHRnlSWGh3Y21WemMybHZiaWdwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpXZDFiR0Z5Ulhod2NtVnpjMmx2Ymp0Y2JpQWdmVnh1WEc0Z0lHMWhkR05vS0dOdmJuUmxiblFwSUh0Y2JpQWdJQ0JzWlhRZ2MybG5ibWxtYVdOaGJuUlViMnRsYmlBOUlHNTFiR3c3WEc1Y2JpQWdJQ0JqYjI1emRDQnRZWFJqYUdWeklEMGdZMjl1ZEdWdWRDNXRZWFJqYUNoMGFHbHpMbkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVLVHRjYmx4dUlDQWdJR2xtSUNodFlYUmphR1Z6SUNFOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNCamIyNXpkQ0I3SUdsdVpHVjRJSDBnUFNCdFlYUmphR1Z6TzF4dVhHNGdJQ0FnSUNCcFppQW9hVzVrWlhnZ1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWm1seWMzUk5ZWFJqYUNBOUlHWnBjbk4wS0cxaGRHTm9aWE1wTzF4dVhHNGdJQ0FnSUNBZ0lHTnZiblJsYm5RZ1BTQm1hWEp6ZEUxaGRHTm9PeUF2THk5Y2JseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCamIyNTBaVzUwVEdWdVozUm9JRDBnWTI5dWRHVnVkQzVzWlc1bmRHZzdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHTnZiblJsYm5STVpXNW5kR2dnUGlBd0tTQjdYRzRnSUNBZ0lDQWdJQ0FnYzJsbmJtbG1hV05oYm5SVWIydGxiaUE5SUZOcFoyNXBabWxqWVc1MFZHOXJaVzR1Wm5KdmJVTnZiblJsYm5SQmJtUlVlWEJsS0dOdmJuUmxiblFzSUhSb2FYTXVkSGx3WlNrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNCeVpYUjFjbTRnYzJsbmJtbG1hV05oYm5SVWIydGxianRjYmlBZ2ZWeHVJQ0JjYmlBZ1lYTkZiblJ5ZVNncElIdGNiaUFnSUNCamIyNXpkQ0JsYm5SeWVTQTlJSHQ5TEZ4dUlDQWdJQ0FnSUNBZ0lISmxaM1ZzWVhKRmVIQnlaWE56YVc5dVVHRjBkR1Z5YmlBOUlHQWtlM1JvYVhNdWNtVm5kV3hoY2tWNGNISmxjM05wYjI1OVlEdGNibHh1SUNBZ0lHVnVkSEo1VzNSb2FYTXVkSGx3WlYwZ1BTQnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsQmhkSFJsY200N1hHNWNiaUFnSUNCeVpYUjFjbTRnWlc1MGNuazdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZSdmEyVnVLRlJ2YTJWdUtTQjdYRzRnSUNBZ1kyOXVjM1FnZXlCMGVYQmxMQ0J5WldkMWJHRnlSWGh3Y21WemMybHZiaUI5SUQwZ1ZHOXJaVzRzWEc0Z0lDQWdJQ0FnSUNBZ2NuVnNaU0E5SUc1bGR5QlNkV3hsS0hSNWNHVXNJSEpsWjNWc1lYSkZlSEJ5WlhOemFXOXVLVHRjYmx4dUlDQWdJSEpsZEhWeWJpQnlkV3hsTzF4dUlDQjlYRzVjYmlBZ2MzUmhkR2xqSUdaeWIyMUZiblJ5ZVNobGJuUnllU2tnZTF4dUlDQWdJR052Ym5OMElHVnVkSEo1UzJWNWN5QTlJRTlpYW1WamRDNXJaWGx6S0dWdWRISjVLU3hjYmlBZ0lDQWdJQ0FnSUNCbWFYSnpkRVZ1ZEhKNVMyVjVJRDBnWm1seWMzUW9aVzUwY25sTFpYbHpLU3hjYmlBZ0lDQWdJQ0FnSUNCMGVYQmxJRDBnWm1seWMzUkZiblJ5ZVV0bGVTd2dMeTh2WEc0Z0lDQWdJQ0FnSUNBZ2NtVm5kV3hoY2tWNGNISmxjM05wYjI1UVlYUjBaWEp1SUQwZ1pXNTBjbmxiZEhsd1pWMHNYRzRnSUNBZ0lDQWdJQ0FnY25Wc1pTQTlJRkoxYkdVdVpuSnZiVlI1Y0dWQmJtUlNaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsQmhkSFJsY200b2RIbHdaU3dnY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhSMFpYSnVLVHRjYmlBZ0lDQWdJQ0FnWEc0Z0lDQWdjbVYwZFhKdUlISjFiR1U3SUZ4dUlDQjlYRzVjYmlBZ2MzUmhkR2xqSUdaeWIyMVVlWEJsUVc1a1VtVm5kV3hoY2tWNGNISmxjM05wYjI1UVlYUjBaWEp1S0hSNWNHVXNJSEpsWjNWc1lYSkZlSEJ5WlhOemFXOXVVR0YwZEdWeWJpa2dlMXh1SUNBZ0lHTnZibk4wSUhWdWFXTnZaR1VnUFNCcGMxVnVhV052WkdVb2NtVm5kV3hoY2tWNGNISmxjM05wYjI1UVlYUjBaWEp1S1N4Y2JpQWdJQ0FnSUNBZ0lDQm1iR0ZuY3lBOUlIVnVhV052WkdVZ1AxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JWSURwY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JGVFZCVVdWOVRWRkpKVGtjc1hHNGdJQ0FnSUNBZ0lDQWdjbVZuUlhod0lEMGdibVYzSUZKbFowVjRjQ2h5WldkMWJHRnlSWGh3Y21WemMybHZibEJoZEhSbGNtNHNJR1pzWVdkektTeGNiaUFnSUNBZ0lDQWdJQ0J5WldkMWJHRnlSWGh3Y21WemMybHZiaUE5SUhKbFowVjRjQ3dnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdjblZzWlNBOUlHNWxkeUJTZFd4bEtIUjVjR1VzSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1S1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJ5ZFd4bE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR2x6Vlc1cFkyOWtaU2h5WldkMWJHRnlSWGh3Y21WemMybHZibEJoZEhSbGNtNHBJSHRjYmlBZ1kyOXVjM1FnZFc1cFkyOWtaVkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVJRDBnTDNWN0x5d2dMeTh2WEc0Z0lDQWdJQ0FnSUdsdVpHVjRJRDBnY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhSMFpYSnVMbk5sWVhKamFDaDFibWxqYjJSbFVtVm5kV3hoY2tWNGNISmxjM05wYjI0cExGeHVJQ0FnSUNBZ0lDQjFibWxqYjJSbElEMGdLR2x1WkdWNElDRTlQU0F0TVNrN1hHNWNiaUFnY21WMGRYSnVJSFZ1YVdOdlpHVTdYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2labWx5YzNRaUxDSmhjbkpoZVZWMGFXeHBkR2xsY3lJc0lsSjFiR1VpTENKMGVYQmxJaXdpY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRpTENKblpYUlVlWEJsSWl3aVoyVjBVbVZuZFd4aGNrVjRjSEpsYzNOcGIyNGlMQ0p0WVhSamFDSXNJbU52Ym5SbGJuUWlMQ0p6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpYldGMFkyaGxjeUlzSW1sdVpHVjRJaXdpWm1seWMzUk5ZWFJqYUNJc0ltTnZiblJsYm5STVpXNW5kR2dpTENKc1pXNW5kR2dpTENKVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aVpuSnZiVU52Ym5SbGJuUkJibVJVZVhCbElpd2lZWE5GYm5SeWVTSXNJbVZ1ZEhKNUlpd2ljbVZuZFd4aGNrVjRjSEpsYzNOcGIyNVFZWFIwWlhKdUlpd2labkp2YlZSdmEyVnVJaXdpVkc5clpXNGlMQ0p5ZFd4bElpd2labkp2YlVWdWRISjVJaXdpWlc1MGNubExaWGx6SWl3aVQySnFaV04wSWl3aWEyVjVjeUlzSW1acGNuTjBSVzUwY25sTFpYa2lMQ0ptY205dFZIbHdaVUZ1WkZKbFozVnNZWEpGZUhCeVpYTnphVzl1VUdGMGRHVnliaUlzSW5WdWFXTnZaR1VpTENKcGMxVnVhV052WkdVaUxDSm1iR0ZuY3lJc0lsVWlMQ0pGVFZCVVdWOVRWRkpKVGtjaUxDSnlaV2RGZUhBaUxDSlNaV2RGZUhBaUxDSjFibWxqYjJSbFVtVm5kV3hoY2tWNGNISmxjM05wYjI0aUxDSnpaV0Z5WTJnaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRkswSXNTVUZCUVN4VlFVRlhMRmRCUVZnc1YwRkJWeXhEUVVGQk8wRkJSV0lzU1VGQlFTeFpRVUZ4UWl4clEwRkJja0lzY1VKQlFYRkNMRVZCUVVFN1FVRkZiRUlzU1VGQlFTeFZRVUZoTEZkQlFXSXNZVUZCWVN4RFFVRkJPenM3T3pzN096czdPRVJCVGpkRE8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN096czdPenRCUVZGQkxFbEJRVTBzUVVGQlJVRXNTMEZCU3l4SFFVRkxReXhWUVVGakxHZENRVUY0UWtRc1MwRkJTeXhCUVVGdFFpeEJRVUZETzBGQlJXeENMRWxCUVVFc1FVRkJUVVVzU1VGQlNTeHBRa0UyUlhSQ0xFRkJOMFZaTzJGQlFVMUJMRWxCUVVrc1EwRkRXRU1zU1VGQlNTeEZRVUZGUXl4cFFrRkJhVUk3YlVOQldISkRPMUZCV1Vrc1NVRkJTU3hEUVVGRFJDeEpRVUZKTEVkQlFVZEJMRWxCUVVrc1EwRkJRenRSUVVOcVFpeEpRVUZKTEVOQlFVTkRMR2xDUVVGcFFpeEhRVUZIUVN4cFFrRkJhVUlzUTBGQlF6czdPenRaUVVjM1EwTXNSMEZCVHl4RlFVRlFRU3hUUVVGUE8xbERhRUpVTEU5RVowSkZRU3hUUVVGQlFTeFBRVUZQTEVkQlFVYzdaMEpCUTFJc1QwRkJUeXhKUVVGSkxFTkJRVU5HTEVsQlFVa3NRMEZCUXp0aFFVTnNRanM3TzFsQlJVUkhMRWRCUVc5Q0xFVkJRWEJDUVN4elFrRkJiMEk3V1VOd1FuUkNMRTlFYjBKRlFTeFRRVUZCUVN4dlFrRkJiMElzUjBGQlJ6dG5Ra0ZEY2tJc1QwRkJUeXhKUVVGSkxFTkJRVU5HTEdsQ1FVRnBRaXhEUVVGRE8yRkJReTlDT3pzN1dVRkZSRWNzUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxEZUVKUUxFOUVkMEpGUVN4VFFVRkJRU3hMUVVGTExFTkJRVU5ETEU5QlFVOHNSVUZCUlR0blFrRkRZaXhKUVVGSlF5eG5Ra0ZCWjBJc1IwRkJSeXhKUVVGSkxFRkJRVU03WjBKQlJUVkNMRWxCUVUxRExFOUJRVThzUjBGQlIwWXNUMEZCVHl4RFFVRkRSQ3hMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZEU0N4cFFrRkJhVUlzUTBGQlF5eEJRVUZETzJkQ1FVVjBSQ3hKUVVGSlRTeFBRVUZQTEV0QlFVc3NTVUZCU1N4RlFVRkZPMjlDUVVOd1FpeEpRVUZOTEVGQlFVVkRMRXRCUVVzc1IwRkJTMFFzVDBGQlR5eERRVUZxUWtNc1MwRkJTeXhCUVVGWkxFRkJRVU03YjBKQlJURkNMRWxCUVVsQkxFdEJRVXNzUzBGQlN5eERRVUZETEVWQlFVVTdkMEpCUTJZc1NVRkJUVU1zVlVGQlZTeEhRVUZIV2l4TFFVRkxMRU5CUVVOVkxFOUJRVThzUTBGQlF5eEJRVUZETzNkQ1FVVnNRMFlzVDBGQlR5eEhRVUZIU1N4VlFVRlZMRU5CUVVNc1EwRkJReXhIUVVGSE8zZENRVVY2UWl4SlFVRk5ReXhoUVVGaExFZEJRVWRNTEU5QlFVOHNRMEZCUTAwc1RVRkJUU3hCUVVGRE8zZENRVVZ5UXl4SlFVRkpSQ3hoUVVGaExFZEJRVWNzUTBGQlF5eEZRVUZGT3pSQ1FVTnlRa29zWjBKQlFXZENMRWRCUVVkTkxGbEJRV2RDTEZOQlFVTkRMR3RDUVVGclFpeERRVUZEVWl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFRDeEpRVUZKTEVOQlFVTXNRMEZCUXp0NVFrRkROVVU3Y1VKQlEwWTdhVUpCUTBZN1owSkJSVVFzVDBGQlQwMHNaMEpCUVdkQ0xFTkJRVU03WVVGRGVrSTdPenRaUVVWRVVTeEhRVUZQTEVWQlFWQkJMRk5CUVU4N1dVTm9SRlFzVDBSblJFVkJMRk5CUVVGQkxFOUJRVThzUjBGQlJ6dG5Ra0ZEVWl4SlFVRk5ReXhMUVVGTExFZEJRVWNzUlVGQlJTeEZRVU5XUXl4M1FrRkJkMElzUjBGQlJ5eEJRVUZETEVWQlFVRXNRMEZCZVVJc1RVRkJRU3hEUVVGMlFpeEpRVUZKTEVOQlFVTm1MR2xDUVVGcFFpeERRVUZGTEVGQlFVTTdaMEpCUlRkRVl5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRaaXhKUVVGSkxFTkJRVU1zUjBGQlIyZENMSGRDUVVGM1FpeERRVUZETzJkQ1FVVTFReXhQUVVGUFJDeExRVUZMTEVOQlFVTTdZVUZEWkRzN096dFpRVVZOUlN4SFFVRlRMRVZCUVZSQkxGZEJRVk03V1VONlJHeENMRTlFZVVSRkxGTkJRVTlCTEZOQlFWTXNRMEZCUTBNc1MwRkJTeXhGUVVGRk8yZENRVU4wUWl4SlFVRlJiRUlzU1VGQlNTeEhRVUYzUW10Q0xFdEJRVXNzUTBGQmFrTnNRaXhKUVVGSkxFVkJRVVZETEdsQ1FVRnBRaXhIUVVGTGFVSXNTMEZCU3l4RFFVRXpRbXBDTEdsQ1FVRnBRaXhGUVVONlFtdENMRWxCUVVrc1IwRkJSeXhKUVVGSmNFSXNTVUZCU1N4RFFVRkRReXhKUVVGSkxFVkJRVVZETEdsQ1FVRnBRaXhEUVVGRExFRkJRVU03WjBKQlJTOURMRTlCUVU5clFpeEpRVUZKTEVOQlFVTTdZVUZEWWpzN08xbEJSVTFETEVkQlFWTXNSVUZCVkVFc1YwRkJVenRaUTJoRmJFSXNUMFJuUlVVc1UwRkJUMEVzVTBGQlV5eERRVUZEVEN4TFFVRkxMRVZCUVVVN1owSkJRM1JDTEVsQlFVMU5MRk5CUVZNc1IwRkJSME1zVFVGQlRTeERRVUZEUXl4SlFVRkpMRU5CUVVOU0xFdEJRVXNzUTBGQlF5eEZRVU01UWxNc1lVRkJZU3hIUVVGSE0wSXNTMEZCU3l4RFFVRkRkMElzVTBGQlV5eERRVUZETEVWQlEyaERja0lzU1VGQlNTeEhRVUZIZDBJc1lVRkJZU3hGUVVOd1FsSXNkMEpCUVhkQ0xFZEJRVWRFTEV0QlFVc3NRMEZCUTJZc1NVRkJTU3hEUVVGRExFVkJRM1JEYlVJc1NVRkJTU3hIUVVGSGNFSXNTVUZCU1N4RFFVRkRNRUlzYlVOQlFXMURMRU5CUVVONlFpeEpRVUZKTEVWQlFVVm5RaXgzUWtGQmQwSXNRMEZCUXl4QlFVRkRPMmRDUVVWMFJpeFBRVUZQUnl4SlFVRkpMRU5CUVVNN1lVRkRZanM3TzFsQlJVMU5MRWRCUVcxRExFVkJRVzVEUVN4eFEwRkJiVU03V1VNeFJUVkRMRTlFTUVWRkxGTkJRVTlCTEcxRFFVRnRReXhEUVVGRGVrSXNTVUZCU1N4RlFVRkZaMElzZDBKQlFYZENMRVZCUVVVN1owSkJRM3BGTEVsQlFVMVZMRTlCUVU4c1IwRkJSME1zVTBGQlV5eERRVUZEV0N4M1FrRkJkMElzUTBGQlF5eEZRVU0zUTFrc1MwRkJTeXhIUVVGSFJpeFBRVUZQTEVkQlEweEhMRlZCUVVNc1MwRkRRME1zVlVGQldTeGhRVUZCTEVWQlEzaENReXhOUVVGTkxFZEJRVWNzU1VGQlNVTXNUVUZCVFN4RFFVRkRhRUlzZDBKQlFYZENMRVZCUVVWWkxFdEJRVXNzUTBGQlF5eEZRVU53UkROQ0xHbENRVUZwUWl4SFFVRkhPRUlzVFVGQlRTeEZRVU14UWxvc1NVRkJTU3hIUVVGSExFbEJRVWx3UWl4SlFVRkpMRU5CUVVORExFbEJRVWtzUlVGQlJVTXNhVUpCUVdsQ0xFTkJRVU1zUVVGQlF6dG5Ra0ZGTDBNc1QwRkJUMnRDTEVsQlFVa3NRMEZCUXp0aFFVTmlPenROUVhCR1NEczdRMEZ4UmtNc1JVRkJRVHRyUWtFelJXOUNjRUlzU1VGQlNTeEJRVlo2UWp0QlFYVkdRU3hUUVVGVE5FSXNVMEZCVXl4RFFVRkRXQ3gzUWtGQmQwSXNSVUZCUlR0SlFVTXpReXhKUVVGTmFVSXNkMEpCUVhkQ0xFOUJRVThzUlVGREwwSjZRaXhMUVVGTExFZEJRVWRSTEhkQ1FVRjNRaXhEUVVGRGEwSXNUVUZCVFN4RFFVRkRSQ3gzUWtGQmQwSXNRMEZCUXl4RlFVTnFSVkFzVDBGQlR5eEhRVUZKYkVJc1MwRkJTeXhMUVVGTExFTkJRVU1zUTBGQlF5eEJRVUZETEVGQlFVTTdTVUZGTDBJc1QwRkJUMnRDTEU5QlFVOHNRMEZCUXp0RFFVTm9RaUo5IiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHBsdXMgPSBcIitcIjtcclxuZXhwb3J0IGNvbnN0IHdpbGRjYXJkID0gXCIuXCI7XHJcbmV4cG9ydCBjb25zdCBhc3RlcmlzayA9IFwiKlwiO1xyXG5leHBvcnQgY29uc3QgZWxsaXBzaXMgPSBcIi4uLlwiO1xyXG5leHBvcnQgY29uc3Qgc2VwYXJhdG9yID0gXCI6Oj1cIjtcclxuZXhwb3J0IGNvbnN0IHRlcm1pbmF0b3IgPSBcIjtcIjtcclxuZXhwb3J0IGNvbnN0IHZlcnRpY2FsQmFyID0gXCJ8XCI7XHJcbmV4cG9ydCBjb25zdCBvcGVuQnJhY2tldCA9IFwiKFwiO1xyXG5leHBvcnQgY29uc3QgY2xvc2VCcmFja2V0ID0gXCIpXCI7XHJcbmV4cG9ydCBjb25zdCBxdWVzdGlvbk1hcmsgPSBcIj9cIjtcclxuZXhwb3J0IGNvbnN0IGV4Y2xhbWF0aW9uTWFyayA9IFwiIVwiO1xyXG5leHBvcnQgY29uc3QgTk9fV0hJVEVTUEFDRSA9IFwiPE5PX1dISVRFU1BBQ0U+XCI7XHJcbmV4cG9ydCBjb25zdCBFTkRfT0ZfTElORSA9IFwiPEVORF9PRl9MSU5FPlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHBsdXMsXHJcbiAgd2lsZGNhcmQsXHJcbiAgYXN0ZXJpc2ssXHJcbiAgZWxsaXBzaXMsXHJcbiAgc2VwYXJhdG9yLFxyXG4gIHRlcm1pbmF0b3IsXHJcbiAgdmVydGljYWxCYXIsXHJcbiAgb3BlbkJyYWNrZXQsXHJcbiAgY2xvc2VCcmFja2V0LFxyXG4gIHF1ZXN0aW9uTWFyayxcclxuICBleGNsYW1hdGlvbk1hcmssXHJcbiAgTk9fV0hJVEVTUEFDRSxcclxuICBFTkRfT0ZfTElORVxyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwic3BlY2lhbFwiOiBcIl4oPzo6Oj18XFxcXHx8XFxcXCh8XFxcXCl8XFxcXD98XFxcXCF8XFxcXCp8XFxcXCt8XFxcXC5cXFxcLlxcXFwufFxcXFwufFx1MDNCNXw7fDxOT19XSElURVNQQUNFPnw8RU5EX09GX0xJTkU+KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInR5cGVcIjogXCJeXFxcXFtbXlxcXFxdXStcXFxcXVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJeW1xcXFx3fl0rXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXStcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluQ29tbWVudEZyb21Ub2tlbkFuZEluQ29tbWVudCh0b2tlbiwgaW5Db21tZW50KSB7XG4gIGNvbnN0IHRva2VuQ29tbWVudFRva2VuID0gdG9rZW4uaXNDb21tZW50VG9rZW4oKTtcblxuICBpZiAodG9rZW5Db21tZW50VG9rZW4pIHtcbiAgICBjb25zdCBjb21tZW50VG9rZW4gPSB0b2tlbiwgLy8vXG4gICAgICAgICAgY29tbWVudFRva2VuSW5Db21tZW50UHJlc2VydmluZyA9IGNvbW1lbnRUb2tlbi5pc0luQ29tbWVudFByZXNlcnZpbmcoKTtcblxuICAgIGluQ29tbWVudCA9IGNvbW1lbnRUb2tlbkluQ29tbWVudFByZXNlcnZpbmc7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBpbkNvbW1lbnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBfdG9rZW4gPSByZXF1aXJlKFwiLi4vdXRpbGl0aWVzL3Rva2VuXCIpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG52YXIgQ29tbW9uTGV4ZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIENvbW1vbkxleGVyKHJ1bGVzLCBJbkNvbW1lbnRDbGFzc2VzLCBOb3RJbkNvbW1lbnRDbGFzc2VzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21tb25MZXhlcik7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgdGhpcy5JbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3NlcztcbiAgICAgICAgdGhpcy5Ob3RJbkNvbW1lbnRDbGFzc2VzID0gTm90SW5Db21tZW50Q2xhc3NlcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKENvbW1vbkxleGVyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRSdWxlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0SW5Db21tZW50Q2xhc3Nlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluQ29tbWVudENsYXNzZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuSW5Db21tZW50Q2xhc3NlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldE5vdEluQ29tbWVudENsYXNzZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb3RJbkNvbW1lbnRDbGFzc2VzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk5vdEluQ29tbWVudENsYXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ0b2tlbmlzZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRva2VuaXNlKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5Db21tZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUoY29udGVudCAhPT0gX2NvbnN0YW50cy5FTVBUWV9TVFJJTkcpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgQ2xhc3NlcyA9IGluQ29tbWVudCA/IHRoaXMuSW5Db21tZW50Q2xhc3NlcyA6IHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3Nlcy5zb21lKGZ1bmN0aW9uKENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IENsYXNzLm1hdGNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZXMuc29tZShmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IHJ1bGUubWF0Y2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBzaWduaWZpY2FudFRva2VuOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29udGVudCAnXCIuY29uY2F0KGNvbnRlbnQsIFwiJyBjYW5ub3QgYmUgdG9rZW5pc2VkLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpbkNvbW1lbnQgPSAoMCwgX3Rva2VuKS5pbkNvbW1lbnRGcm9tVG9rZW5BbmRJbkNvbW1lbnQodG9rZW4sIGluQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbkNvbnRlbnRMZW5ndGggPSB0b2tlbi5nZXRDb250ZW50TGVuZ3RoKCksIHN0YXJ0ID0gdG9rZW5Db250ZW50TGVuZ3RoOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Ob3RoaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vdGhpbmcoQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IENsYXNzLmVudHJpZXMsIEluQ29tbWVudENsYXNzZXMgPSBJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSwgTm90SW5Db21tZW50Q2xhc3NlcyA9IE5vdEluQ29tbWVudENsYXNzZXNGcm9tQ2xhc3MoQ2xhc3MpLCBydWxlcyA9IGVudHJpZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcnVsZS5kZWZhdWx0LmZyb21FbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAgICAgfSksIGxleGVyID0gbmV3IENsYXNzKHJ1bGVzLCBJbkNvbW1lbnRDbGFzc2VzLCBOb3RJbkNvbW1lbnRDbGFzc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGV4ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIEluQ29tbWVudENsYXNzZXMgPSBJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSwgTm90SW5Db21tZW50Q2xhc3NlcyA9IE5vdEluQ29tbWVudENsYXNzZXNGcm9tQ2xhc3MoQ2xhc3MpLCBsZXhlciA9IG5ldyBDbGFzcyhydWxlcywgSW5Db21tZW50Q2xhc3NlcywgTm90SW5Db21tZW50Q2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxleGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUVudHJpZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRW50cmllcyhDbGFzcywgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlcyA9IGVudHJpZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcnVsZS5kZWZhdWx0LmZyb21FbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAgICAgfSksIEluQ29tbWVudENsYXNzZXMgPSBJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSwgTm90SW5Db21tZW50Q2xhc3NlcyA9IE5vdEluQ29tbWVudENsYXNzZXNGcm9tQ2xhc3MoQ2xhc3MpLCBsZXhlciA9IG5ldyBDbGFzcyhydWxlcywgSW5Db21tZW50Q2xhc3NlcywgTm90SW5Db21tZW50Q2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxleGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIENvbW1vbkxleGVyO1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbW9uTGV4ZXI7XG5mdW5jdGlvbiBJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSB7XG4gICAgdmFyIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IENsYXNzLkVuZE9mTGluZUNvbW1lbnRUb2tlbiwgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBDbGFzcy5FbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBDbGFzcy5NaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgSW5Db21tZW50Q2xhc3NlcyA9IFtcbiAgICAgICAgRW5kT2ZMaW5lQ29tbWVudFRva2VuLFxuICAgICAgICBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcbiAgICAgICAgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW5cbiAgICBdO1xuICAgIHJldHVybiBJbkNvbW1lbnRDbGFzc2VzO1xufVxuZnVuY3Rpb24gTm90SW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcykge1xuICAgIHZhciBFbmRPZkxpbmVUb2tlbiA9IENsYXNzLkVuZE9mTGluZVRva2VuLCBXaGl0ZXNwYWNlVG9rZW4gPSBDbGFzcy5XaGl0ZXNwYWNlVG9rZW4sIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBDbGFzcy5TaW5nbGVMaW5lQ29tbWVudFRva2VuLCBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gQ2xhc3MuUmVndWxhckV4cHJlc3Npb25Ub2tlbiwgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IENsYXNzLlN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IENsYXNzLlNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gQ2xhc3MuRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBOb3RJbkNvbW1lbnRDbGFzc2VzID0gW1xuICAgICAgICBFbmRPZkxpbmVUb2tlbixcbiAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxuICAgICAgICBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxuICAgICAgICBTaW5nbGVMaW5lQ29tbWVudFRva2VuLFxuICAgICAgICBSZWd1bGFyRXhwcmVzc2lvblRva2VuLFxuICAgICAgICBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sXG4gICAgICAgIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlblxuICAgIF07XG4gICAgcmV0dXJuIE5vdEluQ29tbWVudENsYXNzZXM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWpiMjF0YjI0dmJHVjRaWEl1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hISmNibHh5WEc1cGJYQnZjblFnVW5Wc1pTQm1jbTl0SUZ3aUxpNHZjblZzWlZ3aU8xeHlYRzVjY2x4dWFXMXdiM0owSUhzZ1JVMVFWRmxmVTFSU1NVNUhJSDBnWm5KdmJTQmNJaTR1TDJOdmJuTjBZVzUwYzF3aU8xeHlYRzVwYlhCdmNuUWdleUJwYmtOdmJXMWxiblJHY205dFZHOXJaVzVCYm1SSmJrTnZiVzFsYm5RZ2ZTQm1jbTl0SUZ3aUxpNHZkWFJwYkdsMGFXVnpMM1J2YTJWdVhDSTdYSEpjYmx4eVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJEYjIxdGIyNU1aWGhsY2lCN1hISmNiaUFnWTI5dWMzUnlkV04wYjNJb2NuVnNaWE1zSUVsdVEyOXRiV1Z1ZEVOc1lYTnpaWE1zSUU1dmRFbHVRMjl0YldWdWRFTnNZWE56WlhNcElIdGNjbHh1SUNBZ0lIUm9hWE11Y25Wc1pYTWdQU0J5ZFd4bGN6dGNjbHh1SUNBZ0lIUm9hWE11U1c1RGIyMXRaVzUwUTJ4aGMzTmxjeUE5SUVsdVEyOXRiV1Z1ZEVOc1lYTnpaWE03WEhKY2JpQWdJQ0IwYUdsekxrNXZkRWx1UTI5dGJXVnVkRU5zWVhOelpYTWdQU0JPYjNSSmJrTnZiVzFsYm5SRGJHRnpjMlZ6TzF4eVhHNGdJSDFjY2x4dUlDQmNjbHh1SUNCblpYUlNkV3hsY3lncElIdGNjbHh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkoxYkdWek8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ1oyVjBTVzVEYjIxdFpXNTBRMnhoYzNObGN5Z3BJSHRjY2x4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TGtsdVEyOXRiV1Z1ZEVOc1lYTnpaWE03WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0JuWlhST2IzUkpia052YlcxbGJuUkRiR0Z6YzJWektDa2dlMXh5WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11VG05MFNXNURiMjF0Wlc1MFEyeGhjM05sY3p0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUhSdmEyVnVhWE5sS0dOdmJuUmxiblFzSUdsdVEyOXRiV1Z1ZENBOUlHWmhiSE5sS1NCN1hISmNiaUFnSUNCamIyNXpkQ0IwYjJ0bGJuTWdQU0JiWFR0Y2NseHVYSEpjYmlBZ0lDQjNhR2xzWlNBb1kyOXVkR1Z1ZENBaFBUMGdSVTFRVkZsZlUxUlNTVTVIS1NCN1hISmNiaUFnSUNBZ0lHeGxkQ0IwYjJ0bGJpQTlJRzUxYkd3N1hISmNibHh5WEc0Z0lDQWdJQ0JqYjI1emRDQkRiR0Z6YzJWeklEMGdhVzVEYjIxdFpXNTBJRDljY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NUpia052YlcxbGJuUkRiR0Z6YzJWeklEcGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxrNXZkRWx1UTI5dGJXVnVkRU5zWVhOelpYTTdYSEpjYmx4eVhHNGdJQ0FnSUNCRGJHRnpjMlZ6TG5OdmJXVW9LRU5zWVhOektTQTlQaUI3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLRU5zWVhOeklDRTlQU0J1ZFd4c0tTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNCMGIydGxiaUE5SUVOc1lYTnpMbTFoZEdOb0tHTnZiblJsYm5RcE8xeHlYRzVjY2x4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2gwYjJ0bGJpQWhQVDBnYm5Wc2JDa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2RISjFaVHRjY2x4dUlDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUgwcE8xeHlYRzVjY2x4dUlDQWdJQ0FnYVdZZ0tIUnZhMlZ1SUQwOVBTQnVkV3hzS1NCN1hISmNiaUFnSUNBZ0lDQWdiR1YwSUhOcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCdWRXeHNPMXh5WEc1Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG5KMWJHVnpMbk52YldVb0tISjFiR1VwSUQwK0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUhOcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCeWRXeGxMbTFoZEdOb0tHTnZiblJsYm5RcE8xeHlYRzVjY2x4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVJQ0U5UFNCdWRXeHNLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJ2YTJWdUlEMGdjMmxuYm1sbWFXTmhiblJVYjJ0bGJqc2dMeTh2WEhKY2JseHlYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnZEhKMVpUdGNjbHh1SUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQjlLVHRjY2x4dUlDQWdJQ0FnZlZ4eVhHNWNjbHh1SUNBZ0lDQWdhV1lnS0hSdmEyVnVJRDA5UFNCdWRXeHNLU0I3WEhKY2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0dCVWFHVWdZMjl1ZEdWdWRDQW5KSHRqYjI1MFpXNTBmU2NnWTJGdWJtOTBJR0psSUhSdmEyVnVhWE5sWkM1Z0tUdGNjbHh1SUNBZ0lDQWdmVnh5WEc1Y2NseHVJQ0FnSUNBZ2RHOXJaVzV6TG5CMWMyZ29kRzlyWlc0cE8xeHlYRzVjY2x4dUlDQWdJQ0FnYVc1RGIyMXRaVzUwSUQwZ2FXNURiMjF0Wlc1MFJuSnZiVlJ2YTJWdVFXNWtTVzVEYjIxdFpXNTBLSFJ2YTJWdUxDQnBia052YlcxbGJuUXBPMXh5WEc1Y2NseHVJQ0FnSUNBZ1kyOXVjM1FnZEc5clpXNURiMjUwWlc1MFRHVnVaM1JvSUQwZ2RHOXJaVzR1WjJWMFEyOXVkR1Z1ZEV4bGJtZDBhQ2dwTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6ZEdGeWRDQTlJSFJ2YTJWdVEyOXVkR1Z1ZEV4bGJtZDBhRHNnTHk4dlhISmNibHh5WEc0Z0lDQWdJQ0JqYjI1MFpXNTBJRDBnWTI5dWRHVnVkQzV6ZFdKemRISnBibWNvYzNSaGNuUXBPMXh5WEc0Z0lDQWdmVnh5WEc1Y2NseHVJQ0FnSUhKbGRIVnliaUIwYjJ0bGJuTTdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQnpkR0YwYVdNZ1puSnZiVTV2ZEdocGJtY29RMnhoYzNNcElIdGNjbHh1SUNBZ0lHTnZibk4wSUhzZ1pXNTBjbWxsY3lCOUlEMGdRMnhoYzNNc1hISmNiaUFnSUNBZ0lDQWdJQ0JKYmtOdmJXMWxiblJEYkdGemMyVnpJRDBnU1c1RGIyMXRaVzUwUTJ4aGMzTmxjMFp5YjIxRGJHRnpjeWhEYkdGemN5a3NYSEpjYmlBZ0lDQWdJQ0FnSUNCT2IzUkpia052YlcxbGJuUkRiR0Z6YzJWeklEMGdUbTkwU1c1RGIyMXRaVzUwUTJ4aGMzTmxjMFp5YjIxRGJHRnpjeWhEYkdGemN5a3NYSEpjYmlBZ0lDQWdJQ0FnSUNCeWRXeGxjeUE5SUdWdWRISnBaWE11YldGd0tDaGxiblJ5ZVNrZ1BUNGdVblZzWlM1bWNtOXRSVzUwY25rb1pXNTBjbmtwS1N4Y2NseHVJQ0FnSUNBZ0lDQWdJR3hsZUdWeUlEMGdibVYzSUVOc1lYTnpLSEoxYkdWekxDQkpia052YlcxbGJuUkRiR0Z6YzJWekxDQk9iM1JKYmtOdmJXMWxiblJEYkdGemMyVnpLVHRjY2x4dVhISmNiaUFnSUNCeVpYUjFjbTRnYkdWNFpYSTdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQnpkR0YwYVdNZ1puSnZiVkoxYkdWektFTnNZWE56TENCeWRXeGxjeWtnZTF4eVhHNGdJQ0FnWTI5dWMzUWdTVzVEYjIxdFpXNTBRMnhoYzNObGN5QTlJRWx1UTI5dGJXVnVkRU5zWVhOelpYTkdjbTl0UTJ4aGMzTW9RMnhoYzNNcExGeHlYRzRnSUNBZ0lDQWdJQ0FnVG05MFNXNURiMjF0Wlc1MFEyeGhjM05sY3lBOUlFNXZkRWx1UTI5dGJXVnVkRU5zWVhOelpYTkdjbTl0UTJ4aGMzTW9RMnhoYzNNcExGeHlYRzRnSUNBZ0lDQWdJQ0FnYkdWNFpYSWdQU0J1WlhjZ1EyeGhjM01vY25Wc1pYTXNJRWx1UTI5dGJXVnVkRU5zWVhOelpYTXNJRTV2ZEVsdVEyOXRiV1Z1ZEVOc1lYTnpaWE1wTzF4eVhHNWNjbHh1SUNBZ0lISmxkSFZ5YmlCc1pYaGxjanRjY2x4dUlDQjlYSEpjYmx4eVhHNGdJSE4wWVhScFl5Qm1jbTl0Ulc1MGNtbGxjeWhEYkdGemN5d2daVzUwY21sbGN5a2dlMXh5WEc0Z0lDQWdZMjl1YzNRZ2NuVnNaWE1nUFNCbGJuUnlhV1Z6TG0xaGNDZ29aVzUwY25rcElEMCtJRkoxYkdVdVpuSnZiVVZ1ZEhKNUtHVnVkSEo1S1Nrc1hISmNiaUFnSUNBZ0lDQWdJQ0JKYmtOdmJXMWxiblJEYkdGemMyVnpJRDBnU1c1RGIyMXRaVzUwUTJ4aGMzTmxjMFp5YjIxRGJHRnpjeWhEYkdGemN5a3NYSEpjYmlBZ0lDQWdJQ0FnSUNCT2IzUkpia052YlcxbGJuUkRiR0Z6YzJWeklEMGdUbTkwU1c1RGIyMXRaVzUwUTJ4aGMzTmxjMFp5YjIxRGJHRnpjeWhEYkdGemN5a3NYSEpjYmlBZ0lDQWdJQ0FnSUNCc1pYaGxjaUE5SUc1bGR5QkRiR0Z6Y3loeWRXeGxjeXdnU1c1RGIyMXRaVzUwUTJ4aGMzTmxjeXdnVG05MFNXNURiMjF0Wlc1MFEyeGhjM05sY3lrN1hISmNibHh5WEc0Z0lDQWdjbVYwZFhKdUlHeGxlR1Z5TzF4eVhHNGdJSDFjY2x4dWZWeHlYRzVjY2x4dVpuVnVZM1JwYjI0Z1NXNURiMjF0Wlc1MFEyeGhjM05sYzBaeWIyMURiR0Z6Y3loRGJHRnpjeWtnZTF4eVhHNGdJR052Ym5OMElIc2dSVzVrVDJaTWFXNWxRMjl0YldWdWRGUnZhMlZ1TENCRmJtUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z1RXbGtaR3hsVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGdmU0E5SUVOc1lYTnpMRnh5WEc0Z0lDQWdJQ0FnSUVsdVEyOXRiV1Z1ZEVOc1lYTnpaWE1nUFNCYlhISmNiaUFnSUNBZ0lDQWdJQ0JGYm1SUFpreHBibVZEYjIxdFpXNTBWRzlyWlc0c1hISmNiaUFnSUNBZ0lDQWdJQ0JGYm1SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaXhjY2x4dUlDQWdJQ0FnSUNBZ0lFMXBaR1JzWlU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVYSEpjYmlBZ0lDQWdJQ0FnWFR0Y2NseHVYSEpjYmlBZ2NtVjBkWEp1SUVsdVEyOXRiV1Z1ZEVOc1lYTnpaWE03WEhKY2JuMWNjbHh1WEhKY2JtWjFibU4wYVc5dUlFNXZkRWx1UTI5dGJXVnVkRU5zWVhOelpYTkdjbTl0UTJ4aGMzTW9RMnhoYzNNcElIdGNjbHh1SUNCamIyNXpkQ0I3SUVWdVpFOW1UR2x1WlZSdmEyVnVMRnh5WEc0Z0lDQWdJQ0FnSUNBZ1YyaHBkR1Z6Y0dGalpWUnZhMlZ1TEZ4eVhHNGdJQ0FnSUNBZ0lDQWdVMmx1WjJ4bFRHbHVaVU52YlcxbGJuUlViMnRsYml4Y2NseHVJQ0FnSUNBZ0lDQWdJRkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVWRzlyWlc0c1hISmNiaUFnSUNBZ0lDQWdJQ0JUZEdGeWRFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1TEZ4eVhHNGdJQ0FnSUNBZ0lDQWdVMmx1WjJ4NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1TEZ4eVhHNGdJQ0FnSUNBZ0lDQWdSRzkxWW14NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1SUgwZ1BTQkRiR0Z6Y3l4Y2NseHVJQ0FnSUNBZ1RtOTBTVzVEYjIxdFpXNTBRMnhoYzNObGN5QTlJRnRjY2x4dUlDQWdJQ0FnSUNCRmJtUlBaa3hwYm1WVWIydGxiaXhjY2x4dUlDQWdJQ0FnSUNCWGFHbDBaWE53WVdObFZHOXJaVzRzWEhKY2JpQWdJQ0FnSUNBZ1UzUmhjblJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpeGNjbHh1SUNBZ0lDQWdJQ0JUYVc1bmJHVk1hVzVsUTI5dGJXVnVkRlJ2YTJWdUxGeHlYRzRnSUNBZ0lDQWdJRkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVWRzlyWlc0c1hISmNiaUFnSUNBZ0lDQWdVMmx1WjJ4NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1TEZ4eVhHNGdJQ0FnSUNBZ0lFUnZkV0pzZVZGMWIzUmxaRk4wY21sdVoweHBkR1Z5WVd4VWIydGxibHh5WEc0Z0lDQWdJQ0JkTzF4eVhHNWNjbHh1SUNCeVpYUjFjbTRnVG05MFNXNURiMjF0Wlc1MFEyeGhjM05sY3p0Y2NseHVmU0pkTENKdVlXMWxjeUk2V3lKRGIyMXRiMjVNWlhobGNpSXNJbkoxYkdWeklpd2lTVzVEYjIxdFpXNTBRMnhoYzNObGN5SXNJazV2ZEVsdVEyOXRiV1Z1ZEVOc1lYTnpaWE1pTENKblpYUlNkV3hsY3lJc0ltZGxkRWx1UTI5dGJXVnVkRU5zWVhOelpYTWlMQ0puWlhST2IzUkpia052YlcxbGJuUkRiR0Z6YzJWeklpd2lkRzlyWlc1cGMyVWlMQ0pqYjI1MFpXNTBJaXdpYVc1RGIyMXRaVzUwSWl3aWRHOXJaVzV6SWl3aVJVMVFWRmxmVTFSU1NVNUhJaXdpZEc5clpXNGlMQ0pEYkdGemMyVnpJaXdpYzI5dFpTSXNJa05zWVhOeklpd2liV0YwWTJnaUxDSnphV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2ljblZzWlNJc0lrVnljbTl5SWl3aWNIVnphQ0lzSW1sdVEyOXRiV1Z1ZEVaeWIyMVViMnRsYmtGdVpFbHVRMjl0YldWdWRDSXNJblJ2YTJWdVEyOXVkR1Z1ZEV4bGJtZDBhQ0lzSW1kbGRFTnZiblJsYm5STVpXNW5kR2dpTENKemRHRnlkQ0lzSW5OMVluTjBjbWx1WnlJc0ltWnliMjFPYjNSb2FXNW5JaXdpWlc1MGNtbGxjeUlzSWtsdVEyOXRiV1Z1ZEVOc1lYTnpaWE5HY205dFEyeGhjM01pTENKT2IzUkpia052YlcxbGJuUkRiR0Z6YzJWelJuSnZiVU5zWVhOeklpd2liV0Z3SWl3aVpXNTBjbmtpTENKU2RXeGxJaXdpWm5KdmJVVnVkSEo1SWl3aWJHVjRaWElpTENKbWNtOXRVblZzWlhNaUxDSm1jbTl0Ulc1MGNtbGxjeUlzSWtWdVpFOW1UR2x1WlVOdmJXMWxiblJVYjJ0bGJpSXNJa1Z1WkU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVJaXdpVFdsa1pHeGxUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0aUxDSkZibVJQWmt4cGJtVlViMnRsYmlJc0lsZG9hWFJsYzNCaFkyVlViMnRsYmlJc0lsTnBibWRzWlV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRpTENKU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxSdmEyVnVJaXdpVTNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlJc0lsTnBibWRzZVZGMWIzUmxaRk4wY21sdVoweHBkR1Z5WVd4VWIydGxiaUlzSWtSdmRXSnNlVkYxYjNSbFpGTjBjbWx1WjB4cGRHVnlZV3hVYjJ0bGJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUlVjc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCTzBGQlEwa3NTVUZCUVN4TlFVRnZRaXhYUVVGd1FpeHZRa0ZCYjBJc1EwRkJRVHM3T3pzN096czdPemhFUVV4dVJUdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPenM3UVVGUFpTeEpRVUZCTEVGQlFVMUJMRmRCUVZjc2FVSkJhMGN2UWl4QlFXeEhZenRoUVVGTlFTeFhRVUZYTEVOQlEyeENReXhMUVVGTExFVkJRVVZETEdkQ1FVRm5RaXhGUVVGRlF5eHRRa0ZCYlVJN01FTkJVakZFTzFGQlUwa3NTVUZCU1N4RFFVRkRSaXhMUVVGTExFZEJRVWRCTEV0QlFVc3NRMEZCUXp0UlFVTnVRaXhKUVVGSkxFTkJRVU5ETEdkQ1FVRm5RaXhIUVVGSFFTeG5Ra0ZCWjBJc1EwRkJRenRSUVVONlF5eEpRVUZKTEVOQlFVTkRMRzFDUVVGdFFpeEhRVUZIUVN4dFFrRkJiVUlzUTBGQlF6czdPenRaUVVkcVJFTXNSMEZCVVN4RlFVRlNRU3hWUVVGUk8xbERaRllzVDBSalJVRXNVMEZCUVVFc1VVRkJVU3hIUVVGSE8yZENRVU5VTEU5QlFVOHNTVUZCU1N4RFFVRkRTQ3hMUVVGTExFTkJRVU03WVVGRGJrSTdPenRaUVVWRVNTeEhRVUZ0UWl4RlFVRnVRa0VzY1VKQlFXMUNPMWxEYkVKeVFpeFBSR3RDUlVFc1UwRkJRVUVzYlVKQlFXMUNMRWRCUVVjN1owSkJRM0JDTEU5QlFVOHNTVUZCU1N4RFFVRkRTQ3huUWtGQlowSXNRMEZCUXp0aFFVTTVRanM3TzFsQlJVUkpMRWRCUVhOQ0xFVkJRWFJDUVN4M1FrRkJjMEk3V1VOMFFuaENMRTlFYzBKRlFTeFRRVUZCUVN4elFrRkJjMElzUjBGQlJ6dG5Ra0ZEZGtJc1QwRkJUeXhKUVVGSkxFTkJRVU5JTEcxQ1FVRnRRaXhEUVVGRE8yRkJRMnBET3pzN1dVRkZSRWtzUjBGQlVTeEZRVUZTUVN4VlFVRlJPMWxETVVKV0xFOUVNRUpGUVN4VFFVRkJRU3hSUVVGUkxFTkJRVU5ETEU5QlFVOHNSVUZCY1VJN2IwSkJRVzVDUXl4VFFVRlRMRWRCUVZSQkxDdERRVUZwUWl4clFrRkJUQ3hMUVVGTE8yZENRVU5xUXl4SlFVRk5ReXhOUVVGTkxFZEJRVWNzUlVGQlJTeEJRVUZETzJkQ1FVVnNRaXhOUVVGUFJpeFBRVUZQTEV0QlFVdEhMRlZCUVZrc1lVRkJRU3hEUVVGRk8yOUNRVU12UWl4SlFVRkpReXhMUVVGTExFZEJRVWNzU1VGQlNTeEJRVUZETzI5Q1FVVnFRaXhKUVVGTlF5eFBRVUZQTEVkQlFVZEtMRk5CUVZNc1IwRkRVQ3hKUVVGSkxFTkJRVU5RTEdkQ1FVRm5RaXhIUVVOdVFpeEpRVUZKTEVOQlFVTkRMRzFDUVVGdFFpeEJRVUZETzI5Q1FVVTNRMVVzVDBGQlR5eERRVUZEUXl4SlFVRkpMRU5CUVVNc1UwRkJRME1zUzBGQlN5eEZRVUZMTzNkQ1FVTjBRaXhKUVVGSlFTeExRVUZMTEV0QlFVc3NTVUZCU1N4RlFVRkZPelJDUVVOc1FrZ3NTMEZCU3l4SFFVRkhSeXhMUVVGTExFTkJRVU5ETEV0QlFVc3NRMEZCUTFJc1QwRkJUeXhEUVVGRExFTkJRVU03TkVKQlJUZENMRWxCUVVsSkxFdEJRVXNzUzBGQlN5eEpRVUZKTEVWQlFVVTdaME5CUTJ4Q0xFOUJRVThzU1VGQlNTeERRVUZET3paQ1FVTmlPM2xDUVVOR08zRkNRVU5HTEVOQlFVTXNRMEZCUXp0dlFrRkZTQ3hKUVVGSlFTeExRVUZMTEV0QlFVc3NTVUZCU1N4RlFVRkZPM2RDUVVOc1FpeEpRVUZKU3l4blFrRkJaMElzUjBGQlJ5eEpRVUZKTEVGQlFVTTdkMEpCUlRWQ0xFbEJRVWtzUTBGQlEyaENMRXRCUVVzc1EwRkJRMkVzU1VGQlNTeERRVUZETEZOQlFVTkpMRWxCUVVrc1JVRkJTenMwUWtGRGVFSkVMR2RDUVVGblFpeEhRVUZIUXl4SlFVRkpMRU5CUVVOR0xFdEJRVXNzUTBGQlExSXNUMEZCVHl4RFFVRkRMRU5CUVVNN05FSkJSWFpETEVsQlFVbFRMR2RDUVVGblFpeExRVUZMTEVsQlFVa3NSVUZCUlR0blEwRkROMEpNTEV0QlFVc3NSMEZCUjBzc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmREUVVVM1FpeFBRVUZQTEVsQlFVa3NRMEZCUXpzMlFrRkRZanQ1UWtGRFJpeERRVUZETEVOQlFVTTdjVUpCUTBvN2IwSkJSVVFzU1VGQlNVd3NTMEZCU3l4TFFVRkxMRWxCUVVrc1JVRkJSVHQzUWtGRGJFSXNUVUZCVFN4SlFVRkpUeXhMUVVGTExFTkJRVU1zUVVGQlF5eGxRVUZoTEVOQlFWVXNUVUZCYzBJc1EwRkJPVUpZTEU5QlFVOHNSVUZCUXl4M1FrRkJjMElzUTBGQlF5eERRVUZETEVOQlFVTTdjVUpCUTJ4Rk8yOUNRVVZFUlN4TlFVRk5MRU5CUVVOVkxFbEJRVWtzUTBGQlExSXNTMEZCU3l4RFFVRkRMRU5CUVVNN2IwSkJSVzVDU0N4VFFVRlRMRWRCUVVkWkxFTkJRVUZCTEVkQlFVRkJMRTFCUVRoQ0xFRkJRV3RDTEVOQlFVRXNaME5CUVdwQ1ZDeExRVUZMTEVWQlFVVklMRk5CUVZNc1EwRkJReXhEUVVGRE8yOUNRVVUzUkN4SlFVRk5ZU3hyUWtGQmEwSXNSMEZCUjFZc1MwRkJTeXhEUVVGRFZ5eG5Ra0ZCWjBJc1JVRkJSU3hGUVVNM1EwTXNTMEZCU3l4SFFVRkhSaXhyUWtGQmEwSXNRVUZCUXl4RlFVRkRMRWRCUVVjN2IwSkJSWEpEWkN4UFFVRlBMRWRCUVVkQkxFOUJRVThzUTBGQlEybENMRk5CUVZNc1EwRkJRMFFzUzBGQlN5eERRVUZETEVOQlFVTTdhVUpCUTNCRE8yZENRVVZFTEU5QlFVOWtMRTFCUVUwc1EwRkJRenRoUVVObU96czdPMWxCUlUxblFpeEhRVUZYTEVWQlFWaEJMR0ZCUVZjN1dVTTNSWEJDTEU5RU5rVkZMRk5CUVU5QkxGZEJRVmNzUTBGQlExZ3NTMEZCU3l4RlFVRkZPMmRDUVVONFFpeEpRVUZOTEVGQlFVVlpMRTlCUVU4c1IwRkJTMW9zUzBGQlN5eERRVUZxUWxrc1QwRkJUeXhCUVVGVkxFVkJRMjVDZWtJc1owSkJRV2RDTEVkQlFVY3dRaXg1UWtGQmVVSXNRMEZCUTJJc1MwRkJTeXhEUVVGRExFVkJRMjVFV2l4dFFrRkJiVUlzUjBGQlJ6QkNMRFJDUVVFMFFpeERRVUZEWkN4TFFVRkxMRU5CUVVNc1JVRkRla1JrTEV0QlFVc3NSMEZCUnpCQ0xFOUJRVThzUTBGQlEwY3NSMEZCUnl4RFFVRkRMRk5CUVVORExFdEJRVXM3TWtKQlFVdERMRXRCUVVrc1UwRkJRME1zVTBGQlV5eERRVUZEUml4TFFVRkxMRU5CUVVNN2FVSkJRVUVzUTBGQlF5eEZRVU55UkVjc1MwRkJTeXhIUVVGSExFbEJRVWx1UWl4TFFVRkxMRU5CUVVOa0xFdEJRVXNzUlVGQlJVTXNaMEpCUVdkQ0xFVkJRVVZETEcxQ1FVRnRRaXhEUVVGRExFRkJRVU03WjBKQlJYUkZMRTlCUVU4clFpeExRVUZMTEVOQlFVTTdZVUZEWkRzN08xbEJSVTFETEVkQlFWTXNSVUZCVkVFc1YwRkJVenRaUTNaR2JFSXNUMFIxUmtVc1UwRkJUMEVzVTBGQlV5eERRVUZEY0VJc1MwRkJTeXhGUVVGRlpDeExRVUZMTEVWQlFVVTdaMEpCUXpkQ0xFbEJRVTFETEdkQ1FVRm5RaXhIUVVGSE1FSXNlVUpCUVhsQ0xFTkJRVU5pTEV0QlFVc3NRMEZCUXl4RlFVTnVSRm9zYlVKQlFXMUNMRWRCUVVjd1FpdzBRa0ZCTkVJc1EwRkJRMlFzUzBGQlN5eERRVUZETEVWQlEzcEViVUlzUzBGQlN5eEhRVUZITEVsQlFVbHVRaXhMUVVGTExFTkJRVU5rTEV0QlFVc3NSVUZCUlVNc1owSkJRV2RDTEVWQlFVVkRMRzFDUVVGdFFpeERRVUZETEVGQlFVTTdaMEpCUlhSRkxFOUJRVThyUWl4TFFVRkxMRU5CUVVNN1lVRkRaRHM3TzFsQlJVMUZMRWRCUVZjc1JVRkJXRUVzWVVGQlZ6dFpReTlHY0VJc1QwUXJSa1VzVTBGQlQwRXNWMEZCVnl4RFFVRkRja0lzUzBGQlN5eEZRVUZGV1N4UFFVRlBMRVZCUVVVN1owSkJRMnBETEVsQlFVMHhRaXhMUVVGTExFZEJRVWN3UWl4UFFVRlBMRU5CUVVOSExFZEJRVWNzUTBGQlF5eFRRVUZEUXl4TFFVRkxPekpDUVVGTFF5eExRVUZKTEZOQlFVTkRMRk5CUVZNc1EwRkJRMFlzUzBGQlN5eERRVUZETzJsQ1FVRkJMRU5CUVVNc1JVRkRja1EzUWl4blFrRkJaMElzUjBGQlJ6QkNMSGxDUVVGNVFpeERRVUZEWWl4TFFVRkxMRU5CUVVNc1JVRkRia1JhTEcxQ1FVRnRRaXhIUVVGSE1FSXNORUpCUVRSQ0xFTkJRVU5rTEV0QlFVc3NRMEZCUXl4RlFVTjZSRzFDTEV0QlFVc3NSMEZCUnl4SlFVRkpia0lzUzBGQlN5eERRVUZEWkN4TFFVRkxMRVZCUVVWRExHZENRVUZuUWl4RlFVRkZReXh0UWtGQmJVSXNRMEZCUXl4QlFVRkRPMmRDUVVWMFJTeFBRVUZQSzBJc1MwRkJTeXhEUVVGRE8yRkJRMlE3TzAxQmRFZElPenREUVhWSFF5eEZRVUZCTzJ0Q1FXaEhiMEpzUXl4WFFVRlhMRUZCVUdoRE8wRkJlVWRCTEZOQlFWTTBRaXg1UWtGQmVVSXNRMEZCUTJJc1MwRkJTeXhGUVVGRk8wbEJRM2hETEVsQlFWRnpRaXh4UWtGQmNVSXNSMEZCWjBWMFFpeExRVUZMTEVOQlFURkdjMElzY1VKQlFYRkNMRVZCUVVWRExEQkNRVUV3UWl4SFFVRnZRM1pDTEV0QlFVc3NRMEZCYmtWMVFpd3dRa0ZCTUVJc1JVRkJSVU1zTmtKQlFUWkNMRWRCUVV0NFFpeExRVUZMTEVOQlFYWkRkMElzTmtKQlFUWkNMRVZCUTJ4R2NrTXNaMEpCUVdkQ0xFZEJRVWM3VVVGRGFrSnRReXh4UWtGQmNVSTdVVUZEY2tKRExEQkNRVUV3UWp0UlFVTXhRa01zTmtKQlFUWkNPMHRCUXpsQ0xFRkJRVU03U1VGRlVpeFBRVUZQY2tNc1owSkJRV2RDTEVOQlFVTTdRMEZEZWtJN1FVRkZSQ3hUUVVGVE1rSXNORUpCUVRSQ0xFTkJRVU5rTEV0QlFVc3NSVUZCUlR0SlFVTXpReXhKUVVGUmVVSXNZMEZCWXl4SFFVMXhRbnBDTEV0QlFVc3NRMEZPZUVONVFpeGpRVUZqTEVWQlEyUkRMR1ZCUVdVc1IwRkxiMEl4UWl4TFFVRkxMRU5CVEhoRE1FSXNaVUZCWlN4RlFVTm1ReXh6UWtGQmMwSXNSMEZKWVROQ0xFdEJRVXNzUTBGS2VFTXlRaXh6UWtGQmMwSXNSVUZEZEVKRExITkNRVUZ6UWl4SFFVZGhOVUlzUzBGQlN5eERRVWg0UXpSQ0xITkNRVUZ6UWl4RlFVTjBRa01zTkVKQlFUUkNMRWRCUlU4M1FpeExRVUZMTEVOQlJuaEROa0lzTkVKQlFUUkNMRVZCUXpWQ1F5dzRRa0ZCT0VJc1IwRkRTemxDTEV0QlFVc3NRMEZFZUVNNFFpdzRRa0ZCT0VJc1JVRkRPVUpETERoQ1FVRTRRaXhIUVVGTEwwSXNTMEZCU3l4RFFVRjRReXRDTERoQ1FVRTRRaXhGUVVOc1F6TkRMRzFDUVVGdFFpeEhRVUZITzFGQlEzQkNjVU1zWTBGQll6dFJRVU5rUXl4bFFVRmxPMUZCUTJaSExEUkNRVUUwUWp0UlFVTTFRa1lzYzBKQlFYTkNPMUZCUTNSQ1F5eHpRa0ZCYzBJN1VVRkRkRUpGTERoQ1FVRTRRanRSUVVNNVFrTXNPRUpCUVRoQ08wdEJReTlDTEVGQlFVTTdTVUZGVGl4UFFVRlBNME1zYlVKQlFXMUNMRU5CUVVNN1EwRkROVUlpZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfdG9rZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi90b2tlblwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBzaWduaWZpY2FudCA9IGZhbHNlO1xudmFyIE5vblNpZ25pZmljYW50VG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFRva2VuKSB7XG4gICAgX2luaGVyaXRzKE5vblNpZ25pZmljYW50VG9rZW4sIFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vblNpZ25pZmljYW50VG9rZW4pO1xuICAgIGZ1bmN0aW9uIE5vblNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25TaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoTm9uU2lnbmlmaWNhbnRUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShDbGFzcywgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTm9uU2lnbmlmaWNhbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBzaWduaWZpY2FudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b2tlbi5kZWZhdWx0Lm1hdGNoKENsYXNzLCBjb250ZW50LCBzaWduaWZpY2FudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b2tlbi5kZWZhdWx0LmZyb21Db250ZW50KENsYXNzLCBjb250ZW50LCBzaWduaWZpY2FudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudEFuZFR5cGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Rva2VuLmRlZmF1bHQuZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlLCBzaWduaWZpY2FudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbjtcbn0oX3Rva2VuLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9uU2lnbmlmaWNhbnRUb2tlbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZSdmEyVnVJR1p5YjIwZ1hDSXVMaTkwYjJ0bGJsd2lPMXh1WEc1amIyNXpkQ0J6YVdkdWFXWnBZMkZ1ZENBOUlHWmhiSE5sTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUdWNGRHVnVaSE1nVkc5clpXNGdlMXh1SUNCamJHOXVaU2hEYkdGemN5d2djM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBJSHNnY21WMGRYSnVJSE4xY0dWeUxtTnNiMjVsS0VOc1lYTnpMQ0J6ZEdGeWRGQnZjMmwwYVc5dUxDQmxibVJRYjNOcGRHbHZiaXdnYzJsbmJtbG1hV05oYm5RcE95QjlYRzVjYmlBZ2MzUmhkR2xqSUcxaGRHTm9LRU5zWVhOekxDQmpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQlViMnRsYmk1dFlYUmphQ2hEYkdGemN5d2dZMjl1ZEdWdWRDd2djMmxuYm1sbWFXTmhiblFwT3lCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxRGIyNTBaVzUwS0VOc1lYTnpMQ0JqYjI1MFpXNTBLU0I3SUhKbGRIVnliaUJVYjJ0bGJpNW1jbTl0UTI5dWRHVnVkQ2hEYkdGemN5d2dZMjl1ZEdWdWRDd2djMmxuYm1sbWFXTmhiblFwT3lCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxRGIyNTBaVzUwUVc1a1ZIbHdaU2hEYkdGemN5d2dZMjl1ZEdWdWRDd2dkSGx3WlNrZ2V5QnlaWFIxY200Z1ZHOXJaVzR1Wm5KdmJVTnZiblJsYm5SQmJtUlVlWEJsS0VOc1lYTnpMQ0JqYjI1MFpXNTBMQ0IwZVhCbExDQnphV2R1YVdacFkyRnVkQ2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKemFXZHVhV1pwWTJGdWRDSXNJazV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKamJHOXVaU0lzSWtOc1lYTnpJaXdpYzNSaGNuUlFiM05wZEdsdmJpSXNJbVZ1WkZCdmMybDBhVzl1SWl3aWJXRjBZMmdpTENKamIyNTBaVzUwSWl3aVZHOXJaVzRpTENKbWNtOXRRMjl1ZEdWdWRDSXNJbVp5YjIxRGIyNTBaVzUwUVc1a1ZIbHdaU0lzSW5SNWNHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZhMElzU1VGQlFTeE5RVUZWTEd0RFFVRldMRlZCUVZVc1JVRkJRVHM3T3pzN096czdPenM3T3pzN096aEVRVVkxUWp0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN01FSkJRVUU3T3pzN096czdPenM3VTBGQlFUczdPenM3T3p0TFFVRkJPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096czdkME5CUVVFN096czdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlNVRXNTVUZCVFVFc1YwRkJWeXhIUVVGSExFdEJRVXNzUVVGQlF6dEJRVVZZTEVsQlFVRXNRVUZCVFVNc2JVSkJRVzFDTEdsQ1EwNXlReXhCUkUxWk8zbERRVTVtT3p0aFFVMXhRa0VzYlVKQlFXMUNPMnRFUVU1NFF6czdPenM3V1VGUFJVTXNSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZVRkFzVDBaUFJVRXNVMEZCUVVFc1MwRkJTeXhEUVVGRFF5eExRVUZMTEVWQlFVVkRMR0ZCUVdFc1JVRkJSVU1zVjBGQlZ5eEZRVUZGTzJkQ1FVRkZMRTlCUVU4c2NVSkJSQzlDU2l4dFFrRkJiVUlzWVVGRGEwSkRMRTlCUVVzc1JVRkJXQ3hKUVVGTExFTkJRVUVzV1VGQlQwTXNTMEZCU3l4RlFVRkZReXhoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUlV3c1YwRkJWeXhGUVVGRk8yRkJRVVU3T3pzN1dVRkZla2ROTEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlZSa0xFOUdVMFVzVTBGQlQwRXNTMEZCU3l4RFFVRkRTQ3hMUVVGTExFVkJRVVZKTEU5QlFVOHNSVUZCUlR0blFrRkJSU3hQUVVGUFF5eE5RVUZMTEZOQlFVTkdMRXRCUVVzc1EwRkJRMGdzUzBGQlN5eEZRVUZGU1N4UFFVRlBMRVZCUVVWUUxGZEJRVmNzUTBGQlF5eERRVUZETzJGQlFVVTdPenRaUVVVeFJWTXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZXSEJDTEU5R1YwVXNVMEZCVDBFc1YwRkJWeXhEUVVGRFRpeExRVUZMTEVWQlFVVkpMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQUXl4TlFVRkxMRk5CUVVORExGZEJRVmNzUTBGQlEwNHNTMEZCU3l4RlFVRkZTU3hQUVVGUExFVkJRVVZRTEZkQlFWY3NRMEZCUXl4RFFVRkRPMkZCUVVVN096dFpRVVYwUmxVc1IwRkJhMElzUlVGQmJFSkJMRzlDUVVGclFqdFpSV0l6UWl4UFJtRkZMRk5CUVU5QkxHdENRVUZyUWl4RFFVRkRVQ3hMUVVGTExFVkJRVVZKTEU5QlFVOHNSVUZCUlVrc1NVRkJTU3hGUVVGRk8yZENRVUZGTEU5QlFVOUlMRTFCUVVzc1UwRkJRMFVzYTBKQlFXdENMRU5CUVVOUUxFdEJRVXNzUlVGQlJVa3NUMEZCVHl4RlFVRkZTU3hKUVVGSkxFVkJRVVZZTEZkQlFWY3NRMEZCUXl4RFFVRkRPMkZCUVVVN08wMUJZbnBJT3p0RFFXTkRMRU5CVW1kRVVTeE5RVUZMTEZOQlVYSkVPMnRDUVZKdlFsQXNiVUpCUVcxQ0xFRkJUbmhESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uU2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBXaGl0ZXNwYWNlVG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblNpZ25pZmljYW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoV2hpdGVzcGFjZVRva2VuLCBOb25TaWduaWZpY2FudFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdoaXRlc3BhY2VUb2tlbik7XG4gICAgZnVuY3Rpb24gV2hpdGVzcGFjZVRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2hpdGVzcGFjZVRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoV2hpdGVzcGFjZVRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc0hUTUxcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc0hUTUwoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLmlubmVySFRNTDsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFdoaXRlc3BhY2VUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgV2hpdGVzcGFjZVRva2VuLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblNpZ25pZmljYW50LmRlZmF1bHQubWF0Y2goV2hpdGVzcGFjZVRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uU2lnbmlmaWNhbnQuZGVmYXVsdC5mcm9tQ29udGVudChXaGl0ZXNwYWNlVG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFdoaXRlc3BhY2VUb2tlbjtcbn0oX25vblNpZ25pZmljYW50LmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2hpdGVzcGFjZVRva2VuO1xuX2RlZmluZVByb3BlcnR5KFdoaXRlc3BhY2VUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy53aGl0ZXNwYWNlVHlwZSk7XG5fZGVmaW5lUHJvcGVydHkoV2hpdGVzcGFjZVRva2VuLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eW1xcdCBdKy8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOTNhR2wwWlhOd1lXTmxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVVMmxuYm1sbWFXTmhiblJVYjJ0bGJpQm1jbTl0SUZ3aUxpNHZMaTR2ZEc5clpXNHZibTl1VTJsbmJtbG1hV05oYm5SY0lqdGNibHh1YVcxd2IzSjBJSHNnZDJocGRHVnpjR0ZqWlZSNWNHVWdmU0JtY205dElGd2lMaTR2TGk0dmRIbHdaWE5jSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVjJocGRHVnpjR0ZqWlZSdmEyVnVJR1Y0ZEdWdVpITWdUbTl1VTJsbmJtbG1hV05oYm5SVWIydGxiaUI3WEc0Z0lHRnpTRlJOVENncElIdGNiaUFnSUNCamIyNXpkQ0JvZEcxc0lEMGdkR2hwY3k1cGJtNWxja2hVVFV3N0lDQXZMeTljYmx4dUlDQWdJSEpsZEhWeWJpQm9kRzFzTzF4dUlDQjlYRzVjYmlBZ1kyeHZibVVvYzNSaGNuUlFiM05wZEdsdmJpd2daVzVrVUc5emFYUnBiMjRwSUhzZ2NtVjBkWEp1SUhOMWNHVnlMbU5zYjI1bEtGZG9hWFJsYzNCaFkyVlViMnRsYml3Z2MzUmhjblJRYjNOcGRHbHZiaXdnWlc1a1VHOXphWFJwYjI0cE95QjlYRzVjYmlBZ2MzUmhkR2xqSUhSNWNHVWdQU0IzYUdsMFpYTndZV05sVkhsd1pUdGNibHh1SUNCemRHRjBhV01nY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRnUFNBdlhsdGNYSFFnWFNzdk8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVMbTFoZEdOb0tGZG9hWFJsYzNCaFkyVlViMnRsYml3Z1kyOXVkR1Z1ZENrN0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJVTnZiblJsYm5Rb1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1RtOXVVMmxuYm1sbWFXTmhiblJVYjJ0bGJpNW1jbTl0UTI5dWRHVnVkQ2hYYUdsMFpYTndZV05sVkc5clpXNHNJR052Ym5SbGJuUXBPeUI5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVjJocGRHVnpjR0ZqWlZSdmEyVnVJaXdpWVhOSVZFMU1JaXdpYUhSdGJDSXNJbWx1Ym1WeVNGUk5UQ0lzSW1Oc2IyNWxJaXdpYzNSaGNuUlFiM05wZEdsdmJpSXNJbVZ1WkZCdmMybDBhVzl1SWl3aWJXRjBZMmdpTENKamIyNTBaVzUwSWl3aVRtOXVVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbVp5YjIxRGIyNTBaVzUwSWl3aWRIbHdaU0lzSW5kb2FYUmxjM0JoWTJWVWVYQmxJaXdpY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGWjBNc1NVRkJRU3hsUVVFMFFpeHJRMEZCTlVJc05FSkJRVFJDTEVWQlFVRTdRVUZGTjBJc1NVRkJRU3hOUVVGaExGZEJRV0lzWVVGQllTeERRVUZCT3pzN096czdPenM3T3pzN096czdPRVJCU2pWRE8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN096czdPenM3TzFWQlFVRTdPM2RDUVVGQk96czdPenM3TUVKQlFVRTdPenM3T3pzN096czdVMEZCUVRzN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzN2QwTkJRVUU3T3pzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVFdVc1NVRkJRU3hCUVVGTlFTeGxRVUZsTEdsQ1EwNXFReXhCUkUxWk8yMUVRVTVtT3p0aFFVMXhRa0VzWlVGQlpUczRRMEZPY0VNN096czdPMWxCVDBWRExFZEJRVTBzUlVGQlRrRXNVVUZCVFR0WlJWQlNMRTlHVDBWQkxGTkJRVUZCTEUxQlFVMHNSMEZCUnp0blFrRkRVQ3hKUVVGTlF5eEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhUUVVGVExFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVnFReXhQUVVGUFJDeEpRVUZKTEVOQlFVTTdZVUZEWWpzN08xbEJSVVJGTEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUldKUUxFOUdZVVZCTEZOQlFVRkJMRXRCUVVzc1EwRkJRME1zWVVGQllTeEZRVUZGUXl4WFFVRlhMRVZCUVVVN1owSkJRVVVzVDBGQlR5eHhRa0ZRZUVKT0xHVkJRV1VzWVVGUFpVa3NUMEZCU3l4RlFVRllMRWxCUVVzc1EwRkJRU3haUVVGUFNpeGxRVUZsTEVWQlFVVkxMR0ZCUVdFc1JVRkJSVU1zVjBGQlZ5eEZRVUZGTzJGQlFVVTdPenM3V1VGTkwwWkRMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSVzVDWkN4UFJtMUNSU3hUUVVGUFFTeExRVUZMTEVOQlFVTkRMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQUXl4bFFVRnRRaXhUUVVGRFJpeExRVUZMTEVOQlFVTlFMR1ZCUVdVc1JVRkJSVkVzVDBGQlR5eERRVUZETEVOQlFVTTdZVUZCUlRzN08xbEJSVGxGUlN4SFFVRlhMRVZCUVZoQkxHRkJRVmM3V1VWeVFuQkNMRTlHY1VKRkxGTkJRVTlCTEZkQlFWY3NRMEZCUTBZc1QwRkJUeXhGUVVGRk8yZENRVUZGTEU5QlFVOURMR1ZCUVcxQ0xGTkJRVU5ETEZkQlFWY3NRMEZCUTFZc1pVRkJaU3hGUVVGRlVTeFBRVUZQTEVOQlFVTXNRMEZCUXp0aFFVRkZPenROUVhKQ2JrYzdPME5CYzBKRExFTkJhRUkwUTBNc1pVRkJiVUlzVTBGblFpOUVPMnRDUVdoQ2IwSlVMR1ZCUVdVc1FVRk9jRU03UVVGbFJTeG5Ra0ZVYlVKQkxHVkJRV1VzUlVGVE0wSlhMRTFCUVVrc1JVRkJSME1zVFVGQll5eG5Ra0ZCUXl4QlFXWXZRanRCUVdsQ1JTeG5Ra0ZZYlVKYUxHVkJRV1VzUlVGWE0wSmhMRzFDUVVGcFFpeFpRVUZoTEVGQmFrSjJReUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9zaWduaWZpY2FudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3Rva2VuL3NpZ25pZmljYW50XCIpKTtcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFNpZ25pZmljYW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoUmVndWxhckV4cHJlc3Npb25Ub2tlbiwgU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZWd1bGFyRXhwcmVzc2lvblRva2VuKTtcbiAgICBmdW5jdGlvbiBSZWd1bGFyRXhwcmVzc2lvblRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVndWxhckV4cHJlc3Npb25Ub2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoUmVndWxhckV4cHJlc3Npb25Ub2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgUmVndWxhckV4cHJlc3Npb25Ub2tlbiwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zaWduaWZpY2FudC5kZWZhdWx0Lm1hdGNoKFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zaWduaWZpY2FudC5kZWZhdWx0LmZyb21Db250ZW50KFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XG59KF9zaWduaWZpY2FudC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XG5fZGVmaW5lUHJvcGVydHkoUmVndWxhckV4cHJlc3Npb25Ub2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5yZWd1bGFyRXhwcmVzc2lvblR5cGUpO1xuX2RlZmluZVByb3BlcnR5KFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIFwicmVndWxhckV4cHJlc3Npb25cIiwgL15cXC8oPzpcXFxcW15cXHNdfFteXFwvXFxyXFxuXSkqXFwvLyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXphV2R1YVdacFkyRnVkQzl5WldkMWJHRnlSWGh3Y21WemMybHZiaTVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElGTnBaMjVwWm1sallXNTBWRzlyWlc0Z1puSnZiU0JjSWk0dUx5NHVMM1J2YTJWdUwzTnBaMjVwWm1sallXNTBYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lISmxaM1ZzWVhKRmVIQnlaWE56YVc5dVZIbHdaU0I5SUdaeWIyMGdYQ0l1TGk4dUxpOTBlWEJsYzF3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxSdmEyVnVJR1Y0ZEdWdVpITWdVMmxuYm1sbWFXTmhiblJVYjJ0bGJpQjdYRzRnSUdOc2IyNWxLSE4wWVhKMFVHOXphWFJwYjI0c0lHVnVaRkJ2YzJsMGFXOXVLU0I3SUhKbGRIVnliaUJ6ZFhCbGNpNWpiRzl1WlNoU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxSdmEyVnVMQ0J6ZEdGeWRGQnZjMmwwYVc5dUxDQmxibVJRYjNOcGRHbHZiaWs3SUgxY2JseHVJQ0J6ZEdGMGFXTWdkSGx3WlNBOUlISmxaM1ZzWVhKRmVIQnlaWE56YVc5dVZIbHdaVHRjYmx4dUlDQnpkR0YwYVdNZ2NtVm5kV3hoY2tWNGNISmxjM05wYjI0Z1BTQXZYbHhjTHlnL09seGNYRnhiWGx4Y2MxMThXMTVjWEM5Y1hISmNYRzVkS1NwY1hDOHZPMXh1WEc0Z0lITjBZWFJwWXlCdFlYUmphQ2hqYjI1MFpXNTBLU0I3SUhKbGRIVnliaUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVMbTFoZEdOb0tGSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVZHOXJaVzRzSUdOdmJuUmxiblFwT3lCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxRGIyNTBaVzUwS0dOdmJuUmxiblFwSUhzZ2NtVjBkWEp1SUZOcFoyNXBabWxqWVc1MFZHOXJaVzR1Wm5KdmJVTnZiblJsYm5Rb1VtVm5kV3hoY2tWNGNISmxjM05wYjI1VWIydGxiaXdnWTI5dWRHVnVkQ2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxSdmEyVnVJaXdpWTJ4dmJtVWlMQ0p6ZEdGeWRGQnZjMmwwYVc5dUlpd2laVzVrVUc5emFYUnBiMjRpTENKdFlYUmphQ0lzSW1OdmJuUmxiblFpTENKVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aVpuSnZiVU52Ym5SbGJuUWlMQ0owZVhCbElpd2ljbVZuZFd4aGNrVjRjSEpsYzNOcGIyNVVlWEJsSWl3aWNtVm5kV3hoY2tWNGNISmxjM05wYjI0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRk5rSXNTVUZCUVN4WlFVRjVRaXhyUTBGQmVrSXNlVUpCUVhsQ0xFVkJRVUU3UVVGRmFFSXNTVUZCUVN4TlFVRmhMRmRCUVdJc1lVRkJZU3hEUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlNtNUVPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3T3pzN08xVkJRVUU3TzNkQ1FVRkJPenM3T3pzN01FSkJRVUU3T3pzN096czdPenM3VTBGQlFUczdPenM3T3p0TFFVRkJPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096czdkME5CUVVFN096czdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlRXVXNTVUZCUVN4QlFVRk5RU3h6UWtGQmMwSXNhVUpEVG5oRExFRkVUVms3ZFVSQlRtWTdPMkZCVFhGQ1FTeHpRa0ZCYzBJN2NVUkJUak5ET3pzN096dFpRVTlGUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWUVVDeFBSazlGUVN4VFFVRkJRU3hMUVVGTExFTkJRVU5ETEdGQlFXRXNSVUZCUlVNc1YwRkJWeXhGUVVGRk8yZENRVUZGTEU5QlFVOHNjVUpCUkhoQ1NDeHpRa0ZCYzBJc1lVRkRVVU1zVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBSQ3h6UWtGQmMwSXNSVUZCUlVVc1lVRkJZU3hGUVVGRlF5eFhRVUZYTEVWQlFVVTdZVUZCUlRzN096dFpRVTEwUjBNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlltUXNUMFpoUlN4VFFVRlBRU3hMUVVGTExFTkJRVU5ETEU5QlFVOHNSVUZCUlR0blFrRkJSU3hQUVVGUFF5eFpRVUZuUWl4VFFVRkRSaXhMUVVGTExFTkJRVU5LTEhOQ1FVRnpRaXhGUVVGRlN5eFBRVUZQTEVOQlFVTXNRMEZCUXp0aFFVRkZPenM3V1VGRmJFWkZMRWRCUVZjc1JVRkJXRUVzWVVGQlZ6dFpSV1p3UWl4UFJtVkZMRk5CUVU5QkxGZEJRVmNzUTBGQlEwWXNUMEZCVHl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZsQlFXZENMRk5CUVVORExGZEJRVmNzUTBGQlExQXNjMEpCUVhOQ0xFVkJRVVZMTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUVVVN08wMUJablpIT3p0RFFXZENReXhEUVZadFJFTXNXVUZCWjBJc1UwRlZia1U3YTBKQlZtOUNUaXh6UWtGQmMwSXNRVUZPTTBNN1FVRlRSU3huUWtGSWJVSkJMSE5DUVVGelFpeEZRVWRzUTFFc1RVRkJTU3hGUVVGSFF5eE5RVUZ4UWl4MVFrRkJReXhCUVZSMFF6dEJRVmRGTEdkQ1FVeHRRbFFzYzBKQlFYTkNMRVZCUzJ4RFZTeHRRa0ZCYVVJc1owTkJRV2xETEVGQldETkVJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25TaWduaWZpY2FudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCIpKTtcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblNpZ25pZmljYW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgTm9uU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuKTtcbiAgICBmdW5jdGlvbiBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNIVE1MXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNIVE1MKCkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5pbm5lckhUTUw7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0Lm1hdGNoKEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0LmZyb21Db250ZW50KEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47XG59KF9ub25TaWduaWZpY2FudC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5lbmRPZkxpbmVUeXBlKTtcbl9kZWZpbmVQcm9wZXJ0eShFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eKD86XFxyXFxufFxccnxcXG4pLyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXViMjVUYVdkdWFXWnBZMkZ1ZEM5bGJtUlBaa3hwYm1VdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk4dUxpOTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkRndpTzF4dVhHNXBiWEJ2Y25RZ2V5QmxibVJQWmt4cGJtVlVlWEJsSUgwZ1puSnZiU0JjSWk0dUx5NHVMM1I1Y0dWelhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklFVnVaRTltVEdsdVpVNXZibE5wWjI1cFptbGpZVzUwVkc5clpXNGdaWGgwWlc1a2N5Qk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJSHRjYmlBZ1kyeHZibVVvYzNSaGNuUlFiM05wZEdsdmJpd2daVzVrVUc5emFYUnBiMjRwSUhzZ2NtVjBkWEp1SUhOMWNHVnlMbU5zYjI1bEtFVnVaRTltVEdsdVpVNXZibE5wWjI1cFptbGpZVzUwVkc5clpXNHNJSE4wWVhKMFVHOXphWFJwYjI0c0lHVnVaRkJ2YzJsMGFXOXVLVHNnZlZ4dVhHNGdJR0Z6U0ZSTlRDZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCb2RHMXNJRDBnZEdocGN5NXBibTVsY2toVVRVdzdJQ0F2THk5Y2JseHVJQ0FnSUhKbGRIVnliaUJvZEcxc08xeHVJQ0I5WEc1Y2JpQWdjM1JoZEdsaklIUjVjR1VnUFNCbGJtUlBaa3hwYm1WVWVYQmxPMXh1WEc0Z0lITjBZWFJwWXlCeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlBOUlDOWVLRDg2WEZ4eVhGeHVmRnhjY254Y1hHNHBMenRjYmx4dUlDQnpkR0YwYVdNZ2JXRjBZMmdvWTI5dWRHVnVkQ2tnZXlCeVpYUjFjbTRnVG05dVUybG5ibWxtYVdOaGJuUlViMnRsYmk1dFlYUmphQ2hGYm1SUFpreHBibVZPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1TENCamIyNTBaVzUwS1RzZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFEyOXVkR1Z1ZENoamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUxtWnliMjFEYjI1MFpXNTBLRVZ1WkU5bVRHbHVaVTV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzRzSUdOdmJuUmxiblFwT3lCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVJXNWtUMlpNYVc1bFRtOXVVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbU5zYjI1bElpd2ljM1JoY25SUWIzTnBkR2x2YmlJc0ltVnVaRkJ2YzJsMGFXOXVJaXdpWVhOSVZFMU1JaXdpYUhSdGJDSXNJbWx1Ym1WeVNGUk5UQ0lzSW0xaGRHTm9JaXdpWTI5dWRHVnVkQ0lzSWs1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0aUxDSm1jbTl0UTI5dWRHVnVkQ0lzSW5SNWNHVWlMQ0psYm1SUFpreHBibVZVZVhCbElpd2ljbVZuZFd4aGNrVjRjSEpsYzNOcGIyNGlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZaME1zU1VGQlFTeGxRVUUwUWl4clEwRkJOVUlzTkVKQlFUUkNMRVZCUVVFN1FVRkZPVUlzU1VGQlFTeE5RVUZoTEZkQlFXSXNZVUZCWVN4RFFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJTak5ETzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN096czdPMVZCUVVFN08zZENRVUZCT3pzN096czdNRUpCUVVFN096czdPenM3T3pzN1UwRkJRVHM3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenM3ZDBOQlFVRTdPenM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJUV1VzU1VGQlFTeEJRVUZOUVN3MFFrRkJORUlzYVVKRFRqbERMRUZFVFZrN1owVkJUbVk3TzJGQlRYRkNRU3cwUWtGQk5FSTdNa1JCVG1wRU96czdPenRaUVU5RlF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVVlFVQ3hQUms5RlFTeFRRVUZCUVN4TFFVRkxMRU5CUVVORExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMmRDUVVGRkxFOUJRVThzY1VKQlJIaENTQ3cwUWtGQk5FSXNZVUZEUlVNc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQUkN3MFFrRkJORUlzUlVGQlJVVXNZVUZCWVN4RlFVRkZReXhYUVVGWExFVkJRVVU3WVVGQlJUczdPMWxCUlc1SVF5eEhRVUZOTEVWQlFVNUJMRkZCUVUwN1dVVlVVaXhQUmxORlFTeFRRVUZCUVN4TlFVRk5MRWRCUVVjN1owSkJRMUFzU1VGQlRVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJRME1zVTBGQlV5eEJRVUZETEVWQlFVVXNSMEZCUnp0blFrRkZha01zVDBGQlQwUXNTVUZCU1N4RFFVRkRPMkZCUTJJN096czdXVUZOVFVVc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRmJrSmtMRTlHYlVKRkxGTkJRVTlCTEV0QlFVc3NRMEZCUTBNc1QwRkJUeXhGUVVGRk8yZENRVUZGTEU5QlFVOURMR1ZCUVcxQ0xGTkJRVU5HTEV0QlFVc3NRMEZCUTFBc05FSkJRVFJDTEVWQlFVVlJMRTlCUVU4c1EwRkJReXhEUVVGRE8yRkJRVVU3T3p0WlFVVXpSa1VzUjBGQlZ5eEZRVUZZUVN4aFFVRlhPMWxGY2tKd1FpeFBSbkZDUlN4VFFVRlBRU3hYUVVGWExFTkJRVU5HTEU5QlFVOHNSVUZCUlR0blFrRkJSU3hQUVVGUFF5eGxRVUZ0UWl4VFFVRkRReXhYUVVGWExFTkJRVU5XTERSQ1FVRTBRaXhGUVVGRlVTeFBRVUZQTEVOQlFVTXNRMEZCUXp0aFFVRkZPenROUVhKQ2FFZzdPME5CYzBKRExFTkJhRUo1UkVNc1pVRkJiVUlzVTBGblFqVkZPMnRDUVdoQ2IwSlVMRFJDUVVFMFFpeEJRVTVxUkR0QlFXVkZMR2RDUVZSdFFrRXNORUpCUVRSQ0xFVkJVM2hEVnl4TlFVRkpMRVZCUVVkRExFMUJRV0VzWlVGQlF5eEJRV1k1UWp0QlFXbENSU3huUWtGWWJVSmFMRFJDUVVFMFFpeEZRVmQ0UTJFc2JVSkJRV2xDTEc5Q1FVRnhRaXhCUVdwQ0wwTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9zaWduaWZpY2FudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3Rva2VuL3NpZ25pZmljYW50XCIpKTtcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFN0cmluZ0xpdGVyYWxUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oU2lnbmlmaWNhbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhTdHJpbmdMaXRlcmFsVG9rZW4sIFNpZ25pZmljYW50VG9rZW4pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU3RyaW5nTGl0ZXJhbFRva2VuKTtcbiAgICBmdW5jdGlvbiBTdHJpbmdMaXRlcmFsVG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdMaXRlcmFsVG9rZW4pO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhTdHJpbmdMaXRlcmFsVG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFN0cmluZ0xpdGVyYWxUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFN0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudCgpLCBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGgsIHN0YXJ0ID0gMSwgZW5kID0gY29udGVudExlbmd0aCAtIDEsIHN0cmluZyA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zaWduaWZpY2FudC5kZWZhdWx0Lm1hdGNoKENsYXNzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NpZ25pZmljYW50LmRlZmF1bHQuZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0cmluZ0xpdGVyYWxUb2tlbjtcbn0oX3NpZ25pZmljYW50LmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyaW5nTGl0ZXJhbFRva2VuO1xuX2RlZmluZVByb3BlcnR5KFN0cmluZ0xpdGVyYWxUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5zdHJpbmdMaXRlcmFsVHlwZSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXphV2R1YVdacFkyRnVkQzl6ZEhKcGJtZE1hWFJsY21Gc0xtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnVTJsbmJtbG1hV05oYm5SVWIydGxiaUJtY205dElGd2lMaTR2TGk0dmRHOXJaVzR2YzJsbmJtbG1hV05oYm5SY0lqdGNibHh1YVcxd2IzSjBJSHNnYzNSeWFXNW5UR2wwWlhKaGJGUjVjR1VnZlNCbWNtOXRJRndpTGk0dkxpNHZkSGx3WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1UzUnlhVzVuVEdsMFpYSmhiRlJ2YTJWdUlHVjRkR1Z1WkhNZ1UybG5ibWxtYVdOaGJuUlViMnRsYmlCN1hHNGdJR05zYjI1bEtFTnNZWE56TENCemRHRnlkRkJ2YzJsMGFXOXVMQ0JsYm1SUWIzTnBkR2x2YmlrZ2V5QnlaWFIxY200Z2MzVndaWEl1WTJ4dmJtVW9RMnhoYzNNc0lITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtUc2dmVnh1WEc0Z0lHZGxkRk4wY21sdVp5Z3BJSHRjYmlBZ0lDQmpiMjV6ZENCamIyNTBaVzUwSUQwZ2RHaHBjeTVuWlhSRGIyNTBaVzUwS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdWdWRFeGxibWQwYUNBOUlHTnZiblJsYm5RdWJHVnVaM1JvTEZ4dUlDQWdJQ0FnSUNBZ0lITjBZWEowSUQwZ01TeGNiaUFnSUNBZ0lDQWdJQ0JsYm1RZ1BTQmpiMjUwWlc1MFRHVnVaM1JvSUMwZ01TeGNiaUFnSUNBZ0lDQWdJQ0J6ZEhKcGJtY2dQU0JqYjI1MFpXNTBMbk4xWW5OMGNtbHVaeWh6ZEdGeWRDd2daVzVrS1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJ6ZEhKcGJtYzdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdkSGx3WlNBOUlITjBjbWx1WjB4cGRHVnlZV3hVZVhCbE8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaERiR0Z6Y3l3Z1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1UybG5ibWxtYVdOaGJuUlViMnRsYmk1dFlYUmphQ2hEYkdGemN5d2dZMjl1ZEdWdWRDazdJSDFjYmx4dUlDQnpkR0YwYVdNZ1puSnZiVU52Ym5SbGJuUW9RMnhoYzNNc0lHTnZiblJsYm5RcElIc2djbVYwZFhKdUlGTnBaMjVwWm1sallXNTBWRzlyWlc0dVpuSnZiVU52Ym5SbGJuUW9RMnhoYzNNc0lHTnZiblJsYm5RcE95QjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lVM1J5YVc1blRHbDBaWEpoYkZSdmEyVnVJaXdpWTJ4dmJtVWlMQ0pEYkdGemN5SXNJbk4wWVhKMFVHOXphWFJwYjI0aUxDSmxibVJRYjNOcGRHbHZiaUlzSW1kbGRGTjBjbWx1WnlJc0ltTnZiblJsYm5RaUxDSm5aWFJEYjI1MFpXNTBJaXdpWTI5dWRHVnVkRXhsYm1kMGFDSXNJbXhsYm1kMGFDSXNJbk4wWVhKMElpd2laVzVrSWl3aWMzUnlhVzVuSWl3aWMzVmljM1J5YVc1bklpd2liV0YwWTJnaUxDSlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2labkp2YlVOdmJuUmxiblFpTENKMGVYQmxJaXdpYzNSeWFXNW5UR2wwWlhKaGJGUjVjR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGTmtJc1NVRkJRU3haUVVGNVFpeHJRMEZCZWtJc2VVSkJRWGxDTEVWQlFVRTdRVUZGY0VJc1NVRkJRU3hOUVVGaExGZEJRV0lzWVVGQllTeERRVUZCT3pzN096czdPenM3T3pzN096czdPRVJCU2k5RE8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN096czdPenM3TzFWQlFVRTdPM2RDUVVGQk96czdPenM3TUVKQlFVRTdPenM3T3pzN096czdVMEZCUVRzN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzN2QwTkJRVUU3T3pzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVFdVc1NVRkJRU3hCUVVGTlFTeHJRa0ZCYTBJc2FVSkRUbkJETEVGRVRWazdiVVJCVG1ZN08yRkJUWEZDUVN4clFrRkJhMEk3YVVSQlRuWkRPenM3T3p0WlFVOUZReXhIUVVGTExFVkJRVXhCTEU5QlFVczdXVVZRVUN4UFJrOUZRU3hUUVVGQlFTeExRVUZMTEVOQlFVTkRMRXRCUVVzc1JVRkJSVU1zWVVGQllTeEZRVUZGUXl4WFFVRlhMRVZCUVVVN1owSkJRVVVzVDBGQlR5eHhRa0ZFTDBKS0xHdENRVUZyUWl4aFFVTnRRa01zVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBReXhMUVVGTExFVkJRVVZETEdGQlFXRXNSVUZCUlVNc1YwRkJWeXhGUVVGRk8yRkJRVVU3T3p0WlFVVnVSME1zUjBGQlV5eEZRVUZVUVN4WFFVRlRPMWxGVkZnc1QwWlRSVUVzVTBGQlFVRXNVMEZCVXl4SFFVRkhPMmRDUVVOV0xFbEJRVTFETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVORExGVkJRVlVzUlVGQlJTeEZRVU16UWtNc1lVRkJZU3hIUVVGSFJpeFBRVUZQTEVOQlFVTkhMRTFCUVUwc1JVRkRPVUpETEV0QlFVc3NSMEZCUnl4RFFVRkRMRVZCUTFSRExFZEJRVWNzUjBGQlIwZ3NZVUZCWVN4SFFVRkhMRU5CUVVNc1JVRkRka0pKTEUxQlFVMHNSMEZCUjA0c1QwRkJUeXhEUVVGRFR5eFRRVUZUTEVOQlFVTklMRXRCUVVzc1JVRkJSVU1zUjBGQlJ5eERRVUZETEVGQlFVTTdaMEpCUlRkRExFOUJRVTlETEUxQlFVMHNRMEZCUXp0aFFVTm1PenM3TzFsQlNVMUZMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSWEpDWkN4UFJuRkNSU3hUUVVGUFFTeExRVUZMTEVOQlFVTmFMRXRCUVVzc1JVRkJSVWtzVDBGQlR5eEZRVUZGTzJkQ1FVRkZMRTlCUVU5VExGbEJRV2RDTEZOQlFVTkVMRXRCUVVzc1EwRkJRMW9zUzBGQlN5eEZRVUZGU1N4UFFVRlBMRU5CUVVNc1EwRkJRenRoUVVGRk96czdXVUZGZUVWVkxFZEJRVmNzUlVGQldFRXNZVUZCVnp0WlJYWkNjRUlzVDBaMVFrVXNVMEZCVDBFc1YwRkJWeXhEUVVGRFpDeExRVUZMTEVWQlFVVkpMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQVXl4WlFVRm5RaXhUUVVGRFF5eFhRVUZYTEVOQlFVTmtMRXRCUVVzc1JVRkJSVWtzVDBGQlR5eERRVUZETEVOQlFVTTdZVUZCUlRzN1RVRjJRamRHT3p0RFFYZENReXhEUVd4Q0swTlRMRmxCUVdkQ0xGTkJhMEl2UkR0clFrRnNRbTlDWml4clFrRkJhMElzUVVGT2RrTTdRVUZ0UWtVc1owSkJZbTFDUVN4clFrRkJhMElzUlVGaE9VSnBRaXhOUVVGSkxFVkJRVWRETEUxQlFXbENMRzFDUVVGRExFRkJia0pzUXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfc3RyaW5nTGl0ZXJhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWxcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFN0cmluZ0xpdGVyYWxUb2tlbikge1xuICAgIF9pbmhlcml0cyhEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sIFN0cmluZ0xpdGVyYWxUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4pO1xuICAgIGZ1bmN0aW9uIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4ucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdHJpbmdMaXRlcmFsLmRlZmF1bHQubWF0Y2goRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3RyaW5nTGl0ZXJhbC5kZWZhdWx0LmZyb21Db250ZW50KERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuO1xufShfc3RyaW5nTGl0ZXJhbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcbl9kZWZpbmVQcm9wZXJ0eShEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sIFwicmVndWxhckV4cHJlc3Npb25cIiwgL15cIig/OlxcXFxbXlxcc118W15cIlxcXFxcXHJcXG5dKSpcIi8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OTBiMnRsYmk5emFXZHVhV1pwWTJGdWRDOXpkSEpwYm1kTWFYUmxjbUZzTDJSdmRXSnNlVkYxYjNSbFpDNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZOMGNtbHVaMHhwZEdWeVlXeFViMnRsYmlCbWNtOXRJRndpTGk0dkxpNHZjMmxuYm1sbWFXTmhiblF2YzNSeWFXNW5UR2wwWlhKaGJGd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QkViM1ZpYkhsUmRXOTBaV1JUZEhKcGJtZE1hWFJsY21Gc1ZHOXJaVzRnWlhoMFpXNWtjeUJUZEhKcGJtZE1hWFJsY21Gc1ZHOXJaVzRnZTF4dUlDQmpiRzl1WlNoemRHRnlkRkJ2YzJsMGFXOXVMQ0JsYm1SUWIzTnBkR2x2YmlrZ2V5QnlaWFIxY200Z2MzVndaWEl1WTJ4dmJtVW9SRzkxWW14NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1TENCemRHRnlkRkJ2YzJsMGFXOXVMQ0JsYm1SUWIzTnBkR2x2YmlrN0lIMWNibHh1SUNCemRHRjBhV01nY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRnUFNBdlhsd2lLRDg2WEZ4Y1hGdGVYRnh6WFh4Ylhsd2lYRnhjWEZ4Y2NseGNibDBwS2x3aUx6dGNibHh1SUNCemRHRjBhV01nYldGMFkyZ29ZMjl1ZEdWdWRDa2dleUJ5WlhSMWNtNGdVM1J5YVc1blRHbDBaWEpoYkZSdmEyVnVMbTFoZEdOb0tFUnZkV0pzZVZGMWIzUmxaRk4wY21sdVoweHBkR1Z5WVd4VWIydGxiaXdnWTI5dWRHVnVkQ2s3SUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlVOdmJuUmxiblFvWTI5dWRHVnVkQ2tnZXlCeVpYUjFjbTRnVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1TG1aeWIyMURiMjUwWlc1MEtFUnZkV0pzZVZGMWIzUmxaRk4wY21sdVoweHBkR1Z5WVd4VWIydGxiaXdnWTI5dWRHVnVkQ2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKRWIzVmliSGxSZFc5MFpXUlRkSEpwYm1kTWFYUmxjbUZzVkc5clpXNGlMQ0pqYkc5dVpTSXNJbk4wWVhKMFVHOXphWFJwYjI0aUxDSmxibVJRYjNOcGRHbHZiaUlzSW0xaGRHTm9JaXdpWTI5dWRHVnVkQ0lzSWxOMGNtbHVaMHhwZEdWeVlXeFViMnRsYmlJc0ltWnliMjFEYjI1MFpXNTBJaXdpY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGSzBJc1NVRkJRU3hqUVVGcFF5eHJRMEZCYWtNc2FVTkJRV2xETEVWQlFVRTdPenM3T3pzN096czdPenM3T3pzNFJFRkdhRVU3YzBOQlFVRTdOa1JCUVVFN2FVVkJRVUU3T3pzN2QwVkJRVUU3WjBWQlFVRTdPenM3T3pzN096czdWVUZCUVRzN2QwSkJRVUU3T3pzN096c3dRa0ZCUVRzN096czdPenM3T3p0VFFVRkJPenM3T3pzN08wdEJRVUU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPenQzUTBGQlFUczdPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRkpaU3hKUVVGQkxFRkJRVTFCTERoQ1FVRTRRaXhwUWtOS2FFUXNRVVJKV1R0cFJVRktaanM3WVVGSmNVSkJMRGhDUVVFNFFqczJSRUZLYmtRN096czdPMWxCUzBWRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJVeFFMRTlHUzBWQkxGTkJRVUZCTEV0QlFVc3NRMEZCUTBNc1lVRkJZU3hGUVVGRlF5eFhRVUZYTEVWQlFVVTdaMEpCUVVVc1QwRkJUeXh4UWtGRWVFSklMRGhDUVVFNFFpeGhRVU5CUXl4UFFVRkxMRVZCUVZnc1NVRkJTeXhEUVVGQkxGbEJRVTlFTERoQ1FVRTRRaXhGUVVGRlJTeGhRVUZoTEVWQlFVVkRMRmRCUVZjc1JVRkJSVHRoUVVGRk96czdPMWxCU1RsSFF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVVlVaQ3hQUmxORkxGTkJRVTlCTEV0QlFVc3NRMEZCUTBNc1QwRkJUeXhGUVVGRk8yZENRVUZGTEU5QlFVOURMR05CUVd0Q0xGTkJRVU5HTEV0QlFVc3NRMEZCUTBvc09FSkJRVGhDTEVWQlFVVkxMRTlCUVU4c1EwRkJReXhEUVVGRE8yRkJRVVU3T3p0WlFVVTFSa1VzUjBGQlZ5eEZRVUZZUVN4aFFVRlhPMWxGV0hCQ0xFOUdWMFVzVTBGQlQwRXNWMEZCVnl4RFFVRkRSaXhQUVVGUExFVkJRVVU3WjBKQlFVVXNUMEZCVDBNc1kwRkJhMElzVTBGQlEwTXNWMEZCVnl4RFFVRkRVQ3c0UWtGQk9FSXNSVUZCUlVzc1QwRkJUeXhEUVVGRExFTkJRVU03WVVGQlJUczdUVUZZYWtnN08wTkJXVU1zUTBGU01rUkRMR05CUVd0Q0xGTkJVVGRGTzJ0Q1FWSnZRazRzT0VKQlFUaENMRUZCU201RU8wRkJUMFVzWjBKQlNHMUNRU3c0UWtGQk9FSXNSVUZITVVOUkxHMUNRVUZwUWl3clFrRkJaME1zUVVGUU1VUWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9lbnRyaWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9lbnRyaWVzXCIpKTtcbnZhciBfbGV4ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb21tb24vbGV4ZXJcIikpO1xudmFyIF93aGl0ZXNwYWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvd2hpdGVzcGFjZVwiKSk7XG52YXIgX3JlZ3VsYXJFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdG9rZW4vc2lnbmlmaWNhbnQvcmVndWxhckV4cHJlc3Npb25cIikpO1xudmFyIF9lbmRPZkxpbmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9lbmRPZkxpbmVcIikpO1xudmFyIF9kb3VibHlRdW90ZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEJORkxleGVyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb21tb25MZXhlcikge1xuICAgIF9pbmhlcml0cyhCTkZMZXhlciwgQ29tbW9uTGV4ZXIpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQk5GTGV4ZXIpO1xuICAgIGZ1bmN0aW9uIEJORkxleGVyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQk5GTGV4ZXIpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhCTkZMZXhlciwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwidG9rZW5zRnJvbUJORlwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRva2Vuc0Zyb21CTkYoYm5mKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBibmYsIHRva2VucyA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEJORkxleGVyLnByb3RvdHlwZSksIFwidG9rZW5pc2VcIiwgdGhpcykuY2FsbCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbU5vdGhpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTm90aGluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xleGVyLmRlZmF1bHQuZnJvbU5vdGhpbmcoQk5GTGV4ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVzKHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9sZXhlci5kZWZhdWx0LmZyb21SdWxlcyhCTkZMZXhlciwgcnVsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUVudHJpZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRW50cmllcyhlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9sZXhlci5kZWZhdWx0LmZyb21FbnRyaWVzKEJORkxleGVyLCBlbnRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBCTkZMZXhlcjtcbn0oX2xleGVyLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQk5GTGV4ZXI7XG5fZGVmaW5lUHJvcGVydHkoQk5GTGV4ZXIsIFwiZW50cmllc1wiLCBfZW50cmllcy5kZWZhdWx0KTtcbl9kZWZpbmVQcm9wZXJ0eShCTkZMZXhlciwgXCJFbmRPZkxpbmVUb2tlblwiLCBfZW5kT2ZMaW5lLmRlZmF1bHQpIC8vL1xuO1xuX2RlZmluZVByb3BlcnR5KEJORkxleGVyLCBcIldoaXRlc3BhY2VUb2tlblwiLCBfd2hpdGVzcGFjZS5kZWZhdWx0KTtcbl9kZWZpbmVQcm9wZXJ0eShCTkZMZXhlciwgXCJFbmRPZkxpbmVDb21tZW50VG9rZW5cIiwgbnVsbCk7XG5fZGVmaW5lUHJvcGVydHkoQk5GTGV4ZXIsIFwiUmVndWxhckV4cHJlc3Npb25Ub2tlblwiLCBfcmVndWxhckV4cHJlc3Npb24uZGVmYXVsdCk7XG5fZGVmaW5lUHJvcGVydHkoQk5GTGV4ZXIsIFwiU2luZ2xlTGluZUNvbW1lbnRUb2tlblwiLCBudWxsKTtcbl9kZWZpbmVQcm9wZXJ0eShCTkZMZXhlciwgXCJFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlblwiLCBudWxsKTtcbl9kZWZpbmVQcm9wZXJ0eShCTkZMZXhlciwgXCJTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuXCIsIG51bGwpO1xuX2RlZmluZVByb3BlcnR5KEJORkxleGVyLCBcIk1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuXCIsIG51bGwpO1xuX2RlZmluZVByb3BlcnR5KEJORkxleGVyLCBcIlNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlblwiLCBudWxsKTtcbl9kZWZpbmVQcm9wZXJ0eShCTkZMZXhlciwgXCJEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW5cIiwgX2RvdWJseVF1b3RlZC5kZWZhdWx0KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5aWJtWXZiR1Y0WlhJdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYSEpjYmx4eVhHNXBiWEJ2Y25RZ1pXNTBjbWxsY3lCbWNtOXRJRndpTGk5bGJuUnlhV1Z6WENJN1hISmNibWx0Y0c5eWRDQkRiMjF0YjI1TVpYaGxjaUJtY205dElGd2lMaTR2WTI5dGJXOXVMMnhsZUdWeVhDSTdYSEpjYm1sdGNHOXlkQ0JYYUdsMFpYTndZV05sVkc5clpXNGdabkp2YlNCY0lpNHVMM1J2YTJWdUwyNXZibE5wWjI1cFptbGpZVzUwTDNkb2FYUmxjM0JoWTJWY0lqdGNjbHh1YVcxd2IzSjBJRkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVWRzlyWlc0Z1puSnZiU0JjSWk0dUwzUnZhMlZ1TDNOcFoyNXBabWxqWVc1MEwzSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVhDSTdYSEpjYm1sdGNHOXlkQ0JGYm1SUFpreHBibVZPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWxibVJQWmt4cGJtVmNJanRjY2x4dWFXMXdiM0owSUVSdmRXSnNlVkYxYjNSbFpGTjBjbWx1WjB4cGRHVnlZV3hVYjJ0bGJpQm1jbTl0SUZ3aUxpNHZkRzlyWlc0dmMybG5ibWxtYVdOaGJuUXZjM1J5YVc1blRHbDBaWEpoYkM5a2IzVmliSGxSZFc5MFpXUmNJanRjY2x4dVhISmNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUVKT1JreGxlR1Z5SUdWNGRHVnVaSE1nUTI5dGJXOXVUR1Y0WlhJZ2UxeHlYRzRnSUhSdmEyVnVjMFp5YjIxQ1RrWW9ZbTVtS1NCN1hISmNiaUFnSUNCamIyNXpkQ0JqYjI1MFpXNTBJRDBnWW01bUxDQWdMeTh2WEhKY2JpQWdJQ0FnSUNBZ0lDQjBiMnRsYm5NZ1BTQnpkWEJsY2k1MGIydGxibWx6WlNoamIyNTBaVzUwS1R0Y2NseHVYSEpjYmlBZ0lDQnlaWFIxY200Z2RHOXJaVzV6TzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnYzNSaGRHbGpJR1Z1ZEhKcFpYTWdQU0JsYm5SeWFXVnpPMXh5WEc1Y2NseHVJQ0J6ZEdGMGFXTWdSVzVrVDJaTWFXNWxWRzlyWlc0Z1BTQkZibVJQWmt4cGJtVk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVPeUF2THk5Y2NseHVYSEpjYmlBZ2MzUmhkR2xqSUZkb2FYUmxjM0JoWTJWVWIydGxiaUE5SUZkb2FYUmxjM0JoWTJWVWIydGxianRjY2x4dVhISmNiaUFnYzNSaGRHbGpJRVZ1WkU5bVRHbHVaVU52YlcxbGJuUlViMnRsYmlBOUlHNTFiR3c3WEhKY2JseHlYRzRnSUhOMFlYUnBZeUJTWldkMWJHRnlSWGh3Y21WemMybHZibFJ2YTJWdUlEMGdVbVZuZFd4aGNrVjRjSEpsYzNOcGIyNVViMnRsYmp0Y2NseHVYSEpjYmlBZ2MzUmhkR2xqSUZOcGJtZHNaVXhwYm1WRGIyMXRaVzUwVkc5clpXNGdQU0J1ZFd4c08xeHlYRzVjY2x4dUlDQnpkR0YwYVdNZ1JXNWtUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0Z1BTQnVkV3hzTzF4eVhHNWNjbHh1SUNCemRHRjBhV01nVTNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlBOUlHNTFiR3c3WEhKY2JseHlYRzRnSUhOMFlYUnBZeUJOYVdSa2JHVlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlBOUlHNTFiR3c3WEhKY2JseHlYRzRnSUhOMFlYUnBZeUJUYVc1bmJIbFJkVzkwWldSVGRISnBibWRNYVhSbGNtRnNWRzlyWlc0Z1BTQnVkV3hzTzF4eVhHNWNjbHh1SUNCemRHRjBhV01nUkc5MVlteDVVWFZ2ZEdWa1UzUnlhVzVuVEdsMFpYSmhiRlJ2YTJWdUlEMGdSRzkxWW14NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1TzF4eVhHNWNjbHh1SUNCemRHRjBhV01nWm5KdmJVNXZkR2hwYm1jb0tTQjdJSEpsZEhWeWJpQkRiMjF0YjI1TVpYaGxjaTVtY205dFRtOTBhR2x1WnloQ1RrWk1aWGhsY2lrN0lIMWNjbHh1WEhKY2JpQWdjM1JoZEdsaklHWnliMjFTZFd4bGN5aHlkV3hsY3lrZ2V5QnlaWFIxY200Z1EyOXRiVzl1VEdWNFpYSXVabkp2YlZKMWJHVnpLRUpPUmt4bGVHVnlMQ0J5ZFd4bGN5azdJSDFjY2x4dVhISmNiaUFnYzNSaGRHbGpJR1p5YjIxRmJuUnlhV1Z6S0dWdWRISnBaWE1wSUhzZ2NtVjBkWEp1SUVOdmJXMXZia3hsZUdWeUxtWnliMjFGYm5SeWFXVnpLRUpPUmt4bGVHVnlMQ0JsYm5SeWFXVnpLVHNnZlZ4eVhHNTlYSEpjYmlKZExDSnVZVzFsY3lJNld5SkNUa1pNWlhobGNpSXNJblJ2YTJWdWMwWnliMjFDVGtZaUxDSmlibVlpTENKamIyNTBaVzUwSWl3aWRHOXJaVzV6SWl3aWRHOXJaVzVwYzJVaUxDSm1jbTl0VG05MGFHbHVaeUlzSWtOdmJXMXZia3hsZUdWeUlpd2labkp2YlZKMWJHVnpJaXdpY25Wc1pYTWlMQ0ptY205dFJXNTBjbWxsY3lJc0ltVnVkSEpwWlhNaUxDSkZibVJQWmt4cGJtVlViMnRsYmlJc0lrVnVaRTltVEdsdVpVNXZibE5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0pYYUdsMFpYTndZV05sVkc5clpXNGlMQ0pGYm1SUFpreHBibVZEYjIxdFpXNTBWRzlyWlc0aUxDSlNaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsUnZhMlZ1SWl3aVUybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaUlzSWtWdVpFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVUzUmhjblJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpSXNJazFwWkdSc1pVOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVUybHVaMng1VVhWdmRHVmtVM1J5YVc1blRHbDBaWEpoYkZSdmEyVnVJaXdpUkc5MVlteDVVWFZ2ZEdWa1UzUnlhVzVuVEdsMFpYSmhiRlJ2YTJWdUlsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJXOUNMRWxCUVVFc1VVRkJWeXhyUTBGQldDeFhRVUZYTEVWQlFVRTdRVUZEVUN4SlFVRkJMRTFCUVdsQ0xHdERRVUZxUWl4cFFrRkJhVUlzUlVGQlFUdEJRVU5pTEVsQlFVRXNWMEZCYjBNc2EwTkJRWEJETEc5RFFVRnZReXhGUVVGQk8wRkJRemRDTEVsQlFVRXNhMEpCUVhkRExHdERRVUY0UXl4M1EwRkJkME1zUlVGQlFUdEJRVU5zUXl4SlFVRkJMRlZCUVcxRExHdERRVUZ1UXl4dFEwRkJiVU1zUlVGQlFUdEJRVU5xUXl4SlFVRkJMR0ZCUVdsRUxHdERRVUZxUkN4cFJFRkJhVVFzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFWQTFSanR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFWTmxMRWxCUVVFc1FVRkJUVUVzVVVGQlVTeHBRa05VTTBJc1FVUlRZVHR2UTBGVVpqczdZVUZUY1VKQkxGRkJRVkU3ZFVOQlZEZENPenM3T3p0WlFWVkZReXhIUVVGaExFVkJRV0pCTEdWQlFXRTdXVVZXWml4UFJsVkZRU3hUUVVGQlFTeGhRVUZoTEVOQlFVTkRMRWRCUVVjc1JVRkJSVHRuUWtGRGFrSXNTVUZCVFVNc1QwRkJUeXhIUVVGSFJDeEhRVUZITEVWQlEySkZMRTFCUVUwc1IwRkJSeXh4UWtGSVJVb3NVVUZCVVN4aFFVZEtTeXhWUVVGUkxFVkJRV1FzU1VGQlN5eERRVUZCTEZsQlFWVkdMRTlCUVU4c1EwRkJReXhCUVVGRE8yZENRVVYyUXl4UFFVRlBReXhOUVVGTkxFTkJRVU03WVVGRFpqczdPenRaUVhkQ1RVVXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZka053UWl4UFJuVkRSU3hUUVVGUFFTeFhRVUZYTEVkQlFVYzdaMEpCUVVVc1QwRkJUME1zVFVGQlZ5eFRRVUZEUkN4WFFVRlhMRU5CUVVOT0xGRkJRVkVzUTBGQlF5eERRVUZETzJGQlFVVTdPenRaUVVVelJGRXNSMEZCVXl4RlFVRlVRU3hYUVVGVE8xbEZla05zUWl4UFJubERSU3hUUVVGUFFTeFRRVUZUTEVOQlFVTkRMRXRCUVVzc1JVRkJSVHRuUWtGQlJTeFBRVUZQUml4TlFVRlhMRk5CUVVORExGTkJRVk1zUTBGQlExSXNVVUZCVVN4RlFVRkZVeXhMUVVGTExFTkJRVU1zUTBGQlF6dGhRVUZGT3pzN1dVRkZia1ZETEVkQlFWY3NSVUZCV0VFc1lVRkJWenRaUlRORGNFSXNUMFl5UTBVc1UwRkJUMEVzVjBGQlZ5eERRVUZEUXl4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwb3NUVUZCVnl4VFFVRkRSeXhYUVVGWExFTkJRVU5XTEZGQlFWRXNSVUZCUlZjc1QwRkJUeXhEUVVGRExFTkJRVU03WVVGQlJUczdUVUV6UTNCR096dERRVFJEUXl4RFFXNURjVU5LTEUxQlFWY3NVMEZ0UTJoRU8ydENRVzVEYjBKUUxGRkJRVkVzUVVGVU4wSTdRVUZwUWtVc1owSkJVbTFDUVN4UlFVRlJMRVZCVVhCQ1Z5eFRRVUZQTEVWQlFVZEJMRkZCUVU4c1UwRkJReXhCUVdwQ00wSTdRVUZ0UWtVc1owSkJWbTFDV0N4UlFVRlJMRVZCVlhCQ1dTeG5Ra0ZCWXl4RlFVRkhReXhWUVVFMFFpeFRRVUZETEVOQlFVTXNSMEZCUnp0QlFXNUNNMFE3UVVGeFFrVXNaMEpCV20xQ1lpeFJRVUZSTEVWQldYQkNZeXhwUWtGQlpTeEZRVUZIUVN4WFFVRmxMRk5CUVVNc1FVRnlRak5ETzBGQmRVSkZMR2RDUVdSdFFtUXNVVUZCVVN4RlFXTndRbVVzZFVKQlFYRkNMRVZCUVVjc1NVRkJTU3hEUVVGRExFRkJka0owUXp0QlFYbENSU3huUWtGb1FtMUNaaXhSUVVGUkxFVkJaMEp3UW1kQ0xIZENRVUZ6UWl4RlFVRkhRU3hyUWtGQmMwSXNVMEZCUXl4QlFYcENla1E3UVVFeVFrVXNaMEpCYkVKdFFtaENMRkZCUVZFc1JVRnJRbkJDYVVJc2QwSkJRWE5DTEVWQlFVY3NTVUZCU1N4RFFVRkRMRUZCTTBKMlF6dEJRVFpDUlN4blFrRndRbTFDYWtJc1VVRkJVU3hGUVc5Q2NFSnJRaXcwUWtGQk1FSXNSVUZCUnl4SlFVRkpMRU5CUVVNc1FVRTNRak5ETzBGQkswSkZMR2RDUVhSQ2JVSnNRaXhSUVVGUkxFVkJjMEp3UW0xQ0xEaENRVUUwUWl4RlFVRkhMRWxCUVVrc1EwRkJReXhCUVM5Q04wTTdRVUZwUTBVc1owSkJlRUp0UW01Q0xGRkJRVkVzUlVGM1FuQkNiMElzSzBKQlFUWkNMRVZCUVVjc1NVRkJTU3hEUVVGRExFRkJha001UXp0QlFXMURSU3huUWtFeFFtMUNjRUlzVVVGQlVTeEZRVEJDY0VKeFFpeG5RMEZCT0VJc1JVRkJSeXhKUVVGSkxFTkJRVU1zUVVGdVF5OURPMEZCY1VORkxHZENRVFZDYlVKeVFpeFJRVUZSTEVWQk5FSndRbk5DTEdkRFFVRTRRaXhGUVVGSFFTeGhRVUU0UWl4VFFVRkRMRUZCY2tONlJTSjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwiZGlnaXRcIjogXCJeXFxcXGQrXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYnJhY2tldFwiOiBcIl4oPzpcXFxcKHxcXFxcKSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJvcGVyYXRvclwiOiBcIl4oPzpcXFxcK3xcXFxcLXxcXFxcKnxcXFxcLylcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9zdHJpbmdMaXRlcmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oU3RyaW5nTGl0ZXJhbFRva2VuKSB7XG4gICAgX2luaGVyaXRzKFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgU3RyaW5nTGl0ZXJhbFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbik7XG4gICAgZnVuY3Rpb24gU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0cmluZ0xpdGVyYWwuZGVmYXVsdC5tYXRjaChTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdHJpbmdMaXRlcmFsLmRlZmF1bHQuZnJvbUNvbnRlbnQoU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XG59KF9zdHJpbmdMaXRlcmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuO1xuX2RlZmluZVByb3BlcnR5KFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXicoPzpcXFxcW15cXHNdfFteJ1xcXFxcXHJcXG5dKSonLyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl6YVdkdWFXWnBZMkZ1ZEM5emRISnBibWRNYVhSbGNtRnNMM05wYm1kc2VWRjFiM1JsWkM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJRk4wY21sdVoweHBkR1Z5WVd4VWIydGxiaUJtY205dElGd2lMaTR2TGk0dmMybG5ibWxtYVdOaGJuUXZjM1J5YVc1blRHbDBaWEpoYkZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCVGFXNW5iSGxSZFc5MFpXUlRkSEpwYm1kTWFYUmxjbUZzVkc5clpXNGdaWGgwWlc1a2N5QlRkSEpwYm1kTWFYUmxjbUZzVkc5clpXNGdlMXh1SUNCamJHOXVaU2h6ZEdGeWRGQnZjMmwwYVc5dUxDQmxibVJRYjNOcGRHbHZiaWtnZXlCeVpYUjFjbTRnYzNWd1pYSXVZMnh2Ym1Vb1UybHVaMng1VVhWdmRHVmtVM1J5YVc1blRHbDBaWEpoYkZSdmEyVnVMQ0J6ZEdGeWRGQnZjMmwwYVc5dUxDQmxibVJRYjNOcGRHbHZiaWs3SUgxY2JseHVJQ0J6ZEdGMGFXTWdjbVZuZFd4aGNrVjRjSEpsYzNOcGIyNGdQU0F2WGljb1B6cGNYRnhjVzE1Y1hITmRmRnRlSjF4Y1hGeGNYSEpjWEc1ZEtTb25MenRjYmx4dUlDQnpkR0YwYVdNZ2JXRjBZMmdvWTI5dWRHVnVkQ2tnZXlCeVpYUjFjbTRnVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1TG0xaGRHTm9LRk5wYm1kc2VWRjFiM1JsWkZOMGNtbHVaMHhwZEdWeVlXeFViMnRsYml3Z1kyOXVkR1Z1ZENrN0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJVTnZiblJsYm5Rb1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1UzUnlhVzVuVEdsMFpYSmhiRlJ2YTJWdUxtWnliMjFEYjI1MFpXNTBLRk5wYm1kc2VWRjFiM1JsWkZOMGNtbHVaMHhwZEdWeVlXeFViMnRsYml3Z1kyOXVkR1Z1ZENrN0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SlRhVzVuYkhsUmRXOTBaV1JUZEhKcGJtZE1hWFJsY21Gc1ZHOXJaVzRpTENKamJHOXVaU0lzSW5OMFlYSjBVRzl6YVhScGIyNGlMQ0psYm1SUWIzTnBkR2x2YmlJc0ltMWhkR05vSWl3aVkyOXVkR1Z1ZENJc0lsTjBjbWx1WjB4cGRHVnlZV3hVYjJ0bGJpSXNJbVp5YjIxRGIyNTBaVzUwSWl3aWNtVm5kV3hoY2tWNGNISmxjM05wYjI0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRkswSXNTVUZCUVN4alFVRnBReXhyUTBGQmFrTXNhVU5CUVdsRExFVkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZHYUVVN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096czdPenM3VlVGQlFUczdkMEpCUVVFN096czdPenN3UWtGQlFUczdPenM3T3pzN096dFRRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3p0M1EwRkJRVHM3T3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZKWlN4SlFVRkJMRUZCUVUxQkxEaENRVUU0UWl4cFFrTkthRVFzUVVSSldUdHBSVUZLWmpzN1lVRkpjVUpCTERoQ1FVRTRRanMyUkVGS2JrUTdPenM3TzFsQlMwVkRMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSVXhRTEU5R1MwVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwTXNZVUZCWVN4RlFVRkZReXhYUVVGWExFVkJRVVU3WjBKQlFVVXNUMEZCVHl4eFFrRkVlRUpJTERoQ1FVRTRRaXhoUVVOQlF5eFBRVUZMTEVWQlFWZ3NTVUZCU3l4RFFVRkJMRmxCUVU5RUxEaENRVUU0UWl4RlFVRkZSU3hoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUlR0aFFVRkZPenM3TzFsQlNUbEhReXhIUVVGTExFVkJRVXhCTEU5QlFVczdXVVZVWkN4UFJsTkZMRk5CUVU5QkxFdEJRVXNzUTBGQlEwTXNUMEZCVHl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEdOQlFXdENMRk5CUVVOR0xFdEJRVXNzUTBGQlEwb3NPRUpCUVRoQ0xFVkJRVVZMTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUVVVN096dFpRVVUxUmtVc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRldIQkNMRTlHVjBVc1UwRkJUMEVzVjBGQlZ5eERRVUZEUml4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNZMEZCYTBJc1UwRkJRME1zVjBGQlZ5eERRVUZEVUN3NFFrRkJPRUlzUlVGQlJVc3NUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3VFVGWWFrZzdPME5CV1VNc1EwRlNNa1JETEdOQlFXdENMRk5CVVRkRk8ydENRVkp2UWs0c09FSkJRVGhDTEVGQlNtNUVPMEZCVDBVc1owSkJTRzFDUVN3NFFrRkJPRUlzUlVGSE1VTlJMRzFDUVVGcFFpd3JRa0ZCWjBNc1FVRlFNVVFpZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uU2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25TaWduaWZpY2FudFRva2VuKSB7XG4gICAgX2luaGVyaXRzKFNpbmdsZUxpbmVDb21tZW50VG9rZW4sIE5vblNpZ25pZmljYW50VG9rZW4pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2luZ2xlTGluZUNvbW1lbnRUb2tlbik7XG4gICAgZnVuY3Rpb24gU2luZ2xlTGluZUNvbW1lbnRUb2tlbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbmdsZUxpbmVDb21tZW50VG9rZW4pO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKENsYXNzLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihTaW5nbGVMaW5lQ29tbWVudFRva2VuLnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBDbGFzcywgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNJbkNvbW1lbnRQcmVzZXJ2aW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0Lm1hdGNoKENsYXNzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblNpZ25pZmljYW50LmRlZmF1bHQuZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFNpbmdsZUxpbmVDb21tZW50VG9rZW47XG59KF9ub25TaWduaWZpY2FudC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNpbmdsZUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5zaW5nbGVMaW5lQ29tbWVudFR5cGUpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkQzlqYjIxdFpXNTBMM05wYm1kc1pVeHBibVV1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJR1p5YjIwZ1hDSXVMaTh1TGk4dUxpOTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkRndpTzF4dVhHNXBiWEJ2Y25RZ2V5QnphVzVuYkdWTWFXNWxRMjl0YldWdWRGUjVjR1VnZlNCbWNtOXRJRndpTGk0dkxpNHZMaTR2ZEhsd1pYTmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdVMmx1WjJ4bFRHbHVaVU52YlcxbGJuUlViMnRsYmlCbGVIUmxibVJ6SUU1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0Z2UxeHVJQ0JqYkc5dVpTaERiR0Z6Y3l3Z2MzUmhjblJRYjNOcGRHbHZiaXdnWlc1a1VHOXphWFJwYjI0cElIc2djbVYwZFhKdUlITjFjR1Z5TG1Oc2IyNWxLRU5zWVhOekxDQnpkR0Z5ZEZCdmMybDBhVzl1TENCbGJtUlFiM05wZEdsdmJpazdJSDFjYmx4dUlDQnBjMGx1UTI5dGJXVnVkRkJ5WlhObGNuWnBibWNvS1NCN1hHNGdJQ0FnWTI5dWMzUWdhVzVEYjIxdFpXNTBVSEpsYzJWeWRtbHVaeUE5SUdaaGJITmxPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHbHVRMjl0YldWdWRGQnlaWE5sY25acGJtYzdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdkSGx3WlNBOUlITnBibWRzWlV4cGJtVkRiMjF0Wlc1MFZIbHdaVHRjYmx4dUlDQnpkR0YwYVdNZ2JXRjBZMmdvUTJ4aGMzTXNJR052Ym5SbGJuUXBJSHNnY21WMGRYSnVJRTV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzR1YldGMFkyZ29RMnhoYzNNc0lHTnZiblJsYm5RcE95QjlYRzVjYmlBZ2MzUmhkR2xqSUdaeWIyMURiMjUwWlc1MEtFTnNZWE56TENCamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUxtWnliMjFEYjI1MFpXNTBLRU5zWVhOekxDQmpiMjUwWlc1MEtUc2dmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJbE5wYm1kc1pVeHBibVZEYjIxdFpXNTBWRzlyWlc0aUxDSmpiRzl1WlNJc0lrTnNZWE56SWl3aWMzUmhjblJRYjNOcGRHbHZiaUlzSW1WdVpGQnZjMmwwYVc5dUlpd2lhWE5KYmtOdmJXMWxiblJRY21WelpYSjJhVzVuSWl3aWFXNURiMjF0Wlc1MFVISmxjMlZ5ZG1sdVp5SXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRDSXNJazV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKbWNtOXRRMjl1ZEdWdWRDSXNJblI1Y0dVaUxDSnphVzVuYkdWTWFXNWxRMjl0YldWdWRGUjVjR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGWjBNc1NVRkJRU3hsUVVFclFpeHJRMEZCTDBJc0swSkJRU3RDTEVWQlFVRTdRVUZGZWtJc1NVRkJRU3hOUVVGblFpeFhRVUZvUWl4blFrRkJaMElzUTBGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVcDBSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVMWxMRWxCUVVFc1FVRkJUVUVzYzBKQlFYTkNMR2xDUTA1NFF5eEJSRTFaT3pCRVFVNW1PenRoUVUxeFFrRXNjMEpCUVhOQ08zRkVRVTR6UXpzN096czdXVUZQUlVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlVGQXNUMFpQUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4TFFVRkxMRVZCUVVWRExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMmRDUVVGRkxFOUJRVThzY1VKQlJDOUNTaXh6UWtGQmMwSXNZVUZEWlVNc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQUXl4TFFVRkxMRVZCUVVWRExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMkZCUVVVN096dFpRVVZ1UjBNc1IwRkJjVUlzUlVGQmNrSkJMSFZDUVVGeFFqdFpSVlIyUWl4UFJsTkZRU3hUUVVGQlFTeHhRa0ZCY1VJc1IwRkJSenRuUWtGRGRFSXNTVUZCVFVNc2JVSkJRVzFDTEVkQlFVY3NTMEZCU3l4QlFVRkRPMmRDUVVWc1F5eFBRVUZQUVN4dFFrRkJiVUlzUTBGQlF6dGhRVU0xUWpzN096dFpRVWxOUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWcVFtUXNUMFpwUWtVc1UwRkJUMEVzUzBGQlN5eERRVUZEVEN4TFFVRkxMRVZCUVVWTkxFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhsUVVGdFFpeFRRVUZEUml4TFFVRkxMRU5CUVVOTUxFdEJRVXNzUlVGQlJVMHNUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3TzFsQlJUTkZSU3hIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZ1UW5CQ0xFOUdiVUpGTEZOQlFVOUJMRmRCUVZjc1EwRkJRMUlzUzBGQlN5eEZRVUZGVFN4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNaVUZCYlVJc1UwRkJRME1zVjBGQlZ5eERRVUZEVWl4TFFVRkxMRVZCUVVWTkxFOUJRVThzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCYmtKb1J6czdRMEZ2UWtNc1EwRmtiVVJETEdWQlFXMUNMRk5CWTNSRk8ydENRV1J2UWxRc2MwSkJRWE5DTEVGQlRqTkRPMEZCWlVVc1owSkJWRzFDUVN4elFrRkJjMElzUlVGVGJFTlhMRTFCUVVrc1JVRkJSME1zVFVGQmNVSXNkVUpCUVVNc1FVRm1kRU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfc2luZ2xlTGluZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZVwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oU2luZ2xlTGluZUNvbW1lbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIFNpbmdsZUxpbmVDb21tZW50VG9rZW4pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuKTtcbiAgICBmdW5jdGlvbiBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4pO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2goY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2luZ2xlTGluZS5kZWZhdWx0Lm1hdGNoKFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NpbmdsZUxpbmUuZGVmYXVsdC5mcm9tQ29udGVudChQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbjtcbn0oX3NpbmdsZUxpbmUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eI1teXFxyXFxuXSovKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwzTnBibWRzWlV4cGJtVXZjSGwwYUc5dVUzUjViR1V1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQlRhVzVuYkdWTWFXNWxRMjl0YldWdWRGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk4dUxpOHVMaTh1TGk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwzTnBibWRzWlV4cGJtVmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdVSGwwYUc5dVUzUjViR1ZUYVc1bmJHVk1hVzVsUTI5dGJXVnVkRlJ2YTJWdUlHVjRkR1Z1WkhNZ1UybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaUI3WEc0Z0lHTnNiMjVsS0hOMFlYSjBVRzl6YVhScGIyNHNJR1Z1WkZCdmMybDBhVzl1S1NCN0lISmxkSFZ5YmlCemRYQmxjaTVqYkc5dVpTaFFlWFJvYjI1VGRIbHNaVk5wYm1kc1pVeHBibVZEYjIxdFpXNTBWRzlyWlc0c0lITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtUc2dmVnh1WEc0Z0lITjBZWFJwWXlCeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlBOUlDOWVJMXRlWEZ4eVhGeHVYU292TzF4dVhHNGdJSE4wWVhScFl5QnRZWFJqYUNoamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCVGFXNW5iR1ZNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVMbTFoZEdOb0tGQjVkR2h2YmxOMGVXeGxVMmx1WjJ4bFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z1kyOXVkR1Z1ZENrN0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJVTnZiblJsYm5Rb1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1UybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaTVtY205dFEyOXVkR1Z1ZENoUWVYUm9iMjVUZEhsc1pWTnBibWRzWlV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRzSUdOdmJuUmxiblFwT3lCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVVIbDBhRzl1VTNSNWJHVlRhVzVuYkdWTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVkyeHZibVVpTENKemRHRnlkRkJ2YzJsMGFXOXVJaXdpWlc1a1VHOXphWFJwYjI0aUxDSnRZWFJqYUNJc0ltTnZiblJsYm5RaUxDSlRhVzVuYkdWTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVpuSnZiVU52Ym5SbGJuUWlMQ0p5WldkMWJHRnlSWGh3Y21WemMybHZiaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVZ0UXl4SlFVRkJMRmRCUVhGRUxHdERRVUZ5UkN4eFJFRkJjVVFzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVWjRSanR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVbGxMRWxCUVVFc1FVRkJUVUVzYVVOQlFXbERMR2xDUTBwdVJDeEJSRWxaTzNkRlFVcG1PenRoUVVseFFrRXNhVU5CUVdsRE8yZEZRVXAwUkRzN096czdXVUZMUlVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlRGQXNUMFpMUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4aFFVRmhMRVZCUVVWRExGZEJRVmNzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBMSEZDUVVSNFFrZ3NhVU5CUVdsRExHRkJRMGhETEU5QlFVc3NSVUZCV0N4SlFVRkxMRU5CUVVFc1dVRkJUMFFzYVVOQlFXbERMRVZCUVVWRkxHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMkZCUVVVN096czdXVUZKYWtoRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJWUmtMRTlHVTBVc1UwRkJUMEVzUzBGQlN5eERRVUZEUXl4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNWMEZCYzBJc1UwRkJRMFlzUzBGQlN5eERRVUZEU2l4cFEwRkJhVU1zUlVGQlJVc3NUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3TzFsQlJXNUhSU3hIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZZY0VJc1QwWlhSU3hUUVVGUFFTeFhRVUZYTEVOQlFVTkdMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQUXl4WFFVRnpRaXhUUVVGRFF5eFhRVUZYTEVOQlFVTlFMR2xEUVVGcFF5eEZRVUZGU3l4UFFVRlBMRU5CUVVNc1EwRkJRenRoUVVGRk96dE5RVmg0U0RzN1EwRlpReXhEUVZJNFJFTXNWMEZCYzBJc1UwRlJjRVk3YTBKQlVtOUNUaXhwUTBGQmFVTXNRVUZLZEVRN1FVRlBSU3huUWtGSWJVSkJMR2xEUVVGcFF5eEZRVWMzUTFFc2JVSkJRV2xDTEdWQlFXZENMRUZCVURGREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblNpZ25pZmljYW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIikpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKXtcbiAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblNpZ25pZmljYW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4sIE5vblNpZ25pZmljYW50VG9rZW4pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4pO1xuICAgIGZ1bmN0aW9uIEVuZE9mTGluZUNvbW1lbnROb25TaWduaWZpY2FudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4sIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzSFRNTFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzSFRNTCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IHRoaXMuaW5uZXJIVE1MOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzSW5Db21tZW50UHJlc2VydmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblNpZ25pZmljYW50LmRlZmF1bHQubWF0Y2goRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0LmZyb21Db250ZW50KEVuZE9mTGluZUNvbW1lbnROb25TaWduaWZpY2FudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbjtcbn0oX25vblNpZ25pZmljYW50LmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4sIFwidHlwZVwiLCBfdHlwZXMuZW5kT2ZMaW5lQ29tbWVudFR5cGUpO1xuX2RlZmluZVByb3BlcnR5KEVuZE9mTGluZUNvbW1lbnROb25TaWduaWZpY2FudFRva2VuLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eKD86XFxyXFxufFxccnxcXG4pLyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwyVnVaRTltVEdsdVpTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUU1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0Z1puSnZiU0JjSWk0dUx5NHVMeTR1TDNSdmEyVnVMMjV2YmxOcFoyNXBabWxqWVc1MFhDSTdYRzVjYm1sdGNHOXlkQ0I3SUdWdVpFOW1UR2x1WlVOdmJXMWxiblJVZVhCbElIMGdabkp2YlNCY0lpNHVMeTR1THk0dUwzUjVjR1Z6WENJN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUVWdVpFOW1UR2x1WlVOdmJXMWxiblJPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUdWNGRHVnVaSE1nVG05dVUybG5ibWxtYVdOaGJuUlViMnRsYmlCN1hHNGdJR05zYjI1bEtITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtTQjdJSEpsZEhWeWJpQnpkWEJsY2k1amJHOXVaU2hGYm1SUFpreHBibVZEYjIxdFpXNTBUbTl1VTJsbmJtbG1hV05oYm5SVWIydGxiaXdnYzNSaGNuUlFiM05wZEdsdmJpd2daVzVrVUc5emFYUnBiMjRwT3lCOVhHNWNiaUFnWVhOSVZFMU1LQ2tnZTF4dUlDQWdJR052Ym5OMElHaDBiV3dnUFNCMGFHbHpMbWx1Ym1WeVNGUk5URHNnSUM4dkwxeHVYRzRnSUNBZ2NtVjBkWEp1SUdoMGJXdzdYRzRnSUgxY2JseHVJQ0JwYzBsdVEyOXRiV1Z1ZEZCeVpYTmxjblpwYm1jb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYVc1RGIyMXRaVzUwVUhKbGMyVnlkbWx1WnlBOUlIUnlkV1U3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdhVzVEYjIxdFpXNTBVSEpsYzJWeWRtbHVaenRjYmlBZ2ZWeHVYRzRnSUhOMFlYUnBZeUIwZVhCbElEMGdaVzVrVDJaTWFXNWxRMjl0YldWdWRGUjVjR1U3WEc1Y2JpQWdjM1JoZEdsaklISmxaM1ZzWVhKRmVIQnlaWE56YVc5dUlEMGdMMTRvUHpwY1hISmNYRzU4WEZ4eWZGeGNiaWt2TzF4dVhHNGdJSE4wWVhScFl5QnRZWFJqYUNoamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUxtMWhkR05vS0VWdVpFOW1UR2x1WlVOdmJXMWxiblJPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1TENCamIyNTBaVzUwS1RzZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFEyOXVkR1Z1ZENoamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUxtWnliMjFEYjI1MFpXNTBLRVZ1WkU5bVRHbHVaVU52YlcxbGJuUk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVMQ0JqYjI1MFpXNTBLVHNnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWtWdVpFOW1UR2x1WlVOdmJXMWxiblJPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aVkyeHZibVVpTENKemRHRnlkRkJ2YzJsMGFXOXVJaXdpWlc1a1VHOXphWFJwYjI0aUxDSmhjMGhVVFV3aUxDSm9kRzFzSWl3aWFXNXVaWEpJVkUxTUlpd2lhWE5KYmtOdmJXMWxiblJRY21WelpYSjJhVzVuSWl3aWFXNURiMjF0Wlc1MFVISmxjMlZ5ZG1sdVp5SXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRDSXNJazV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKbWNtOXRRMjl1ZEdWdWRDSXNJblI1Y0dVaUxDSmxibVJQWmt4cGJtVkRiMjF0Wlc1MFZIbHdaU0lzSW5KbFozVnNZWEpGZUhCeVpYTnphVzl1SWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUldkRExFbEJRVUVzWlVGQkswSXNhME5CUVM5Q0xDdENRVUVyUWl4RlFVRkJPMEZCUlRGQ0xFbEJRVUVzVFVGQlowSXNWMEZCYUVJc1owSkJRV2RDTEVOQlFVRTdPenM3T3pzN096czdPenM3T3pzNFJFRktja1E3YzBOQlFVRTdOa1JCUVVFN2FVVkJRVUU3T3pzN2QwVkJRVUU3WjBWQlFVRTdPenM3T3pzN096czdWVUZCUVRzN2QwSkJRVUU3T3pzN096c3dRa0ZCUVRzN096czdPenM3T3p0VFFVRkJPenM3T3pzN08wdEJRVUU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPenQzUTBGQlFUczdPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRk5aU3hKUVVGQkxFRkJRVTFCTEcxRFFVRnRReXhwUWtOT2NrUXNRVVJOV1R0MVJVRk9aanM3WVVGTmNVSkJMRzFEUVVGdFF6dHJSVUZPZUVRN096czdPMWxCVDBWRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJWQlFMRTlHVDBWQkxGTkJRVUZCTEV0QlFVc3NRMEZCUTBNc1lVRkJZU3hGUVVGRlF5eFhRVUZYTEVWQlFVVTdaMEpCUVVVc1QwRkJUeXh4UWtGRWVFSklMRzFEUVVGdFF5eGhRVU5NUXl4UFFVRkxMRVZCUVZnc1NVRkJTeXhEUVVGQkxGbEJRVTlFTEcxRFFVRnRReXhGUVVGRlJTeGhRVUZoTEVWQlFVVkRMRmRCUVZjc1JVRkJSVHRoUVVGRk96czdXVUZGTVVoRExFZEJRVTBzUlVGQlRrRXNVVUZCVFR0WlJWUlNMRTlHVTBWQkxGTkJRVUZCTEUxQlFVMHNSMEZCUnp0blFrRkRVQ3hKUVVGTlF5eEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhUUVVGVExFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVnFReXhQUVVGUFJDeEpRVUZKTEVOQlFVTTdZVUZEWWpzN08xbEJSVVJGTEVkQlFYRkNMRVZCUVhKQ1FTeDFRa0ZCY1VJN1dVVm1ka0lzVDBabFJVRXNVMEZCUVVFc2NVSkJRWEZDTEVkQlFVYzdaMEpCUTNSQ0xFbEJRVTFETEcxQ1FVRnRRaXhIUVVGSExFbEJRVWtzUVVGQlF6dG5Ra0ZGYWtNc1QwRkJUMEVzYlVKQlFXMUNMRU5CUVVNN1lVRkROVUk3T3pzN1dVRk5UVU1zUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxGZWtKa0xFOUdlVUpGTEZOQlFVOUJMRXRCUVVzc1EwRkJRME1zVDBGQlR5eEZRVUZGTzJkQ1FVRkZMRTlCUVU5RExHVkJRVzFDTEZOQlFVTkdMRXRCUVVzc1EwRkJRMVFzYlVOQlFXMURMRVZCUVVWVkxFOUJRVThzUTBGQlF5eERRVUZETzJGQlFVVTdPenRaUVVWc1IwVXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZNMEp3UWl4UFJqSkNSU3hUUVVGUFFTeFhRVUZYTEVOQlFVTkdMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQUXl4bFFVRnRRaXhUUVVGRFF5eFhRVUZYTEVOQlFVTmFMRzFEUVVGdFF5eEZRVUZGVlN4UFFVRlBMRU5CUVVNc1EwRkJRenRoUVVGRk96dE5RVE5DZGtnN08wTkJORUpETEVOQmRFSm5SVU1zWlVGQmJVSXNVMEZ6UW01R08ydENRWFJDYjBKWUxHMURRVUZ0UXl4QlFVNTRSRHRCUVhGQ1JTeG5Ra0ZtYlVKQkxHMURRVUZ0UXl4RlFXVXZRMkVzVFVGQlNTeEZRVUZIUXl4TlFVRnZRaXh6UWtGQlF5eEJRWEpDY2tNN1FVRjFRa1VzWjBKQmFrSnRRbVFzYlVOQlFXMURMRVZCYVVJdlEyVXNiVUpCUVdsQ0xHOUNRVUZ4UWl4QlFYWkNMME1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uU2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uU2lnbmlmaWNhbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgTm9uU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgZnVuY3Rpb24gRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKENsYXNzLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzSW5Db21tZW50UHJlc2VydmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5Db21tZW50UHJlc2VydmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChDbGFzcywgY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uU2lnbmlmaWNhbnQuZGVmYXVsdC5tYXRjaChDbGFzcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0LmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjtcbn0oX25vblNpZ25pZmljYW50LmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIFwidHlwZVwiLCBfdHlwZXMuZW5kT2ZNdWx0aUxpbmVDb21tZW50VHlwZSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMeTR1TDNOeVl5OTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkQzlqYjIxdFpXNTBMMjExYkhScFRHbHVaUzlsYm1SUFppNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUU1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0Z1puSnZiU0JjSWk0dUx5NHVMeTR1THk0dUwzUnZhMlZ1TDI1dmJsTnBaMjVwWm1sallXNTBYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lHVnVaRTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlI1Y0dVZ2ZTQm1jbTl0SUZ3aUxpNHZMaTR2TGk0dkxpNHZkSGx3WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1JXNWtUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0Z1pYaDBaVzVrY3lCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUlIdGNiaUFnWTJ4dmJtVW9RMnhoYzNNc0lITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtTQjdJSEpsZEhWeWJpQnpkWEJsY2k1amJHOXVaU2hEYkdGemN5d2djM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBPeUI5WEc1Y2JpQWdhWE5KYmtOdmJXMWxiblJRY21WelpYSjJhVzVuS0NrZ2UxeHVJQ0FnSUdOdmJuTjBJR2x1UTI5dGJXVnVkRkJ5WlhObGNuWnBibWNnUFNCbVlXeHpaVHRjYmx4dUlDQWdJSEpsZEhWeWJpQnBia052YlcxbGJuUlFjbVZ6WlhKMmFXNW5PMXh1SUNCOVhHNWNiaUFnYzNSaGRHbGpJSFI1Y0dVZ1BTQmxibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVZVhCbE8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaERiR0Z6Y3l3Z1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1RtOXVVMmxuYm1sbWFXTmhiblJVYjJ0bGJpNXRZWFJqYUNoRGJHRnpjeXdnWTI5dWRHVnVkQ2s3SUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlVOdmJuUmxiblFvUTJ4aGMzTXNJR052Ym5SbGJuUXBJSHNnY21WMGRYSnVJRTV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzR1Wm5KdmJVTnZiblJsYm5Rb1EyeGhjM01zSUdOdmJuUmxiblFwT3lCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVJXNWtUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0aUxDSmpiRzl1WlNJc0lrTnNZWE56SWl3aWMzUmhjblJRYjNOcGRHbHZiaUlzSW1WdVpGQnZjMmwwYVc5dUlpd2lhWE5KYmtOdmJXMWxiblJRY21WelpYSjJhVzVuSWl3aWFXNURiMjF0Wlc1MFVISmxjMlZ5ZG1sdVp5SXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRDSXNJazV2YmxOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKbWNtOXRRMjl1ZEdWdWRDSXNJblI1Y0dVaUxDSmxibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVZVhCbElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJXZERMRWxCUVVFc1pVRkJhME1zYTBOQlFXeERMR3REUVVGclF5eEZRVUZCTzBGQlJYaENMRWxCUVVFc1RVRkJiVUlzVjBGQmJrSXNiVUpCUVcxQ0xFTkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZLTjBRN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096czdPenM3VlVGQlFUczdkMEpCUVVFN096czdPenN3UWtGQlFUczdPenM3T3pzN096dFRRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3p0M1EwRkJRVHM3T3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZOWlN4SlFVRkJMRUZCUVUxQkxEQkNRVUV3UWl4cFFrTk9OVU1zUVVSTldUczRSRUZPWmpzN1lVRk5jVUpCTERCQ1FVRXdRanQ1UkVGT0wwTTdPenM3TzFsQlQwVkRMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSVkJRTEU5R1QwVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwTXNTMEZCU3l4RlFVRkZReXhoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUlR0blFrRkJSU3hQUVVGUExIRkNRVVF2UWtvc01FSkJRVEJDTEdGQlExZERMRTlCUVVzc1JVRkJXQ3hKUVVGTExFTkJRVUVzV1VGQlQwTXNTMEZCU3l4RlFVRkZReXhoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUlR0aFFVRkZPenM3V1VGRmJrZERMRWRCUVhGQ0xFVkJRWEpDUVN4MVFrRkJjVUk3V1VWVWRrSXNUMFpUUlVFc1UwRkJRVUVzY1VKQlFYRkNMRWRCUVVjN1owSkJRM1JDTEVsQlFVMURMRzFDUVVGdFFpeEhRVUZITEV0QlFVc3NRVUZCUXp0blFrRkZiRU1zVDBGQlQwRXNiVUpCUVcxQ0xFTkJRVU03WVVGRE5VSTdPenM3V1VGSlRVTXNSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZha0prTEU5R2FVSkZMRk5CUVU5QkxFdEJRVXNzUTBGQlEwd3NTMEZCU3l4RlFVRkZUU3hQUVVGUExFVkJRVVU3WjBKQlFVVXNUMEZCVDBNc1pVRkJiVUlzVTBGQlEwWXNTMEZCU3l4RFFVRkRUQ3hMUVVGTExFVkJRVVZOTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUVVVN096dFpRVVV6UlVVc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRmJrSndRaXhQUm0xQ1JTeFRRVUZQUVN4WFFVRlhMRU5CUVVOU0xFdEJRVXNzUlVGQlJVMHNUMEZCVHl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEdWQlFXMUNMRk5CUVVORExGZEJRVmNzUTBGQlExSXNTMEZCU3l4RlFVRkZUU3hQUVVGUExFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFXNUNhRWM3TzBOQmIwSkRMRU5CWkhWRVF5eGxRVUZ0UWl4VFFXTXhSVHRyUWtGa2IwSlVMREJDUVVFd1FpeEJRVTR2UXp0QlFXVkZMR2RDUVZSdFFrRXNNRUpCUVRCQ0xFVkJVM1JEVnl4TlFVRkpMRVZCUVVkRExFMUJRWGxDTERKQ1FVRkRMRUZCWmpGREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2VuZE9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2ZcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICBmdW5jdGlvbiBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbmRPZi5kZWZhdWx0Lm1hdGNoKFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbmRPZi5kZWZhdWx0LmZyb21Db250ZW50KFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG59KF9lbmRPZi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXiMjIy8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwyMTFiSFJwVEdsdVpTOWxibVJQWmk5d2VYUm9iMjVUZEhsc1pTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUVWdVpFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk4dUxpOHVMaTh1TGk4dUxpOTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkQzlqYjIxdFpXNTBMMjExYkhScFRHbHVaUzlsYm1SUFpsd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlFlWFJvYjI1VGRIbHNaVVZ1WkU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVJR1Y0ZEdWdVpITWdSVzVrVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGdlMXh1SUNCamJHOXVaU2h6ZEdGeWRGQnZjMmwwYVc5dUxDQmxibVJRYjNOcGRHbHZiaWtnZXlCeVpYUjFjbTRnYzNWd1pYSXVZMnh2Ym1Vb1VIbDBhRzl1VTNSNWJHVkZibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpd2djM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBPeUI5WEc1Y2JpQWdjM1JoZEdsaklISmxaM1ZzWVhKRmVIQnlaWE56YVc5dUlEMGdMMTRqSXlNdk8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQkZibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpNXRZWFJqYUNoUWVYUm9iMjVUZEhsc1pVVnVaRTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlJ2YTJWdUxDQmpiMjUwWlc1MEtUc2dmVnh1WEc0Z0lITjBZWFJwWXlCbWNtOXRRMjl1ZEdWdWRDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQkZibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpNW1jbTl0UTI5dWRHVnVkQ2hRZVhSb2IyNVRkSGxzWlVWdVpFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1TENCamIyNTBaVzUwS1RzZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklsQjVkR2h2YmxOMGVXeGxSVzVrVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGlMQ0pqYkc5dVpTSXNJbk4wWVhKMFVHOXphWFJwYjI0aUxDSmxibVJRYjNOcGRHbHZiaUlzSW0xaGRHTm9JaXdpWTI5dWRHVnVkQ0lzSWtWdVpFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVpuSnZiVU52Ym5SbGJuUWlMQ0p5WldkMWJHRnlSWGh3Y21WemMybHZiaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVYxUXl4SlFVRkJMRTFCUVRaRUxHdERRVUUzUkN3MlJFRkJOa1FzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVWndSenR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVbGxMRWxCUVVFc1FVRkJUVUVzY1VOQlFYRkRMR2xDUTBwMlJDeEJSRWxaTzJkR1FVcG1PenRoUVVseFFrRXNjVU5CUVhGRE8yOUZRVW94UkRzN096czdXVUZMUlVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlRGQXNUMFpMUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4aFFVRmhMRVZCUVVWRExGZEJRVmNzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBMSEZDUVVSNFFrZ3NjVU5CUVhGRExHRkJRMUJETEU5QlFVc3NSVUZCV0N4SlFVRkxMRU5CUVVFc1dVRkJUMFFzY1VOQlFYRkRMRVZCUVVWRkxHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMkZCUVVVN096czdXVUZKY2toRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJWUmtMRTlHVTBVc1UwRkJUMEVzUzBGQlN5eERRVUZEUXl4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNUVUZCTUVJc1UwRkJRMFlzUzBGQlN5eERRVUZEU2l4eFEwRkJjVU1zUlVGQlJVc3NUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3TzFsQlJUTkhSU3hIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZZY0VJc1QwWlhSU3hUUVVGUFFTeFhRVUZYTEVOQlFVTkdMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQUXl4TlFVRXdRaXhUUVVGRFF5eFhRVUZYTEVOQlFVTlFMSEZEUVVGeFF5eEZRVUZGU3l4UFFVRlBMRU5CUVVNc1EwRkJRenRoUVVGRk96dE5RVmhvU1RzN1EwRlpReXhEUVZKclJVTXNUVUZCTUVJc1UwRlJOVVk3YTBKQlVtOUNUaXh4UTBGQmNVTXNRVUZLTVVRN1FVRlBSU3huUWtGSWJVSkJMSEZEUVVGeFF5eEZRVWRxUkZFc2JVSkJRV2xDTEZOQlFWVXNRVUZRY0VNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblNpZ25pZmljYW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIikpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi90eXBlc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKXtcbiAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uU2lnbmlmaWNhbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBOb25TaWduaWZpY2FudFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pO1xuICAgIGZ1bmN0aW9uIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShDbGFzcywgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzSW5Db21tZW50UHJlc2VydmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0Lm1hdGNoKENsYXNzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblNpZ25pZmljYW50LmRlZmF1bHQuZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG59KF9ub25TaWduaWZpY2FudC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5zdGFydE9mTXVsdGlMaW5lQ29tbWVudFR5cGUpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXViMjVUYVdkdWFXWnBZMkZ1ZEM5amIyMXRaVzUwTDIxMWJIUnBUR2x1WlM5emRHRnlkRTltTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdUbTl1VTJsbmJtbG1hV05oYm5SVWIydGxiaUJtY205dElGd2lMaTR2TGk0dkxpNHZMaTR2ZEc5clpXNHZibTl1VTJsbmJtbG1hV05oYm5SY0lqdGNibHh1YVcxd2IzSjBJSHNnYzNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlVlWEJsSUgwZ1puSnZiU0JjSWk0dUx5NHVMeTR1THk0dUwzUjVjR1Z6WENJN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUZOMFlYSjBUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0Z1pYaDBaVzVrY3lCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUlIdGNiaUFnWTJ4dmJtVW9RMnhoYzNNc0lITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtTQjdJSEpsZEhWeWJpQnpkWEJsY2k1amJHOXVaU2hEYkdGemN5d2djM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBPeUI5WEc1Y2JpQWdhWE5KYmtOdmJXMWxiblJRY21WelpYSjJhVzVuS0NrZ2UxeHVJQ0FnSUdOdmJuTjBJR2x1UTI5dGJXVnVkRkJ5WlhObGNuWnBibWNnUFNCMGNuVmxPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHbHVRMjl0YldWdWRGQnlaWE5sY25acGJtYzdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdkSGx3WlNBOUlITjBZWEowVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkhsd1pUdGNibHh1SUNCemRHRjBhV01nYldGMFkyZ29RMnhoYzNNc0lHTnZiblJsYm5RcElIc2djbVYwZFhKdUlFNXZibE5wWjI1cFptbGpZVzUwVkc5clpXNHViV0YwWTJnb1EyeGhjM01zSUdOdmJuUmxiblFwT3lCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxRGIyNTBaVzUwS0VOc1lYTnpMQ0JqYjI1MFpXNTBLU0I3SUhKbGRIVnliaUJPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1TG1aeWIyMURiMjUwWlc1MEtFTnNZWE56TENCamIyNTBaVzUwS1RzZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklsTjBZWEowVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGlMQ0pqYkc5dVpTSXNJa05zWVhOeklpd2ljM1JoY25SUWIzTnBkR2x2YmlJc0ltVnVaRkJ2YzJsMGFXOXVJaXdpYVhOSmJrTnZiVzFsYm5SUWNtVnpaWEoyYVc1bklpd2lhVzVEYjIxdFpXNTBVSEpsYzJWeWRtbHVaeUlzSW0xaGRHTm9JaXdpWTI5dWRHVnVkQ0lzSWs1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0aUxDSm1jbTl0UTI5dWRHVnVkQ0lzSW5SNWNHVWlMQ0p6ZEdGeWRFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUjVjR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGWjBNc1NVRkJRU3hsUVVGclF5eHJRMEZCYkVNc2EwTkJRV3RETEVWQlFVRTdRVUZGZEVJc1NVRkJRU3hOUVVGdFFpeFhRVUZ1UWl4dFFrRkJiVUlzUTBGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVb3ZSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVMWxMRWxCUVVFc1FVRkJUVUVzTkVKQlFUUkNMR2xDUTA0NVF5eEJSRTFaTzJkRlFVNW1PenRoUVUxeFFrRXNORUpCUVRSQ096SkVRVTVxUkRzN096czdXVUZQUlVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlVGQXNUMFpQUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4TFFVRkxMRVZCUVVWRExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMmRDUVVGRkxFOUJRVThzY1VKQlJDOUNTaXcwUWtGQk5FSXNZVUZEVTBNc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQUXl4TFFVRkxMRVZCUVVWRExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMkZCUVVVN096dFpRVVZ1UjBNc1IwRkJjVUlzUlVGQmNrSkJMSFZDUVVGeFFqdFpSVlIyUWl4UFJsTkZRU3hUUVVGQlFTeHhRa0ZCY1VJc1IwRkJSenRuUWtGRGRFSXNTVUZCVFVNc2JVSkJRVzFDTEVkQlFVY3NTVUZCU1N4QlFVRkRPMmRDUVVWcVF5eFBRVUZQUVN4dFFrRkJiVUlzUTBGQlF6dGhRVU0xUWpzN096dFpRVWxOUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWcVFtUXNUMFpwUWtVc1UwRkJUMEVzUzBGQlN5eERRVUZEVEN4TFFVRkxMRVZCUVVWTkxFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhsUVVGdFFpeFRRVUZEUml4TFFVRkxMRU5CUVVOTUxFdEJRVXNzUlVGQlJVMHNUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3TzFsQlJUTkZSU3hIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZ1UW5CQ0xFOUdiVUpGTEZOQlFVOUJMRmRCUVZjc1EwRkJRMUlzUzBGQlN5eEZRVUZGVFN4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNaVUZCYlVJc1UwRkJRME1zVjBGQlZ5eERRVUZEVWl4TFFVRkxMRVZCUVVWTkxFOUJRVThzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCYmtKb1J6czdRMEZ2UWtNc1EwRmtlVVJETEdWQlFXMUNMRk5CWXpWRk8ydENRV1J2UWxRc05FSkJRVFJDTEVGQlRtcEVPMEZCWlVVc1owSkJWRzFDUVN3MFFrRkJORUlzUlVGVGVFTlhMRTFCUVVrc1JVRkJSME1zVFVGQk1rSXNOa0pCUVVNc1FVRm1OVU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfc3RhcnRPZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2ZcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgZnVuY3Rpb24gUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXJ0T2YuZGVmYXVsdC5tYXRjaChQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdGFydE9mLmRlZmF1bHQuZnJvbUNvbnRlbnQoUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG59KF9zdGFydE9mLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuO1xuX2RlZmluZVByb3BlcnR5KFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXiMjIy8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwyMTFiSFJwVEdsdVpTOXpkR0Z5ZEU5bUwzQjVkR2h2YmxOMGVXeGxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1UzUmhjblJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpQm1jbTl0SUZ3aUxpNHZMaTR2TGk0dkxpNHZMaTR2ZEc5clpXNHZibTl1VTJsbmJtbG1hV05oYm5RdlkyOXRiV1Z1ZEM5dGRXeDBhVXhwYm1VdmMzUmhjblJQWmx3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCUWVYUm9iMjVUZEhsc1pWTjBZWEowVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGdaWGgwWlc1a2N5QlRkR0Z5ZEU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVJSHRjYmlBZ1kyeHZibVVvYzNSaGNuUlFiM05wZEdsdmJpd2daVzVrVUc5emFYUnBiMjRwSUhzZ2NtVjBkWEp1SUhOMWNHVnlMbU5zYjI1bEtGQjVkR2h2YmxOMGVXeGxVM1JoY25SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaXdnYzNSaGNuUlFiM05wZEdsdmJpd2daVzVrVUc5emFYUnBiMjRwT3lCOVhHNWNiaUFnYzNSaGRHbGpJSEpsWjNWc1lYSkZlSEJ5WlhOemFXOXVJRDBnTDE0akl5TXZPMXh1WEc0Z0lITjBZWFJwWXlCdFlYUmphQ2hqYjI1MFpXNTBLU0I3SUhKbGRIVnliaUJUZEdGeWRFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1TG0xaGRHTm9LRkI1ZEdodmJsTjBlV3hsVTNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z1kyOXVkR1Z1ZENrN0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJVTnZiblJsYm5Rb1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1UzUmhjblJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpNW1jbTl0UTI5dWRHVnVkQ2hRZVhSb2IyNVRkSGxzWlZOMFlYSjBUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0c0lHTnZiblJsYm5RcE95QjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lVSGwwYUc5dVUzUjViR1ZUZEdGeWRFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVkyeHZibVVpTENKemRHRnlkRkJ2YzJsMGFXOXVJaXdpWlc1a1VHOXphWFJwYjI0aUxDSnRZWFJqYUNJc0ltTnZiblJsYm5RaUxDSlRkR0Z5ZEU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVJaXdpWm5KdmJVTnZiblJsYm5RaUxDSnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVjVReXhKUVVGQkxGRkJRU3RFTEd0RFFVRXZSQ3dyUkVGQkswUXNSVUZCUVRzN096czdPenM3T3pzN096czdPemhFUVVaNFJ6dHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPenM3T3p0VlFVRkJPenQzUWtGQlFUczdPenM3T3pCQ1FVRkJPenM3T3pzN096czdPMU5CUVVFN096czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN08zZERRVUZCT3pzN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVVsbExFbEJRVUVzUVVGQlRVRXNkVU5CUVhWRExHbENRMHA2UkN4QlJFbFpPMjlHUVVwbU96dGhRVWx4UWtFc2RVTkJRWFZETzNORlFVbzFSRHM3T3pzN1dVRkxSVU1zUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxGVEZBc1QwWkxSVUVzVTBGQlFVRXNTMEZCU3l4RFFVRkRReXhoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUlR0blFrRkJSU3hQUVVGUExIRkNRVVI0UWtnc2RVTkJRWFZETEdGQlExUkRMRTlCUVVzc1JVRkJXQ3hKUVVGTExFTkJRVUVzV1VGQlQwUXNkVU5CUVhWRExFVkJRVVZGTEdGQlFXRXNSVUZCUlVNc1YwRkJWeXhGUVVGRk8yRkJRVVU3T3pzN1dVRkpka2hETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlZSa0xFOUdVMFVzVTBGQlQwRXNTMEZCU3l4RFFVRkRReXhQUVVGUExFVkJRVVU3WjBKQlFVVXNUMEZCVDBNc1VVRkJORUlzVTBGQlEwWXNTMEZCU3l4RFFVRkRTaXgxUTBGQmRVTXNSVUZCUlVzc1QwRkJUeXhEUVVGRExFTkJRVU03WVVGQlJUczdPMWxCUlM5SFJTeEhRVUZYTEVWQlFWaEJMR0ZCUVZjN1dVVlljRUlzVDBaWFJTeFRRVUZQUVN4WFFVRlhMRU5CUVVOR0xFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhSUVVFMFFpeFRRVUZEUXl4WFFVRlhMRU5CUVVOUUxIVkRRVUYxUXl4RlFVRkZTeXhQUVVGUExFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFWaHdTVHM3UTBGWlF5eERRVkp2UlVNc1VVRkJORUlzVTBGUmFFYzdhMEpCVW05Q1RpeDFRMEZCZFVNc1FVRktOVVE3UVVGUFJTeG5Ra0ZJYlVKQkxIVkRRVUYxUXl4RlFVZHVSRkVzYlVKQlFXbENMRk5CUVZVc1FVRlFjRU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uU2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uU2lnbmlmaWNhbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgTm9uU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgZnVuY3Rpb24gTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKENsYXNzLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ2xhc3MsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzSW5Db21tZW50UHJlc2VydmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKENsYXNzLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25TaWduaWZpY2FudC5kZWZhdWx0Lm1hdGNoKENsYXNzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblNpZ25pZmljYW50LmRlZmF1bHQuZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuO1xufShfbm9uU2lnbmlmaWNhbnQuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjtcbl9kZWZpbmVQcm9wZXJ0eShNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5taWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwyMTFiSFJwVEdsdVpTOXRhV1JrYkdWUFppNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUU1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0Z1puSnZiU0JjSWk0dUx5NHVMeTR1THk0dUwzUnZhMlZ1TDI1dmJsTnBaMjVwWm1sallXNTBYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lHMXBaR1JzWlU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSNWNHVWdmU0JtY205dElGd2lMaTR2TGk0dkxpNHZMaTR2ZEhsd1pYTmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdUV2xrWkd4bFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRnWlhoMFpXNWtjeUJPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUh0Y2JpQWdZMnh2Ym1Vb1EyeGhjM01zSUhOMFlYSjBVRzl6YVhScGIyNHNJR1Z1WkZCdmMybDBhVzl1S1NCN0lISmxkSFZ5YmlCemRYQmxjaTVqYkc5dVpTaERiR0Z6Y3l3Z2MzUmhjblJRYjNOcGRHbHZiaXdnWlc1a1VHOXphWFJwYjI0cE95QjlYRzVjYmlBZ2FYTkpia052YlcxbGJuUlFjbVZ6WlhKMmFXNW5LQ2tnZTF4dUlDQWdJR052Ym5OMElHbHVRMjl0YldWdWRGQnlaWE5sY25acGJtY2dQU0IwY25WbE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUdsdVEyOXRiV1Z1ZEZCeVpYTmxjblpwYm1jN1hHNGdJSDFjYmx4dUlDQnpkR0YwYVdNZ2RIbHdaU0E5SUcxcFpHUnNaVTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlI1Y0dVN1hHNWNiaUFnYzNSaGRHbGpJRzFoZEdOb0tFTnNZWE56TENCamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUxtMWhkR05vS0VOc1lYTnpMQ0JqYjI1MFpXNTBLVHNnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0UTI5dWRHVnVkQ2hEYkdGemN5d2dZMjl1ZEdWdWRDa2dleUJ5WlhSMWNtNGdUbTl1VTJsbmJtbG1hV05oYm5SVWIydGxiaTVtY205dFEyOXVkR1Z1ZENoRGJHRnpjeXdnWTI5dWRHVnVkQ2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKTmFXUmtiR1ZQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpSXNJbU5zYjI1bElpd2lRMnhoYzNNaUxDSnpkR0Z5ZEZCdmMybDBhVzl1SWl3aVpXNWtVRzl6YVhScGIyNGlMQ0pwYzBsdVEyOXRiV1Z1ZEZCeVpYTmxjblpwYm1jaUxDSnBia052YlcxbGJuUlFjbVZ6WlhKMmFXNW5JaXdpYldGMFkyZ2lMQ0pqYjI1MFpXNTBJaXdpVG05dVUybG5ibWxtYVdOaGJuUlViMnRsYmlJc0ltWnliMjFEYjI1MFpXNTBJaXdpZEhsd1pTSXNJbTFwWkdSc1pVOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUjVjR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGWjBNc1NVRkJRU3hsUVVGclF5eHJRMEZCYkVNc2EwTkJRV3RETEVWQlFVRTdRVUZGY2tJc1NVRkJRU3hOUVVGdFFpeFhRVUZ1UWl4dFFrRkJiVUlzUTBGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVcG9SVHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVMWxMRWxCUVVFc1FVRkJUVUVzTmtKQlFUWkNMR2xDUTA0dlF5eEJSRTFaTzJsRlFVNW1PenRoUVUxeFFrRXNOa0pCUVRaQ096UkVRVTVzUkRzN096czdXVUZQUlVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlVGQXNUMFpQUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4TFFVRkxMRVZCUVVWRExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMmRDUVVGRkxFOUJRVThzY1VKQlJDOUNTaXcyUWtGQk5rSXNZVUZEVVVNc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQUXl4TFFVRkxMRVZCUVVWRExHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMkZCUVVVN096dFpRVVZ1UjBNc1IwRkJjVUlzUlVGQmNrSkJMSFZDUVVGeFFqdFpSVlIyUWl4UFJsTkZRU3hUUVVGQlFTeHhRa0ZCY1VJc1IwRkJSenRuUWtGRGRFSXNTVUZCVFVNc2JVSkJRVzFDTEVkQlFVY3NTVUZCU1N4QlFVRkRPMmRDUVVWcVF5eFBRVUZQUVN4dFFrRkJiVUlzUTBGQlF6dGhRVU0xUWpzN096dFpRVWxOUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWcVFtUXNUMFpwUWtVc1UwRkJUMEVzUzBGQlN5eERRVUZEVEN4TFFVRkxMRVZCUVVWTkxFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhsUVVGdFFpeFRRVUZEUml4TFFVRkxMRU5CUVVOTUxFdEJRVXNzUlVGQlJVMHNUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3TzFsQlJUTkZSU3hIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZ1UW5CQ0xFOUdiVUpGTEZOQlFVOUJMRmRCUVZjc1EwRkJRMUlzUzBGQlN5eEZRVUZGVFN4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNaVUZCYlVJc1UwRkJRME1zVjBGQlZ5eERRVUZEVWl4TFFVRkxMRVZCUVVWTkxFOUJRVThzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCYmtKb1J6czdRMEZ2UWtNc1EwRmtNRVJETEdWQlFXMUNMRk5CWXpkRk8ydENRV1J2UWxRc05rSkJRVFpDTEVGQlRteEVPMEZCWlVVc1owSkJWRzFDUVN3MlFrRkJOa0lzUlVGVGVrTlhMRTFCUVVrc1JVRkJSME1zVFVGQk5FSXNPRUpCUVVNc1FVRm1OME1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbWlkZGxlT2YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZlwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFB5dGhvblN0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuKSB7XG4gICAgX2luaGVyaXRzKFB5dGhvblN0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFB5dGhvblN0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pO1xuICAgIGZ1bmN0aW9uIFB5dGhvblN0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21pZGRsZU9mLmRlZmF1bHQubWF0Y2goUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21pZGRsZU9mLmRlZmF1bHQuZnJvbUNvbnRlbnQoUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjtcbn0oX21pZGRsZU9mLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjtcbl9kZWZpbmVQcm9wZXJ0eShQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eKD86W15cXHJcXG5dKz8oPz0jIyMpfFteXFxyXFxuXSspLyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXViMjVUYVdkdWFXWnBZMkZ1ZEM5amIyMXRaVzUwTDIxMWJIUnBUR2x1WlM5dGFXUmtiR1ZQWmk5d2VYUm9iMjVUZEhsc1pTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUUxcFpHUnNaVTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlJ2YTJWdUlHWnliMjBnWENJdUxpOHVMaTh1TGk4dUxpOHVMaTkwYjJ0bGJpOXViMjVUYVdkdWFXWnBZMkZ1ZEM5amIyMXRaVzUwTDIxMWJIUnBUR2x1WlM5dGFXUmtiR1ZQWmx3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCUWVYUm9iMjVUZEhsc1pVMXBaR1JzWlU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVJR1Y0ZEdWdVpITWdUV2xrWkd4bFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRnZTF4dUlDQmpiRzl1WlNoemRHRnlkRkJ2YzJsMGFXOXVMQ0JsYm1SUWIzTnBkR2x2YmlrZ2V5QnlaWFIxY200Z2MzVndaWEl1WTJ4dmJtVW9VSGwwYUc5dVUzUjViR1ZOYVdSa2JHVlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z2MzUmhjblJRYjNOcGRHbHZiaXdnWlc1a1VHOXphWFJwYjI0cE95QjlYRzVjYmlBZ2MzUmhkR2xqSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1SUQwZ0wxNG9QenBiWGx4Y2NseGNibDByUHlnL1BTTWpJeWw4VzE1Y1hISmNYRzVkS3lrdk8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQk5hV1JrYkdWUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaTV0WVhSamFDaFFlWFJvYjI1VGRIbHNaVTFwWkdSc1pVOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1TENCamIyNTBaVzUwS1RzZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFEyOXVkR1Z1ZENoamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCTmFXUmtiR1ZQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpNW1jbTl0UTI5dWRHVnVkQ2hRZVhSb2IyNVRkSGxzWlUxcFpHUnNaVTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlJ2YTJWdUxDQmpiMjUwWlc1MEtUc2dmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJbEI1ZEdodmJsTjBlV3hsVFdsa1pHeGxUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0aUxDSmpiRzl1WlNJc0luTjBZWEowVUc5emFYUnBiMjRpTENKbGJtUlFiM05wZEdsdmJpSXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRDSXNJazFwWkdSc1pVOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVpuSnZiVU52Ym5SbGJuUWlMQ0p5WldkMWJHRnlSWGh3Y21WemMybHZiaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVV3UXl4SlFVRkJMRk5CUVdkRkxHdERRVUZvUlN4blJVRkJaMFVzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVWXhSenR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVbGxMRWxCUVVFc1FVRkJUVUVzZDBOQlFYZERMR2xDUTBveFJDeEJSRWxaTzNOR1FVcG1PenRoUVVseFFrRXNkME5CUVhkRE8zVkZRVW8zUkRzN096czdXVUZMUlVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlRGQXNUMFpMUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4aFFVRmhMRVZCUVVWRExGZEJRVmNzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBMSEZDUVVSNFFrZ3NkME5CUVhkRExHRkJRMVpETEU5QlFVc3NSVUZCV0N4SlFVRkxMRU5CUVVFc1dVRkJUMFFzZDBOQlFYZERMRVZCUVVWRkxHRkJRV0VzUlVGQlJVTXNWMEZCVnl4RlFVRkZPMkZCUVVVN096czdXVUZKZUVoRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJWUmtMRTlHVTBVc1UwRkJUMEVzUzBGQlN5eERRVUZEUXl4UFFVRlBMRVZCUVVVN1owSkJRVVVzVDBGQlQwTXNVMEZCTmtJc1UwRkJRMFlzUzBGQlN5eERRVUZEU2l4M1EwRkJkME1zUlVGQlJVc3NUMEZCVHl4RFFVRkRMRU5CUVVNN1lVRkJSVHM3TzFsQlJXcElSU3hIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZZY0VJc1QwWlhSU3hUUVVGUFFTeFhRVUZYTEVOQlFVTkdMRTlCUVU4c1JVRkJSVHRuUWtGQlJTeFBRVUZQUXl4VFFVRTJRaXhUUVVGRFF5eFhRVUZYTEVOQlFVTlFMSGREUVVGM1F5eEZRVUZGU3l4UFFVRlBMRU5CUVVNc1EwRkJRenRoUVVGRk96dE5RVmgwU1RzN1EwRlpReXhEUVZKeFJVTXNVMEZCTmtJc1UwRlJiRWM3YTBKQlVtOUNUaXgzUTBGQmQwTXNRVUZLTjBRN1FVRlBSU3huUWtGSWJVSkJMSGREUVVGM1F5eEZRVWR3UkZFc2JVSkJRV2xDTEcxRFFVRnZReXhCUVZBNVJDSjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2VudHJpZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2VudHJpZXNcIikpO1xudmFyIF9sZXhlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2NvbW1vbi9sZXhlclwiKSk7XG52YXIgX3doaXRlc3BhY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCIpKTtcbnZhciBfcmVndWxhckV4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiKSk7XG52YXIgX2VuZE9mTGluZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2VuZE9mTGluZVwiKSk7XG52YXIgX3NpbmdseVF1b3RlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvc2luZ2x5UXVvdGVkXCIpKTtcbnZhciBfZG91Ymx5UXVvdGVkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdG9rZW4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbC9kb3VibHlRdW90ZWRcIikpO1xudmFyIF9weXRob25TdHlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZS9weXRob25TdHlsZVwiKSk7XG52YXIgX2VuZE9mTGluZTEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L2VuZE9mTGluZVwiKSk7XG52YXIgX3B5dGhvblN0eWxlMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlXCIpKTtcbnZhciBfcHl0aG9uU3R5bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9weXRob25TdHlsZVwiKSk7XG52YXIgX3B5dGhvblN0eWxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL3B5dGhvblN0eWxlXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgQmFzaWNMZXhlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29tbW9uTGV4ZXIpIHtcbiAgICBfaW5oZXJpdHMoQmFzaWNMZXhlciwgQ29tbW9uTGV4ZXIpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQmFzaWNMZXhlcik7XG4gICAgZnVuY3Rpb24gQmFzaWNMZXhlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2ljTGV4ZXIpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhCYXNpY0xleGVyLCBudWxsLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tTm90aGluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Ob3RoaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbGV4ZXIuZGVmYXVsdC5mcm9tTm90aGluZyhCYXNpY0xleGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlcyhydWxlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbGV4ZXIuZGVmYXVsdC5mcm9tUnVsZXMoQmFzaWNMZXhlciwgcnVsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUVudHJpZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRW50cmllcyhlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9sZXhlci5kZWZhdWx0LmZyb21FbnRyaWVzKEJhc2ljTGV4ZXIsIGVudHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEJhc2ljTGV4ZXI7XG59KF9sZXhlci5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljTGV4ZXI7XG5fZGVmaW5lUHJvcGVydHkoQmFzaWNMZXhlciwgXCJlbnRyaWVzXCIsIF9lbnRyaWVzLmRlZmF1bHQpO1xuX2RlZmluZVByb3BlcnR5KEJhc2ljTGV4ZXIsIFwiRW5kT2ZMaW5lVG9rZW5cIiwgX2VuZE9mTGluZS5kZWZhdWx0KSAvLy9cbjtcbl9kZWZpbmVQcm9wZXJ0eShCYXNpY0xleGVyLCBcIldoaXRlc3BhY2VUb2tlblwiLCBfd2hpdGVzcGFjZS5kZWZhdWx0KTtcbl9kZWZpbmVQcm9wZXJ0eShCYXNpY0xleGVyLCBcIkVuZE9mTGluZUNvbW1lbnRUb2tlblwiLCBfZW5kT2ZMaW5lMS5kZWZhdWx0KSAvLy9cbjtcbl9kZWZpbmVQcm9wZXJ0eShCYXNpY0xleGVyLCBcIlJlZ3VsYXJFeHByZXNzaW9uVG9rZW5cIiwgX3JlZ3VsYXJFeHByZXNzaW9uLmRlZmF1bHQpO1xuX2RlZmluZVByb3BlcnR5KEJhc2ljTGV4ZXIsIFwiU2luZ2xlTGluZUNvbW1lbnRUb2tlblwiLCBfcHl0aG9uU3R5bGUuZGVmYXVsdCkgLy8vXG47XG5fZGVmaW5lUHJvcGVydHkoQmFzaWNMZXhlciwgXCJFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlblwiLCBfcHl0aG9uU3R5bGUxLmRlZmF1bHQpIC8vL1xuO1xuX2RlZmluZVByb3BlcnR5KEJhc2ljTGV4ZXIsIFwiU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlblwiLCBfcHl0aG9uU3R5bGUyLmRlZmF1bHQpIC8vL1xuO1xuX2RlZmluZVByb3BlcnR5KEJhc2ljTGV4ZXIsIFwiTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW5cIiwgX3B5dGhvblN0eWxlMy5kZWZhdWx0KSAvLy9cbjtcbl9kZWZpbmVQcm9wZXJ0eShCYXNpY0xleGVyLCBcIlNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlblwiLCBfc2luZ2x5UXVvdGVkLmRlZmF1bHQpO1xuX2RlZmluZVByb3BlcnR5KEJhc2ljTGV4ZXIsIFwiRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuXCIsIF9kb3VibHlRdW90ZWQuZGVmYXVsdCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWlZWE5wWXk5c1pYaGxjaTVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2NseHVYSEpjYm1sdGNHOXlkQ0JsYm5SeWFXVnpJR1p5YjIwZ1hDSXVMMlZ1ZEhKcFpYTmNJanRjY2x4dWFXMXdiM0owSUVOdmJXMXZia3hsZUdWeUlHWnliMjBnWENJdUxpOWpiMjF0YjI0dmJHVjRaWEpjSWp0Y2NseHVhVzF3YjNKMElGZG9hWFJsYzNCaFkyVlViMnRsYmlCbWNtOXRJRndpTGk0dmRHOXJaVzR2Ym05dVUybG5ibWxtYVdOaGJuUXZkMmhwZEdWemNHRmpaVndpTzF4eVhHNXBiWEJ2Y25RZ1VtVm5kV3hoY2tWNGNISmxjM05wYjI1VWIydGxiaUJtY205dElGd2lMaTR2ZEc5clpXNHZjMmxuYm1sbWFXTmhiblF2Y21WbmRXeGhja1Y0Y0hKbGMzTnBiMjVjSWp0Y2NseHVhVzF3YjNKMElFVnVaRTltVEdsdVpVNXZibE5wWjI1cFptbGpZVzUwVkc5clpXNGdabkp2YlNCY0lpNHVMM1J2YTJWdUwyNXZibE5wWjI1cFptbGpZVzUwTDJWdVpFOW1UR2x1WlZ3aU8xeHlYRzVwYlhCdmNuUWdVMmx1WjJ4NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk5MGIydGxiaTl6YVdkdWFXWnBZMkZ1ZEM5emRISnBibWRNYVhSbGNtRnNMM05wYm1kc2VWRjFiM1JsWkZ3aU8xeHlYRzVwYlhCdmNuUWdSRzkxWW14NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1SUdaeWIyMGdYQ0l1TGk5MGIydGxiaTl6YVdkdWFXWnBZMkZ1ZEM5emRISnBibWRNYVhSbGNtRnNMMlJ2ZFdKc2VWRjFiM1JsWkZ3aU8xeHlYRzVwYlhCdmNuUWdVSGwwYUc5dVUzUjViR1ZUYVc1bmJHVk1hVzVsUTI5dGJXVnVkRlJ2YTJWdUlHWnliMjBnWENJdUxpOTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkQzlqYjIxdFpXNTBMM05wYm1kc1pVeHBibVV2Y0hsMGFHOXVVM1I1YkdWY0lqdGNjbHh1YVcxd2IzSjBJRVZ1WkU5bVRHbHVaVU52YlcxbGJuUk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJR1p5YjIwZ1hDSXVMaTkwYjJ0bGJpOXViMjVUYVdkdWFXWnBZMkZ1ZEM5amIyMXRaVzUwTDJWdVpFOW1UR2x1WlZ3aU8xeHlYRzVwYlhCdmNuUWdVSGwwYUc5dVUzUjViR1ZGYm1SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaUJtY205dElGd2lMaTR2ZEc5clpXNHZibTl1VTJsbmJtbG1hV05oYm5RdlkyOXRiV1Z1ZEM5dGRXeDBhVXhwYm1VdlpXNWtUMll2Y0hsMGFHOXVVM1I1YkdWY0lqdGNjbHh1YVcxd2IzSjBJRkI1ZEdodmJsTjBlV3hsVTNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlCbWNtOXRJRndpTGk0dmRHOXJaVzR2Ym05dVUybG5ibWxtYVdOaGJuUXZZMjl0YldWdWRDOXRkV3gwYVV4cGJtVXZjM1JoY25SUFppOXdlWFJvYjI1VGRIbHNaVndpTzF4eVhHNXBiWEJ2Y25RZ1VIbDBhRzl1VTNSNWJHVk5hV1JrYkdWUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaUJtY205dElGd2lMaTR2ZEc5clpXNHZibTl1VTJsbmJtbG1hV05oYm5RdlkyOXRiV1Z1ZEM5dGRXeDBhVXhwYm1VdmJXbGtaR3hsVDJZdmNIbDBhRzl1VTNSNWJHVmNJanRjY2x4dVhISmNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUVKaGMybGpUR1Y0WlhJZ1pYaDBaVzVrY3lCRGIyMXRiMjVNWlhobGNpQjdYSEpjYmlBZ2MzUmhkR2xqSUdWdWRISnBaWE1nUFNCbGJuUnlhV1Z6TzF4eVhHNWNjbHh1SUNCemRHRjBhV01nUlc1a1QyWk1hVzVsVkc5clpXNGdQU0JGYm1SUFpreHBibVZPYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1T3lBdkx5OWNjbHh1WEhKY2JpQWdjM1JoZEdsaklGZG9hWFJsYzNCaFkyVlViMnRsYmlBOUlGZG9hWFJsYzNCaFkyVlViMnRsYmp0Y2NseHVYSEpjYmlBZ2MzUmhkR2xqSUVWdVpFOW1UR2x1WlVOdmJXMWxiblJVYjJ0bGJpQTlJRVZ1WkU5bVRHbHVaVU52YlcxbGJuUk9iMjVUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVPeUF2THk5Y2NseHVYSEpjYmlBZ2MzUmhkR2xqSUZKbFozVnNZWEpGZUhCeVpYTnphVzl1Vkc5clpXNGdQU0JTWldkMWJHRnlSWGh3Y21WemMybHZibFJ2YTJWdU8xeHlYRzVjY2x4dUlDQnpkR0YwYVdNZ1UybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaUE5SUZCNWRHaHZibE4wZVd4bFUybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxianNnTHk4dlhISmNibHh5WEc0Z0lITjBZWFJwWXlCRmJtUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlBOUlGQjVkR2h2YmxOMGVXeGxSVzVrVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNDdJQzh2TDF4eVhHNWNjbHh1SUNCemRHRjBhV01nVTNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlBOUlGQjVkR2h2YmxOMGVXeGxVM1JoY25SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxianNnTHk4dlhISmNibHh5WEc0Z0lITjBZWFJwWXlCTmFXUmtiR1ZQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpQTlJRkI1ZEdodmJsTjBlV3hsVFdsa1pHeGxUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0N0lDOHZMMXh5WEc1Y2NseHVJQ0J6ZEdGMGFXTWdVMmx1WjJ4NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1SUQwZ1UybHVaMng1VVhWdmRHVmtVM1J5YVc1blRHbDBaWEpoYkZSdmEyVnVPMXh5WEc1Y2NseHVJQ0J6ZEdGMGFXTWdSRzkxWW14NVVYVnZkR1ZrVTNSeWFXNW5UR2wwWlhKaGJGUnZhMlZ1SUQwZ1JHOTFZbXg1VVhWdmRHVmtVM1J5YVc1blRHbDBaWEpoYkZSdmEyVnVPMXh5WEc1Y2NseHVJQ0J6ZEdGMGFXTWdabkp2YlU1dmRHaHBibWNvS1NCN0lISmxkSFZ5YmlCRGIyMXRiMjVNWlhobGNpNW1jbTl0VG05MGFHbHVaeWhDWVhOcFkweGxlR1Z5S1RzZ2ZWeHlYRzVjY2x4dUlDQnpkR0YwYVdNZ1puSnZiVkoxYkdWektISjFiR1Z6S1NCN0lISmxkSFZ5YmlCRGIyMXRiMjVNWlhobGNpNW1jbTl0VW5Wc1pYTW9RbUZ6YVdOTVpYaGxjaXdnY25Wc1pYTXBPeUI5WEhKY2JseHlYRzRnSUhOMFlYUnBZeUJtY205dFJXNTBjbWxsY3lobGJuUnlhV1Z6S1NCN0lISmxkSFZ5YmlCRGIyMXRiMjVNWlhobGNpNW1jbTl0Ulc1MGNtbGxjeWhDWVhOcFkweGxlR1Z5TENCbGJuUnlhV1Z6S1RzZ2ZWeHlYRzU5WEhKY2JpSmRMQ0p1WVcxbGN5STZXeUpDWVhOcFkweGxlR1Z5SWl3aVpuSnZiVTV2ZEdocGJtY2lMQ0pEYjIxdGIyNU1aWGhsY2lJc0ltWnliMjFTZFd4bGN5SXNJbkoxYkdWeklpd2labkp2YlVWdWRISnBaWE1pTENKbGJuUnlhV1Z6SWl3aVJXNWtUMlpNYVc1bFZHOXJaVzRpTENKRmJtUlBaa3hwYm1WT2IyNVRhV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2lWMmhwZEdWemNHRmpaVlJ2YTJWdUlpd2lSVzVrVDJaTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVJXNWtUMlpNYVc1bFEyOXRiV1Z1ZEU1dmJsTnBaMjVwWm1sallXNTBWRzlyWlc0aUxDSlNaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsUnZhMlZ1SWl3aVUybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaUlzSWxCNWRHaHZibE4wZVd4bFUybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaUlzSWtWdVpFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVVIbDBhRzl1VTNSNWJHVkZibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpSXNJbE4wWVhKMFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRpTENKUWVYUm9iMjVUZEhsc1pWTjBZWEowVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGlMQ0pOYVdSa2JHVlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlJc0lsQjVkR2h2YmxOMGVXeGxUV2xrWkd4bFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRpTENKVGFXNW5iSGxSZFc5MFpXUlRkSEpwYm1kTWFYUmxjbUZzVkc5clpXNGlMQ0pFYjNWaWJIbFJkVzkwWldSVGRISnBibWRNYVhSbGNtRnNWRzlyWlc0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRmIwSXNTVUZCUVN4UlFVRlhMR3REUVVGWUxGZEJRVmNzUlVGQlFUdEJRVU5RTEVsQlFVRXNUVUZCYVVJc2EwTkJRV3BDTEdsQ1FVRnBRaXhGUVVGQk8wRkJRMklzU1VGQlFTeFhRVUZ2UXl4clEwRkJjRU1zYjBOQlFXOURMRVZCUVVFN1FVRkROMElzU1VGQlFTeHJRa0ZCZDBNc2EwTkJRWGhETEhkRFFVRjNReXhGUVVGQk8wRkJRMnhETEVsQlFVRXNWVUZCYlVNc2EwTkJRVzVETEcxRFFVRnRReXhGUVVGQk8wRkJRMnBETEVsQlFVRXNZVUZCYVVRc2EwTkJRV3BFTEdsRVFVRnBSQ3hGUVVGQk8wRkJRMnBFTEVsQlFVRXNZVUZCYVVRc2EwTkJRV3BFTEdsRVFVRnBSQ3hGUVVGQk8wRkJRemxETEVsQlFVRXNXVUZCZDBRc2EwTkJRWGhFTEhkRVFVRjNSQ3hGUVVGQk8wRkJRM1JFTEVsQlFVRXNWMEZCTWtNc2EwTkJRVE5ETERKRFFVRXlReXhGUVVGQk8wRkJRM3BETEVsQlFVRXNZVUZCTmtRc2EwTkJRVGRFTERaRVFVRTJSQ3hGUVVGQk8wRkJRek5FTEVsQlFVRXNZVUZCSzBRc2EwTkJRUzlFTEN0RVFVRXJSQ3hGUVVGQk8wRkJRemxFTEVsQlFVRXNZVUZCWjBVc2EwTkJRV2hGTEdkRlFVRm5SU3hGUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlluSklPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3T3pzN08xVkJRVUU3TzNkQ1FVRkJPenM3T3pzN08wdEJRVUU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGbFpTeEpRVUZCTEVGQlFVMUJMRlZCUVZVc2FVSkRaamRDTEVGRVpXRTdjME5CWm1ZN08yRkJaWEZDUVN4VlFVRlZPM2xEUVdZdlFqczdPenM3V1VGelExTkRMRWRCUVZjc1JVRkJXRUVzWVVGQlZ6dFpSWFJEY0VJc1QwWnpRMFVzVTBGQlQwRXNWMEZCVnl4SFFVRkhPMmRDUVVGRkxFOUJRVTlETEUxQlFWY3NVMEZCUTBRc1YwRkJWeXhEUVVGRFJDeFZRVUZWTEVOQlFVTXNRMEZCUXp0aFFVRkZPenM3V1VGRk4wUkhMRWRCUVZNc1JVRkJWRUVzVjBGQlV6dFpSWGhEYkVJc1QwWjNRMFVzVTBGQlQwRXNVMEZCVXl4RFFVRkRReXhMUVVGTExFVkJRVVU3WjBKQlFVVXNUMEZCVDBZc1RVRkJWeXhUUVVGRFF5eFRRVUZUTEVOQlFVTklMRlZCUVZVc1JVRkJSVWtzUzBGQlN5eERRVUZETEVOQlFVTTdZVUZCUlRzN08xbEJSWEpGUXl4SFFVRlhMRVZCUVZoQkxHRkJRVmM3V1VVeFEzQkNMRTlHTUVORkxGTkJRVTlCTEZkQlFWY3NRMEZCUTBNc1QwRkJUeXhGUVVGRk8yZENRVUZGTEU5QlFVOUtMRTFCUVZjc1UwRkJRMGNzVjBGQlZ5eERRVUZEVEN4VlFVRlZMRVZCUVVWTkxFOUJRVThzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCTVVOMFJqczdRMEV5UTBNc1EwRTFRblZEU2l4TlFVRlhMRk5CTkVKc1JEdHJRa0UxUW05Q1JpeFZRVUZWTEVGQlppOUNPMEZCWjBKRkxHZENRVVJ0UWtFc1ZVRkJWU3hGUVVOMFFrMHNVMEZCVHl4RlFVRkhRU3hSUVVGUExGTkJRVU1zUVVGb1FqTkNPMEZCYTBKRkxHZENRVWh0UWs0c1ZVRkJWU3hGUVVkMFFrOHNaMEpCUVdNc1JVRkJSME1zVlVGQk5FSXNVMEZCUXl4RFFVRkRMRWRCUVVjN1FVRnNRak5FTzBGQmIwSkZMR2RDUVV4dFFsSXNWVUZCVlN4RlFVdDBRbE1zYVVKQlFXVXNSVUZCUjBFc1YwRkJaU3hUUVVGRExFRkJjRUl6UXp0QlFYTkNSU3huUWtGUWJVSlVMRlZCUVZVc1JVRlBkRUpWTEhWQ1FVRnhRaXhGUVVGSFF5eFhRVUZ0UXl4VFFVRkRMRU5CUVVNc1IwRkJSenRCUVhSQ2VrVTdRVUYzUWtVc1owSkJWRzFDV0N4VlFVRlZMRVZCVTNSQ1dTeDNRa0ZCYzBJc1JVRkJSMEVzYTBKQlFYTkNMRk5CUVVNc1FVRjRRbnBFTzBGQk1FSkZMR2RDUVZodFFsb3NWVUZCVlN4RlFWZDBRbUVzZDBKQlFYTkNMRVZCUVVkRExGbEJRV2xETEZOQlFVTXNRMEZCUXl4SFFVRkhPMEZCTVVKNFJUdEJRVFJDUlN4blFrRmliVUprTEZWQlFWVXNSVUZoZEVKbExEUkNRVUV3UWl4RlFVRkhReXhoUVVGeFF5eFRRVUZETEVOQlFVTXNSMEZCUnp0QlFUVkNhRVk3UVVFNFFrVXNaMEpCWm0xQ2FFSXNWVUZCVlN4RlFXVjBRbWxDTERoQ1FVRTBRaXhGUVVGSFF5eGhRVUYxUXl4VFFVRkRMRU5CUVVNc1IwRkJSenRCUVRsQ2NFWTdRVUZuUTBVc1owSkJha0p0UW14Q0xGVkJRVlVzUlVGcFFuUkNiVUlzSzBKQlFUWkNMRVZCUVVkRExHRkJRWGRETEZOQlFVTXNRMEZCUXl4SFFVRkhPMEZCYUVOMFJqdEJRV3REUlN4blFrRnVRbTFDY0VJc1ZVRkJWU3hGUVcxQ2RFSnhRaXhuUTBGQk9FSXNSVUZCUjBFc1lVRkJPRUlzVTBGQlF5eEJRV3hEZWtVN1FVRnZRMFVzWjBKQmNrSnRRbkpDTEZWQlFWVXNSVUZ4UW5SQ2MwSXNaME5CUVRoQ0xFVkJRVWRCTEdGQlFUaENMRk5CUVVNc1FVRndRM3BGSW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfc2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b2tlbi9zaWduaWZpY2FudFwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihTaWduaWZpY2FudFRva2VuKSB7XG4gICAgX2luaGVyaXRzKEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sIFNpZ25pZmljYW50VG9rZW4pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgZnVuY3Rpb24gRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4ucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzSFRNTFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzSFRNTCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IHRoaXMuaW5uZXJIVE1MOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2goY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2lnbmlmaWNhbnQuZGVmYXVsdC5tYXRjaChFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2lnbmlmaWNhbnQuZGVmYXVsdC5mcm9tQ29udGVudChFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuO1xufShfc2lnbmlmaWNhbnQuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuO1xuX2RlZmluZVByb3BlcnR5KEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sIFwidHlwZVwiLCBfdHlwZXMuZW5kT2ZMaW5lVHlwZSk7XG5fZGVmaW5lUHJvcGVydHkoRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXig/OlxcclxcbnxcXHJ8XFxuKS8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl6YVdkdWFXWnBZMkZ1ZEM5bGJtUlBaa3hwYm1VdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJR1p5YjIwZ1hDSXVMaTh1TGk5MGIydGxiaTl6YVdkdWFXWnBZMkZ1ZEZ3aU8xeHVYRzVwYlhCdmNuUWdleUJsYm1SUFpreHBibVZVZVhCbElIMGdabkp2YlNCY0lpNHVMeTR1TDNSNWNHVnpYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRVZ1WkU5bVRHbHVaVk5wWjI1cFptbGpZVzUwVkc5clpXNGdaWGgwWlc1a2N5QlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlIdGNiaUFnWTJ4dmJtVW9jM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBJSHNnY21WMGRYSnVJSE4xY0dWeUxtTnNiMjVsS0VWdVpFOW1UR2x1WlZOcFoyNXBabWxqWVc1MFZHOXJaVzRzSUhOMFlYSjBVRzl6YVhScGIyNHNJR1Z1WkZCdmMybDBhVzl1S1RzZ2ZWeHVYRzRnSUdGelNGUk5UQ2dwSUh0Y2JpQWdJQ0JqYjI1emRDQm9kRzFzSUQwZ2RHaHBjeTVwYm01bGNraFVUVXc3SUNBdkx5OWNibHh1SUNBZ0lISmxkSFZ5YmlCb2RHMXNPMXh1SUNCOVhHNWNiaUFnYzNSaGRHbGpJSFI1Y0dVZ1BTQmxibVJQWmt4cGJtVlVlWEJsTzF4dVhHNGdJSE4wWVhScFl5QnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJpQTlJQzllS0Q4NlhGeHlYRnh1ZkZ4Y2NueGNYRzRwTHp0Y2JseHVJQ0J6ZEdGMGFXTWdiV0YwWTJnb1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1UybG5ibWxtYVdOaGJuUlViMnRsYmk1dFlYUmphQ2hGYm1SUFpreHBibVZUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVMQ0JqYjI1MFpXNTBLVHNnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0UTI5dWRHVnVkQ2hqYjI1MFpXNTBLU0I3SUhKbGRIVnliaUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVMbVp5YjIxRGIyNTBaVzUwS0VWdVpFOW1UR2x1WlZOcFoyNXBabWxqWVc1MFZHOXJaVzRzSUdOdmJuUmxiblFwT3lCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVJXNWtUMlpNYVc1bFUybG5ibWxtYVdOaGJuUlViMnRsYmlJc0ltTnNiMjVsSWl3aWMzUmhjblJRYjNOcGRHbHZiaUlzSW1WdVpGQnZjMmwwYVc5dUlpd2lZWE5JVkUxTUlpd2lhSFJ0YkNJc0ltbHVibVZ5U0ZSTlRDSXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRDSXNJbE5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0ptY205dFEyOXVkR1Z1ZENJc0luUjVjR1VpTENKbGJtUlBaa3hwYm1WVWVYQmxJaXdpY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGTmtJc1NVRkJRU3haUVVGNVFpeHJRMEZCZWtJc2VVSkJRWGxDTEVWQlFVRTdRVUZGZUVJc1NVRkJRU3hOUVVGaExGZEJRV0lzWVVGQllTeERRVUZCT3pzN096czdPenM3T3pzN096czdPRVJCU2pORE8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN096czdPenM3TzFWQlFVRTdPM2RDUVVGQk96czdPenM3TUVKQlFVRTdPenM3T3pzN096czdVMEZCUVRzN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzN2QwTkJRVUU3T3pzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVFdVc1NVRkJRU3hCUVVGTlFTeDVRa0ZCZVVJc2FVSkRUak5ETEVGRVRWazdNRVJCVG1ZN08yRkJUWEZDUVN4NVFrRkJlVUk3ZDBSQlRqbERPenM3T3p0WlFVOUZReXhIUVVGTExFVkJRVXhCTEU5QlFVczdXVVZRVUN4UFJrOUZRU3hUUVVGQlFTeExRVUZMTEVOQlFVTkRMR0ZCUVdFc1JVRkJSVU1zVjBGQlZ5eEZRVUZGTzJkQ1FVRkZMRTlCUVU4c2NVSkJSSGhDU0N4NVFrRkJlVUlzWVVGRFMwTXNUMEZCU3l4RlFVRllMRWxCUVVzc1EwRkJRU3haUVVGUFJDeDVRa0ZCZVVJc1JVRkJSVVVzWVVGQllTeEZRVUZGUXl4WFFVRlhMRVZCUVVVN1lVRkJSVHM3TzFsQlJXaElReXhIUVVGTkxFVkJRVTVCTEZGQlFVMDdXVVZVVWl4UFJsTkZRU3hUUVVGQlFTeE5RVUZOTEVkQlFVYzdaMEpCUTFBc1NVRkJUVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1UwRkJVeXhCUVVGRExFVkJRVVVzUjBGQlJ6dG5Ra0ZGYWtNc1QwRkJUMFFzU1VGQlNTeERRVUZETzJGQlEySTdPenM3V1VGTlRVVXNSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZia0prTEU5R2JVSkZMRk5CUVU5QkxFdEJRVXNzUTBGQlEwTXNUMEZCVHl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZsQlFXZENMRk5CUVVOR0xFdEJRVXNzUTBGQlExQXNlVUpCUVhsQ0xFVkJRVVZSTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUVVVN096dFpRVVZ5UmtVc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRmNrSndRaXhQUm5GQ1JTeFRRVUZQUVN4WFFVRlhMRU5CUVVOR0xFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhaUVVGblFpeFRRVUZEUXl4WFFVRlhMRU5CUVVOV0xIbENRVUY1UWl4RlFVRkZVU3hQUVVGUExFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFYSkNNVWM3TzBOQmMwSkRMRU5CYUVKelJFTXNXVUZCWjBJc1UwRm5RblJGTzJ0Q1FXaENiMEpVTEhsQ1FVRjVRaXhCUVU0NVF6dEJRV1ZGTEdkQ1FWUnRRa0VzZVVKQlFYbENMRVZCVTNKRFZ5eE5RVUZKTEVWQlFVZERMRTFCUVdFc1pVRkJReXhCUVdZNVFqdEJRV2xDUlN4blFrRlliVUphTEhsQ1FVRjVRaXhGUVZkeVEyRXNiVUpCUVdsQ0xHOUNRVUZ4UWl4QlFXcENMME1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfc2lnbmlmaWNhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi90b2tlbi9zaWduaWZpY2FudFwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oU2lnbmlmaWNhbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgU2lnbmlmaWNhbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbik7XG4gICAgZnVuY3Rpb24gRW5kT2ZMaW5lQ29tbWVudFNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuLnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNIVE1MXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNIVE1MKCkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5pbm5lckhUTUw7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNJbkNvbW1lbnRQcmVzZXJ2aW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2goY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2lnbmlmaWNhbnQuZGVmYXVsdC5tYXRjaChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NpZ25pZmljYW50LmRlZmF1bHQuZnJvbUNvbnRlbnQoRW5kT2ZMaW5lQ29tbWVudFNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuO1xufShfc2lnbmlmaWNhbnQuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbjtcbl9kZWZpbmVQcm9wZXJ0eShFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgXCJ0eXBlXCIsIF90eXBlcy5lbmRPZkxpbmVDb21tZW50VHlwZSk7XG5fZGVmaW5lUHJvcGVydHkoRW5kT2ZMaW5lQ29tbWVudFNpZ25pZmljYW50VG9rZW4sIFwicmVndWxhckV4cHJlc3Npb25cIiwgL14oPzpcXHJcXG58XFxyfFxcbikvKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXphV2R1YVdacFkyRnVkQzlqYjIxdFpXNTBMMlZ1WkU5bVRHbHVaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElGTnBaMjVwWm1sallXNTBWRzlyWlc0Z1puSnZiU0JjSWk0dUx5NHVMeTR1TDNSdmEyVnVMM05wWjI1cFptbGpZVzUwWENJN1hHNWNibWx0Y0c5eWRDQjdJR1Z1WkU5bVRHbHVaVU52YlcxbGJuUlVlWEJsSUgwZ1puSnZiU0JjSWk0dUx5NHVMeTR1TDNSNWNHVnpYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRVZ1WkU5bVRHbHVaVU52YlcxbGJuUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlHVjRkR1Z1WkhNZ1UybG5ibWxtYVdOaGJuUlViMnRsYmlCN1hHNGdJR05zYjI1bEtITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtTQjdJSEpsZEhWeWJpQnpkWEJsY2k1amJHOXVaU2hGYm1SUFpreHBibVZEYjIxdFpXNTBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpd2djM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBPeUI5WEc1Y2JpQWdZWE5JVkUxTUtDa2dlMXh1SUNBZ0lHTnZibk4wSUdoMGJXd2dQU0IwYUdsekxtbHVibVZ5U0ZSTlREc2dJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJR2gwYld3N1hHNGdJSDFjYmx4dUlDQnBjMGx1UTI5dGJXVnVkRkJ5WlhObGNuWnBibWNvS1NCN1hHNGdJQ0FnWTI5dWMzUWdhVzVEYjIxdFpXNTBVSEpsYzJWeWRtbHVaeUE5SUhSeWRXVTdYRzVjYmlBZ0lDQnlaWFIxY200Z2FXNURiMjF0Wlc1MFVISmxjMlZ5ZG1sdVp6dGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5QjBlWEJsSUQwZ1pXNWtUMlpNYVc1bFEyOXRiV1Z1ZEZSNWNHVTdYRzVjYmlBZ2MzUmhkR2xqSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1SUQwZ0wxNG9QenBjWEhKY1hHNThYRnh5ZkZ4Y2Jpa3ZPMXh1WEc0Z0lITjBZWFJwWXlCdFlYUmphQ2hqYjI1MFpXNTBLU0I3SUhKbGRIVnliaUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVMbTFoZEdOb0tFVnVaRTltVEdsdVpVTnZiVzFsYm5SVGFXZHVhV1pwWTJGdWRGUnZhMlZ1TENCamIyNTBaVzUwS1RzZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFEyOXVkR1Z1ZENoamIyNTBaVzUwS1NCN0lISmxkSFZ5YmlCVGFXZHVhV1pwWTJGdWRGUnZhMlZ1TG1aeWIyMURiMjUwWlc1MEtFVnVaRTltVEdsdVpVTnZiVzFsYm5SVGFXZHVhV1pwWTJGdWRGUnZhMlZ1TENCamIyNTBaVzUwS1RzZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklrVnVaRTltVEdsdVpVTnZiVzFsYm5SVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aVkyeHZibVVpTENKemRHRnlkRkJ2YzJsMGFXOXVJaXdpWlc1a1VHOXphWFJwYjI0aUxDSmhjMGhVVFV3aUxDSm9kRzFzSWl3aWFXNXVaWEpJVkUxTUlpd2lhWE5KYmtOdmJXMWxiblJRY21WelpYSjJhVzVuSWl3aWFXNURiMjF0Wlc1MFVISmxjMlZ5ZG1sdVp5SXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRDSXNJbE5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0ptY205dFEyOXVkR1Z1ZENJc0luUjVjR1VpTENKbGJtUlBaa3hwYm1WRGIyMXRaVzUwVkhsd1pTSXNJbkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSVFpDTEVsQlFVRXNXVUZCTkVJc2EwTkJRVFZDTERSQ1FVRTBRaXhGUVVGQk8wRkJSWEJDTEVsQlFVRXNUVUZCWjBJc1YwRkJhRUlzWjBKQlFXZENMRU5CUVVFN096czdPenM3T3pzN096czdPenM0UkVGS2NrUTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPenM3T3pzN1ZVRkJRVHM3ZDBKQlFVRTdPenM3T3pzd1FrRkJRVHM3T3pzN096czdPenRUUVVGQk96czdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096dDNRMEZCUVRzN096czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGTlpTeEpRVUZCTEVGQlFVMUJMR2REUVVGblF5eHBRa05PYkVRc1FVUk5XVHRwUlVGT1pqczdZVUZOY1VKQkxHZERRVUZuUXpzclJFRk9ja1E3T3pzN08xbEJUMFZETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlZCUUxFOUdUMFZCTEZOQlFVRkJMRXRCUVVzc1EwRkJRME1zWVVGQllTeEZRVUZGUXl4WFFVRlhMRVZCUVVVN1owSkJRVVVzVDBGQlR5eHhRa0ZFZUVKSUxHZERRVUZuUXl4aFFVTkdReXhQUVVGTExFVkJRVmdzU1VGQlN5eERRVUZCTEZsQlFVOUVMR2REUVVGblF5eEZRVUZGUlN4aFFVRmhMRVZCUVVWRExGZEJRVmNzUlVGQlJUdGhRVUZGT3pzN1dVRkZka2hETEVkQlFVMHNSVUZCVGtFc1VVRkJUVHRaUlZSU0xFOUdVMFZCTEZOQlFVRkJMRTFCUVUwc1IwRkJSenRuUWtGRFVDeEpRVUZOUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVGQlFVTXNSVUZCUlN4SFFVRkhPMmRDUVVWcVF5eFBRVUZQUkN4SlFVRkpMRU5CUVVNN1lVRkRZanM3TzFsQlJVUkZMRWRCUVhGQ0xFVkJRWEpDUVN4MVFrRkJjVUk3V1VWbWRrSXNUMFpsUlVFc1UwRkJRVUVzY1VKQlFYRkNMRWRCUVVjN1owSkJRM1JDTEVsQlFVMURMRzFDUVVGdFFpeEhRVUZITEVsQlFVa3NRVUZCUXp0blFrRkZha01zVDBGQlQwRXNiVUpCUVcxQ0xFTkJRVU03WVVGRE5VSTdPenM3V1VGTlRVTXNSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZla0prTEU5R2VVSkZMRk5CUVU5QkxFdEJRVXNzUTBGQlEwTXNUMEZCVHl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZsQlFXZENMRk5CUVVOR0xFdEJRVXNzUTBGQlExUXNaME5CUVdkRExFVkJRVVZWTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUVVVN096dFpRVVUxUmtVc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRk0wSndRaXhQUmpKQ1JTeFRRVUZQUVN4WFFVRlhMRU5CUVVOR0xFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhaUVVGblFpeFRRVUZEUXl4WFFVRlhMRU5CUVVOYUxHZERRVUZuUXl4RlFVRkZWU3hQUVVGUExFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFUTkNha2c3TzBOQk5FSkRMRU5CZEVJMlJFTXNXVUZCWjBJc1UwRnpRamRGTzJ0Q1FYUkNiMEpZTEdkRFFVRm5ReXhCUVU1eVJEdEJRWEZDUlN4blFrRm1iVUpCTEdkRFFVRm5ReXhGUVdVMVEyRXNUVUZCU1N4RlFVRkhReXhOUVVGdlFpeHpRa0ZCUXl4QlFYSkNja003UVVGMVFrVXNaMEpCYWtKdFFtUXNaME5CUVdkRExFVkJhVUkxUTJVc2JVSkJRV2xDTEc5Q1FVRnhRaXhCUVhaQ0wwTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9zaW5nbGVMaW5lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKXtcbiAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgQ1N0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oU2luZ2xlTGluZUNvbW1lbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBTaW5nbGVMaW5lQ29tbWVudFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4pO1xuICAgIGZ1bmN0aW9uIENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQ1N0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NpbmdsZUxpbmUuZGVmYXVsdC5tYXRjaChDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Db250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2luZ2xlTGluZS5kZWZhdWx0LmZyb21Db250ZW50KENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW47XG59KF9zaW5nbGVMaW5lLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ1N0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbjtcbl9kZWZpbmVQcm9wZXJ0eShDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eXFwvXFwvW15cXHJcXG5dKi8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUwzTnlZeTkwYjJ0bGJpOXViMjVUYVdkdWFXWnBZMkZ1ZEM5amIyMXRaVzUwTDNOcGJtZHNaVXhwYm1VdlkxTjBlV3hsTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdVMmx1WjJ4bFRHbHVaVU52YlcxbGJuUlViMnRsYmlCbWNtOXRJRndpTGk0dkxpNHZMaTR2TGk0dmRHOXJaVzR2Ym05dVUybG5ibWxtYVdOaGJuUXZZMjl0YldWdWRDOXphVzVuYkdWTWFXNWxYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRU5UZEhsc1pWTnBibWRzWlV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRnWlhoMFpXNWtjeUJUYVc1bmJHVk1hVzVsUTI5dGJXVnVkRlJ2YTJWdUlIdGNiaUFnWTJ4dmJtVW9jM1JoY25SUWIzTnBkR2x2Yml3Z1pXNWtVRzl6YVhScGIyNHBJSHNnY21WMGRYSnVJSE4xY0dWeUxtTnNiMjVsS0VOVGRIbHNaVk5wYm1kc1pVeHBibVZEYjIxdFpXNTBWRzlyWlc0c0lITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtUc2dmVnh1WEc0Z0lITjBZWFJwWXlCeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlBOUlDOWVYRnd2WEZ3dlcxNWNYSEpjWEc1ZEtpODdYRzVjYmlBZ2MzUmhkR2xqSUcxaGRHTm9LR052Ym5SbGJuUXBJSHNnY21WMGRYSnVJRk5wYm1kc1pVeHBibVZEYjIxdFpXNTBWRzlyWlc0dWJXRjBZMmdvUTFOMGVXeGxVMmx1WjJ4bFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z1kyOXVkR1Z1ZENrN0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJVTnZiblJsYm5Rb1kyOXVkR1Z1ZENrZ2V5QnlaWFIxY200Z1UybHVaMnhsVEdsdVpVTnZiVzFsYm5SVWIydGxiaTVtY205dFEyOXVkR1Z1ZENoRFUzUjViR1ZUYVc1bmJHVk1hVzVsUTI5dGJXVnVkRlJ2YTJWdUxDQmpiMjUwWlc1MEtUc2dmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJa05UZEhsc1pWTnBibWRzWlV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRpTENKamJHOXVaU0lzSW5OMFlYSjBVRzl6YVhScGIyNGlMQ0psYm1SUWIzTnBkR2x2YmlJc0ltMWhkR05vSWl3aVkyOXVkR1Z1ZENJc0lsTnBibWRzWlV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRpTENKbWNtOXRRMjl1ZEdWdWRDSXNJbkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSVzFETEVsQlFVRXNWMEZCY1VRc2EwTkJRWEpFTEhGRVFVRnhSQ3hGUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlJuaEdPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3T3pzN08xVkJRVUU3TzNkQ1FVRkJPenM3T3pzN01FSkJRVUU3T3pzN096czdPenM3VTBGQlFUczdPenM3T3p0TFFVRkJPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096czdkME5CUVVFN096czdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlNXVXNTVUZCUVN4QlFVRk5RU3cwUWtGQk5FSXNhVUpEU2psRExFRkVTVms3YlVWQlNtWTdPMkZCU1hGQ1FTdzBRa0ZCTkVJN01rUkJTbXBFT3pzN096dFpRVXRGUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWTVVDeFBSa3RGUVN4VFFVRkJRU3hMUVVGTExFTkJRVU5ETEdGQlFXRXNSVUZCUlVNc1YwRkJWeXhGUVVGRk8yZENRVUZGTEU5QlFVOHNjVUpCUkhoQ1NDdzBRa0ZCTkVJc1lVRkRSVU1zVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBSQ3cwUWtGQk5FSXNSVUZCUlVVc1lVRkJZU3hGUVVGRlF5eFhRVUZYTEVWQlFVVTdZVUZCUlRzN096dFpRVWsxUjBNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRlZHUXNUMFpUUlN4VFFVRlBRU3hMUVVGTExFTkJRVU5ETEU5QlFVOHNSVUZCUlR0blFrRkJSU3hQUVVGUFF5eFhRVUZ6UWl4VFFVRkRSaXhMUVVGTExFTkJRVU5LTERSQ1FVRTBRaXhGUVVGRlN5eFBRVUZQTEVOQlFVTXNRMEZCUXp0aFFVRkZPenM3V1VGRk9VWkZMRWRCUVZjc1JVRkJXRUVzWVVGQlZ6dFpSVmh3UWl4UFJsZEZMRk5CUVU5QkxGZEJRVmNzUTBGQlEwWXNUMEZCVHl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZkQlFYTkNMRk5CUVVORExGZEJRVmNzUTBGQlExQXNORUpCUVRSQ0xFVkJRVVZMTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUVVVN08wMUJXRzVJT3p0RFFWbERMRU5CVW5sRVF5eFhRVUZ6UWl4VFFWRXZSVHRyUWtGU2IwSk9MRFJDUVVFMFFpeEJRVXBxUkR0QlFVOUZMR2RDUVVodFFrRXNORUpCUVRSQ0xFVkJSM2hEVVN4dFFrRkJhVUlzYTBKQlFXMUNMRUZCVURkREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2VuZE9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2ZcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBDU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoQ1N0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICBmdW5jdGlvbiBDU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQ1N0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQ1N0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXRjaFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VuZE9mLmRlZmF1bHQubWF0Y2goQ1N0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbmRPZi5kZWZhdWx0LmZyb21Db250ZW50KENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBDU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjtcbn0oX2VuZE9mLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ1N0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoQ1N0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIFwicmVndWxhckV4cHJlc3Npb25cIiwgL15cXCpcXC8vKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUx5NHVMeTR1TDNOeVl5OTBiMnRsYmk5dWIyNVRhV2R1YVdacFkyRnVkQzlqYjIxdFpXNTBMMjExYkhScFRHbHVaUzlsYm1SUFppOWpVM1I1YkdVdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JGYm1SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaUJtY205dElGd2lMaTR2TGk0dkxpNHZMaTR2TGk0dmRHOXJaVzR2Ym05dVUybG5ibWxtYVdOaGJuUXZZMjl0YldWdWRDOXRkV3gwYVV4cGJtVXZaVzVrVDJaY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1ExTjBlV3hsUlc1a1QyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRnWlhoMFpXNWtjeUJGYm1SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaUI3WEc0Z0lHTnNiMjVsS0hOMFlYSjBVRzl6YVhScGIyNHNJR1Z1WkZCdmMybDBhVzl1S1NCN0lISmxkSFZ5YmlCemRYQmxjaTVqYkc5dVpTaERVM1I1YkdWRmJtUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z2MzUmhjblJRYjNOcGRHbHZiaXdnWlc1a1VHOXphWFJwYjI0cE95QjlYRzVjYmlBZ2MzUmhkR2xqSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1SUQwZ0wxNWNYQ3BjWEM4dk8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQkZibVJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpNXRZWFJqYUNoRFUzUjViR1ZGYm1SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaXdnWTI5dWRHVnVkQ2s3SUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlVOdmJuUmxiblFvWTI5dWRHVnVkQ2tnZXlCeVpYUjFjbTRnUlc1a1QyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzR1Wm5KdmJVTnZiblJsYm5Rb1ExTjBlV3hsUlc1a1QyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRzSUdOdmJuUmxiblFwT3lCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVExTjBlV3hsUlc1a1QyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRpTENKamJHOXVaU0lzSW5OMFlYSjBVRzl6YVhScGIyNGlMQ0psYm1SUWIzTnBkR2x2YmlJc0ltMWhkR05vSWl3aVkyOXVkR1Z1ZENJc0lrVnVaRTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlJ2YTJWdUlpd2labkp2YlVOdmJuUmxiblFpTENKeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWMVF5eEpRVUZCTEUxQlFUWkVMR3REUVVFM1JDdzJSRUZCTmtRc1JVRkJRVHM3T3pzN096czdPenM3T3pzN096aEVRVVp3Unp0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN096czdPenRWUVVGQk96dDNRa0ZCUVRzN096czdPekJDUVVGQk96czdPenM3T3pzN08xTkJRVUU3T3pzN096czdTMEZCUVRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TzNkRFFVRkJPenM3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVWxsTEVsQlFVRXNRVUZCVFVFc1owTkJRV2RETEdsQ1EwcHNSQ3hCUkVsWk96SkZRVXBtT3p0aFFVbHhRa0VzWjBOQlFXZERPeXRFUVVweVJEczdPenM3V1VGTFJVTXNSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZURkFzVDBaTFJVRXNVMEZCUVVFc1MwRkJTeXhEUVVGRFF5eGhRVUZoTEVWQlFVVkRMRmRCUVZjc1JVRkJSVHRuUWtGQlJTeFBRVUZQTEhGQ1FVUjRRa2dzWjBOQlFXZERMR0ZCUTBaRExFOUJRVXNzUlVGQldDeEpRVUZMTEVOQlFVRXNXVUZCVDBRc1owTkJRV2RETEVWQlFVVkZMR0ZCUVdFc1JVRkJSVU1zVjBGQlZ5eEZRVUZGTzJGQlFVVTdPenM3V1VGSmFFaERMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSVlJrTEU5R1UwVXNVMEZCVDBFc1MwRkJTeXhEUVVGRFF5eFBRVUZQTEVWQlFVVTdaMEpCUVVVc1QwRkJUME1zVFVGQk1FSXNVMEZCUTBZc1MwRkJTeXhEUVVGRFNpeG5RMEZCWjBNc1JVRkJSVXNzVDBGQlR5eERRVUZETEVOQlFVTTdZVUZCUlRzN08xbEJSWFJIUlN4SFFVRlhMRVZCUVZoQkxHRkJRVmM3V1VWWWNFSXNUMFpYUlN4VFFVRlBRU3hYUVVGWExFTkJRVU5HTEU5QlFVOHNSVUZCUlR0blFrRkJSU3hQUVVGUFF5eE5RVUV3UWl4VFFVRkRReXhYUVVGWExFTkJRVU5RTEdkRFFVRm5ReXhGUVVGRlN5eFBRVUZQTEVOQlFVTXNRMEZCUXp0aFFVRkZPenROUVZnelNEczdRMEZaUXl4RFFWSTJSRU1zVFVGQk1FSXNVMEZSZGtZN2EwSkJVbTlDVGl4blEwRkJaME1zUVVGS2NrUTdRVUZQUlN4blFrRkliVUpCTEdkRFFVRm5ReXhGUVVjMVExRXNiVUpCUVdsQ0xGVkJRVmNzUVVGUWNrTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9zdGFydE9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pIHtcbiAgICBfaW5oZXJpdHMoQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKTtcbiAgICBmdW5jdGlvbiBDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbik7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdGFydE9mLmRlZmF1bHQubWF0Y2goQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXJ0T2YuZGVmYXVsdC5mcm9tQ29udGVudChDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuO1xufShfc3RhcnRPZi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47XG5fZGVmaW5lUHJvcGVydHkoQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXlxcL1xcKi8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwyMTFiSFJwVEdsdVpTOXpkR0Z5ZEU5bUwyTlRkSGxzWlM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJRk4wWVhKMFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRnWm5KdmJTQmNJaTR1THk0dUx5NHVMeTR1THk0dUwzUnZhMlZ1TDI1dmJsTnBaMjVwWm1sallXNTBMMk52YlcxbGJuUXZiWFZzZEdsTWFXNWxMM04wWVhKMFQyWmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdRMU4wZVd4bFUzUmhjblJQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpQmxlSFJsYm1SeklGTjBZWEowVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGdlMXh1SUNCamJHOXVaU2h6ZEdGeWRGQnZjMmwwYVc5dUxDQmxibVJRYjNOcGRHbHZiaWtnZXlCeVpYUjFjbTRnYzNWd1pYSXVZMnh2Ym1Vb1ExTjBlV3hsVTNSaGNuUlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYml3Z2MzUmhjblJRYjNOcGRHbHZiaXdnWlc1a1VHOXphWFJwYjI0cE95QjlYRzVjYmlBZ2MzUmhkR2xqSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1SUQwZ0wxNWNYQzljWENvdk8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQlRkR0Z5ZEU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVMbTFoZEdOb0tFTlRkSGxzWlZOMFlYSjBUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0c0lHTnZiblJsYm5RcE95QjlYRzVjYmlBZ2MzUmhkR2xqSUdaeWIyMURiMjUwWlc1MEtHTnZiblJsYm5RcElIc2djbVYwZFhKdUlGTjBZWEowVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNHVabkp2YlVOdmJuUmxiblFvUTFOMGVXeGxVM1JoY25SUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaXdnWTI5dWRHVnVkQ2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKRFUzUjViR1ZUZEdGeWRFOW1UWFZzZEdsTWFXNWxRMjl0YldWdWRGUnZhMlZ1SWl3aVkyeHZibVVpTENKemRHRnlkRkJ2YzJsMGFXOXVJaXdpWlc1a1VHOXphWFJwYjI0aUxDSnRZWFJqYUNJc0ltTnZiblJsYm5RaUxDSlRkR0Z5ZEU5bVRYVnNkR2xNYVc1bFEyOXRiV1Z1ZEZSdmEyVnVJaXdpWm5KdmJVTnZiblJsYm5RaUxDSnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVjVReXhKUVVGQkxGRkJRU3RFTEd0RFFVRXZSQ3dyUkVGQkswUXNSVUZCUVRzN096czdPenM3T3pzN096czdPemhFUVVaNFJ6dHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPenM3T3p0VlFVRkJPenQzUWtGQlFUczdPenM3T3pCQ1FVRkJPenM3T3pzN096czdPMU5CUVVFN096czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN08zZERRVUZCT3pzN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVVsbExFbEJRVUVzUVVGQlRVRXNhME5CUVd0RExHbENRMHB3UkN4QlJFbFpPeXRGUVVwbU96dGhRVWx4UWtFc2EwTkJRV3RETzJsRlFVcDJSRHM3T3pzN1dVRkxSVU1zUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxGVEZBc1QwWkxSVUVzVTBGQlFVRXNTMEZCU3l4RFFVRkRReXhoUVVGaExFVkJRVVZETEZkQlFWY3NSVUZCUlR0blFrRkJSU3hQUVVGUExIRkNRVVI0UWtnc2EwTkJRV3RETEdGQlEwcERMRTlCUVVzc1JVRkJXQ3hKUVVGTExFTkJRVUVzV1VGQlQwUXNhME5CUVd0RExFVkJRVVZGTEdGQlFXRXNSVUZCUlVNc1YwRkJWeXhGUVVGRk8yRkJRVVU3T3pzN1dVRkpiRWhETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlZSa0xFOUdVMFVzVTBGQlQwRXNTMEZCU3l4RFFVRkRReXhQUVVGUExFVkJRVVU3WjBKQlFVVXNUMEZCVDBNc1VVRkJORUlzVTBGQlEwWXNTMEZCU3l4RFFVRkRTaXhyUTBGQmEwTXNSVUZCUlVzc1QwRkJUeXhEUVVGRExFTkJRVU03WVVGQlJUczdPMWxCUlRGSFJTeEhRVUZYTEVWQlFWaEJMR0ZCUVZjN1dVVlljRUlzVDBaWFJTeFRRVUZQUVN4WFFVRlhMRU5CUVVOR0xFOUJRVThzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBReXhSUVVFMFFpeFRRVUZEUXl4WFFVRlhMRU5CUVVOUUxHdERRVUZyUXl4RlFVRkZTeXhQUVVGUExFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFWZ3ZTRHM3UTBGWlF5eERRVklyUkVNc1VVRkJORUlzVTBGUk0wWTdhMEpCVW05Q1RpeHJRMEZCYTBNc1FVRktka1E3UVVGUFJTeG5Ra0ZJYlVKQkxHdERRVUZyUXl4RlFVYzVRMUVzYlVKQlFXbENMRlZCUVZjc1FVRlFja01pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbWlkZGxlT2YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZlwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbikge1xuICAgIF9pbmhlcml0cyhDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ1N0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pO1xuICAgIGZ1bmN0aW9uIENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1N0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4pO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ1N0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2goY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbWlkZGxlT2YuZGVmYXVsdC5tYXRjaChDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQ29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21pZGRsZU9mLmRlZmF1bHQuZnJvbUNvbnRlbnQoQ1N0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuO1xufShfbWlkZGxlT2YuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjtcbl9kZWZpbmVQcm9wZXJ0eShDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXig/OlteXFxyXFxuXSs/KD89XFwqXFwvKXxbXlxcclxcbl0rKS8pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5MGIydGxiaTl1YjI1VGFXZHVhV1pwWTJGdWRDOWpiMjF0Wlc1MEwyMTFiSFJwVEdsdVpTOXRhV1JrYkdWUFppOWpVM1I1YkdVdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JOYVdSa2JHVlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlCbWNtOXRJRndpTGk0dkxpNHZMaTR2TGk0dkxpNHZkRzlyWlc0dmJtOXVVMmxuYm1sbWFXTmhiblF2WTI5dGJXVnVkQzl0ZFd4MGFVeHBibVV2Yldsa1pHeGxUMlpjSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nUTFOMGVXeGxUV2xrWkd4bFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzRnWlhoMFpXNWtjeUJOYVdSa2JHVlBaazExYkhScFRHbHVaVU52YlcxbGJuUlViMnRsYmlCN1hHNGdJR05zYjI1bEtITjBZWEowVUc5emFYUnBiMjRzSUdWdVpGQnZjMmwwYVc5dUtTQjdJSEpsZEhWeWJpQnpkWEJsY2k1amJHOXVaU2hEVTNSNWJHVk5hV1JrYkdWUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaXdnYzNSaGNuUlFiM05wZEdsdmJpd2daVzVrVUc5emFYUnBiMjRwT3lCOVhHNWNiaUFnYzNSaGRHbGpJSEpsWjNWc1lYSkZlSEJ5WlhOemFXOXVJRDBnTDE0b1B6cGJYbHhjY2x4Y2JsMHJQeWcvUFZ4Y0tseGNMeWw4VzE1Y1hISmNYRzVkS3lrdk8xeHVYRzRnSUhOMFlYUnBZeUJ0WVhSamFDaGpiMjUwWlc1MEtTQjdJSEpsZEhWeWJpQk5hV1JrYkdWUFprMTFiSFJwVEdsdVpVTnZiVzFsYm5SVWIydGxiaTV0WVhSamFDaERVM1I1YkdWTmFXUmtiR1ZQWmsxMWJIUnBUR2x1WlVOdmJXMWxiblJVYjJ0bGJpd2dZMjl1ZEdWdWRDazdJSDFjYmx4dUlDQnpkR0YwYVdNZ1puSnZiVU52Ym5SbGJuUW9ZMjl1ZEdWdWRDa2dleUJ5WlhSMWNtNGdUV2xrWkd4bFQyWk5kV3gwYVV4cGJtVkRiMjF0Wlc1MFZHOXJaVzR1Wm5KdmJVTnZiblJsYm5Rb1ExTjBlV3hsVFdsa1pHeGxUMlpOZFd4MGFVeHBibVZEYjIxdFpXNTBWRzlyWlc0c0lHTnZiblJsYm5RcE95QjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lRMU4wZVd4bFRXbGtaR3hsVDJaTmRXeDBhVXhwYm1WRGIyMXRaVzUwVkc5clpXNGlMQ0pqYkc5dVpTSXNJbk4wWVhKMFVHOXphWFJwYjI0aUxDSmxibVJRYjNOcGRHbHZiaUlzSW0xaGRHTm9JaXdpWTI5dWRHVnVkQ0lzSWsxcFpHUnNaVTltVFhWc2RHbE1hVzVsUTI5dGJXVnVkRlJ2YTJWdUlpd2labkp2YlVOdmJuUmxiblFpTENKeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVd1F5eEpRVUZCTEZOQlFXZEZMR3REUVVGb1JTeG5SVUZCWjBVc1JVRkJRVHM3T3pzN096czdPenM3T3pzN096aEVRVVl4Unp0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN096czdPenRWUVVGQk96dDNRa0ZCUVRzN096czdPekJDUVVGQk96czdPenM3T3pzN08xTkJRVUU3T3pzN096czdTMEZCUVRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TzNkRFFVRkJPenM3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVWxsTEVsQlFVRXNRVUZCVFVFc2JVTkJRVzFETEdsQ1EwcHlSQ3hCUkVsWk8ybEdRVXBtT3p0aFFVbHhRa0VzYlVOQlFXMURPMnRGUVVwNFJEczdPenM3V1VGTFJVTXNSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZURkFzVDBaTFJVRXNVMEZCUVVFc1MwRkJTeXhEUVVGRFF5eGhRVUZoTEVWQlFVVkRMRmRCUVZjc1JVRkJSVHRuUWtGQlJTeFBRVUZQTEhGQ1FVUjRRa2dzYlVOQlFXMURMR0ZCUTB4RExFOUJRVXNzUlVGQldDeEpRVUZMTEVOQlFVRXNXVUZCVDBRc2JVTkJRVzFETEVWQlFVVkZMR0ZCUVdFc1JVRkJSVU1zVjBGQlZ5eEZRVUZGTzJGQlFVVTdPenM3V1VGSmJraERMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSVlJrTEU5R1UwVXNVMEZCVDBFc1MwRkJTeXhEUVVGRFF5eFBRVUZQTEVWQlFVVTdaMEpCUVVVc1QwRkJUME1zVTBGQk5rSXNVMEZCUTBZc1MwRkJTeXhEUVVGRFNpeHRRMEZCYlVNc1JVRkJSVXNzVDBGQlR5eERRVUZETEVOQlFVTTdZVUZCUlRzN08xbEJSVFZIUlN4SFFVRlhMRVZCUVZoQkxHRkJRVmM3V1VWWWNFSXNUMFpYUlN4VFFVRlBRU3hYUVVGWExFTkJRVU5HTEU5QlFVOHNSVUZCUlR0blFrRkJSU3hQUVVGUFF5eFRRVUUyUWl4VFFVRkRReXhYUVVGWExFTkJRVU5RTEcxRFFVRnRReXhGUVVGRlN5eFBRVUZQTEVOQlFVTXNRMEZCUXp0aFFVRkZPenROUVZocVNUczdRMEZaUXl4RFFWSm5SVU1zVTBGQk5rSXNVMEZSTjBZN2EwSkJVbTlDVGl4dFEwRkJiVU1zUVVGS2VFUTdRVUZQUlN4blFrRkliVUpCTEcxRFFVRnRReXhGUVVjdlExRXNiVUpCUVdsQ0xHOURRVUZ4UXl4QlFWQXZSQ0o5IiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bGUgfSBmcm9tIFwiLi9ydWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHR5cGVzIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwiLi9zcGVjaWFsU3ltYm9sc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJORkxleGVyIH0gZnJvbSBcIi4vYm5mL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2ljTGV4ZXIgfSBmcm9tIFwiLi9iYXNpYy9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25MZXhlciB9IGZyb20gXCIuL2NvbW1vbi9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50L2VuZE9mTGluZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L2VuZE9mTGluZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFdoaXRlc3BhY2VUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L3doaXRlc3BhY2VcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2YvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL3B5dGhvblN0eWxlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG5cclxuICB7IFwiY29sb3VyXCI6IFwiXiMoPzpbMC05YS1mQS1GXXs2fXxbMC05YS1mQS1GXXszfSlcIiB9LFxyXG5cclxuICB7IFwia2V5d29yZFwiOiBcIl4oPzohaW1wb3J0YW50fEBtZWRpYSlcIiB9LFxyXG5cclxuICB7IFwicGVyY2VudGFnZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspXFxcXCVcIiB9LFxyXG5cclxuICB7IFwiZnJlcXVlbmN5XCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKykoPzpoenxraHopXCIgfSxcclxuXHJcbiAgeyBcImZyYWN0aW9uXCI6IFwiXlsxLTldWzAtOV0qP2ZyXCIgfSxcclxuXHJcbiAgeyBcImxlbmd0aFwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86cHh8Y218bW18aW58cHR8cGMpXCIgfSxcclxuXHJcbiAgeyBcImFuZ2xlXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKykoPzpkZWd8cmFkfGdyYWQpXCIgfSxcclxuXHJcbiAgeyBcInRpbWVcIjogXCJeKD86WzAtOV0rfFswLTldKlxcXFwuWzAtOV0rKSg/OnN8bXMpXCIgfSxcclxuXHJcbiAgeyBcInJlbXNcIjogXCJeKD86WzAtOV0rfFswLTldKlxcXFwuWzAtOV0rKXJlbVwiIH0sXHJcblxyXG4gIHsgXCJlbXNcIjogXCJeKD86WzAtOV0rfFswLTldKlxcXFwuWzAtOV0rKWVtXCIgfSxcclxuXHJcbiAgeyBcIm51bWJlclwiOiBcIl5bMC05XSt8WzAtOV0qXFxcXC5bMC05XStcIiB9LFxyXG5cclxuICB7IFwic3BlY2lhbFwiOiBcIl47fDo6fDp8XFxcXC58LHwvfFxcXFx8PXx+PXw9fD58XFxcXHt8XFxcXH18XFxcXCh8XFxcXCl8XFxcXFt8XFxcXF1cIiB9LFxyXG5cclxuICB7IFwib3BlcmF0b3JcIjogXCJeXig/OmFuZHxub3R8b25seSkkXCIgfSxcclxuXHJcbiAgeyBcImlkZW50aWZpZXJcIjogXCJeW19hLXpBLVowLTktXStcIiB9LFxyXG5cclxuICB7IFwidW5hcnktb3BlcmF0b3JcIjogXCJeXFxcXCt8XFxcXC1cIiB9LFxyXG5cclxuICB7IFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXStcIiB9XHJcblxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDsgLy8vXHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsOyAvLy9cclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKENTU0xleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoQ1NTTGV4ZXIsIHJ1bGVzKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoQ1NTTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICAgIGRvY3VtZW50ICAgICAgICAgICAgICAgICA6Oj0gICggcnVsZSB8IGVycm9yICkrIDtcblxuICAgICAgcnVsZSAgICAgICAgICAgICAgICAgICAgIDo6PSAgbmFtZSBhbWJpZ3VvdXNNb2RpZmllcj8gXCI6Oj1cIiBkZWZpbml0aW9ucyBcIjtcIiA7XG5cbiAgICAgIG5hbWUgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSA7XG5cbiAgICAgIGRlZmluaXRpb25zICAgICAgICAgICAgICA6Oj0gIGRlZmluaXRpb24gKCBcInxcIiBkZWZpbml0aW9uICkqIDtcblxuICAgICAgZGVmaW5pdGlvbiAgICAgICAgICAgICAgIDo6PSAgcGFydCsgO1xuIFxuICAgICAgcGFydCAgICAgICAgICAgICAgICAgICAgIDo6PSAgbm9uVGVybWluYWxQYXJ0IHF1YW50aWZpZXIqXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub1doaXRlc3BhY2VQYXJ0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgbm9uVGVybWluYWxQYXJ0ICAgICAgICAgIDo6PSAgY2hvaWNlT2ZQYXJ0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzZXF1ZW5jZU9mUGFydHNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcnVsZU5hbWUgbG9va0FoZWFkTW9kaWZpZXI/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgdGVybWluYWxQYXJ0ICAgICAgICAgICAgIDo6PSAgc2lnbmlmaWNhbnRUb2tlblR5cGVcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByZWd1bGFyRXhwcmVzc2lvblxuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdGVybWluYWxTeW1ib2xcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlbmRPZkxpbmVcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB3aWxkY2FyZFxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgbm9XaGl0ZXNwYWNlUGFydCAgICAgICAgIDo6PSAgXCI8Tk9fV0hJVEVTUEFDRT5cIiA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgIGNob2ljZU9mUGFydHMgICAgICAgICAgICA6Oj0gIFwiKFwiIHBhcnQgKCBcInxcIiBwYXJ0ICkrIFwiKVwiIDtcblxuICAgICAgc2VxdWVuY2VPZlBhcnRzICAgICAgICAgIDo6PSAgXCIoXCIgcGFydCBwYXJ0KyBcIilcIiA7XG5cbiAgICAgIHJ1bGVOYW1lICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSA7XG5cbiAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlICAgICA6Oj0gIFt0eXBlXSA7XG5cbiAgICAgIHJlZ3VsYXJFeHByZXNzaW9uICAgICAgICA6Oj0gIFtyZWd1bGFyLWV4cHJlc3Npb25dIDtcblxuICAgICAgdGVybWluYWxTeW1ib2wgICAgICAgICAgIDo6PSAgW3N0cmluZy1saXRlcmFsXSA7XG5cbiAgICAgIGVuZE9mTGluZSAgICAgICAgICAgICAgICA6Oj0gIFwiPEVORF9PRl9MSU5FPlwiIDtcblxuICAgICAgd2lsZGNhcmQgICAgICAgICAgICAgICAgIDo6PSAgXCIuXCIgO1xuXG4gICAgICBxdWFudGlmaWVyICAgICAgICAgICAgICAgOjo9ICBvcHRpb25hbFF1YW50aWZpZXJcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9uZU9yTW9yZVF1YW50aWZpZXJcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB6ZXJvT3JNb3JlUXVhbnRpZmllclxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgYW1iaWd1b3VzTW9kaWZpZXIgICAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIhXCIgO1xuXG4gICAgICBsb29rQWhlYWRNb2RpZmllciAgICAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIi4uLlwiIDtcblxuICAgICAgb3B0aW9uYWxRdWFudGlmaWVyICAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCI/XCIgO1xuXG4gICAgICBvbmVPck1vcmVRdWFudGlmaWVyICAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIitcIiA7XG5cbiAgICAgIHplcm9Pck1vcmVRdWFudGlmaWVyICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiKlwiIDtcblxuICAgICAgZXJyb3IgICAgICAgICAgICAgICAgICAgIDo6PSAgLiA7XG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWRkaW5nRnJvbVBhZGRpbmdMZW5ndGgocGFkZGluZ0xlbmd0aCkge1xuICBsZXQgcGFkZGluZyA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgcGFkZGluZ0xlbmd0aDsgcG9zaXRpb24rKykge1xuICAgIHBhZGRpbmcgKz0gU1BBQ0VfQ0hBUkFDVEVSO1xuICB9XG5cbiAgcmV0dXJuIHBhZGRpbmc7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIF9zdHJpbmcgPSByZXF1aXJlKFwiLi91dGlsaXRpZXMvc3RyaW5nXCIpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG52YXIgZXhjbGFtYXRpb25NYXJrID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmV4Y2xhbWF0aW9uTWFyaztcbnZhciBSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBSdWxlKG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYW1iaWd1b3VzID0gYW1iaWd1b3VzO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgICAgIHRoaXMuTm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUnVsZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzQW1iaWd1b3VzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNBbWJpZ3VvdXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW1iaWd1b3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9ucygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldE5vblRlcm1pbmFsTm9kZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vblRlcm1pbmFsTm9kZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Ob25UZXJtaW5hbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJzZXROYW1lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmFtZShuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNldEFtYmlndW91c1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFtYmlndW91cyhhbWJpZ3VvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFtYmlndW91cyA9IGFtYmlndW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNldERlZmluaXRpb25zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJzZXROb25UZXJtaW5hbE5vZGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROb25UZXJtaW5hbE5vZGUoTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Ob25UZXJtaW5hbE5vZGUgPSBOb25UZXJtaW5hbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhZGREZWZpbml0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRGVmaW5pdGlvbihkZWZpbml0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uc0luY2x1ZGVzRGVmaW5pdGlvbiA9IHRoaXMuZGVmaW5pdGlvbnMuaW5jbHVkZXMoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uc0luY2x1ZGVzRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25zTGVuZ3RoID0gdGhpcy5kZWZpbml0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGRlZmluaXRpb25zTGVuZ3RoOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwb3NpdGlvbiwgZGVsZXRlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluaXRpb25zLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJlbW92ZURlZmluaXRpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVEZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbnNJbmNsdWRlc0RlZmluaXRpb24gPSB0aGlzLmRlZmluaXRpb25zLmluY2x1ZGVzKGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc0luY2x1ZGVzRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbkluZGV4ID0gdGhpcy5kZWZpbml0aW9ucy5pbmRleE9mKGRlZmluaXRpb24pLCBzdGFydCA9IGRlZmluaXRpb25JbmRleCwgZGVsZXRlQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluaXRpb25zLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJlcGxhY2VEZWZpbml0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZURlZmluaXRpb24ob2xkRGVmaW5pdGlvbiwgbmV3RGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBvbGREZWZpbml0aW9uSW5kZXggPSB0aGlzLmRlZmluaXRpb25zLmluZGV4T2Yob2xkRGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKG9sZERlZmluaXRpb25JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG9sZERlZmluaXRpb25JbmRleCwgZGVsZXRlQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluaXRpb25zLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5ld0RlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uoc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcnVsZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLmluY3JlYXNlRGVwdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9vRGVlcCA9IHN0YXRlLmlzVG9vRGVlcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0b29EZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwYXJzZSB0cmVlIGlzIHRvbyBkZWVwIGF0IHJ1bGUgXFxcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiXFxcIi5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkLCBkZWZpbml0aW9uTm9kZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5zb21lKGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbk5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IF90aGlzLnBhcnNlRGVmaW5pdGlvbihkZWZpbml0aW9uLCBkZWZpbml0aW9uTm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZU5hbWUgPSB0aGlzLm5hbWUsIGNoaWxkTm9kZXMgPSBkZWZpbml0aW9uTm9kZXMsIG5vblRlcm1pbmFsTm9kZSA9IHRoaXMuTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBydWxlTm9kZSA9IG5vblRlcm1pbmFsTm9kZTsgLy8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmRlY3JlYXNlRGVwdGgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwYXJzZURlZmluaXRpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURlZmluaXRpb24oZGVmaW5pdGlvbiwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gZGVmaW5pdGlvbi5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzU3RyaW5nKG1heGltdW1SdWxlTmFtZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aUxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25zTGVuZ3RoID0gdGhpcy5kZWZpbml0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbXVsdGlMaW5lID0gbXVsdGlMaW5lICYmIGRlZmluaXRpb25zTGVuZ3RoID4gMTsgLy8vXG4gICAgICAgICAgICAgICAgdmFyIG1heGltdW1QYWRkaW5nID0gKDAsIF9zdHJpbmcpLnBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aChtYXhpbXVtUnVsZU5hbWVMZW5ndGgpLCBkZWZpbml0aW9uc1N0cmluZzEgPSB0aGlzLmRlZmluaXRpb25zLnJlZHVjZShmdW5jdGlvbihkZWZpbml0aW9uc1N0cmluZywgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zU3RyaW5nID09PSBfY29uc3RhbnRzLkVNUFRZX1NUUklORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnNTdHJpbmcgPSBkZWZpbml0aW9uU3RyaW5nOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zU3RyaW5nID0gbXVsdGlMaW5lID8gXCJcIi5jb25jYXQoZGVmaW5pdGlvbnNTdHJpbmcsIFwiXFxuXFxuXCIpLmNvbmNhdChtYXhpbXVtUGFkZGluZywgXCIgICB8IFwiKS5jb25jYXQoZGVmaW5pdGlvblN0cmluZykgOiBcIlwiLmNvbmNhdChkZWZpbml0aW9uc1N0cmluZywgXCIgfCBcIikuY29uY2F0KGRlZmluaXRpb25TdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uc1N0cmluZztcbiAgICAgICAgICAgICAgICB9LCBfY29uc3RhbnRzLkVNUFRZX1NUUklORyksIHJ1bGVOYW1lID0gdGhpcy5uYW1lLCBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aCwgYW1iaWd1b3VzU3RyaW5nID0gdGhpcy5hbWJpZ3VvdXMgPyBleGNsYW1hdGlvbk1hcmsgOiBfY29uc3RhbnRzLkVNUFRZX1NUUklORywgYW1iaWd1b3VzU3RyaW5nTGVuZ3RoID0gYW1iaWd1b3VzU3RyaW5nLmxlbmd0aCwgcGFkZGluZ0xlbmd0aCA9IG1heGltdW1SdWxlTmFtZUxlbmd0aCAtIHJ1bGVOYW1lTGVuZ3RoIC0gYW1iaWd1b3VzU3RyaW5nTGVuZ3RoLCBwYWRkaW5nID0gKDAsIF9zdHJpbmcpLnBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aChwYWRkaW5nTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VtaWNvbG9uU3RyaW5nID0gbXVsdGlMaW5lID8gXCJcXG5cXG5cIi5jb25jYXQobWF4aW11bVBhZGRpbmcsIFwiICAgO1wiKSA6IFwiIDtcIiwgc3RyaW5nID0gXCJcXG5cXG5cIi5jb25jYXQodGhpcy5uYW1lKS5jb25jYXQoYW1iaWd1b3VzU3RyaW5nKS5jb25jYXQocGFkZGluZywgXCIgOjo9IFwiKS5jb25jYXQoZGVmaW5pdGlvbnNTdHJpbmcxKS5jb25jYXQoc2VtaWNvbG9uU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZShDbGFzcywgcnVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IENsYXNzO1xuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFJ1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcnVsZS5nZXROYW1lKCksIGFtYmlndW91cyA9IHJ1bGUuaXNBbWJpZ3VvdXMoKSwgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCksIE5vblRlcm1pbmFsTm9kZSA9IHJ1bGUuZ2V0Tm9uVGVybWluYWxOb2RlKCk7XG4gICAgICAgICAgICAgICAgcnVsZSA9IG5ldyBDbGFzcyhuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb25UZXJtaW5hbE5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJ1bGU7XG59KCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSdWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OXlkV3hsTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdleUJ6Y0dWamFXRnNVM2x0WW05c2N5QjlJR1p5YjIwZ1hDSnZZMk5oYlMxc1pYaGxjbk5jSWp0Y2JseHVhVzF3YjNKMElIc2dSVTFRVkZsZlUxUlNTVTVISUgwZ1puSnZiU0JjSWk0dlkyOXVjM1JoYm5SelhDSTdYRzVwYlhCdmNuUWdleUJ3WVdSa2FXNW5Sbkp2YlZCaFpHUnBibWRNWlc1bmRHZ2dmU0JtY205dElGd2lMaTkxZEdsc2FYUnBaWE12YzNSeWFXNW5YQ0k3WEc1Y2JtTnZibk4wSUhzZ1pYaGpiR0Z0WVhScGIyNU5ZWEpySUgwZ1BTQnpjR1ZqYVdGc1UzbHRZbTlzY3p0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVW5Wc1pTQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtHNWhiV1VzSUdGdFltbG5kVzkxY3l3Z1pHVm1hVzVwZEdsdmJuTXNJRTV2YmxSbGNtMXBibUZzVG05a1pTa2dlMXh1SUNBZ0lIUm9hWE11Ym1GdFpTQTlJRzVoYldVN1hHNGdJQ0FnZEdocGN5NWhiV0pwWjNWdmRYTWdQU0JoYldKcFozVnZkWE03WEc0Z0lDQWdkR2hwY3k1a1pXWnBibWwwYVc5dWN5QTlJR1JsWm1sdWFYUnBiMjV6TzF4dUlDQWdJSFJvYVhNdVRtOXVWR1Z5YldsdVlXeE9iMlJsSUQwZ1RtOXVWR1Z5YldsdVlXeE9iMlJsTzF4dUlDQjlYRzVjYmlBZ1oyVjBUbUZ0WlNncElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NXVZVzFsTzF4dUlDQjlYRzVjYmlBZ2FYTkJiV0pwWjNWdmRYTW9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11WVcxaWFXZDFiM1Z6TzF4dUlDQjlYRzVjYmlBZ1oyVjBSR1ZtYVc1cGRHbHZibk1vS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVpHVm1hVzVwZEdsdmJuTTdYRzRnSUgxY2JseHVJQ0JuWlhST2IyNVVaWEp0YVc1aGJFNXZaR1VvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVRtOXVWR1Z5YldsdVlXeE9iMlJsTzF4dUlDQjlYRzVjYmlBZ2MyVjBUbUZ0WlNodVlXMWxLU0I3WEc0Z0lDQWdkR2hwY3k1dVlXMWxJRDBnYm1GdFpUdGNiaUFnZlZ4dVhHNGdJSE5sZEVGdFltbG5kVzkxY3loaGJXSnBaM1Z2ZFhNcElIdGNiaUFnSUNCMGFHbHpMbUZ0WW1sbmRXOTFjeUE5SUdGdFltbG5kVzkxY3p0Y2JpQWdmVnh1WEc0Z0lITmxkRVJsWm1sdWFYUnBiMjV6S0dSbFptbHVhWFJwYjI1ektTQjdYRzRnSUNBZ2RHaHBjeTVrWldacGJtbDBhVzl1Y3lBOUlHUmxabWx1YVhScGIyNXpPMXh1SUNCOVhHNWNiaUFnYzJWMFRtOXVWR1Z5YldsdVlXeE9iMlJsS0U1dmJsUmxjbTFwYm1Gc1RtOWtaU2tnZTF4dUlDQWdJSFJvYVhNdVRtOXVWR1Z5YldsdVlXeE9iMlJsSUQwZ1RtOXVWR1Z5YldsdVlXeE9iMlJsTzF4dUlDQjlYRzVjYmlBZ1lXUmtSR1ZtYVc1cGRHbHZiaWhrWldacGJtbDBhVzl1TENCd2IzTnBkR2x2YmlrZ2UxeHVJQ0FnSUdOdmJuTjBJR1JsWm1sdWFYUnBiMjV6U1c1amJIVmtaWE5FWldacGJtbDBhVzl1SUQwZ2RHaHBjeTVrWldacGJtbDBhVzl1Y3k1cGJtTnNkV1JsY3loa1pXWnBibWwwYVc5dUtUdGNibHh1SUNBZ0lHbG1JQ2doWkdWbWFXNXBkR2x2Ym5OSmJtTnNkV1JsYzBSbFptbHVhWFJwYjI0cElIdGNiaUFnSUNBZ0lHbG1JQ2h3YjNOcGRHbHZiaUE5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElHUmxabWx1YVhScGIyNXpUR1Z1WjNSb0lEMGdkR2hwY3k1a1pXWnBibWwwYVc5dWN5NXNaVzVuZEdnN1hHNWNiaUFnSUNBZ0lDQWdjRzl6YVhScGIyNGdQU0JrWldacGJtbDBhVzl1YzB4bGJtZDBhRHNnTHk4dlhHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHTnZibk4wSUhOMFlYSjBJRDBnY0c5emFYUnBiMjRzSUM4dkwxeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdWc1pYUmxRMjkxYm5RZ1BTQXdPMXh1WEc0Z0lDQWdJQ0IwYUdsekxtUmxabWx1YVhScGIyNXpMbk53YkdsalpTaHpkR0Z5ZEN3Z1pHVnNaWFJsUTI5MWJuUXNJR1JsWm1sdWFYUnBiMjRwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGJXOTJaVVJsWm1sdWFYUnBiMjRvWkdWbWFXNXBkR2x2YmlrZ2UxeHVJQ0FnSUdOdmJuTjBJR1JsWm1sdWFYUnBiMjV6U1c1amJIVmtaWE5FWldacGJtbDBhVzl1SUQwZ2RHaHBjeTVrWldacGJtbDBhVzl1Y3k1cGJtTnNkV1JsY3loa1pXWnBibWwwYVc5dUtUdGNibHh1SUNBZ0lHbG1JQ2hrWldacGJtbDBhVzl1YzBsdVkyeDFaR1Z6UkdWbWFXNXBkR2x2YmlrZ2UxeHVJQ0FnSUNBZ1kyOXVjM1FnWkdWbWFXNXBkR2x2YmtsdVpHVjRJRDBnZEdocGN5NWtaV1pwYm1sMGFXOXVjeTVwYm1SbGVFOW1LR1JsWm1sdWFYUnBiMjRwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjM1JoY25RZ1BTQmtaV1pwYm1sMGFXOXVTVzVrWlhnc0lDQXZMeTljYmlBZ0lDQWdJQ0FnSUNBZ0lHUmxiR1YwWlVOdmRXNTBJRDBnTVR0Y2JseHVJQ0FnSUNBZ2RHaHBjeTVrWldacGJtbDBhVzl1Y3k1emNHeHBZMlVvYzNSaGNuUXNJR1JsYkdWMFpVTnZkVzUwS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYQnNZV05sUkdWbWFXNXBkR2x2YmlodmJHUkVaV1pwYm1sMGFXOXVMQ0J1WlhkRVpXWnBibWwwYVc5dUtTQjdYRzRnSUNBZ1kyOXVjM1FnYjJ4a1JHVm1hVzVwZEdsdmJrbHVaR1Y0SUQwZ2RHaHBjeTVrWldacGJtbDBhVzl1Y3k1cGJtUmxlRTltS0c5c1pFUmxabWx1YVhScGIyNHBPMXh1WEc0Z0lDQWdhV1lnS0c5c1pFUmxabWx1YVhScGIyNUpibVJsZUNBK0lDMHhLU0I3WEc0Z0lDQWdJQ0JqYjI1emRDQnpkR0Z5ZENBOUlHOXNaRVJsWm1sdWFYUnBiMjVKYm1SbGVDd2dMeTh2WEc0Z0lDQWdJQ0FnSUNBZ0lDQmtaV3hsZEdWRGIzVnVkQ0E5SURFN1hHNWNiaUFnSUNBZ0lIUm9hWE11WkdWbWFXNXBkR2x2Ym5NdWMzQnNhV05sS0hOMFlYSjBMQ0JrWld4bGRHVkRiM1Z1ZEN3Z2JtVjNSR1ZtYVc1cGRHbHZiaWxjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J3WVhKelpTaHpkR0YwWlN3Z1kyRnNiR0poWTJzcElIdGNiaUFnSUNCc1pYUWdjblZzWlU1dlpHVWdQU0J1ZFd4c08xeHVYRzRnSUNBZ2MzUmhkR1V1YVc1amNtVmhjMlZFWlhCMGFDZ3BPMXh1WEc0Z0lDQWdZMjl1YzNRZ2RHOXZSR1ZsY0NBOUlITjBZWFJsTG1selZHOXZSR1ZsY0NncE8xeHVYRzRnSUNBZ2FXWWdLSFJ2YjBSbFpYQXBJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaGdWR2hsSUhCaGNuTmxJSFJ5WldVZ2FYTWdkRzl2SUdSbFpYQWdZWFFnY25Wc1pTQmNJaVI3ZEdocGN5NXVZVzFsZlZ3aUxtQXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHeGxkQ0J3WVhKelpXUXNYRzRnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjVPYjJSbGN6dGNibHh1SUNBZ0lIUm9hWE11WkdWbWFXNXBkR2x2Ym5NdWMyOXRaU2dvWkdWbWFXNXBkR2x2YmlrZ1BUNGdlMXh1SUNBZ0lDQWdaR1ZtYVc1cGRHbHZiazV2WkdWeklEMGdXMTA3WEc1Y2JpQWdJQ0FnSUhCaGNuTmxaQ0E5SUhSb2FYTXVjR0Z5YzJWRVpXWnBibWwwYVc5dUtHUmxabWx1YVhScGIyNHNJR1JsWm1sdWFYUnBiMjVPYjJSbGN5d2djM1JoZEdVc0lHTmhiR3hpWVdOcktUdGNibHh1SUNBZ0lDQWdhV1lnS0hCaGNuTmxaQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEhKMVpUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOUtUdGNibHh1SUNBZ0lHbG1JQ2h3WVhKelpXUXBJSHRjYmlBZ0lDQWdJR052Ym5OMElISjFiR1ZPWVcxbElEMGdkR2hwY3k1dVlXMWxMQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQWdJR05vYVd4a1RtOWtaWE1nUFNCa1pXWnBibWwwYVc5dVRtOWtaWE1zSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0FnSUc1dmJsUmxjbTFwYm1Gc1RtOWtaU0E5SUhSb2FYTXVUbTl1VkdWeWJXbHVZV3hPYjJSbExtWnliMjFTZFd4bFRtRnRaVUZ1WkVOb2FXeGtUbTlrWlhNb2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBPMXh1WEc0Z0lDQWdJQ0J5ZFd4bFRtOWtaU0E5SUc1dmJsUmxjbTFwYm1Gc1RtOWtaVHNnTHk4dlhHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzNSaGRHVXVaR1ZqY21WaGMyVkVaWEIwYUNncE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhKMWJHVk9iMlJsTzF4dUlDQjlYRzVjYmlBZ2NHRnljMlZFWldacGJtbDBhVzl1S0dSbFptbHVhWFJwYjI0c0lHNXZaR1Z6TENCemRHRjBaU3dnWTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0JzWlhRZ2NHRnljMlZrTzF4dVhHNGdJQ0FnWTI5dWMzUWdjMkYyWldSSmJtUmxlQ0E5SUhOMFlYUmxMbWRsZEZOaGRtVmtTVzVrWlhnb0tUdGNibHh1SUNBZ0lIQmhjbk5sWkNBOUlHUmxabWx1YVhScGIyNHVjR0Z5YzJVb2JtOWtaWE1zSUhOMFlYUmxMQ0JqWVd4c1ltRmpheWs3WEc1Y2JpQWdJQ0JwWmlBb0lYQmhjbk5sWkNrZ2UxeHVJQ0FnSUNBZ2MzUmhkR1V1WW1GamEzUnlZV05yS0hOaGRtVmtTVzVrWlhncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUJ3WVhKelpXUTdYRzRnSUgxY2JseHVJQ0JoYzFOMGNtbHVaeWh0WVhocGJYVnRVblZzWlU1aGJXVk1aVzVuZEdnc0lHMTFiSFJwVEdsdVpTQTlJSFJ5ZFdVcElIdGNiaUFnSUNCamIyNXpkQ0JrWldacGJtbDBhVzl1YzB4bGJtZDBhQ0E5SUhSb2FYTXVaR1ZtYVc1cGRHbHZibk11YkdWdVozUm9PMXh1WEc0Z0lDQWdiWFZzZEdsTWFXNWxJRDBnYlhWc2RHbE1hVzVsSUNZbUlDaGtaV1pwYm1sMGFXOXVjMHhsYm1kMGFDQStJREVwT3lBZ0x5OHZYRzVjYmlBZ0lDQmpiMjV6ZENCdFlYaHBiWFZ0VUdGa1pHbHVaeUE5SUhCaFpHUnBibWRHY205dFVHRmtaR2x1WjB4bGJtZDBhQ2h0WVhocGJYVnRVblZzWlU1aGJXVk1aVzVuZEdncExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6VTNSeWFXNW5JRDBnZEdocGN5NWtaV1pwYm1sMGFXOXVjeTV5WldSMVkyVW9LR1JsWm1sdWFYUnBiMjV6VTNSeWFXNW5MQ0JrWldacGJtbDBhVzl1S1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JrWldacGJtbDBhVzl1VTNSeWFXNW5JRDBnWkdWbWFXNXBkR2x2Ymk1aGMxTjBjbWx1WnlncE8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9aR1ZtYVc1cGRHbHZibk5UZEhKcGJtY2dQVDA5SUVWTlVGUlpYMU5VVWtsT1J5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmtaV1pwYm1sMGFXOXVjMU4wY21sdVp5QTlJR1JsWm1sdWFYUnBiMjVUZEhKcGJtYzdJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1pHVm1hVzVwZEdsdmJuTlRkSEpwYm1jZ1BTQnRkV3gwYVV4cGJtVWdQMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JnSkh0a1pXWnBibWwwYVc5dWMxTjBjbWx1WjMxY2JseHVKSHR0WVhocGJYVnRVR0ZrWkdsdVozMGdJQ0I4SUNSN1pHVm1hVzVwZEdsdmJsTjBjbWx1WjMxZ0lEcGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JnSkh0a1pXWnBibWwwYVc5dWMxTjBjbWx1WjMwZ2ZDQWtlMlJsWm1sdWFYUnBiMjVUZEhKcGJtZDlZRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdSbFptbHVhWFJwYjI1elUzUnlhVzVuTzF4dUlDQWdJQ0FnSUNBZ0lIMHNJRVZOVUZSWlgxTlVVa2xPUnlrc1hHNGdJQ0FnSUNBZ0lDQWdjblZzWlU1aGJXVWdQU0IwYUdsekxtNWhiV1VzSUM4dkwxeHVJQ0FnSUNBZ0lDQWdJSEoxYkdWT1lXMWxUR1Z1WjNSb0lEMGdjblZzWlU1aGJXVXViR1Z1WjNSb0xGeHVJQ0FnSUNBZ0lDQWdJR0Z0WW1sbmRXOTFjMU4wY21sdVp5QTlJSFJvYVhNdVlXMWlhV2QxYjNWeklEOWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdWNFkyeGhiV0YwYVc5dVRXRnlheUE2WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRVZOVUZSWlgxTlVVa2xPUnl4Y2JpQWdJQ0FnSUNBZ0lDQmhiV0pwWjNWdmRYTlRkSEpwYm1kTVpXNW5kR2dnUFNCaGJXSnBaM1Z2ZFhOVGRISnBibWN1YkdWdVozUm9MRnh1SUNBZ0lDQWdJQ0FnSUhCaFpHUnBibWRNWlc1bmRHZ2dQU0J0WVhocGJYVnRVblZzWlU1aGJXVk1aVzVuZEdnZ0xTQnlkV3hsVG1GdFpVeGxibWQwYUNBdElHRnRZbWxuZFc5MWMxTjBjbWx1WjB4bGJtZDBhQ3hjYmlBZ0lDQWdJQ0FnSUNCd1lXUmthVzVuSUQwZ2NHRmtaR2x1WjBaeWIyMVFZV1JrYVc1blRHVnVaM1JvS0hCaFpHUnBibWRNWlc1bmRHZ3BPMXh1WEc0Z0lDQWdZMjl1YzNRZ2MyVnRhV052Ykc5dVUzUnlhVzVuSUQwZ2JYVnNkR2xNYVc1bElEOWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWUZ4dVhHNGtlMjFoZUdsdGRXMVFZV1JrYVc1bmZTQWdJRHRnSURwY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JjSWlBN1hDSXNYRzRnSUNBZ0lDQWdJQ0FnYzNSeWFXNW5JRDBnWUZ4dVhHNGtlM1JvYVhNdWJtRnRaWDBrZTJGdFltbG5kVzkxYzFOMGNtbHVaMzBrZTNCaFpHUnBibWQ5SURvNlBTQWtlMlJsWm1sdWFYUnBiMjV6VTNSeWFXNW5mU1I3YzJWdGFXTnZiRzl1VTNSeWFXNW5mV0E3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjM1J5YVc1bk8xeHVJQ0I5WEc1Y2JpQWdjM1JoZEdsaklHWnliMjFTZFd4bEtFTnNZWE56TENCeWRXeGxLU0I3WEc0Z0lDQWdhV1lnS0hKMWJHVWdQVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUNBZ2NuVnNaU0E5SUVOc1lYTnpPMXh1SUNBZ0lDQWdRMnhoYzNNZ1BTQlNkV3hsTzF4dUlDQWdJSDFjYmlBZ0lDQmNiaUFnSUNCamIyNXpkQ0J1WVcxbElEMGdjblZzWlM1blpYUk9ZVzFsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdZVzFpYVdkMWIzVnpJRDBnY25Wc1pTNXBjMEZ0WW1sbmRXOTFjeWdwTEZ4dUlDQWdJQ0FnSUNBZ0lHUmxabWx1YVhScGIyNXpJRDBnY25Wc1pTNW5aWFJFWldacGJtbDBhVzl1Y3lncExGeHVJQ0FnSUNBZ0lDQWdJRTV2YmxSbGNtMXBibUZzVG05a1pTQTlJSEoxYkdVdVoyVjBUbTl1VkdWeWJXbHVZV3hPYjJSbEtDazdYRzVjYmlBZ0lDQnlkV3hsSUQwZ2JtVjNJRU5zWVhOektHNWhiV1VzSUdGdFltbG5kVzkxY3l3Z1pHVm1hVzVwZEdsdmJuTXNJRTV2YmxSbGNtMXBibUZzVG05a1pTazdYRzVjYmlBZ0lDQnlaWFIxY200Z2NuVnNaVHRjYmlBZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYkltVjRZMnhoYldGMGFXOXVUV0Z5YXlJc0luTndaV05wWVd4VGVXMWliMnh6SWl3aVVuVnNaU0lzSW01aGJXVWlMQ0poYldKcFozVnZkWE1pTENKa1pXWnBibWwwYVc5dWN5SXNJazV2YmxSbGNtMXBibUZzVG05a1pTSXNJbWRsZEU1aGJXVWlMQ0pwYzBGdFltbG5kVzkxY3lJc0ltZGxkRVJsWm1sdWFYUnBiMjV6SWl3aVoyVjBUbTl1VkdWeWJXbHVZV3hPYjJSbElpd2ljMlYwVG1GdFpTSXNJbk5sZEVGdFltbG5kVzkxY3lJc0luTmxkRVJsWm1sdWFYUnBiMjV6SWl3aWMyVjBUbTl1VkdWeWJXbHVZV3hPYjJSbElpd2lZV1JrUkdWbWFXNXBkR2x2YmlJc0ltUmxabWx1YVhScGIyNGlMQ0p3YjNOcGRHbHZiaUlzSW1SbFptbHVhWFJwYjI1elNXNWpiSFZrWlhORVpXWnBibWwwYVc5dUlpd2lhVzVqYkhWa1pYTWlMQ0oxYm1SbFptbHVaV1FpTENKa1pXWnBibWwwYVc5dWMweGxibWQwYUNJc0lteGxibWQwYUNJc0luTjBZWEowSWl3aVpHVnNaWFJsUTI5MWJuUWlMQ0p6Y0d4cFkyVWlMQ0p5WlcxdmRtVkVaV1pwYm1sMGFXOXVJaXdpWkdWbWFXNXBkR2x2YmtsdVpHVjRJaXdpYVc1a1pYaFBaaUlzSW5KbGNHeGhZMlZFWldacGJtbDBhVzl1SWl3aWIyeGtSR1ZtYVc1cGRHbHZiaUlzSW01bGQwUmxabWx1YVhScGIyNGlMQ0p2YkdSRVpXWnBibWwwYVc5dVNXNWtaWGdpTENKd1lYSnpaU0lzSW5OMFlYUmxJaXdpWTJGc2JHSmhZMnNpTENKeWRXeGxUbTlrWlNJc0ltbHVZM0psWVhObFJHVndkR2dpTENKMGIyOUVaV1Z3SWl3aWFYTlViMjlFWldWd0lpd2lSWEp5YjNJaUxDSndZWEp6WldRaUxDSmtaV1pwYm1sMGFXOXVUbTlrWlhNaUxDSnpiMjFsSWl3aWNHRnljMlZFWldacGJtbDBhVzl1SWl3aWNuVnNaVTVoYldVaUxDSmphR2xzWkU1dlpHVnpJaXdpYm05dVZHVnliV2x1WVd4T2IyUmxJaXdpWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeUlzSW1SbFkzSmxZWE5sUkdWd2RHZ2lMQ0p1YjJSbGN5SXNJbk5oZG1Wa1NXNWtaWGdpTENKblpYUlRZWFpsWkVsdVpHVjRJaXdpWW1GamEzUnlZV05ySWl3aVlYTlRkSEpwYm1jaUxDSnRZWGhwYlhWdFVuVnNaVTVoYldWTVpXNW5kR2dpTENKdGRXeDBhVXhwYm1VaUxDSnRZWGhwYlhWdFVHRmtaR2x1WnlJc0luQmhaR1JwYm1kR2NtOXRVR0ZrWkdsdVoweGxibWQwYUNJc0ltUmxabWx1YVhScGIyNXpVM1J5YVc1bklpd2ljbVZrZFdObElpd2laR1ZtYVc1cGRHbHZibE4wY21sdVp5SXNJa1ZOVUZSWlgxTlVVa2xPUnlJc0luSjFiR1ZPWVcxbFRHVnVaM1JvSWl3aVlXMWlhV2QxYjNWelUzUnlhVzVuSWl3aVlXMWlhV2QxYjNWelUzUnlhVzVuVEdWdVozUm9JaXdpY0dGa1pHbHVaMHhsYm1kMGFDSXNJbkJoWkdScGJtY2lMQ0p6WlcxcFkyOXNiMjVUZEhKcGJtY2lMQ0p6ZEhKcGJtY2lMQ0ptY205dFVuVnNaU0lzSWtOc1lYTnpJaXdpY25Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXJRaXhKUVVGQkxGbEJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdRVUZGYUVJc1NVRkJRU3hWUVVGaExGZEJRV0lzWVVGQllTeERRVUZCTzBGQlEwUXNTVUZCUVN4UFFVRnZRaXhYUVVGd1FpeHZRa0ZCYjBJc1EwRkJRVHM3T3pzN096czdPemhFUVV3M1JEdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN08wRkJUMEVzU1VGQlRTeEJRVUZGUVN4bFFVRmxMRWRCUVV0RExGbEJRV01zWjBKQlFXeERSQ3hsUVVGbExFRkJRVzFDTEVGQlFVTTdRVUZGTlVJc1NVRkJRU3hCUVVGTlJTeEpRVUZKTEdsQ1ExUjBRaXhCUkZOWk8yRkJRVTFCTEVsQlFVa3NRMEZEV0VNc1NVRkJTU3hGUVVGRlF5eFRRVUZUTEVWQlFVVkRMRmRCUVZjc1JVRkJSVU1zWlVGQlpUdHRRMEZXTTBRN1VVRlhTU3hKUVVGSkxFTkJRVU5JTEVsQlFVa3NSMEZCUjBFc1NVRkJTU3hEUVVGRE8xRkJRMnBDTEVsQlFVa3NRMEZCUTBNc1UwRkJVeXhIUVVGSFFTeFRRVUZUTEVOQlFVTTdVVUZETTBJc1NVRkJTU3hEUVVGRFF5eFhRVUZYTEVkQlFVZEJMRmRCUVZjc1EwRkJRenRSUVVNdlFpeEpRVUZKTEVOQlFVTkRMR1ZCUVdVc1IwRkJSMEVzWlVGQlpTeERRVUZET3pzN08xbEJSM3BEUXl4SFFVRlBMRVZCUVZCQkxGTkJRVTg3V1VWcVFsUXNUMFpwUWtWQkxGTkJRVUZCTEU5QlFVOHNSMEZCUnp0blFrRkRVaXhQUVVGUExFbEJRVWtzUTBGQlEwb3NTVUZCU1N4RFFVRkRPMkZCUTJ4Q096czdXVUZGUkVzc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRmNrSmlMRTlHY1VKRlFTeFRRVUZCUVN4WFFVRlhMRWRCUVVjN1owSkJRMW9zVDBGQlR5eEpRVUZKTEVOQlFVTktMRk5CUVZNc1EwRkJRenRoUVVOMlFqczdPMWxCUlVSTExFZEJRV01zUlVGQlpFRXNaMEpCUVdNN1dVVjZRbWhDTEU5R2VVSkZRU3hUUVVGQlFTeGpRVUZqTEVkQlFVYzdaMEpCUTJZc1QwRkJUeXhKUVVGSkxFTkJRVU5LTEZkQlFWY3NRMEZCUXp0aFFVTjZRanM3TzFsQlJVUkxMRWRCUVd0Q0xFVkJRV3hDUVN4dlFrRkJhMEk3V1VVM1FuQkNMRTlHTmtKRlFTeFRRVUZCUVN4clFrRkJhMElzUjBGQlJ6dG5Ra0ZEYmtJc1QwRkJUeXhKUVVGSkxFTkJRVU5LTEdWQlFXVXNRMEZCUXp0aFFVTTNRanM3TzFsQlJVUkxMRWRCUVU4c1JVRkJVRUVzVTBGQlR6dFpSV3BEVkN4UFJtbERSVUVzVTBGQlFVRXNUMEZCVHl4RFFVRkRVaXhKUVVGSkxFVkJRVVU3WjBKQlExb3NTVUZCU1N4RFFVRkRRU3hKUVVGSkxFZEJRVWRCTEVsQlFVa3NRMEZCUXp0aFFVTnNRanM3TzFsQlJVUlRMRWRCUVZrc1JVRkJXa0VzWTBGQldUdFpSWEpEWkN4UFJuRkRSVUVzVTBGQlFVRXNXVUZCV1N4RFFVRkRVaXhUUVVGVExFVkJRVVU3WjBKQlEzUkNMRWxCUVVrc1EwRkJRMEVzVTBGQlV5eEhRVUZIUVN4VFFVRlRMRU5CUVVNN1lVRkROVUk3T3p0WlFVVkVVeXhIUVVGakxFVkJRV1JCTEdkQ1FVRmpPMWxGZWtOb1FpeFBSbmxEUlVFc1UwRkJRVUVzWTBGQll5eERRVUZEVWl4WFFVRlhMRVZCUVVVN1owSkJRekZDTEVsQlFVa3NRMEZCUTBFc1YwRkJWeXhIUVVGSFFTeFhRVUZYTEVOQlFVTTdZVUZEYUVNN096dFpRVVZFVXl4SFFVRnJRaXhGUVVGc1FrRXNiMEpCUVd0Q08xbEZOME53UWl4UFJqWkRSVUVzVTBGQlFVRXNhMEpCUVd0Q0xFTkJRVU5TTEdWQlFXVXNSVUZCUlR0blFrRkRiRU1zU1VGQlNTeERRVUZEUVN4bFFVRmxMRWRCUVVkQkxHVkJRV1VzUTBGQlF6dGhRVU40UXpzN08xbEJSVVJUTEVkQlFXRXNSVUZCWWtFc1pVRkJZVHRaUldwRVppeFBSbWxFUlVFc1UwRkJRVUVzWVVGQllTeERRVUZEUXl4VlFVRlZMRVZCUVVWRExGRkJRVkVzUlVGQlJUdG5Ra0ZEYkVNc1NVRkJUVU1zTmtKQlFUWkNMRWRCUVVjc1NVRkJTU3hEUVVGRFlpeFhRVUZYTEVOQlFVTmpMRkZCUVZFc1EwRkJRMGdzVlVGQlZTeERRVUZETEVGQlFVTTdaMEpCUlRWRkxFbEJRVWtzUTBGQlEwVXNOa0pCUVRaQ0xFVkJRVVU3YjBKQlEyeERMRWxCUVVsRUxGRkJRVkVzUzBGQlMwY3NVMEZCVXl4RlFVRkZPM2RDUVVNeFFpeEpRVUZOUXl4cFFrRkJhVUlzUjBGQlJ5eEpRVUZKTEVOQlFVTm9RaXhYUVVGWExFTkJRVU5wUWl4TlFVRk5MRUZCUVVNN2QwSkJSV3hFVEN4UlFVRlJMRWRCUVVkSkxHbENRVUZwUWl4RFFVRkRMRU5CUVVNc1IwRkJSenR4UWtGRGJFTTdiMEpCUlVRc1NVRkJUVVVzUzBGQlN5eEhRVUZIVGl4UlFVRlJMRVZCUTJoQ1R5eFhRVUZYTEVkQlFVY3NRMEZCUXl4QlFVRkRPMjlDUVVWMFFpeEpRVUZKTEVOQlFVTnVRaXhYUVVGWExFTkJRVU52UWl4TlFVRk5MRU5CUVVOR0xFdEJRVXNzUlVGQlJVTXNWMEZCVnl4RlFVRkZVaXhWUVVGVkxFTkJRVU1zUTBGQlF6dHBRa0ZEZWtRN1lVRkRSanM3TzFsQlJVUlZMRWRCUVdkQ0xFVkJRV2hDUVN4clFrRkJaMEk3V1VWc1JXeENMRTlHYTBWRlFTeFRRVUZCUVN4blFrRkJaMElzUTBGQlExWXNWVUZCVlN4RlFVRkZPMmRDUVVNelFpeEpRVUZOUlN3MlFrRkJOa0lzUjBGQlJ5eEpRVUZKTEVOQlFVTmlMRmRCUVZjc1EwRkJRMk1zVVVGQlVTeERRVUZEU0N4VlFVRlZMRU5CUVVNc1FVRkJRenRuUWtGRk5VVXNTVUZCU1VVc05rSkJRVFpDTEVWQlFVVTdiMEpCUTJwRExFbEJRVTFUTEdWQlFXVXNSMEZCUnl4SlFVRkpMRU5CUVVOMFFpeFhRVUZYTEVOQlFVTjFRaXhQUVVGUExFTkJRVU5hTEZWQlFWVXNRMEZCUXl4RlFVTjBSRThzUzBGQlN5eEhRVUZIU1N4bFFVRmxMRVZCUTNaQ1NDeFhRVUZYTEVkQlFVY3NRMEZCUXl4QlFVRkRPMjlDUVVWMFFpeEpRVUZKTEVOQlFVTnVRaXhYUVVGWExFTkJRVU52UWl4TlFVRk5MRU5CUVVOR0xFdEJRVXNzUlVGQlJVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN2FVSkJRemRETzJGQlEwWTdPenRaUVVWRVN5eEhRVUZwUWl4RlFVRnFRa0VzYlVKQlFXbENPMWxGT1VWdVFpeFBSamhGUlVFc1UwRkJRVUVzYVVKQlFXbENMRU5CUVVORExHRkJRV0VzUlVGQlJVTXNZVUZCWVN4RlFVRkZPMmRDUVVNNVF5eEpRVUZOUXl4clFrRkJhMElzUjBGQlJ5eEpRVUZKTEVOQlFVTXpRaXhYUVVGWExFTkJRVU4xUWl4UFFVRlBMRU5CUVVORkxHRkJRV0VzUTBGQlF5eEJRVUZETzJkQ1FVVnVSU3hKUVVGSlJTeHJRa0ZCYTBJc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJUdHZRa0ZETTBJc1NVRkJUVlFzUzBGQlN5eEhRVUZIVXl4clFrRkJhMElzUlVGRE1VSlNMRmRCUVZjc1IwRkJSeXhEUVVGRExFRkJRVU03YjBKQlJYUkNMRWxCUVVrc1EwRkJRMjVDTEZkQlFWY3NRMEZCUTI5Q0xFMUJRVTBzUTBGQlEwWXNTMEZCU3l4RlFVRkZReXhYUVVGWExFVkJRVVZQTEdGQlFXRXNRMEZCUXl4QlFYSkdhRVU3YVVKQmMwWkxPMkZCUTBZN096dFpRVVZFUlN4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWNlJsQXNUMFo1UmtWQkxGTkJRVUZCTEV0QlFVc3NRMEZCUTBNc1MwRkJTeXhGUVVGRlF5eFJRVUZSTEVWQlFVVTdPMmRDUVVOeVFpeEpRVUZKUXl4UlFVRlJMRWRCUVVjc1NVRkJTU3hCUVVGRE8yZENRVVZ3UWtZc1MwRkJTeXhEUVVGRFJ5eGhRVUZoTEVWQlFVVXNRMEZCUXp0blFrRkZkRUlzU1VGQlRVTXNUMEZCVHl4SFFVRkhTaXhMUVVGTExFTkJRVU5MTEZOQlFWTXNSVUZCUlN4QlFVRkRPMmRDUVVWc1F5eEpRVUZKUkN4UFFVRlBMRVZCUVVVN2IwSkJRMWdzVFVGQlRTeEpRVUZKUlN4TFFVRkxMRU5CUVVNc1FVRkJReXgxUTBGQmIwTXNRMEZCV1N4TlFVRkZMRU5CUVZvc1NVRkJTU3hEUVVGRGNrTXNTVUZCU1N4RlFVRkRMRXRCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03YVVKQlEzWkZPMmRDUVVWRUxFbEJRVWx6UXl4TlFVRk5MRVZCUTA1RExHVkJRV1VzUVVGQlF6dG5Ra0ZGY0VJc1NVRkJTU3hEUVVGRGNrTXNWMEZCVnl4RFFVRkRjME1zU1VGQlNTeERRVUZETEZOQlFVTXpRaXhWUVVGVkxFVkJRVXM3YjBKQlEzQkRNRUlzWlVGQlpTeEhRVUZITEVWQlFVVXNRMEZCUXp0dlFrRkZja0pFTEUxQlFVMHNSMEZCUnl4TlFVRkxSeXhsUVVGbExFTkJRVU0xUWl4VlFVRlZMRVZCUVVVd1FpeGxRVUZsTEVWQlFVVlNMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeERRVUZETEVOQlFVTTdiMEpCUlRWRkxFbEJRVWxOTEUxQlFVMHNSVUZCUlR0M1FrRkRWaXhQUVVGUExFbEJRVWtzUTBGQlF6dHhRa0ZEWWp0cFFrRkRSaXhEUVVGRExFTkJRVU03WjBKQlJVZ3NTVUZCU1VFc1RVRkJUU3hGUVVGRk8yOUNRVU5XTEVsQlFVMUpMRkZCUVZFc1IwRkJSeXhKUVVGSkxFTkJRVU14UXl4SlFVRkpMRVZCUTNCQ01rTXNWVUZCVlN4SFFVRkhTaXhsUVVGbExFVkJRelZDU3l4bFFVRmxMRWRCUVVjc1NVRkJTU3hEUVVGRGVrTXNaVUZCWlN4RFFVRkRNRU1zZVVKQlFYbENMRU5CUVVOSUxGRkJRVkVzUlVGQlJVTXNWVUZCVlN4RFFVRkRMRUZCUVVNN2IwSkJSVGRHVml4UlFVRlJMRWRCUVVkWExHVkJRV1VzUTBGQlF5eERRVUZETEVkQlFVYzdhVUpCUTJoRE8yZENRVVZFWWl4TFFVRkxMRU5CUVVObExHRkJRV0VzUlVGQlJTeERRVUZETzJkQ1FVVjBRaXhQUVVGUFlpeFJRVUZSTEVOQlFVTTdZVUZEYWtJN096dFpRVVZFVVN4SFFVRmxMRVZCUVdaQkxHbENRVUZsTzFsRk9VaHFRaXhQUmpoSVJVRXNVMEZCUVVFc1pVRkJaU3hEUVVGRE5VSXNWVUZCVlN4RlFVRkZhME1zUzBGQlN5eEZRVUZGYUVJc1MwRkJTeXhGUVVGRlF5eFJRVUZSTEVWQlFVVTdaMEpCUTJ4RUxFbEJRVWxOTEUxQlFVMHNRVUZCUXp0blFrRkZXQ3hKUVVGTlZTeFZRVUZWTEVkQlFVZHFRaXhMUVVGTExFTkJRVU5yUWl4aFFVRmhMRVZCUVVVc1FVRkJRenRuUWtGRmVrTllMRTFCUVUwc1IwRkJSM3BDTEZWQlFWVXNRMEZCUTJsQ0xFdEJRVXNzUTBGQlEybENMRXRCUVVzc1JVRkJSV2hDTEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hEUVVGRExFTkJRVU03WjBKQlJXeEVMRWxCUVVrc1EwRkJRMDBzVFVGQlRTeEZRVUZGTzI5Q1FVTllVQ3hMUVVGTExFTkJRVU50UWl4VFFVRlRMRU5CUVVOR0xGVkJRVlVzUTBGQlF5eERRVUZETzJsQ1FVTTNRanRuUWtGRlJDeFBRVUZQVml4TlFVRk5MRU5CUVVNN1lVRkRaanM3TzFsQlJVUmhMRWRCUVZFc1JVRkJVa0VzVlVGQlVUdFpSVFZKVml4UFJqUkpSVUVzVTBGQlFVRXNVVUZCVVN4RFFVRkRReXh4UWtGQmNVSXNSVUZCYjBJN2IwSkJRV3hDUXl4VFFVRlRMRWRCUVZSQkxDdERRVUZuUWl4clFrRkJTaXhKUVVGSk8yZENRVU01UXl4SlFVRk5ia01zYVVKQlFXbENMRWRCUVVjc1NVRkJTU3hEUVVGRGFFSXNWMEZCVnl4RFFVRkRhVUlzVFVGQlRTeEJRVUZETzJkQ1FVVnNSR3RETEZOQlFWTXNSMEZCUjBFc1UwRkJVeXhKUVVGTGJrTXNhVUpCUVdsQ0xFZEJRVWNzUTBGQlF5eEJRVUZETEVOQlFVTXNRMEZCUlN4SFFVRkhPMmRDUVVWMFJDeEpRVUZOYjBNc1kwRkJZeXhIUVVGSFF5eERRVUZCUVN4SFFVRkJRU3hQUVVGM1FpeEJRVUYxUWl4RFFVRkJMREJDUVVGMFFrZ3NjVUpCUVhGQ0xFTkJRVU1zUlVGRGFFVkpMR3RDUVVGcFFpeEhRVUZITEVsQlFVa3NRMEZCUTNSRUxGZEJRVmNzUTBGQlEzVkVMRTFCUVUwc1EwRkJReXhUUVVGRFJDeHBRa0ZCYVVJc1JVRkJSVE5ETEZWQlFWVXNSVUZCU3p0dlFrRkROMFVzU1VGQlRUWkRMR2RDUVVGblFpeEhRVUZITjBNc1ZVRkJWU3hEUVVGRGMwTXNVVUZCVVN4RlFVRkZMRUZCUVVNN2IwSkJSUzlETEVsQlFVbExMR2xDUVVGcFFpeExRVUZMUnl4VlFVRlpMR0ZCUVVFc1JVRkJSVHQzUWtGRGRFTklMR2xDUVVGcFFpeEhRVUZIUlN4blFrRkJaMElzUTBGQlF5eERRVUZETEVkQlFVYzdjVUpCUXpGRExFMUJRVTA3ZDBKQlEweEdMR2xDUVVGcFFpeEhRVUZIU0N4VFFVRlRMRWRCUTFJc1FVRkJReXhGUVVGQkxFTkJSV3hEUXl4TlFVRmpMRU5CUm5OQ1JTeHBRa0ZCYVVJc1JVRkJReXhOUVVWNFJDeERRVUZwUWl4RFFVRlBSU3hOUVVGblFpeERRVUYwUTBvc1kwRkJZeXhGUVVGRExFOUJRVXNzUTBGQmJVSXNRMEZCUVN4TlFVRkJMRU5CUVdwQ1NTeG5Ra0ZCWjBJc1EwRkJSU3hIUVVOTUxFRkJRVU1zUlVGQlFTeERRVUY1UWtFc1RVRkJaMElzUTBGQmRrTkdMR2xDUVVGcFFpeEZRVUZETEV0QlFVY3NRMEZCYlVJc1EwRkJRU3hOUVVGQkxFTkJRV3BDUlN4blFrRkJaMElzUTBGQlJTeERRVUZETzNGQ1FVTnlSVHR2UWtGRlJDeFBRVUZQUml4cFFrRkJhVUlzUTBGQlF6dHBRa0ZETVVJc1JVRkJSVWNzVlVGQldTeGpRVUZETEVWQlEyaENha0lzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXpGRExFbEJRVWtzUlVGRGNFSTBSQ3hqUVVGakxFZEJRVWRzUWl4UlFVRlJMRU5CUVVOMlFpeE5RVUZOTEVWQlEyaERNRU1zWlVGQlpTeEhRVUZITEVsQlFVa3NRMEZCUXpWRUxGTkJRVk1zUjBGRFdrb3NaVUZCWlN4SFFVTmlPRVFzVlVGQldTeGhRVUZCTEVWQlEyeERSeXh4UWtGQmNVSXNSMEZCUjBRc1pVRkJaU3hEUVVGRE1VTXNUVUZCVFN4RlFVTTVRelJETEdGQlFXRXNSMEZCUjFnc2NVSkJRWEZDTEVkQlFVZFJMR05CUVdNc1IwRkJSMFVzY1VKQlFYRkNMRVZCUXpsRlJTeFBRVUZQTEVkQlFVZFVMRU5CUVVGQkxFZEJRVUZCTEU5QlFYZENMRUZCUVdVc1EwRkJRU3d3UWtGQlpGRXNZVUZCWVN4RFFVRkRMRUZCUVVNN1owSkJSWGhFTEVsQlFVMUZMR1ZCUVdVc1IwRkJSMW9zVTBGQlV5eEhRVU5TTEVGQlFVTXNUVUZGT1VJc1EwRkJhVUlzVFVGQlNTeERRVUZ1UWtNc1kwRkJZeXhGUVVGRExFMUJRVWtzUTBGQlF5eEhRVU5UTEVsQlFVa3NSVUZEZWtKWkxFMUJRVTBzUjBGQlJ5eEJRVUZETEUxQlJYQkNMRU5CUVdOTUxFMUJRV1VzUTBGQk0wSXNTVUZCU1N4RFFVRkROMFFzU1VGQlNTeERRVUZ0UWl4RFFVRkZaMFVzVFVGQlR5eERRVUY2UWtnc1pVRkJaU3hEUVVGWExFTkJRVTlNTEUxQlFXbENMRU5CUVdoRFVTeFBRVUZQTEVWQlFVTXNUMEZCU3l4RFFVRnZRaXhEUVVGRlF5eE5RVUZsTEVOQlFXNURWQ3hyUWtGQmFVSXNRMEZCYlVJc1EwRkJRU3hOUVVGQkxFTkJRV2hDVXl4bFFVRmxMRU5CUVVVc1FVRkJRenRuUWtGRmFrWXNUMEZCVDBNc1RVRkJUU3hEUVVGRE8yRkJRMlk3T3pzN1dVRkZUVU1zUjBGQlVTeEZRVUZTUVN4VlFVRlJPMWxGZEV4cVFpeFBSbk5NUlN4VFFVRlBRU3hSUVVGUkxFTkJRVU5ETEV0QlFVc3NSVUZCUlVNc1NVRkJTU3hGUVVGRk8yZENRVU16UWl4SlFVRkpRU3hKUVVGSkxFdEJRVXR3UkN4VFFVRlRMRVZCUVVVN2IwSkJRM1JDYjBRc1NVRkJTU3hIUVVGSFJDeExRVUZMTEVOQlFVTTdiMEpCUTJKQkxFdEJRVXNzUjBGQlIzSkZMRWxCUVVrc1EwRkJRenRwUWtGRFpEdG5Ra0ZGUkN4SlFVRk5ReXhKUVVGSkxFZEJRVWR4UlN4SlFVRkpMRU5CUVVOcVJTeFBRVUZQTEVWQlFVVXNSVUZEY2tKSUxGTkJRVk1zUjBGQlIyOUZMRWxCUVVrc1EwRkJRMmhGTEZkQlFWY3NSVUZCUlN4RlFVTTVRa2dzVjBGQlZ5eEhRVUZIYlVVc1NVRkJTU3hEUVVGREwwUXNZMEZCWXl4RlFVRkZMRVZCUTI1RFNDeGxRVUZsTEVkQlFVZHJSU3hKUVVGSkxFTkJRVU01UkN4clFrRkJhMElzUlVGQlJTeEJRVUZETzJkQ1FVVnNSRGhFTEVsQlFVa3NSMEZCUnl4SlFVRkpSQ3hMUVVGTExFTkJRVU53UlN4SlFVRkpMRVZCUVVWRExGTkJRVk1zUlVGQlJVTXNWMEZCVnl4RlFVRkZReXhsUVVGbExFTkJRVU1zUTBGQlF6dG5Ra0ZGYUVVc1QwRkJUMnRGTEVsQlFVa3NRMEZCUXp0aFFVTmlPenROUVhCTlNEczdRMEZ4VFVNc1JVRkJRVHRyUWtFMVRHOUNkRVVzU1VGQlNTeEJRVlI2UWlKOSIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYSU1VTV9ERVBUSCA9IDk5O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0cyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG52YXIgU3RhdGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlKHJ1bGVNYXAsIHRva2VucywgaW5kZXgsIGRlcHRoLCBtYXhpbXVtRGVwdGgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRlKTtcbiAgICAgICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLm1heGltdW1EZXB0aCA9IG1heGltdW1EZXB0aDtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFN0YXRlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRSdWxlTWFwXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZU1hcCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0VG9rZW5zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9rZW5zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldEluZGV4XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXREZXB0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0TWF4aW11bURlcHRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4aW11bURlcHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heGltdW1EZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFNhdmVkSW5kZXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTYXZlZEluZGV4KCkge1xuICAgICAgICAgICAgICAgIHZhciBzYXZlZEluZGV4ID0gdGhpcy5pbmRleDsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhdmVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXROZXh0VG9rZW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZXh0VG9rZW4oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRUb2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHRva2Vuc0xlbmd0aCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IHRva2Vuc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4gPSB0aGlzLnRva2Vuc1t0aGlzLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0TmV4dFNpZ25pZmljYW50VG9rZW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnNMZW5ndGggPSB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUodGhpcy5pbmRleCA8IHRva2Vuc0xlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXgrK10sIHRva2VuU2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblNpZ25pZmljYW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbmlmaWNhbnRUb2tlbiA9IHRva2VuOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWduaWZpY2FudFRva2VuID0gc2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpZ25pZmljYW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc05leHRUb2tlbldoaXRlc3BhY2VUb2tlblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTmV4dFRva2VuV2hpdGVzcGFjZVRva2VuKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgdG9rZW5zTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLnRva2Vuc1t0aGlzLmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuV2hpdGVzcGFjZVRva2VuID0gbmV4dFRva2VuLmlzV2hpdGVzcGFjZVRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc1Rvb0RlZXBcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Rvb0RlZXAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb0RlZXAgPSB0aGlzLmRlcHRoID4gdGhpcy5tYXhpbXVtRGVwdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb0RlZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJiYWNrdHJhY2tcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiYWNrdHJhY2soc2F2ZWRJbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzYXZlZEluZGV4OyAvLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNldEluZGV4XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpbmNyZWFzZURlcHRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5jcmVhc2VEZXB0aCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJkZWNyZWFzZURlcHRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcmVhc2VEZXB0aCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tVG9rZW5zQW5kUnVsZU1hcFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Ub2tlbnNBbmRSdWxlTWFwKHRva2VucywgcnVsZU1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDAsIGRlcHRoID0gMCwgbWF4aW11bURlcHRoID0gX2RlZmF1bHRzLkRFRkFVTFRfTUFYSU1VTV9ERVBUSCwgc3RhdGUgPSBuZXcgU3RhdGUocnVsZU1hcCwgdG9rZW5zLCBpbmRleCwgZGVwdGgsIG1heGltdW1EZXB0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0YXRlO1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5emRHRjBaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElIc2dSRVZHUVZWTVZGOU5RVmhKVFZWTlgwUkZVRlJJSUgwZ1puSnZiU0JjSWk0dlpHVm1ZWFZzZEhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1UzUmhkR1VnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWh5ZFd4bFRXRndMQ0IwYjJ0bGJuTXNJR2x1WkdWNExDQmtaWEIwYUN3Z2JXRjRhVzExYlVSbGNIUm9LU0I3WEc0Z0lDQWdkR2hwY3k1eWRXeGxUV0Z3SUQwZ2NuVnNaVTFoY0R0Y2JpQWdJQ0IwYUdsekxuUnZhMlZ1Y3lBOUlIUnZhMlZ1Y3p0Y2JseDBYSFIwYUdsekxtbHVaR1Y0SUQwZ2FXNWtaWGc3WEc1Y2RGeDBkR2hwY3k1a1pYQjBhQ0E5SUdSbGNIUm9PMXh1SUNBZ0lIUm9hWE11YldGNGFXMTFiVVJsY0hSb0lEMGdiV0Y0YVcxMWJVUmxjSFJvTzF4dUlDQjlYRzVjYmlBZ1oyVjBVblZzWlUxaGNDZ3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeTV5ZFd4bFRXRndPMXh1SUNCOVhHNWNiaUFnWjJWMFZHOXJaVzV6S0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxuUnZhMlZ1Y3p0Y2JpQWdmVnh1WEc1Y2RHZGxkRWx1WkdWNEtDa2dlMXh1WEhSY2RISmxkSFZ5YmlCMGFHbHpMbWx1WkdWNE8xeHVYSFI5WEc1Y2JpQWdaMlYwUkdWd2RHZ29LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11WkdWd2RHZzdYRzRnSUgxY2JseHVYSFJuWlhSTllYaHBiWFZ0UkdWd2RHZ29LU0I3WEc1Y2RGeDBjbVYwZFhKdUlIUm9hWE11YldGNGFXMTFiVVJsY0hSb08xeHVYSFI5WEc1Y2JseDBaMlYwVTJGMlpXUkpibVJsZUNncElIdGNiaUFnSUNCamIyNXpkQ0J6WVhabFpFbHVaR1Y0SUQwZ2RHaHBjeTVwYm1SbGVEc2dMeTh2WEc0Z0lGeHVJQ0FnSUhKbGRIVnliaUJ6WVhabFpFbHVaR1Y0TzF4dUlDQjlYRzVjYmlBZ1oyVjBUbVY0ZEZSdmEyVnVLQ2tnZTF4dUlDQWdJR3hsZENCdVpYaDBWRzlyWlc0Z1BTQnVkV3hzTzF4dVhHNGdJQ0FnWTI5dWMzUWdkRzlyWlc1elRHVnVaM1JvSUQwZ2RHaHBjeTUwYjJ0bGJuTXViR1Z1WjNSb08xeHVYRzRnSUNBZ2FXWWdLSFJvYVhNdWFXNWtaWGdnUENCMGIydGxibk5NWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJRzVsZUhSVWIydGxiaUE5SUhSb2FYTXVkRzlyWlc1elczUm9hWE11YVc1a1pYZ3JLMTA3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlHNWxlSFJVYjJ0bGJqdGNiaUFnZlZ4dVhHNGdJR2RsZEU1bGVIUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUtDa2dlMXh1WEhSY2RHeGxkQ0J1WlhoMFUybG5ibWxtYVdOaGJuUlViMnRsYmlBOUlHNTFiR3c3WEc1Y2JpQWdYSFJqYjI1emRDQjBiMnRsYm5OTVpXNW5kR2dnUFNCMGFHbHpMblJ2YTJWdWN5NXNaVzVuZEdnN1hHNWNiaUFnWEhSM2FHbHNaU0FvZEdocGN5NXBibVJsZUNBOElIUnZhMlZ1YzB4bGJtZDBhQ2tnZTF4dUlDQmNkRngwWTI5dWMzUWdkRzlyWlc0Z1BTQjBhR2x6TG5SdmEyVnVjMXQwYUdsekxtbHVaR1Y0S3l0ZExGeHVYSFJjZEZ4MFhIUmNkRngwZEc5clpXNVRhV2R1YVdacFkyRnVkQ0E5SUhSdmEyVnVMbWx6VTJsbmJtbG1hV05oYm5Rb0tUdGNibHh1SUNCY2RGeDBhV1lnS0hSdmEyVnVVMmxuYm1sbWFXTmhiblFwSUh0Y2JpQWdYSFJjZENBZ1kyOXVjM1FnYzJsbmJtbG1hV05oYm5SVWIydGxiaUE5SUhSdmEyVnVPeUF2THk5Y2JseHVYSFJjZEZ4MFhIUnVaWGgwVTJsbmJtbG1hV05oYm5SVWIydGxiaUE5SUhOcFoyNXBabWxqWVc1MFZHOXJaVzQ3WEhRdkx5OWNibHh1WEhSY2RGeDBYSFJpY21WaGF6dGNibHgwWEhSY2RIMWNiaUFnWEhSOVhHNWNibHgwWEhSeVpYUjFjbTRnYm1WNGRGTnBaMjVwWm1sallXNTBWRzlyWlc0N1hHNGdJSDFjYmx4dUlDQnBjMDVsZUhSVWIydGxibGRvYVhSbGMzQmhZMlZVYjJ0bGJpZ3BJSHRjYmlBZ0lDQnNaWFFnYm1WNGRGUnZhMlZ1VjJocGRHVnpjR0ZqWlZSdmEyVnVJRDBnWm1Gc2MyVTdYRzVjYmlBZ0lDQmpiMjV6ZENCMGIydGxibk5NWlc1bmRHZ2dQU0IwYUdsekxuUnZhMlZ1Y3k1c1pXNW5kR2c3WEc1Y2JpQWdJQ0JwWmlBb2RHaHBjeTVwYm1SbGVDQThJSFJ2YTJWdWMweGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ1kyOXVjM1FnYm1WNGRGUnZhMlZ1SUQwZ2RHaHBjeTUwYjJ0bGJuTmJkR2hwY3k1cGJtUmxlRjA3WEc1Y2JpQWdJQ0FnSUc1bGVIUlViMnRsYmxkb2FYUmxjM0JoWTJWVWIydGxiaUE5SUc1bGVIUlViMnRsYmk1cGMxZG9hWFJsYzNCaFkyVlViMnRsYmlncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUJ1WlhoMFZHOXJaVzVYYUdsMFpYTndZV05sVkc5clpXNDdYRzRnSUgxY2JseHVJQ0JwYzFSdmIwUmxaWEFvS1NCN1hHNGdJQ0FnWTI5dWMzUWdkRzl2UkdWbGNDQTlJQ2gwYUdsekxtUmxjSFJvSUQ0Z2RHaHBjeTV0WVhocGJYVnRSR1Z3ZEdncE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhSdmIwUmxaWEE3WEc0Z0lIMWNibHh1WEhSaVlXTnJkSEpoWTJzb2MyRjJaV1JKYm1SbGVDa2dlMXh1WEhSY2RIUm9hWE11YVc1a1pYZ2dQU0J6WVhabFpFbHVaR1Y0T3lBZ0x5OHZYRzVjZEgxY2JseHVJQ0J6WlhSSmJtUmxlQ2hwYm1SbGVDa2dlMXh1SUNBZ0lIUm9hWE11YVc1a1pYZ2dQU0JwYm1SbGVEdGNiaUFnZlZ4dVhHNGdJR2x1WTNKbFlYTmxSR1Z3ZEdnb0tTQjdYRzRnSUNBZ2RHaHBjeTVrWlhCMGFDc3JPMXh1SUNCOVhHNWNiaUFnWkdWamNtVmhjMlZFWlhCMGFDZ3BJSHRjYmlBZ0lDQjBhR2x6TG1SbGNIUm9MUzA3WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJWUnZhMlZ1YzBGdVpGSjFiR1ZOWVhBb2RHOXJaVzV6TENCeWRXeGxUV0Z3S1NCN1hHNGdJQ0FnWTI5dWMzUWdhVzVrWlhnZ1BTQXdMRnh1WEhSY2RGeDBYSFJjZEdSbGNIUm9JRDBnTUN4Y2JseDBYSFJjZEZ4MFhIUnRZWGhwYlhWdFJHVndkR2dnUFNCRVJVWkJWVXhVWDAxQldFbE5WVTFmUkVWUVZFZ3NYRzVjZEZ4MFhIUmNkRngwYzNSaGRHVWdQU0J1WlhjZ1UzUmhkR1VvY25Wc1pVMWhjQ3dnZEc5clpXNXpMQ0JwYm1SbGVDd2daR1Z3ZEdnc0lHMWhlR2x0ZFcxRVpYQjBhQ2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjM1JoZEdVN1hHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpUZEdGMFpTSXNJbkoxYkdWTllYQWlMQ0owYjJ0bGJuTWlMQ0pwYm1SbGVDSXNJbVJsY0hSb0lpd2liV0Y0YVcxMWJVUmxjSFJvSWl3aVoyVjBVblZzWlUxaGNDSXNJbWRsZEZSdmEyVnVjeUlzSW1kbGRFbHVaR1Y0SWl3aVoyVjBSR1Z3ZEdnaUxDSm5aWFJOWVhocGJYVnRSR1Z3ZEdnaUxDSm5aWFJUWVhabFpFbHVaR1Y0SWl3aWMyRjJaV1JKYm1SbGVDSXNJbWRsZEU1bGVIUlViMnRsYmlJc0ltNWxlSFJVYjJ0bGJpSXNJblJ2YTJWdWMweGxibWQwYUNJc0lteGxibWQwYUNJc0ltZGxkRTVsZUhSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aWJtVjRkRk5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0owYjJ0bGJpSXNJblJ2YTJWdVUybG5ibWxtYVdOaGJuUWlMQ0pwYzFOcFoyNXBabWxqWVc1MElpd2ljMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbWx6VG1WNGRGUnZhMlZ1VjJocGRHVnpjR0ZqWlZSdmEyVnVJaXdpYm1WNGRGUnZhMlZ1VjJocGRHVnpjR0ZqWlZSdmEyVnVJaXdpYVhOWGFHbDBaWE53WVdObFZHOXJaVzRpTENKcGMxUnZiMFJsWlhBaUxDSjBiMjlFWldWd0lpd2lZbUZqYTNSeVlXTnJJaXdpYzJWMFNXNWtaWGdpTENKcGJtTnlaV0Z6WlVSbGNIUm9JaXdpWkdWamNtVmhjMlZFWlhCMGFDSXNJbVp5YjIxVWIydGxibk5CYm1SU2RXeGxUV0Z3SWl3aVJFVkdRVlZNVkY5TlFWaEpUVlZOWDBSRlVGUklJaXdpYzNSaGRHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZjME1zU1VGQlFTeFRRVUZaTEZkQlFWb3NXVUZCV1N4RFFVRkJPenM3T3pzN096czdPRVJCUm14RU8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN1FVRkpaU3hKUVVGQkxFRkJRVTFCTEV0QlFVc3NhVUpEU25aQ0xFRkVTVms3WVVGQlRVRXNTMEZCU3l4RFFVTmFReXhQUVVGUExFVkJRVVZETEUxQlFVMHNSVUZCUlVNc1MwRkJTeXhGUVVGRlF5eExRVUZMTEVWQlFVVkRMRmxCUVZrN2IwTkJUSHBFTzFGQlRVa3NTVUZCU1N4RFFVRkRTaXhQUVVGUExFZEJRVWRCTEU5QlFVOHNRMEZCUXp0UlFVTjJRaXhKUVVGSkxFTkJRVU5ETEUxQlFVMHNSMEZCUjBFc1RVRkJUU3hEUVVGRE8xRkJRM1pDTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhIUVVGSFFTeExRVUZMTEVOQlFVTTdVVUZEYmtJc1NVRkJTU3hEUVVGRFF5eExRVUZMTEVkQlFVZEJMRXRCUVVzc1EwRkJRenRSUVVOcVFpeEpRVUZKTEVOQlFVTkRMRmxCUVZrc1IwRkJSMEVzV1VGQldTeERRVUZET3pzN08xbEJSMjVEUXl4SFFVRlZMRVZCUVZaQkxGbEJRVlU3V1VWaVdpeFBSbUZGUVN4VFFVRkJRU3hWUVVGVkxFZEJRVWM3WjBKQlExZ3NUMEZCVHl4SlFVRkpMRU5CUVVOTUxFOUJRVThzUTBGQlF6dGhRVU55UWpzN08xbEJSVVJOTEVkQlFWTXNSVUZCVkVFc1YwRkJVenRaUldwQ1dDeFBSbWxDUlVFc1UwRkJRVUVzVTBGQlV5eEhRVUZITzJkQ1FVTldMRTlCUVU4c1NVRkJTU3hEUVVGRFRDeE5RVUZOTEVOQlFVTTdZVUZEY0VJN096dFpRVVZHVFN4SFFVRlJMRVZCUVZKQkxGVkJRVkU3V1VWeVFsUXNUMFp4UWtOQkxGTkJRVUZCTEZGQlFWRXNSMEZCUnp0blFrRkRWaXhQUVVGUExFbEJRVWtzUTBGQlEwd3NTMEZCU3l4RFFVRkRPMkZCUTJ4Q096czdXVUZGUVUwc1IwRkJVU3hGUVVGU1FTeFZRVUZSTzFsRmVrSldMRTlHZVVKRlFTeFRRVUZCUVN4UlFVRlJMRWRCUVVjN1owSkJRMVFzVDBGQlR5eEpRVUZKTEVOQlFVTk1MRXRCUVVzc1EwRkJRenRoUVVOdVFqczdPMWxCUlVaTkxFZEJRV1VzUlVGQlprRXNhVUpCUVdVN1dVVTNRbWhDTEU5R05rSkRRU3hUUVVGQlFTeGxRVUZsTEVkQlFVYzdaMEpCUTJwQ0xFOUJRVThzU1VGQlNTeERRVUZEVEN4WlFVRlpMRU5CUVVNN1lVRkRla0k3T3p0WlFVVkVUU3hIUVVGaExFVkJRV0pCTEdWQlFXRTdXVVZxUTJRc1QwWnBRME5CTEZOQlFVRkJMR0ZCUVdFc1IwRkJSenRuUWtGRFlpeEpRVUZOUXl4VlFVRlZMRWRCUVVjc1NVRkJTU3hEUVVGRFZDeExRVUZMTEVGQlFVTXNSVUZCUXl4SFFVRkhPMmRDUVVWc1F5eFBRVUZQVXl4VlFVRlZMRU5CUVVNN1lVRkRia0k3T3p0WlFVVkVReXhIUVVGWkxFVkJRVnBCTEdOQlFWazdXVVYyUTJRc1QwWjFRMFZCTEZOQlFVRkJMRmxCUVZrc1IwRkJSenRuUWtGRFlpeEpRVUZKUXl4VFFVRlRMRWRCUVVjc1NVRkJTU3hCUVVGRE8yZENRVVZ5UWl4SlFVRk5ReXhaUVVGWkxFZEJRVWNzU1VGQlNTeERRVUZEWWl4TlFVRk5MRU5CUVVOakxFMUJRVTBzUVVGQlF6dG5Ra0ZGZUVNc1NVRkJTU3hKUVVGSkxFTkJRVU5pTEV0QlFVc3NSMEZCUjFrc1dVRkJXU3hGUVVGRk8yOUNRVU0zUWtRc1UwRkJVeXhIUVVGSExFbEJRVWtzUTBGQlExb3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRME1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0cFFrRkRka003WjBKQlJVUXNUMEZCVDFjc1UwRkJVeXhEUVVGRE8yRkJRMnhDT3pzN1dVRkZSRWNzUjBGQmRVSXNSVUZCZGtKQkxIbENRVUYxUWp0WlJXNUVla0lzVDBadFJFVkJMRk5CUVVGQkxIVkNRVUYxUWl4SFFVRkhPMmRDUVVNeFFpeEpRVUZKUXl4dlFrRkJiMElzUjBGQlJ5eEpRVUZKTEVGQlFVTTdaMEpCUlM5Q0xFbEJRVTFJTEZsQlFWa3NSMEZCUnl4SlFVRkpMRU5CUVVOaUxFMUJRVTBzUTBGQlEyTXNUVUZCVFN4QlFVRkRPMmRDUVVWNFF5eE5RVUZQTEVsQlFVa3NRMEZCUTJJc1MwRkJTeXhIUVVGSFdTeFpRVUZaTEVOQlFVVTdiMEpCUTJwRExFbEJRVTFKTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVOcVFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRReXhMUVVGTExFVkJRVVVzUTBGQlF5eEZRVU55UTJsQ0xHZENRVUZuUWl4SFFVRkhSQ3hMUVVGTExFTkJRVU5GTEdGQlFXRXNSVUZCUlN4QlFVRkRPMjlDUVVVelF5eEpRVUZKUkN4blFrRkJaMElzUlVGQlJUdDNRa0ZEY0VJc1NVRkJUVVVzWjBKQlFXZENMRWRCUVVkSUxFdEJRVXNzUVVGQlF5eEZRVUZETEVkQlFVYzdkMEpCUlhKRFJDeHZRa0ZCYjBJc1IwRkJSMGtzWjBKQlFXZENMRU5CUVVNc1EwRkJReXhIUVVGSE8zZENRVVUxUXl4TlFVRk5PM0ZDUVVOT08ybENRVU5CTzJkQ1FVVkdMRTlCUVU5S0xHOUNRVUZ2UWl4RFFVRkRPMkZCUXpOQ096czdXVUZGUkVzc1IwRkJNRUlzUlVGQk1VSkJMRFJDUVVFd1FqdFpSWGhGTlVJc1QwWjNSVVZCTEZOQlFVRkJMREJDUVVFd1FpeEhRVUZITzJkQ1FVTXpRaXhKUVVGSlF5eDNRa0ZCZDBJc1IwRkJSeXhMUVVGTExFRkJRVU03WjBKQlJYSkRMRWxCUVUxVUxGbEJRVmtzUjBGQlJ5eEpRVUZKTEVOQlFVTmlMRTFCUVUwc1EwRkJRMk1zVFVGQlRTeEJRVUZETzJkQ1FVVjRReXhKUVVGSkxFbEJRVWtzUTBGQlEySXNTMEZCU3l4SFFVRkhXU3haUVVGWkxFVkJRVVU3YjBKQlF6ZENMRWxCUVUxRUxGTkJRVk1zUjBGQlJ5eEpRVUZKTEVOQlFVTmFMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU5ETEV0QlFVc3NRMEZCUXl4QlFVRkRPMjlDUVVVeFEzRkNMSGRDUVVGM1FpeEhRVUZIVml4VFFVRlRMRU5CUVVOWExHbENRVUZwUWl4RlFVRkZMRU5CUVVNN2FVSkJRekZFTzJkQ1FVVkVMRTlCUVU5RUxIZENRVUYzUWl4RFFVRkRPMkZCUTJwRE96czdXVUZGUkVVc1IwRkJVeXhGUVVGVVFTeFhRVUZUTzFsRmRFWllMRTlHYzBaRlFTeFRRVUZCUVN4VFFVRlRMRWRCUVVjN1owSkJRMVlzU1VGQlRVTXNUMEZCVHl4SFFVRkpMRWxCUVVrc1EwRkJRM1pDTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVORExGbEJRVmtzUVVGQlF5eEJRVUZETzJkQ1FVVnFSQ3hQUVVGUGMwSXNUMEZCVHl4RFFVRkRPMkZCUTJoQ096czdXVUZGUmtNc1IwRkJVeXhGUVVGVVFTeFhRVUZUTzFsRk5VWldMRTlHTkVaRFFTeFRRVUZCUVN4VFFVRlRMRU5CUVVOb1FpeFZRVUZWTEVWQlFVVTdaMEpCUTNKQ0xFbEJRVWtzUTBGQlExUXNTMEZCU3l4SFFVRkhVeXhWUVVGVkxFTkJRVU1zUTBGQlJTeEhRVUZITzJGQlF6ZENPenM3V1VGRlFXbENMRWRCUVZFc1JVRkJVa0VzVlVGQlVUdFpSV2hIVml4UFJtZEhSVUVzVTBGQlFVRXNVVUZCVVN4RFFVRkRNVUlzUzBGQlN5eEZRVUZGTzJkQ1FVTmtMRWxCUVVrc1EwRkJRMEVzUzBGQlN5eEhRVUZIUVN4TFFVRkxMRU5CUVVNN1lVRkRjRUk3T3p0WlFVVkVNa0lzUjBGQllTeEZRVUZpUVN4bFFVRmhPMWxGY0VkbUxFOUdiMGRGUVN4VFFVRkJRU3hoUVVGaExFZEJRVWM3WjBKQlEyUXNTVUZCU1N4RFFVRkRNVUlzUzBGQlN5eEZRVUZGTEVOQlFVTTdZVUZEWkRzN08xbEJSVVF5UWl4SFFVRmhMRVZCUVdKQkxHVkJRV0U3V1VWNFIyWXNUMFozUjBWQkxGTkJRVUZCTEdGQlFXRXNSMEZCUnp0blFrRkRaQ3hKUVVGSkxFTkJRVU16UWl4TFFVRkxMRVZCUVVVc1EwRkJRenRoUVVOa096czdPMWxCUlUwMFFpeEhRVUZ2UWl4RlFVRndRa0VzYzBKQlFXOUNPMWxGTlVjM1FpeFBSalJIUlN4VFFVRlBRU3h2UWtGQmIwSXNRMEZCUXpsQ0xFMUJRVTBzUlVGQlJVUXNUMEZCVHl4RlFVRkZPMmRDUVVNelF5eEpRVUZOUlN4TFFVRkxMRWRCUVVjc1EwRkJReXhGUVVOa1F5eExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVTlVReXhaUVVGWkxFZEJRVWMwUWl4VFFVRnhRaXh6UWtGQlFTeEZRVU53UTBNc1MwRkJTeXhIUVVGSExFbEJRVWxzUXl4TFFVRkxMRU5CUVVORExFOUJRVThzUlVGQlJVTXNUVUZCVFN4RlFVRkZReXhMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1dVRkJXU3hEUVVGRExFRkJRVU03WjBKQlJXaEZMRTlCUVU4MlFpeExRVUZMTEVOQlFVTTdZVUZEWkRzN1RVRnVTRWc3TzBOQmIwaERMRVZCUVVFN2EwSkJhRWh2UW14RExFdEJRVXNzUVVGS01VSWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuZXhwb3J0IGNvbnN0IHsgZmlyc3QsIHNlY29uZCwgdGhpcmQsIGZvdXJ0aCwgbGFzdCwgcHVzaCwgZmlsdGVyLCBmb3J3YXJkc1NvbWUsIGJhY2t3YXJkc1NvbWUgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gZXZlbihhcnJheSkgeyByZXR1cm4gYXJyYXkuZmlsdGVyKChlbnRyeSwgaW5kZXgpID0+IGlzRXZlbihpbmRleCkpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxCdXRGaXJzdEFuZExhc3QoYXJyYXkpIHtcbiAgYXJyYXkgPSBhcnJheS5zbGljZSgpOyAgLy8vXG5cbiAgYXJyYXkuc2hpZnQoKTtcblxuICBhcnJheS5wb3AoKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzRXZlbihpbmRleCkge1xuICBjb25zdCBldmVuID0gKE1hdGguZmxvb3IoaW5kZXgvMikgPT09IGluZGV4LzIpO1xuXG4gIHJldHVybiBldmVuO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9uZWNlc3NhcnkgPSByZXF1aXJlKFwibmVjZXNzYXJ5XCIpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuL3V0aWxpdGllcy9hcnJheVwiKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG52YXIgTkVXX0xJTkVfQ0hBUkFDVEVSID0gX25lY2Vzc2FyeS5jaGFyYWN0ZXJzLk5FV19MSU5FX0NIQVJBQ1RFUiwgU1BBQ0VfQ0hBUkFDVEVSID0gX25lY2Vzc2FyeS5jaGFyYWN0ZXJzLlNQQUNFX0NIQVJBQ1RFUjtcbnZhciBQYXJzZVRyZWUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlVHJlZShsaW5lcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VUcmVlKTtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUGFyc2VUcmVlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMubGluZXMuc2xpY2UoKSwgcGFyc2VUcmVlID0gbmV3IFBhcnNlVHJlZShsaW5lcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFdpZHRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gKDAsIF9hcnJheSkubGFzdCh0aGlzLmxpbmVzKSwgbGFzdExpbmVMZW5ndGggPSBsYXN0TGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gbGFzdExpbmVMZW5ndGg7IC8vL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXREZXB0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoLCBkZXB0aCA9IGxpbmVzTGVuZ3RoOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmb3JFYWNoTGluZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2hMaW5lKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFwcGVuZFRvVG9wXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVG9Ub3AocGFyc2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5saW5lcy51bnNoaWZ0KGxpbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXBwZW5kVG9MZWZ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVG9MZWZ0KHBhcnNlVHJlZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcGFyc2VUcmVlLmZvckVhY2hMaW5lKGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxpbmVzW2luZGV4XSA9IGxpbmUgKyBfdGhpcy5saW5lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhcHBlbmRUb1JpZ2h0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVG9SaWdodChwYXJzZVRyZWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHBhcnNlVHJlZS5mb3JFYWNoTGluZShmdW5jdGlvbihsaW5lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5saW5lc1tpbmRleF0gPSBfdGhpcy5saW5lc1tpbmRleF0gKyBsaW5lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXBwZW5kVG9Cb3R0b21cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUb0JvdHRvbShwYXJzZVRyZWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHBhcnNlVHJlZS5mb3JFYWNoTGluZShmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhZGRUb3BNYXJnaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb3BNYXJnaW4odG9wTWFyZ2luRGVwdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksIHRvcE1hcmdpbldpZHRoID0gd2lkdGgsIHRvcE1hcmdpblN0cmluZyA9IG1hcmdpblN0cmluZ0Zyb21NYXJnaW5XaWR0aCh0b3BNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdG9wTWFyZ2luRGVwdGg7IGluZGV4Kyspe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVzLnVuc2hpZnQodG9wTWFyZ2luU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhZGRMZWZ0TWFyZ2luXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdE1hcmdpblN0cmluZyA9IG1hcmdpblN0cmluZ0Zyb21NYXJnaW5XaWR0aChsZWZ0TWFyZ2luV2lkdGgpLCBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpbmVzTGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSBsZWZ0TWFyZ2luU3RyaW5nICsgdGhpcy5saW5lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYWRkUmlnaHRNYXJnaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0TWFyZ2luU3RyaW5nID0gbWFyZ2luU3RyaW5nRnJvbU1hcmdpbldpZHRoKHJpZ2h0TWFyZ2luV2lkdGgpLCBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpbmVzTGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIHJpZ2h0TWFyZ2luU3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFkZEJvdHRvbU1hcmdpblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJvdHRvbU1hcmdpbihib3R0b21NYXJnaW5EZXB0aCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSwgYm90dG9tTWFyZ2luV2lkdGggPSB3aWR0aCwgYm90dG9tTWFyZ2luU3RyaW5nID0gbWFyZ2luU3RyaW5nRnJvbU1hcmdpbldpZHRoKGJvdHRvbU1hcmdpbldpZHRoKTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBib3R0b21NYXJnaW5EZXB0aDsgaW5kZXgrKyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZXMucHVzaChib3R0b21NYXJnaW5TdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInBvcExpbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BMaW5lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2hpZnRMaW5lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnRMaW5lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwdXNoTGluZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hMaW5lKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ1bnNoaWZ0TGluZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnRMaW5lKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVzLnVuc2hpZnQobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcxID0gdGhpcy5saW5lcy5yZWR1Y2UoZnVuY3Rpb24oc3RyaW5nLCBsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBsaW5lICsgTkVXX0xJTkVfQ0hBUkFDVEVSO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0sIF9jb25zdGFudHMuRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBQYXJzZVRyZWU7XG59KCk7XG5leHBvcnRzLmRlZmF1bHQgPSBQYXJzZVRyZWU7XG5mdW5jdGlvbiBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgobWFyZ2luV2lkdGgsIHNwYWNlQ2hhcmFjdGVyKSB7XG4gICAgc3BhY2VDaGFyYWN0ZXIgPSBzcGFjZUNoYXJhY3RlciB8fCBTUEFDRV9DSEFSQUNURVI7XG4gICAgdmFyIG1hcmdpblN0cmluZyA9IF9jb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IG1hcmdpbldpZHRoOyBpbmRleCsrKXtcbiAgICAgICAgbWFyZ2luU3RyaW5nICs9IHNwYWNlQ2hhcmFjdGVyO1xuICAgIH1cbiAgICByZXR1cm4gbWFyZ2luU3RyaW5nO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OXdZWEp6WlZSeVpXVXVhbk1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lHTm9ZWEpoWTNSbGNuTWdmU0JtY205dElGd2libVZqWlhOellYSjVYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lHeGhjM1FnZlNCbWNtOXRJRndpTGk5MWRHbHNhWFJwWlhNdllYSnlZWGxjSWp0Y2JseHVhVzF3YjNKMElIc2dSVTFRVkZsZlUxUlNTVTVISUgwZ1puSnZiU0JjSWk0dlkyOXVjM1JoYm5SelhDSTdYRzVjYm1OdmJuTjBJSHNnVGtWWFgweEpUa1ZmUTBoQlVrRkRWRVZTTENCVFVFRkRSVjlEU0VGU1FVTlVSVklnZlNBOUlHTm9ZWEpoWTNSbGNuTTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGQmhjbk5sVkhKbFpTQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtHeHBibVZ6S1NCN1hHNGdJQ0FnZEdocGN5NXNhVzVsY3lBOUlHeHBibVZ6TzF4dUlDQjlYRzVjYmlBZ1kyeHZibVVvS1NCN1hHNGdJQ0FnWTI5dWMzUWdiR2x1WlhNZ1BTQjBhR2x6TG14cGJtVnpMbk5zYVdObEtDa3NJQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQndZWEp6WlZSeVpXVWdQU0J1WlhjZ1VHRnljMlZVY21WbEtHeHBibVZ6S1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJ3WVhKelpWUnlaV1U3WEc0Z0lIMWNibHh1SUNCblpYUlhhV1IwYUNncElIdGNiaUFnSUNCc1pYUWdkMmxrZEdnN1hHNWNiaUFnSUNCc1pYUWdiR2x1WlhOTVpXNW5kR2dnUFNCMGFHbHpMbXhwYm1WekxteGxibWQwYUR0Y2JseHVJQ0FnSUdsbUlDaHNhVzVsYzB4bGJtZDBhQ0E5UFQwZ01Da2dlMXh1SUNBZ0lDQWdkMmxrZEdnZ1BTQXdPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCamIyNXpkQ0JzWVhOMFRHbHVaU0E5SUd4aGMzUW9kR2hwY3k1c2FXNWxjeWtzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnNZWE4wVEdsdVpVeGxibWQwYUNBOUlHeGhjM1JNYVc1bExteGxibWQwYUR0Y2JseHVJQ0FnSUNBZ2QybGtkR2dnUFNCc1lYTjBUR2x1WlV4bGJtZDBhRHNnTHk4dlhHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJSGRwWkhSb08xeHVJQ0I5WEc1Y2JpQWdaMlYwUkdWd2RHZ29LU0I3WEc0Z0lDQWdZMjl1YzNRZ2JHbHVaWE5NWlc1bmRHZ2dQU0IwYUdsekxteHBibVZ6TG14bGJtZDBhQ3hjYmlBZ0lDQWdJQ0FnSUNCa1pYQjBhQ0E5SUd4cGJtVnpUR1Z1WjNSb095QWdMeTh2WEc1Y2JpQWdJQ0J5WlhSMWNtNGdaR1Z3ZEdnN1hHNGdJSDFjYmx4dUlDQm1iM0pGWVdOb1RHbHVaU2hqWVd4c1ltRmpheWtnZTF4dUlDQWdJSFJvYVhNdWJHbHVaWE11Wm05eVJXRmphQ2hqWVd4c1ltRmpheWs3WEc0Z0lIMWNibHh1SUNCaGNIQmxibVJVYjFSdmNDaHdZWEp6WlZSeVpXVXBJSHRjYmlBZ0lDQndZWEp6WlZSeVpXVXVabTl5UldGamFFeHBibVVvS0d4cGJtVXBJRDArSUh0Y2JpQWdJQ0FnSUhSb2FYTXViR2x1WlhNdWRXNXphR2xtZENoc2FXNWxLVHRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUdGd2NHVnVaRlJ2VEdWbWRDaHdZWEp6WlZSeVpXVXBJSHRjYmlBZ0lDQndZWEp6WlZSeVpXVXVabTl5UldGamFFeHBibVVvS0d4cGJtVXNJR2x1WkdWNEtTQTlQaUI3WEc0Z0lDQWdJQ0IwYUdsekxteHBibVZ6VzJsdVpHVjRYU0E5SUd4cGJtVWdLeUIwYUdsekxteHBibVZ6VzJsdVpHVjRYVHRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUdGd2NHVnVaRlJ2VW1sbmFIUW9jR0Z5YzJWVWNtVmxLU0I3WEc0Z0lDQWdjR0Z5YzJWVWNtVmxMbVp2Y2tWaFkyaE1hVzVsS0Noc2FXNWxMQ0JwYm1SbGVDa2dQVDRnZTF4dUlDQWdJQ0FnZEdocGN5NXNhVzVsYzF0cGJtUmxlRjBnUFNCMGFHbHpMbXhwYm1WelcybHVaR1Y0WFNBcklHeHBibVU3WEc0Z0lDQWdmU2s3WEc0Z0lIMWNibHh1SUNCaGNIQmxibVJVYjBKdmRIUnZiU2h3WVhKelpWUnlaV1VwSUh0Y2JpQWdJQ0J3WVhKelpWUnlaV1V1Wm05eVJXRmphRXhwYm1Vb0tHeHBibVVwSUQwK0lIdGNiaUFnSUNBZ0lIUm9hWE11YkdsdVpYTXVjSFZ6YUNoc2FXNWxLVHRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUdGa1pGUnZjRTFoY21kcGJpaDBiM0JOWVhKbmFXNUVaWEIwYUNrZ2UxeHVJQ0FnSUdOdmJuTjBJSGRwWkhSb0lEMGdkR2hwY3k1blpYUlhhV1IwYUNncExGeHVJQ0FnSUNBZ0lDQWdJSFJ2Y0UxaGNtZHBibGRwWkhSb0lEMGdkMmxrZEdnc0lDQXZMeTljYmlBZ0lDQWdJQ0FnSUNCMGIzQk5ZWEpuYVc1VGRISnBibWNnUFNCdFlYSm5hVzVUZEhKcGJtZEdjbTl0VFdGeVoybHVWMmxrZEdnb2RHOXdUV0Z5WjJsdVYybGtkR2dwTzF4dVhHNGdJQ0FnWm05eUlDaHNaWFFnYVc1a1pYZ2dQU0F3T3lCcGJtUmxlQ0E4SUhSdmNFMWhjbWRwYmtSbGNIUm9PeUJwYm1SbGVDc3JLU0I3WEc0Z0lDQWdJQ0IwYUdsekxteHBibVZ6TG5WdWMyaHBablFvZEc5d1RXRnlaMmx1VTNSeWFXNW5LVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JoWkdSTVpXWjBUV0Z5WjJsdUtHeGxablJOWVhKbmFXNVhhV1IwYUNrZ2UxeHVJQ0FnSUdOdmJuTjBJR3hsWm5STllYSm5hVzVUZEhKcGJtY2dQU0J0WVhKbmFXNVRkSEpwYm1kR2NtOXRUV0Z5WjJsdVYybGtkR2dvYkdWbWRFMWhjbWRwYmxkcFpIUm9LU3hjYmlBZ0lDQWdJQ0FnSUNCc2FXNWxjMHhsYm1kMGFDQTlJSFJvYVhNdWJHbHVaWE11YkdWdVozUm9PMXh1WEc0Z0lDQWdabTl5SUNoc1pYUWdhVzVrWlhnZ1BTQXdPeUJwYm1SbGVDQThJR3hwYm1WelRHVnVaM1JvT3lCcGJtUmxlQ3NyS1NCN1hHNGdJQ0FnSUNCMGFHbHpMbXhwYm1WelcybHVaR1Y0WFNBOUlHeGxablJOWVhKbmFXNVRkSEpwYm1jZ0t5QjBhR2x6TG14cGJtVnpXMmx1WkdWNFhUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQmhaR1JTYVdkb2RFMWhjbWRwYmloeWFXZG9kRTFoY21kcGJsZHBaSFJvS1NCN1hHNGdJQ0FnWTI5dWMzUWdjbWxuYUhSTllYSm5hVzVUZEhKcGJtY2dQU0J0WVhKbmFXNVRkSEpwYm1kR2NtOXRUV0Z5WjJsdVYybGtkR2dvY21sbmFIUk5ZWEpuYVc1WGFXUjBhQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2JHbHVaWE5NWlc1bmRHZ2dQU0IwYUdsekxteHBibVZ6TG14bGJtZDBhRHRjYmx4dUlDQWdJR1p2Y2lBb2JHVjBJR2x1WkdWNElEMGdNRHNnYVc1a1pYZ2dQQ0JzYVc1bGMweGxibWQwYURzZ2FXNWtaWGdyS3lrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTVzYVc1bGMxdHBibVJsZUYwZ1BTQjBhR2x6TG14cGJtVnpXMmx1WkdWNFhTQXJJSEpwWjJoMFRXRnlaMmx1VTNSeWFXNW5PMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR0ZrWkVKdmRIUnZiVTFoY21kcGJpaGliM1IwYjIxTllYSm5hVzVFWlhCMGFDa2dlMXh1SUNBZ0lHTnZibk4wSUhkcFpIUm9JRDBnZEdocGN5NW5aWFJYYVdSMGFDZ3BMRnh1SUNBZ0lDQWdJQ0FnSUdKdmRIUnZiVTFoY21kcGJsZHBaSFJvSUQwZ2QybGtkR2dzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0JpYjNSMGIyMU5ZWEpuYVc1VGRISnBibWNnUFNCdFlYSm5hVzVUZEhKcGJtZEdjbTl0VFdGeVoybHVWMmxrZEdnb1ltOTBkRzl0VFdGeVoybHVWMmxrZEdncE8xeHVYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2FXNWtaWGdnUFNBd095QnBibVJsZUNBOElHSnZkSFJ2YlUxaGNtZHBia1JsY0hSb095QnBibVJsZUNzcktTQjdYRzRnSUNBZ0lDQjBhR2x6TG14cGJtVnpMbkIxYzJnb1ltOTBkRzl0VFdGeVoybHVVM1J5YVc1bktUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ1hHNGdJSEJ2Y0V4cGJtVW9LU0I3SUhKbGRIVnliaUIwYUdsekxteHBibVZ6TG5CdmNDZ3BPeUI5WEc0Z0lGeHVJQ0J6YUdsbWRFeHBibVVvS1NCN0lISmxkSFZ5YmlCMGFHbHpMbXhwYm1WekxuTm9hV1owS0NrN0lIMWNiaUFnWEc0Z0lIQjFjMmhNYVc1bEtHeHBibVVwSUhzZ2RHaHBjeTVzYVc1bGN5NXdkWE5vS0d4cGJtVXBPeUI5WEc0Z0lGeHVJQ0IxYm5Ob2FXWjBUR2x1WlNoc2FXNWxLU0I3SUhSb2FYTXViR2x1WlhNdWRXNXphR2xtZENoc2FXNWxLVHNnZlZ4dVhHNGdJR0Z6VTNSeWFXNW5LQ2tnZTF4dUlDQWdJR052Ym5OMElITjBjbWx1WnlBOUlIUm9hWE11YkdsdVpYTXVjbVZrZFdObEtDaHpkSEpwYm1jc0lHeHBibVVwSUQwK0lIdGNiaUFnSUNBZ0lITjBjbWx1WnlBclBTQnNhVzVsSUNzZ1RrVlhYMHhKVGtWZlEwaEJVa0ZEVkVWU08xeHVYRzRnSUNBZ0lDQnlaWFIxY200Z2MzUnlhVzVuTzF4dUlDQWdJSDBzSUVWTlVGUlpYMU5VVWtsT1J5azdYRzVjYmlBZ0lDQnlaWFIxY200Z2MzUnlhVzVuTzF4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlHMWhjbWRwYmxOMGNtbHVaMFp5YjIxTllYSm5hVzVYYVdSMGFDaHRZWEpuYVc1WGFXUjBhQ3dnYzNCaFkyVkRhR0Z5WVdOMFpYSXBJSHRjYmlBZ2MzQmhZMlZEYUdGeVlXTjBaWElnUFNCemNHRmpaVU5vWVhKaFkzUmxjaUI4ZkNCVFVFRkRSVjlEU0VGU1FVTlVSVkk3WEc1Y2JpQWdiR1YwSUcxaGNtZHBibE4wY21sdVp5QTlJRVZOVUZSWlgxTlVVa2xPUnp0Y2JseHVJQ0JtYjNJZ0tHeGxkQ0JwYm1SbGVDQTlJREE3SUdsdVpHVjRJRHdnYldGeVoybHVWMmxrZEdnN0lHbHVaR1Y0S3lzcElIdGNiaUFnSUNCdFlYSm5hVzVUZEhKcGJtY2dLejBnYzNCaFkyVkRhR0Z5WVdOMFpYSTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdiV0Z5WjJsdVUzUnlhVzVuTzF4dWZWeHVJbDBzSW01aGJXVnpJanBiSWs1RlYxOU1TVTVGWDBOSVFWSkJRMVJGVWlJc0ltTm9ZWEpoWTNSbGNuTWlMQ0pUVUVGRFJWOURTRUZTUVVOVVJWSWlMQ0pRWVhKelpWUnlaV1VpTENKc2FXNWxjeUlzSW1Oc2IyNWxJaXdpYzJ4cFkyVWlMQ0p3WVhKelpWUnlaV1VpTENKblpYUlhhV1IwYUNJc0luZHBaSFJvSWl3aWJHbHVaWE5NWlc1bmRHZ2lMQ0pzWlc1bmRHZ2lMQ0pzWVhOMFRHbHVaU0lzSW14aGMzUWlMQ0pzWVhOMFRHbHVaVXhsYm1kMGFDSXNJbWRsZEVSbGNIUm9JaXdpWkdWd2RHZ2lMQ0ptYjNKRllXTm9UR2x1WlNJc0ltTmhiR3hpWVdOcklpd2labTl5UldGamFDSXNJbUZ3Y0dWdVpGUnZWRzl3SWl3aWJHbHVaU0lzSW5WdWMyaHBablFpTENKaGNIQmxibVJVYjB4bFpuUWlMQ0pwYm1SbGVDSXNJbUZ3Y0dWdVpGUnZVbWxuYUhRaUxDSmhjSEJsYm1SVWIwSnZkSFJ2YlNJc0luQjFjMmdpTENKaFpHUlViM0JOWVhKbmFXNGlMQ0owYjNCTllYSm5hVzVFWlhCMGFDSXNJblJ2Y0UxaGNtZHBibGRwWkhSb0lpd2lkRzl3VFdGeVoybHVVM1J5YVc1bklpd2liV0Z5WjJsdVUzUnlhVzVuUm5KdmJVMWhjbWRwYmxkcFpIUm9JaXdpWVdSa1RHVm1kRTFoY21kcGJpSXNJbXhsWm5STllYSm5hVzVYYVdSMGFDSXNJbXhsWm5STllYSm5hVzVUZEhKcGJtY2lMQ0poWkdSU2FXZG9kRTFoY21kcGJpSXNJbkpwWjJoMFRXRnlaMmx1VjJsa2RHZ2lMQ0p5YVdkb2RFMWhjbWRwYmxOMGNtbHVaeUlzSW1Ga1pFSnZkSFJ2YlUxaGNtZHBiaUlzSW1KdmRIUnZiVTFoY21kcGJrUmxjSFJvSWl3aVltOTBkRzl0VFdGeVoybHVWMmxrZEdnaUxDSmliM1IwYjIxTllYSm5hVzVUZEhKcGJtY2lMQ0p3YjNCTWFXNWxJaXdpY0c5d0lpd2ljMmhwWm5STWFXNWxJaXdpYzJocFpuUWlMQ0p3ZFhOb1RHbHVaU0lzSW5WdWMyaHBablJNYVc1bElpd2lZWE5UZEhKcGJtY2lMQ0p6ZEhKcGJtY2lMQ0p5WldSMVkyVWlMQ0pGVFZCVVdWOVRWRkpKVGtjaUxDSnRZWEpuYVc1WGFXUjBhQ0lzSW5Od1lXTmxRMmhoY21GamRHVnlJaXdpYldGeVoybHVVM1J5YVc1bklsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJUSkNMRWxCUVVFc1ZVRkJWeXhYUVVGWUxGZEJRVmNzUTBGQlFUdEJRVVZxUWl4SlFVRkJMRTFCUVcxQ0xGZEJRVzVDTEcxQ1FVRnRRaXhEUVVGQk8wRkJSVmdzU1VGQlFTeFZRVUZoTEZkQlFXSXNZVUZCWVN4RFFVRkJPenM3T3pzN096czdPRVJCVGpGRE8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN1FVRlJRU3hKUVVGUlFTeHJRa0ZCYTBJc1IwRkJjMEpETEZWQlFWVXNXVUZCYkVSRUxHdENRVUZyUWl4RlFVRkZSU3hsUVVGbExFZEJRVXRFTEZWQlFWVXNXVUZCT1VKRExHVkJRV1VzUVVGQlowSTdRVUZGTlVNc1NVRkJRU3hCUVVGTlF5eFRRVUZUTEdsQ1FYbElNMElzUVVGNlNGazdZVUZCVFVFc1UwRkJVeXhEUVVOb1FrTXNTMEZCU3p0M1EwRllia0k3VVVGWlNTeEpRVUZKTEVOQlFVTkJMRXRCUVVzc1IwRkJSMEVzUzBGQlN5eERRVUZET3pzN08xbEJSM0pDUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VObVVDeFBSR1ZGUVN4VFFVRkJRU3hMUVVGTExFZEJRVWM3WjBKQlEwNHNTVUZCVFVRc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlEwRXNTMEZCU3l4RFFVRkRSU3hMUVVGTExFVkJRVVVzUlVGRE1VSkRMRk5CUVZNc1IwRkJSeXhKUVVGSlNpeFRRVUZUTEVOQlFVTkRMRXRCUVVzc1EwRkJReXhCUVVGRE8yZENRVVYyUXl4UFFVRlBSeXhUUVVGVExFTkJRVU03WVVGRGJFSTdPenRaUVVWRVF5eEhRVUZSTEVWQlFWSkJMRlZCUVZFN1dVTjBRbFlzVDBSelFrVkJMRk5CUVVGQkxGRkJRVkVzUjBGQlJ6dG5Ra0ZEVkN4SlFVRkpReXhMUVVGTExFRkJRVU03WjBKQlJWWXNTVUZCU1VNc1YwRkJWeXhIUVVGSExFbEJRVWtzUTBGQlEwNHNTMEZCU3l4RFFVRkRUeXhOUVVGTkxFRkJRVU03WjBKQlJYQkRMRWxCUVVsRUxGZEJRVmNzUzBGQlN5eERRVUZETEVWQlFVVTdiMEpCUTNKQ1JDeExRVUZMTEVkQlFVY3NRMEZCUXl4RFFVRkRPMmxDUVVOWUxFMUJRVTA3YjBKQlEwd3NTVUZCVFVjc1VVRkJVU3hIUVVGSFF5eERRVUZCUVN4SFFVRkJRU3hOUVVGSkxFRkJRVmtzUTBGQlFTeE5RVUZZTEVsQlFVa3NRMEZCUTFRc1MwRkJTeXhEUVVGRExFVkJRek5DVlN4alFVRmpMRWRCUVVkR0xGRkJRVkVzUTBGQlEwUXNUVUZCVFN4QlFVRkRPMjlDUVVWMlEwWXNTMEZCU3l4SFFVRkhTeXhqUVVGakxFTkJRVU1zUTBGQlF5eEhRVUZITzJsQ1FVTTFRanRuUWtGRlJDeFBRVUZQVEN4TFFVRkxMRU5CUVVNN1lVRkRaRHM3TzFsQlJVUk5MRWRCUVZFc1JVRkJVa0VzVlVGQlVUdFpRM1pEVml4UFJIVkRSVUVzVTBGQlFVRXNVVUZCVVN4SFFVRkhPMmRDUVVOVUxFbEJRVTFNTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVOT0xFdEJRVXNzUTBGQlEwOHNUVUZCVFN4RlFVTXZRa3NzUzBGQlN5eEhRVUZIVGl4WFFVRlhMRUZCUVVNc1JVRkJSU3hIUVVGSE8yZENRVVV2UWl4UFFVRlBUU3hMUVVGTExFTkJRVU03WVVGRFpEczdPMWxCUlVSRExFZEJRVmNzUlVGQldFRXNZVUZCVnp0WlF6bERZaXhQUkRoRFJVRXNVMEZCUVVFc1YwRkJWeXhEUVVGRFF5eFJRVUZSTEVWQlFVVTdaMEpCUTNCQ0xFbEJRVWtzUTBGQlEyUXNTMEZCU3l4RFFVRkRaU3hQUVVGUExFTkJRVU5FTEZGQlFWRXNRMEZCUXl4RFFVRkRPMkZCUXpsQ096czdXVUZGUkVVc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRGJFUmlMRTlFYTBSRlFTeFRRVUZCUVN4WFFVRlhMRU5CUVVOaUxGTkJRVk1zUlVGQlJUczdaMEpCUTNKQ1FTeFRRVUZUTEVOQlFVTlZMRmRCUVZjc1EwRkJReXhUUVVGRFNTeEpRVUZKTEVWQlFVczdiMEpCUXpsQ0xFMUJRVXRxUWl4TFFVRkxMRU5CUVVOclFpeFBRVUZQTEVOQlFVTkVMRWxCUVVrc1EwRkJReXhEUVVGRE8ybENRVU14UWl4RFFVRkRMRU5CUVVNN1lVRkRTanM3TzFsQlJVUkZMRWRCUVZrc1JVRkJXa0VzWTBGQldUdFpRM2hFWkN4UFJIZEVSVUVzVTBGQlFVRXNXVUZCV1N4RFFVRkRhRUlzVTBGQlV5eEZRVUZGT3p0blFrRkRkRUpCTEZOQlFWTXNRMEZCUTFVc1YwRkJWeXhEUVVGRExGTkJRVU5KTEVsQlFVa3NSVUZCUlVjc1MwRkJTeXhGUVVGTE8yOUNRVU55UXl4TlFVRkxjRUlzUzBGQlN5eERRVUZEYjBJc1MwRkJTeXhEUVVGRExFZEJRVWRJTEVsQlFVa3NSMEZCUnl4TlFVRkxha0lzUzBGQlN5eERRVUZEYjBJc1MwRkJTeXhEUVVGRExFTkJRVU03YVVKQlF6bERMRU5CUVVNc1EwRkJRenRoUVVOS096czdXVUZGUkVNc1IwRkJZU3hGUVVGaVFTeGxRVUZoTzFsRE9VUm1MRTlFT0VSRlFTeFRRVUZCUVN4aFFVRmhMRU5CUVVOc1FpeFRRVUZUTEVWQlFVVTdPMmRDUVVOMlFrRXNVMEZCVXl4RFFVRkRWU3hYUVVGWExFTkJRVU1zVTBGQlEwa3NTVUZCU1N4RlFVRkZSeXhMUVVGTExFVkJRVXM3YjBKQlEzSkRMRTFCUVV0d1FpeExRVUZMTEVOQlFVTnZRaXhMUVVGTExFTkJRVU1zUjBGQlJ5eE5RVUZMY0VJc1MwRkJTeXhEUVVGRGIwSXNTMEZCU3l4RFFVRkRMRWRCUVVkSUxFbEJRVWtzUTBGQlF6dHBRa0ZET1VNc1EwRkJReXhEUVVGRE8yRkJRMG83T3p0WlFVVkVTeXhIUVVGakxFVkJRV1JCTEdkQ1FVRmpPMWxEY0VWb1FpeFBSRzlGUlVFc1UwRkJRVUVzWTBGQll5eERRVUZEYmtJc1UwRkJVeXhGUVVGRk96dG5Ra0ZEZUVKQkxGTkJRVk1zUTBGQlExVXNWMEZCVnl4RFFVRkRMRk5CUVVOSkxFbEJRVWtzUlVGQlN6dHZRa0ZET1VJc1RVRkJTMnBDTEV0QlFVc3NRMEZCUTNWQ0xFbEJRVWtzUTBGQlEwNHNTVUZCU1N4RFFVRkRMRU5CUVVNN2FVSkJRM1pDTEVOQlFVTXNRMEZCUXp0aFFVTktPenM3V1VGRlJFOHNSMEZCV1N4RlFVRmFRU3hqUVVGWk8xbERNVVZrTEU5RU1FVkZRU3hUUVVGQlFTeFpRVUZaTEVOQlFVTkRMR05CUVdNc1JVRkJSVHRuUWtGRE0wSXNTVUZCVFhCQ0xFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTkVMRkZCUVZFc1JVRkJSU3hGUVVOMlFuTkNMR05CUVdNc1IwRkJSM0pDTEV0QlFVc3NSVUZEZEVKelFpeGxRVUZsTEVkQlFVZERMREpDUVVFeVFpeERRVUZEUml4alFVRmpMRU5CUVVNc1FVRkJRenRuUWtGRmNFVXNTVUZCU3l4SlFVRkpUaXhMUVVGTExFZEJRVWNzUTBGQlF5eEZRVUZGUVN4TFFVRkxMRWRCUVVkTExHTkJRV01zUlVGQlJVd3NTMEZCU3l4RlFVRkZMRU5CUVVVN2IwSkJRMjVFTEVsQlFVa3NRMEZCUTNCQ0xFdEJRVXNzUTBGQlEydENMRTlCUVU4c1EwRkJRMU1zWlVGQlpTeERRVUZETEVOQlFVTTdhVUpCUTNKRE8yRkJRMFk3T3p0WlFVVkVSU3hIUVVGaExFVkJRV0pCTEdWQlFXRTdXVU53Um1Zc1QwUnZSa1ZCTEZOQlFVRkJMR0ZCUVdFc1EwRkJRME1zWlVGQlpTeEZRVUZGTzJkQ1FVTTNRaXhKUVVGTlF5eG5Ra0ZCWjBJc1IwRkJSMGdzTWtKQlFUSkNMRU5CUVVORkxHVkJRV1VzUTBGQlF5eEZRVU12UkhoQ0xGZEJRVmNzUjBGQlJ5eEpRVUZKTEVOQlFVTk9MRXRCUVVzc1EwRkJRMDhzVFVGQlRTeEJRVUZETzJkQ1FVVjBReXhKUVVGTExFbEJRVWxoTEV0QlFVc3NSMEZCUnl4RFFVRkRMRVZCUVVWQkxFdEJRVXNzUjBGQlIyUXNWMEZCVnl4RlFVRkZZeXhMUVVGTExFVkJRVVVzUTBGQlJUdHZRa0ZEYUVRc1NVRkJTU3hEUVVGRGNFSXNTMEZCU3l4RFFVRkRiMElzUzBGQlN5eERRVUZETEVkQlFVZFhMR2RDUVVGblFpeEhRVUZITEVsQlFVa3NRMEZCUXk5Q0xFdEJRVXNzUTBGQlEyOUNMRXRCUVVzc1EwRkJReXhEUVVGRE8ybENRVU14UkR0aFFVTkdPenM3V1VGRlJGa3NSMEZCWXl4RlFVRmtRU3huUWtGQll6dFpRemRHYUVJc1QwUTJSa1ZCTEZOQlFVRkJMR05CUVdNc1EwRkJRME1zWjBKQlFXZENMRVZCUVVVN1owSkJReTlDTEVsQlFVMURMR2xDUVVGcFFpeEhRVUZIVGl3eVFrRkJNa0lzUTBGQlEwc3NaMEpCUVdkQ0xFTkJRVU1zUlVGRGFrVXpRaXhYUVVGWExFZEJRVWNzU1VGQlNTeERRVUZEVGl4TFFVRkxMRU5CUVVOUExFMUJRVTBzUVVGQlF6dG5Ra0ZGZEVNc1NVRkJTeXhKUVVGSllTeExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVRkZRU3hMUVVGTExFZEJRVWRrTEZkQlFWY3NSVUZCUldNc1MwRkJTeXhGUVVGRkxFTkJRVVU3YjBKQlEyaEVMRWxCUVVrc1EwRkJRM0JDTEV0QlFVc3NRMEZCUTI5Q0xFdEJRVXNzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUTNCQ0xFdEJRVXNzUTBGQlEyOUNMRXRCUVVzc1EwRkJReXhIUVVGSFl5eHBRa0ZCYVVJc1EwRkJRenRwUWtGRE0wUTdZVUZEUmpzN08xbEJSVVJETEVkQlFXVXNSVUZCWmtFc2FVSkJRV1U3V1VOMFIycENMRTlFYzBkRlFTeFRRVUZCUVN4bFFVRmxMRU5CUVVORExHbENRVUZwUWl4RlFVRkZPMmRDUVVOcVF5eEpRVUZOTDBJc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlEwUXNVVUZCVVN4RlFVRkZMRVZCUTNaQ2FVTXNhVUpCUVdsQ0xFZEJRVWRvUXl4TFFVRkxMRVZCUTNwQ2FVTXNhMEpCUVd0Q0xFZEJRVWRXTERKQ1FVRXlRaXhEUVVGRFV5eHBRa0ZCYVVJc1EwRkJReXhCUVVGRE8yZENRVVV4UlN4SlFVRkxMRWxCUVVscVFpeExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVRkZRU3hMUVVGTExFZEJRVWRuUWl4cFFrRkJhVUlzUlVGQlJXaENMRXRCUVVzc1JVRkJSU3hEUVVGRk8yOUNRVU4wUkN4SlFVRkpMRU5CUVVOd1FpeExRVUZMTEVOQlFVTjFRaXhKUVVGSkxFTkJRVU5sTEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03YVVKQlEzSkRPMkZCUTBZN096dFpRVVZFUXl4SFFVRlBMRVZCUVZCQkxGTkJRVTg3V1VOb1NGUXNUMFJuU0VWQkxGTkJRVUZCTEU5QlFVOHNSMEZCUnp0blFrRkJSU3hQUVVGUExFbEJRVWtzUTBGQlEzWkRMRXRCUVVzc1EwRkJRM2RETEVkQlFVY3NSVUZCUlN4RFFVRkRPMkZCUVVVN096dFpRVVYwUTBNc1IwRkJVeXhGUVVGVVFTeFhRVUZUTzFsRGJFaFlMRTlFYTBoRlFTeFRRVUZCUVN4VFFVRlRMRWRCUVVjN1owSkJRVVVzVDBGQlR5eEpRVUZKTEVOQlFVTjZReXhMUVVGTExFTkJRVU13UXl4TFFVRkxMRVZCUVVVc1EwRkJRenRoUVVGRk96czdXVUZGTVVORExFZEJRVkVzUlVGQlVrRXNWVUZCVVR0WlEzQklWaXhQUkc5SVJVRXNVMEZCUVVFc1VVRkJVU3hEUVVGRE1VSXNTVUZCU1N4RlFVRkZPMmRDUVVGRkxFbEJRVWtzUTBGQlEycENMRXRCUVVzc1EwRkJRM1ZDTEVsQlFVa3NRMEZCUTA0c1NVRkJTU3hEUVVGRExFTkJRVU03WVVGQlJUczdPMWxCUlhwRE1rSXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbERkRWhpTEU5RWMwaEZRU3hUUVVGQlFTeFhRVUZYTEVOQlFVTXpRaXhKUVVGSkxFVkJRVVU3WjBKQlFVVXNTVUZCU1N4RFFVRkRha0lzUzBGQlN5eERRVUZEYTBJc1QwRkJUeXhEUVVGRFJDeEpRVUZKTEVOQlFVTXNRMEZCUXp0aFFVRkZPenM3V1VGRkwwTTBRaXhIUVVGUkxFVkJRVkpCTEZWQlFWRTdXVU40U0ZZc1QwUjNTRVZCTEZOQlFVRkJMRkZCUVZFc1IwRkJSenRuUWtGRFZDeEpRVUZOUXl4UFFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE9VTXNTMEZCU3l4RFFVRkRLME1zVFVGQlRTeERRVUZETEZOQlFVTkVMRTFCUVUwc1JVRkJSVGRDTEVsQlFVa3NSVUZCU3p0dlFrRkRha1EyUWl4TlFVRk5MRWxCUVVrM1FpeEpRVUZKTEVkQlFVZHlRaXhyUWtGQmEwSXNRMEZCUXp0dlFrRkZjRU1zVDBGQlQydEVMRTFCUVUwc1EwRkJRenRwUWtGRFppeEZRVUZGUlN4VlFVRlpMR05CUVVNc1FVRkJRenRuUWtGRmFrSXNUMEZCVDBZc1QwRkJUU3hEUVVGRE8yRkJRMlk3TzAxQmFFbElPenREUVdsSlF5eEZRVUZCTzJ0Q1FYWkliMEl2UXl4VFFVRlRMRUZCVmpsQ08wRkJiVWxCTEZOQlFWTTJRaXd5UWtGQk1rSXNRMEZCUTNGQ0xGZEJRVmNzUlVGQlJVTXNZMEZCWXl4RlFVRkZPMGxCUTJoRlFTeGpRVUZqTEVkQlFVZEJMR05CUVdNc1NVRkJTWEJFTEdWQlFXVXNRMEZCUXp0SlFVVnVSQ3hKUVVGSmNVUXNXVUZCV1N4SFFVRkhTQ3hWUVVGWkxHRkJRVUVzUVVGQlF6dEpRVVZvUXl4SlFVRkxMRWxCUVVrMVFpeExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVRkZRU3hMUVVGTExFZEJRVWMyUWl4WFFVRlhMRVZCUVVVM1FpeExRVUZMTEVWQlFVVXNRMEZCUlR0UlFVTm9SQ3RDTEZsQlFWa3NTVUZCU1VRc1kwRkJZeXhEUVVGRE8wdEJRMmhETzBsQlJVUXNUMEZCVDBNc1dVRkJXU3hEUVVGRE8wTkJRM0pDSW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbmVjZXNzYXJ5ID0gcmVxdWlyZShcIm5lY2Vzc2FyeVwiKTtcbnZhciBfcGFyc2VUcmVlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFyc2VUcmVlXCIpKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEJBUl9DSEFSQUNURVIgPSBfbmVjZXNzYXJ5LmNoYXJhY3RlcnMuQkFSX0NIQVJBQ1RFUjtcbnZhciBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUGFyc2VUcmVlKSB7XG4gICAgX2luaGVyaXRzKFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLCBQYXJzZVRyZWUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuICAgIGZ1bmN0aW9uIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKGxpbmVzLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsaW5lcyk7XG4gICAgICAgIF90aGlzLnZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFkZExlZnRNYXJnaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLnByb3RvdHlwZSksIFwiYWRkTGVmdE1hcmdpblwiLCB0aGlzKS5jYWxsKHRoaXMsIGxlZnRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uICs9IGxlZnRNYXJnaW5XaWR0aDsgLy8vXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tV2lkdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gQkFSX0NIQVJBQ1RFUiwgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IDAsIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oVmVydGljYWxCcmFuY2hQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbiksIGxlZnRNYXJnaW5XaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKSwgcmlnaHRNYXJnaW5XaWR0aCA9IHdpZHRoIC0gbGVmdE1hcmdpbldpZHRoIC0gMTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbURlcHRoQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21EZXB0aEFuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oQ2xhc3MsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gbGluZXNGcm9tRGVwdGgoZGVwdGgpLCBhcmdzID0gW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvblxuICAgICAgICAgICAgICAgIF0sIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDbGFzcywgYXJncykpOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljYWxCcmFuY2hQYXJzZVRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENsYXNzLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBzdHJpbmc7IC8vL1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBDbGFzczsgLy8vXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gX3BhcnNlVHJlZS5kZWZhdWx0OyAvLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdHJpbmcsIGxpbmVzID0gW1xuICAgICAgICAgICAgICAgICAgICBsaW5lXG4gICAgICAgICAgICAgICAgXSwgYXJncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb25cbiAgICAgICAgICAgICAgICBdLCB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ2xhc3MsIGFyZ3MpKTsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xufShfcGFyc2VUcmVlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWU7XG5mdW5jdGlvbiBsaW5lc0Zyb21EZXB0aChkZXB0aCkge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUoaW5kZXggPCBkZXB0aCl7XG4gICAgICAgIGxpbmVzW2luZGV4KytdID0gX2NvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYSnpaVlJ5WldVdmRtVnlkR2xqWVd4Q2NtRnVZMmd1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJR05vWVhKaFkzUmxjbk1nZlNCbWNtOXRJRndpYm1WalpYTnpZWEo1WENJN1hHNWNibWx0Y0c5eWRDQlFZWEp6WlZSeVpXVWdabkp2YlNCY0lpNHVMM0JoY25ObFZISmxaVndpTzF4dVhHNXBiWEJ2Y25RZ2V5QkZUVkJVV1Y5VFZGSkpUa2NnZlNCbWNtOXRJRndpTGk0dlkyOXVjM1JoYm5SelhDSTdYRzVjYm1OdmJuTjBJSHNnUWtGU1gwTklRVkpCUTFSRlVpQjlJRDBnWTJoaGNtRmpkR1Z5Y3p0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWdaWGgwWlc1a2N5QlFZWEp6WlZSeVpXVWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaHNhVzVsY3l3Z2RtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaWtnZTF4dUlDQWdJSE4xY0dWeUtHeHBibVZ6S1R0Y2JpQWdJQ0JjYmlBZ0lDQjBhR2x6TG5abGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNGdQU0IyWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dU8xeHVJQ0I5WEc0Z0lGeHVJQ0JuWlhSV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TG5abGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNDdYRzRnSUgxY2JseHVJQ0JoWkdSTVpXWjBUV0Z5WjJsdUtHeGxablJOWVhKbmFXNVhhV1IwYUNrZ2UxeHVJQ0FnSUhOMWNHVnlMbUZrWkV4bFpuUk5ZWEpuYVc0b2JHVm1kRTFoY21kcGJsZHBaSFJvS1R0Y2JseHVJQ0FnSUhSb2FYTXVkbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlBclBTQnNaV1owVFdGeVoybHVWMmxrZEdnN0lDOHZMMXh1SUNCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxWGFXUjBhQ2gzYVdSMGFDa2dlMXh1SUNBZ0lHTnZibk4wSUhOMGNtbHVaeUE5SUVKQlVsOURTRUZTUVVOVVJWSXNYRzRnSUNBZ0lDQWdJQ0FnZG1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpQTlJREFzWEc0Z0lDQWdJQ0FnSUNBZ2RtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1VnUFNCV1pYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaUzVtY205dFUzUnlhVzVuUVc1a1ZtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaWhXWlhKMGFXTmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTd2djM1J5YVc1bkxDQjJaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1S1N4Y2JpQWdJQ0FnSUNBZ0lDQnNaV1owVFdGeVoybHVWMmxrZEdnZ1BTQk5ZWFJvTG1ac2IyOXlLSGRwWkhSb0x6SXBMRnh1SUNBZ0lDQWdJQ0FnSUhKcFoyaDBUV0Z5WjJsdVYybGtkR2dnUFNCM2FXUjBhQ0F0SUd4bFpuUk5ZWEpuYVc1WGFXUjBhQ0F0SURFN1hHNWNiaUFnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaUzVoWkdSTVpXWjBUV0Z5WjJsdUtHeGxablJOWVhKbmFXNVhhV1IwYUNrN1hHNGdJQ0FnZG1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVXVZV1JrVW1sbmFIUk5ZWEpuYVc0b2NtbG5hSFJOWVhKbmFXNVhhV1IwYUNrN1hHNWNiaUFnSUNCeVpYUjFjbTRnZG1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlVSbGNIUm9RVzVrVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpaERiR0Z6Y3l3Z1pHVndkR2dzSUhabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNHBJSHRjYmlBZ0lDQmpiMjV6ZENCc2FXNWxjeUE5SUd4cGJtVnpSbkp2YlVSbGNIUm9LR1JsY0hSb0tTeGNiaUFnSUNBZ0lDQWdJQ0JoY21keklEMGdXMjUxYkd3c0lHeHBibVZ6TENCMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVYU3hjYmlBZ0lDQWdJQ0FnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0E5SUc1bGR5QW9SblZ1WTNScGIyNHVjSEp2ZEc5MGVYQmxMbUpwYm1RdVlYQndiSGtvUTJ4aGMzTXNJR0Z5WjNNcEtUc2dJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJSFpsY25ScFkyRnNRbkpoYm1Ob1VHRnljMlZVY21WbE8xeHVJQ0I5WEc1Y2JpQWdjM1JoZEdsaklHWnliMjFUZEhKcGJtZEJibVJXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUtFTnNZWE56TENCemRISnBibWNzSUhabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNHBJSHRjYmlBZ0lDQnBaaUFvZG1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpQTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJRDBnYzNSeWFXNW5PeUFnTHk4dlhHNGdJQ0FnSUNCemRISnBibWNnUFNCRGJHRnpjenNnTHk4dlhHNGdJQ0FnSUNCRGJHRnpjeUE5SUZCaGNuTmxWSEpsWlRzZ0lDOHZMMXh1SUNBZ0lIMWNiaUFnSUNCY2JpQWdJQ0JqYjI1emRDQnNhVzVsSUQwZ2MzUnlhVzVuTENBdkx5OWNiaUFnSUNBZ0lDQWdJQ0JzYVc1bGN5QTlJRnRzYVc1bFhTeGNiaUFnSUNBZ0lDQWdJQ0JoY21keklEMGdXMjUxYkd3c0lHeHBibVZ6TENCMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVYU3hjYmlBZ0lDQWdJQ0FnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0E5SUc1bGR5QW9SblZ1WTNScGIyNHVjSEp2ZEc5MGVYQmxMbUpwYm1RdVlYQndiSGtvUTJ4aGMzTXNJR0Z5WjNNcEtUc2dJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJSFpsY25ScFkyRnNRbkpoYm1Ob1VHRnljMlZVY21WbE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR3hwYm1WelJuSnZiVVJsY0hSb0tHUmxjSFJvS1NCN1hHNGdJR052Ym5OMElHeHBibVZ6SUQwZ1cxMDdYRzVjYmlBZ2JHVjBJR2x1WkdWNElEMGdNRHRjYmx4dUlDQjNhR2xzWlNBb2FXNWtaWGdnUENCa1pYQjBhQ2tnZTF4dUlDQWdJR3hwYm1WelcybHVaR1Y0S3l0ZElEMGdSVTFRVkZsZlUxUlNTVTVITzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUd4cGJtVnpPMXh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJa0pCVWw5RFNFRlNRVU5VUlZJaUxDSmphR0Z5WVdOMFpYSnpJaXdpVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWlMQ0pzYVc1bGN5SXNJblpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0aUxDSm5aWFJXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUlpd2lZV1JrVEdWbWRFMWhjbWRwYmlJc0lteGxablJOWVhKbmFXNVhhV1IwYUNJc0ltWnliMjFYYVdSMGFDSXNJbmRwWkhSb0lpd2ljM1J5YVc1bklpd2lkbVZ5ZEdsallXeENjbUZ1WTJoUVlYSnpaVlJ5WldVaUxDSm1jbTl0VTNSeWFXNW5RVzVrVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpSXNJazFoZEdnaUxDSm1iRzl2Y2lJc0luSnBaMmgwVFdGeVoybHVWMmxrZEdnaUxDSmhaR1JTYVdkb2RFMWhjbWRwYmlJc0ltWnliMjFFWlhCMGFFRnVaRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0aUxDSkRiR0Z6Y3lJc0ltUmxjSFJvSWl3aWJHbHVaWE5HY205dFJHVndkR2dpTENKaGNtZHpJaXdpUm5WdVkzUnBiMjRpTENKd2NtOTBiM1I1Y0dVaUxDSmlhVzVrSWl3aVlYQndiSGtpTENKMWJtUmxabWx1WldRaUxDSlFZWEp6WlZSeVpXVWlMQ0pzYVc1bElpd2lhVzVrWlhnaUxDSkZUVkJVV1Y5VFZGSkpUa2NpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGTWtJc1NVRkJRU3hWUVVGWExGZEJRVmdzVjBGQlZ5eERRVUZCTzBGQlJXaENMRWxCUVVFc1ZVRkJZeXhyUTBGQlpDeGpRVUZqTEVWQlFVRTdRVUZGVUN4SlFVRkJMRlZCUVdNc1YwRkJaQ3hqUVVGakxFTkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZPTTBNN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096QkNRVUZCT3pzN096czdPenM3TzFOQlFVRTdPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPM2REUVVGQk96czdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFWRkJMRWxCUVUwc1FVRkJSVUVzWVVGQllTeEhRVUZMUXl4VlFVRlZMRmxCUVRWQ1JDeGhRVUZoTEVGQlFXVXNRVUZCUXp0QlFVVjBRaXhKUVVGQkxFRkJRVTFGTEhWQ1FVRjFRaXhwUWtGelJIcERMRUZCZEVSWk8ybEVRVlptT3p0aFFWVnhRa0VzZFVKQlFYVkNMRU5CUXpsQ1F5eExRVUZMTEVWQlFVVkRMSE5DUVVGelFqdHpSRUZZTTBNN08ydERRVmxWUkN4TFFVRkxMRU5EV21Zc1EwUlphVUk3VVVGRllpeE5RVUZMUXl4elFrRkJjMElzUjBGQlIwRXNjMEpCUVhOQ0xFTkJRVU03T3pzN08xbEJSM1pFUXl4SFFVRjVRaXhGUVVGNlFrRXNNa0pCUVhsQ08xbERha0l6UWl4UFJHbENSVUVzVTBGQlFVRXNlVUpCUVhsQ0xFZEJRVWM3WjBKQlF6RkNMRTlCUVU4c1NVRkJTU3hEUVVGRFJDeHpRa0ZCYzBJc1EwRkJRenRoUVVOd1F6czdPMWxCUlVSRkxFZEJRV0VzUlVGQllrRXNaVUZCWVR0WlEzSkNaaXhQUkhGQ1JVRXNVMEZCUVVFc1lVRkJZU3hEUVVGRFF5eGxRVUZsTEVWQlFVVTdaMEpCUXpkQ0xIRkNRVnBwUWt3c2RVSkJRWFZDTEdGQldXeERTU3hsUVVGaExFVkJRVzVDTEVsQlFVc3NRMEZCUVN4WlFVRmxReXhsUVVGbExFTkRkRUoyUXl4RFJITkNlVU03WjBKQlJYSkRMRWxCUVVrc1EwRkJRMGdzYzBKQlFYTkNMRWxCUVVsSExHVkJRV1VzUTBGQlF5eERRVUZETEVkQlFVYzdZVUZEY0VRN096czdXVUZGVFVNc1IwRkJVeXhGUVVGVVFTeFhRVUZUTzFsRE0wSnNRaXhQUkRKQ1JTeFRRVUZQUVN4VFFVRlRMRU5CUVVORExFdEJRVXNzUlVGQlJUdG5Ra0ZEZEVJc1NVRkJUVU1zVFVGQlRTeEhRVUZIVml4aFFVRmhMRVZCUTNSQ1NTeHpRa0ZCYzBJc1IwRkJSeXhEUVVGRExFVkJRekZDVHl4MVFrRkJkVUlzUjBGQlIxUXNkVUpCUVhWQ0xFTkJRVU5WTEcxRFFVRnRReXhEUVVGRFZpeDFRa0ZCZFVJc1JVRkJSVkVzVFVGQlRTeEZRVUZGVGl4elFrRkJjMElzUTBGQlF5eEZRVU01U1Vjc1pVRkJaU3hIUVVGSFRTeEpRVUZKTEVOQlFVTkRMRXRCUVVzc1EwRkJRMHdzUzBGQlN5eEhRVUZETEVOQlFVTXNRMEZCUXl4RlFVTnlRMDBzWjBKQlFXZENMRWRCUVVkT0xFdEJRVXNzUjBGQlIwWXNaVUZCWlN4SFFVRkhMRU5CUVVNc1FVRkJRenRuUWtGRmNrUkpMSFZDUVVGMVFpeERRVUZEVEN4aFFVRmhMRU5CUVVORExHVkJRV1VzUTBGQlF5eERRVUZETzJkQ1FVTjJSRWtzZFVKQlFYVkNMRU5CUVVOTExHTkJRV01zUTBGQlEwUXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dG5Ra0ZGZWtRc1QwRkJUMG9zZFVKQlFYVkNMRU5CUVVNN1lVRkRhRU03T3p0WlFVVk5UU3hIUVVGclF5eEZRVUZzUTBFc2IwTkJRV3RETzFsRGVFTXpReXhQUkhkRFJTeFRRVUZQUVN4clEwRkJhME1zUTBGQlEwTXNTMEZCU3l4RlFVRkZReXhMUVVGTExFVkJRVVZtTEhOQ1FVRnpRaXhGUVVGRk8yZENRVU01UlN4SlFVRk5SQ3hMUVVGTExFZEJRVWRwUWl4alFVRmpMRU5CUVVORUxFdEJRVXNzUTBGQlF5eEZRVU0zUWtVc1NVRkJTU3hIUVVGSE8yOUNRVUZETEVsQlFVazdiMEpCUVVWc1FpeExRVUZMTzI5Q1FVRkZReXh6UWtGQmMwSTdhVUpCUVVNc1JVRkROVU5QTEhWQ1FVRjFRaXhIUVVGSExFbEJRVWtzUTBGQlExY3NVVUZCVVN4RFFVRkRReXhUUVVGVExFTkJRVU5ETEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhEUVVGRFVDeExRVUZMTEVWQlFVVkhMRWxCUVVrc1EwRkJReXhEUVVGRExFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVjBSaXhQUVVGUFZpeDFRa0ZCZFVJc1EwRkJRenRoUVVOb1F6czdPMWxCUlUxRExFZEJRVzFETEVWQlFXNURRU3h4UTBGQmJVTTdXVU5vUkRWRExFOUVaMFJGTEZOQlFVOUJMRzFEUVVGdFF5eERRVUZEVFN4TFFVRkxMRVZCUVVWU0xFMUJRVTBzUlVGQlJVNHNjMEpCUVhOQ0xFVkJRVVU3WjBKQlEyaEdMRWxCUVVsQkxITkNRVUZ6UWl4TFFVRkxjMElzVTBGQlV5eEZRVUZGTzI5Q1FVTjRRM1JDTEhOQ1FVRnpRaXhIUVVGSFRTeE5RVUZOTEVOQlFVTXNRMEZCUlN4SFFVRkhPMjlDUVVOeVEwRXNUVUZCVFN4SFFVRkhVU3hMUVVGTExFTkJRVU1zUTBGQlF5eEhRVUZITzI5Q1FVTnVRa0VzUzBGQlN5eEhRVUZIVXl4VlFVRlRMRkZCUVVFc1EwRkJReXhEUVVGRkxFZEJRVWM3YVVKQlEzaENPMmRDUVVWRUxFbEJRVTFETEVsQlFVa3NSMEZCUjJ4Q0xFMUJRVTBzUlVGRFlsQXNTMEZCU3l4SFFVRkhPMjlDUVVGRGVVSXNTVUZCU1R0cFFrRkJReXhGUVVOa1VDeEpRVUZKTEVkQlFVYzdiMEpCUVVNc1NVRkJTVHR2UWtGQlJXeENMRXRCUVVzN2IwSkJRVVZETEhOQ1FVRnpRanRwUWtGQlF5eEZRVU0xUTA4c2RVSkJRWFZDTEVkQlFVY3NTVUZCU1N4RFFVRkRWeXhSUVVGUkxFTkJRVU5ETEZOQlFWTXNRMEZCUTBNc1NVRkJTU3hEUVVGRFF5eExRVUZMTEVOQlFVTlFMRXRCUVVzc1JVRkJSVWNzU1VGQlNTeERRVUZETEVOQlFVTXNRVUZCUXl4RlFVRkZMRWRCUVVjN1owSkJSWFJHTEU5QlFVOVdMSFZDUVVGMVFpeERRVUZETzJGQlEyaERPenROUVRkRVNEczdRMEU0UkVNc1EwRndSRzlFWjBJc1ZVRkJVeXhUUVc5RU4wUTdhMEpCY0VSdlFucENMSFZDUVVGMVFpeEJRVlkxUXp0QlFXZEZRU3hUUVVGVGEwSXNZMEZCWXl4RFFVRkRSQ3hMUVVGTExFVkJRVVU3U1VGRE4wSXNTVUZCVFdoQ0xFdEJRVXNzUjBGQlJ5eEZRVUZGTEVGQlFVTTdTVUZGYWtJc1NVRkJTVEJDTEV0QlFVc3NSMEZCUnl4RFFVRkRMRUZCUVVNN1NVRkZaQ3hOUVVGUFFTeExRVUZMTEVkQlFVZFdMRXRCUVVzc1EwRkJSVHRSUVVOd1FtaENMRXRCUVVzc1EwRkJRekJDTEV0QlFVc3NSVUZCUlN4RFFVRkRMRWRCUVVkRExGVkJRVmtzWVVGQlFTeERRVUZETzB0QlF5OUNPMGxCUlVRc1QwRkJUek5DTEV0QlFVc3NRMEZCUXp0RFFVTmtJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF92ZXJ0aWNhbEJyYW5jaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVydGljYWxCcmFuY2hcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgUnVsZU5hbWVQYXJzZVRyZWUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKSB7XG4gICAgX2luaGVyaXRzKFJ1bGVOYW1lUGFyc2VUcmVlLCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSdWxlTmFtZVBhcnNlVHJlZSk7XG4gICAgZnVuY3Rpb24gUnVsZU5hbWVQYXJzZVRyZWUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdWxlTmFtZVBhcnNlVHJlZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFJ1bGVOYW1lUGFyc2VUcmVlLCBudWxsLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLCB0b2tlbkluZGV4ZXMgPSB0b2tlbkluZGV4ZXNGcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKSwgc3RyaW5nID0gXCJcIi5jb25jYXQocnVsZU5hbWUpLmNvbmNhdCh0b2tlbkluZGV4ZXMpLCBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLCB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IF92ZXJ0aWNhbEJyYW5jaC5kZWZhdWx0LmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSwgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSwgcnVsZU5hbWVQYXJzZVRyZWUgPSBfdmVydGljYWxCcmFuY2guZGVmYXVsdC5mcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihSdWxlTmFtZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBydWxlTmFtZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lUGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJ1bGVOYW1lUGFyc2VUcmVlO1xufShfdmVydGljYWxCcmFuY2guZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSdWxlTmFtZVBhcnNlVHJlZTtcbmZ1bmN0aW9uIHRva2VuSW5kZXhlc0Zyb21Ob25UZXJtaW5hbE5vZGVBbmRUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgICB2YXIgZmlyc3RTaWduaWZpY2FudFRva2VuID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbigpLCBsYXN0U2lnbmlmaWNhbnRUb2tlbiA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbigpLCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRva2Vucy5pbmRleE9mKGZpcnN0U2lnbmlmaWNhbnRUb2tlbiksIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZihsYXN0U2lnbmlmaWNhbnRUb2tlbiksIHRva2VuSW5kZXhlcyA9IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICE9PSBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID8gXCIoXCIuY29uY2F0KGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4LCBcIi1cIikuY29uY2F0KGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXgsIFwiKVwiKSA6IFwiKFwiLmNvbmNhdChmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgXCIpXCIpO1xuICAgIHJldHVybiB0b2tlbkluZGV4ZXM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWEp6WlZSeVpXVXZjblZzWlU1aGJXVXVhbk1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2JtbHRjRzl5ZENCV1pYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0JtY205dElGd2lMaTkyWlhKMGFXTmhiRUp5WVc1amFGd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlNkV3hsVG1GdFpWQmhjbk5sVkhKbFpTQmxlSFJsYm1SeklGWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsSUh0Y2JpQWdjM1JoZEdsaklHWnliMjFPYjI1VVpYSnRhVzVoYkU1dlpHVkJibVJVYjJ0bGJuTW9ibTl1VkdWeWJXbHVZV3hPYjJSbExDQjBiMnRsYm5NcElIdGNiaUFnSUNCamIyNXpkQ0J5ZFd4bFRtRnRaU0E5SUc1dmJsUmxjbTFwYm1Gc1RtOWtaUzVuWlhSU2RXeGxUbUZ0WlNncExGeHVJQ0FnSUNBZ0lDQWdJSFJ2YTJWdVNXNWtaWGhsY3lBOUlIUnZhMlZ1U1c1a1pYaGxjMFp5YjIxT2IyNVVaWEp0YVc1aGJFNXZaR1ZCYm1SVWIydGxibk1vYm05dVZHVnliV2x1WVd4T2IyUmxMQ0IwYjJ0bGJuTXBMRnh1SUNBZ0lDQWdJQ0FnSUhOMGNtbHVaeUE5SUdBa2UzSjFiR1ZPWVcxbGZTUjdkRzlyWlc1SmJtUmxlR1Z6ZldBc1hHNGdJQ0FnSUNBZ0lDQWdjM1J5YVc1blRHVnVaM1JvSUQwZ2MzUnlhVzVuTG14bGJtZDBhQ3hjYmlBZ0lDQWdJQ0FnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaVmRwWkhSb0lEMGdjM1J5YVc1blRHVnVaM1JvTENBdkx5OWNiaUFnSUNBZ0lDQWdJQ0IyWlhKMGFXTmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTQTlJRlpsY25ScFkyRnNRbkpoYm1Ob1VHRnljMlZVY21WbExtWnliMjFYYVdSMGFDaDJaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlZkcFpIUm9LU3hjYmlBZ0lDQWdJQ0FnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJRDBnZG1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVXVaMlYwVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpZ3BMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVk9ZVzFsVUdGeWMyVlVjbVZsSUQwZ1ZtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1V1Wm5KdmJWTjBjbWx1WjBGdVpGWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRvVW5Wc1pVNWhiV1ZRWVhKelpWUnlaV1VzSUhOMGNtbHVaeXdnZG1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpazdYRzVjYmlBZ0lDQnlkV3hsVG1GdFpWQmhjbk5sVkhKbFpTNWhjSEJsYm1SVWIxUnZjQ2gyWlhKMGFXTmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTazdYRzVjYmlBZ0lDQnlaWFIxY200Z2NuVnNaVTVoYldWUVlYSnpaVlJ5WldVN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdkRzlyWlc1SmJtUmxlR1Z6Um5KdmJVNXZibFJsY20xcGJtRnNUbTlrWlVGdVpGUnZhMlZ1Y3lodWIyNVVaWEp0YVc1aGJFNXZaR1VzSUhSdmEyVnVjeWtnZTF4dUlDQmpiMjV6ZENCbWFYSnpkRk5wWjI1cFptbGpZVzUwVkc5clpXNGdQU0J1YjI1VVpYSnRhVzVoYkU1dlpHVXVaMlYwUm1seWMzUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUtDa3NYRzRnSUNBZ0lDQWdJR3hoYzNSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUQwZ2JtOXVWR1Z5YldsdVlXeE9iMlJsTG1kbGRFeGhjM1JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVLQ2tzWEc0Z0lDQWdJQ0FnSUdacGNuTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJrbHVaR1Y0SUQwZ2RHOXJaVzV6TG1sdVpHVjRUMllvWm1seWMzUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUtTeGNiaUFnSUNBZ0lDQWdiR0Z6ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzVKYm1SbGVDQTlJSFJ2YTJWdWN5NXBibVJsZUU5bUtHeGhjM1JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVLU3hjYmlBZ0lDQWdJQ0FnZEc5clpXNUpibVJsZUdWeklEMGdLR1pwY25OMFUybG5ibWxtYVdOaGJuUlViMnRsYmtsdVpHVjRJQ0U5UFNCc1lYTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJrbHVaR1Y0S1NBL1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCZ0tDUjdabWx5YzNSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1U1c1a1pYaDlMU1I3YkdGemRGTnBaMjVwWm1sallXNTBWRzlyWlc1SmJtUmxlSDBwWUNBNlhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHQW9KSHRtYVhKemRGTnBaMjVwWm1sallXNTBWRzlyWlc1SmJtUmxlSDBwWUR0Y2JseHVJQ0J5WlhSMWNtNGdkRzlyWlc1SmJtUmxlR1Z6TzF4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxKMWJHVk9ZVzFsVUdGeWMyVlVjbVZsSWl3aVpuSnZiVTV2YmxSbGNtMXBibUZzVG05a1pVRnVaRlJ2YTJWdWN5SXNJbTV2YmxSbGNtMXBibUZzVG05a1pTSXNJblJ2YTJWdWN5SXNJbkoxYkdWT1lXMWxJaXdpWjJWMFVuVnNaVTVoYldVaUxDSjBiMnRsYmtsdVpHVjRaWE1pTENKMGIydGxia2x1WkdWNFpYTkdjbTl0VG05dVZHVnliV2x1WVd4T2IyUmxRVzVrVkc5clpXNXpJaXdpYzNSeWFXNW5JaXdpYzNSeWFXNW5UR1Z1WjNSb0lpd2liR1Z1WjNSb0lpd2lkbVZ5ZEdsallXeENjbUZ1WTJoUVlYSnpaVlJ5WldWWGFXUjBhQ0lzSW5abGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxJaXdpVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWlMQ0ptY205dFYybGtkR2dpTENKMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJaXdpWjJWMFZtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaUlzSW5KMWJHVk9ZVzFsVUdGeWMyVlVjbVZsSWl3aVpuSnZiVk4wY21sdVowRnVaRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0aUxDSmhjSEJsYm1SVWIxUnZjQ0lzSW1acGNuTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbWRsZEVacGNuTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbXhoYzNSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aVoyVjBUR0Z6ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKbWFYSnpkRk5wWjI1cFptbGpZVzUwVkc5clpXNUpibVJsZUNJc0ltbHVaR1Y0VDJZaUxDSnNZWE4wVTJsbmJtbG1hV05oYm5SVWIydGxia2x1WkdWNElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJXOURMRWxCUVVFc1pVRkJhMElzYTBOQlFXeENMR3RDUVVGclFpeEZRVUZCT3pzN096czdPenM3T3pzN096czdPRVJCUm5SRU8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN096czdTMEZCUVRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVbGxMRWxCUVVFc1FVRkJUVUVzYVVKQlFXbENMR2xDUVdsQ2JrTXNRVUZxUWxrN2VVUkJTbVk3TzJGQlNYRkNRU3hwUWtGQmFVSTdaMFJCU25SRE96czdPenRaUVV0VFF5eEhRVUUwUWl4RlFVRTFRa0VzT0VKQlFUUkNPMWxEVEhKRExFOUVTMFVzVTBGQlQwRXNORUpCUVRSQ0xFTkJRVU5ETEdWQlFXVXNSVUZCUlVNc1RVRkJUU3hGUVVGRk8yZENRVU16UkN4SlFVRk5ReXhSUVVGUkxFZEJRVWRHTEdWQlFXVXNRMEZCUTBjc1YwRkJWeXhGUVVGRkxFVkJRM2hEUXl4WlFVRlpMRWRCUVVkRExIZERRVUYzUXl4RFFVRkRUQ3hsUVVGbExFVkJRVVZETEUxQlFVMHNRMEZCUXl4RlFVTm9Sa3NzVFVGQlRTeEhRVUZITEVGQlFVTXNSVUZCUVN4RFFVRmhSaXhOUVVGWkxFTkJRWFpDUml4UlFVRlJMRU5CUVdkQ0xFTkJRVUVzVFVGQlFTeERRVUZpUlN4WlFVRlpMRU5CUVVVc1JVRkRja05ITEZsQlFWa3NSMEZCUjBRc1RVRkJUU3hEUVVGRFJTeE5RVUZOTEVWQlF6VkNReXcwUWtGQk5FSXNSMEZCUjBZc1dVRkJXU3hGUVVNelEwY3NkVUpCUVhWQ0xFZEJRVWRETEdWQlFYVkNMRk5CUVVORExGTkJRVk1zUTBGQlEwZ3NORUpCUVRSQ0xFTkJRVU1zUlVGRGVrWkpMSE5DUVVGelFpeEhRVUZIU0N4MVFrRkJkVUlzUTBGQlEwa3NlVUpCUVhsQ0xFVkJRVVVzUlVGRE5VVkRMR2xDUVVGcFFpeEhRVUZIU2l4bFFVRjFRaXhUUVVGRFN5eHRRMEZCYlVNc1EwRkJRMnhDTEdsQ1FVRnBRaXhGUVVGRlVTeE5RVUZOTEVWQlFVVlBMSE5DUVVGelFpeERRVUZETEVGQlFVTTdaMEpCUlhwSlJTeHBRa0ZCYVVJc1EwRkJRMFVzVjBGQlZ5eERRVUZEVUN4MVFrRkJkVUlzUTBGQlF5eERRVUZETzJkQ1FVVjJSQ3hQUVVGUFN5eHBRa0ZCYVVJc1EwRkJRenRoUVVNeFFqczdUVUZzUWtnN08wTkJiVUpETEVOQlpqaERTaXhsUVVGMVFpeFRRV1Z5UlR0clFrRm1iMEppTEdsQ1FVRnBRaXhCUVVwMFF6dEJRWEZDUVN4VFFVRlRUeXgzUTBGQmQwTXNRMEZCUTB3c1pVRkJaU3hGUVVGRlF5eE5RVUZOTEVWQlFVVTdTVUZEZWtVc1NVRkJUV2xDTEhGQ1FVRnhRaXhIUVVGSGJFSXNaVUZCWlN4RFFVRkRiVUlzZDBKQlFYZENMRVZCUVVVc1JVRkRiRVZETEc5Q1FVRnZRaXhIUVVGSGNFSXNaVUZCWlN4RFFVRkRjVUlzZFVKQlFYVkNMRVZCUVVVc1JVRkRhRVZETERCQ1FVRXdRaXhIUVVGSGNrSXNUVUZCVFN4RFFVRkRjMElzVDBGQlR5eERRVUZEVEN4eFFrRkJjVUlzUTBGQlF5eEZRVU5zUlUwc2VVSkJRWGxDTEVkQlFVZDJRaXhOUVVGTkxFTkJRVU56UWl4UFFVRlBMRU5CUVVOSUxHOUNRVUZ2UWl4RFFVRkRMRVZCUTJoRmFFSXNXVUZCV1N4SFFVRkhMRUZCUVVOclFpd3dRa0ZCTUVJc1MwRkJTMFVzZVVKQlFYbENMRWRCUTNoRUxFRkJRVU1zUjBGQlF5eERRVUZuUTBFc1RVRkJlVUlzUTBGQmRrUkdMREJDUVVFd1FpeEZRVUZETEVkQlFVTXNRMEZCTkVJc1EwRkJRU3hOUVVGRExFTkJRVE5DUlN4NVFrRkJlVUlzUlVGQlF5eEhRVUZETEVOQlFVTXNSMEZETlVRc1FVRkJReXhIUVVGRExFTkJRVFpDTEUxQlFVTXNRMEZCTlVKR0xEQkNRVUV3UWl4RlFVRkRMRWRCUVVNc1EwRkJReXhCUVVGRE8wbEJSVEZFTEU5QlFVOXNRaXhaUVVGWkxFTkJRVU03UTBGRGNrSWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9uZWNlc3NhcnkgPSByZXF1aXJlKFwibmVjZXNzYXJ5XCIpO1xudmFyIF9wYXJzZVRyZWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJzZVRyZWVcIikpO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgREFTSF9DSEFSQUNURVIgPSBfbmVjZXNzYXJ5LmNoYXJhY3RlcnMuREFTSF9DSEFSQUNURVI7XG52YXIgSG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUGFyc2VUcmVlKSB7XG4gICAgX2luaGVyaXRzKEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUsIFBhcnNlVHJlZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihIb3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICBmdW5jdGlvbiBIb3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUsIG51bGwsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21XaWR0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21XaWR0aCh3aWR0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBzdHJpbmdGcm9tQ2hhcmFjdGVyc1dpZHRoKHdpZHRoLCBEQVNIX0NIQVJBQ1RFUiksIGxpbmUgPSBzdHJpbmcsIGxpbmVzID0gW1xuICAgICAgICAgICAgICAgICAgICBsaW5lXG4gICAgICAgICAgICAgICAgXSwgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSA9IG5ldyBIb3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlKGxpbmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBIb3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlO1xufShfcGFyc2VUcmVlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZTtcbmZ1bmN0aW9uIHN0cmluZ0Zyb21DaGFyYWN0ZXJzV2lkdGgoY2hhcmFjdGVyc1dpZHRoLCBjaGFyYWN0ZXIpIHtcbiAgICB2YXIgc3RyaW5nID0gX2NvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY2hhcmFjdGVyc1dpZHRoOyBpbmRleCsrKXtcbiAgICAgICAgc3RyaW5nICs9IGNoYXJhY3RlcjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYSnpaVlJ5WldVdmFHOXlhWHB2Ym5SaGJFSnlZVzVqYUM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJSHNnWTJoaGNtRmpkR1Z5Y3lCOUlHWnliMjBnWENKdVpXTmxjM05oY25sY0lqdGNibHh1YVcxd2IzSjBJRkJoY25ObFZISmxaU0JtY205dElGd2lMaTR2Y0dGeWMyVlVjbVZsWENJN1hHNWNibWx0Y0c5eWRDQjdJRVZOVUZSWlgxTlVVa2xPUnlCOUlHWnliMjBnWENJdUxpOWpiMjV6ZEdGdWRITmNJanRjYmx4dVkyOXVjM1FnZXlCRVFWTklYME5JUVZKQlExUkZVaUI5SUQwZ1kyaGhjbUZqZEdWeWN6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1NHOXlhWHB2Ym5SaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlNCbGVIUmxibVJ6SUZCaGNuTmxWSEpsWlNCN1hHNGdJSE4wWVhScFl5Qm1jbTl0VjJsa2RHZ29kMmxrZEdncElIdGNiaUFnSUNCamIyNXpkQ0J6ZEhKcGJtY2dQU0J6ZEhKcGJtZEdjbTl0UTJoaGNtRmpkR1Z5YzFkcFpIUm9LSGRwWkhSb0xDQkVRVk5JWDBOSVFWSkJRMVJGVWlrc1hHNGdJQ0FnSUNBZ0lDQWdiR2x1WlNBOUlITjBjbWx1Wnl3Z0x5OHZYRzRnSUNBZ0lDQWdJQ0FnYkdsdVpYTWdQU0JiYkdsdVpWMHNYRzRnSUNBZ0lDQWdJQ0FnYUc5eWFYcHZiblJoYkVKeVlXNWphRkJoY25ObFZISmxaU0E5SUc1bGR5QkliM0pwZW05dWRHRnNRbkpoYm1Ob1VHRnljMlZVY21WbEtHeHBibVZ6S1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJvYjNKcGVtOXVkR0ZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxPMXh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUhOMGNtbHVaMFp5YjIxRGFHRnlZV04wWlhKelYybGtkR2dvWTJoaGNtRmpkR1Z5YzFkcFpIUm9MQ0JqYUdGeVlXTjBaWElwSUh0Y2JpQWdiR1YwSUhOMGNtbHVaeUE5SUVWTlVGUlpYMU5VVWtsT1J6dGNibHh1SUNCbWIzSWdLR3hsZENCcGJtUmxlQ0E5SURBN0lHbHVaR1Y0SUR3Z1kyaGhjbUZqZEdWeWMxZHBaSFJvT3lCcGJtUmxlQ3NyS1NCN1hHNGdJQ0FnYzNSeWFXNW5JQ3M5SUdOb1lYSmhZM1JsY2p0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCemRISnBibWM3WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpUkVGVFNGOURTRUZTUVVOVVJWSWlMQ0pqYUdGeVlXTjBaWEp6SWl3aVNHOXlhWHB2Ym5SaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlNJc0ltWnliMjFYYVdSMGFDSXNJbmRwWkhSb0lpd2ljM1J5YVc1bklpd2ljM1J5YVc1blJuSnZiVU5vWVhKaFkzUmxjbk5YYVdSMGFDSXNJbXhwYm1VaUxDSnNhVzVsY3lJc0ltaHZjbWw2YjI1MFlXeENjbUZ1WTJoUVlYSnpaVlJ5WldVaUxDSlFZWEp6WlZSeVpXVWlMQ0pqYUdGeVlXTjBaWEp6VjJsa2RHZ2lMQ0pqYUdGeVlXTjBaWElpTENKRlRWQlVXVjlUVkZKSlRrY2lMQ0pwYm1SbGVDSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXlRaXhKUVVGQkxGVkJRVmNzVjBGQldDeFhRVUZYTEVOQlFVRTdRVUZGYUVJc1NVRkJRU3hWUVVGakxHdERRVUZrTEdOQlFXTXNSVUZCUVR0QlFVVlFMRWxCUVVFc1ZVRkJZeXhYUVVGa0xHTkJRV01zUTBGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVNHpRenR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZSUVN4SlFVRk5MRUZCUVVWQkxHTkJRV01zUjBGQlMwTXNWVUZCVlN4WlFVRTNRa1FzWTBGQll5eEJRVUZsTEVGQlFVTTdRVUZGZGtJc1NVRkJRU3hCUVVGTlJTeDVRa0ZCZVVJc2FVSkJWek5ETEVGQldGazdiVVJCVm1ZN08yRkJWWEZDUVN4NVFrRkJlVUk3ZDBSQlZqbERPenM3T3p0WlFWZFRReXhIUVVGVExFVkJRVlJCTEZkQlFWTTdXVU5ZYkVJc1QwUlhSU3hUUVVGUFFTeFRRVUZUTEVOQlFVTkRMRXRCUVVzc1JVRkJSVHRuUWtGRGRFSXNTVUZCVFVNc1RVRkJUU3hIUVVGSFF5eDVRa0ZCZVVJc1EwRkJRMFlzUzBGQlN5eEZRVUZGU2l4alFVRmpMRU5CUVVNc1JVRkRla1JQTEVsQlFVa3NSMEZCUjBZc1RVRkJUU3hGUVVOaVJ5eExRVUZMTEVkQlFVYzdiMEpCUVVORUxFbEJRVWs3YVVKQlFVTXNSVUZEWkVVc2VVSkJRWGxDTEVkQlFVY3NTVUZCU1ZBc2VVSkJRWGxDTEVOQlFVTk5MRXRCUVVzc1EwRkJReXhCUVVGRE8yZENRVVYyUlN4UFFVRlBReXg1UWtGQmVVSXNRMEZCUXp0aFFVTnNRenM3VFVGc1FrZzdPME5CYlVKRExFTkJWSE5FUXl4VlFVRlRMRk5CVXk5RU8ydENRVlJ2UWxJc2VVSkJRWGxDTEVGQlZqbERPMEZCY1VKQkxGTkJRVk5KTEhsQ1FVRjVRaXhEUVVGRFN5eGxRVUZsTEVWQlFVVkRMRk5CUVZNc1JVRkJSVHRKUVVNM1JDeEpRVUZKVUN4TlFVRk5MRWRCUVVkUkxGVkJRVmtzWVVGQlFTeEJRVUZETzBsQlJURkNMRWxCUVVzc1NVRkJTVU1zUzBGQlN5eEhRVUZITEVOQlFVTXNSVUZCUlVFc1MwRkJTeXhIUVVGSFNDeGxRVUZsTEVWQlFVVkhMRXRCUVVzc1JVRkJSU3hEUVVGRk8xRkJRM0JFVkN4TlFVRk5MRWxCUVVsUExGTkJRVk1zUTBGQlF6dExRVU55UWp0SlFVVkVMRTlCUVU5UUxFMUJRVTBzUTBGQlF6dERRVU5tSW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfdmVydGljYWxCcmFuY2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZlcnRpY2FsQnJhbmNoXCIpKTtcbnZhciBfaG9yaXpvbnRhbEJyYW5jaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaG9yaXpvbnRhbEJyYW5jaFwiKSk7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uL3V0aWxpdGllcy9hcnJheVwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIENoaWxkTm9kZXNQYXJzZVRyZWUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKSB7XG4gICAgX2luaGVyaXRzKENoaWxkTm9kZXNQYXJzZVRyZWUsIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENoaWxkTm9kZXNQYXJzZVRyZWUpO1xuICAgIGZ1bmN0aW9uIENoaWxkTm9kZXNQYXJzZVRyZWUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGlsZE5vZGVzUGFyc2VUcmVlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQ2hpbGROb2Rlc1BhcnNlVHJlZSwgbnVsbCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNoaWxkTm9kZXNBbmRUb2tlbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ2hpbGROb2Rlc0FuZFRva2VucyhjaGlsZE5vZGVzLCB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2Rlc1BhcnNlVHJlZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlUGFyc2VUcmVlczEgPSBjaGlsZE5vZGVzLnJlZHVjZShmdW5jdGlvbihjaGlsZE5vZGVQYXJzZVRyZWVzLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZS5hc1BhcnNlVHJlZSh0b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzLnB1c2goY2hpbGROb2RlUGFyc2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVBhcnNlVHJlZXM7XG4gICAgICAgICAgICAgICAgfSwgW10pLCBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID0gY2hpbGROb2RlUGFyc2VUcmVlczEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdENoaWxkTm9kZVBhcnNlVHJlZSA9ICgwLCBfYXJyYXkpLmZpcnN0KGNoaWxkTm9kZVBhcnNlVHJlZXMxKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlOyAvLy9cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdW5kZWZpbmVkLCBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IDAsIGNoaWxkTm9kZVBhcnNlVHJlZXNXaWR0aCA9IDAsIGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZVBhcnNlVHJlZXMxLmZvckVhY2goZnVuY3Rpb24oY2hpbGROb2RlUGFyc2VUcmVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZVBhcnNlVHJlZVdpZHRoID0gY2hpbGROb2RlUGFyc2VUcmVlLmdldFdpZHRoKCksIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoID0gY2hpbGROb2RlUGFyc2VUcmVlLmdldERlcHRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaGlsZE5vZGVQYXJzZVRyZWUgPSBjaGlsZE5vZGVQYXJzZVRyZWUsIGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBmaXJzdENoaWxkTm9kZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGNoaWxkTm9kZVBhcnNlVHJlZXNMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUgPSBjaGlsZE5vZGVQYXJzZVRyZWUsIGxhc3RDaGlsZE5vZGVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gbGFzdENoaWxkTm9kZVBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gbGFzdENoaWxkTm9kZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uICs9IGNoaWxkTm9kZVBhcnNlVHJlZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGggPSBNYXRoLm1heChjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGgsIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGxhc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uIC0gZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uICsgMSwgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBfdmVydGljYWxCcmFuY2guZGVmYXVsdC5mcm9tV2lkdGgod2lkdGgpLCBob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlID0gX2hvcml6b250YWxCcmFuY2guZGVmYXVsdC5mcm9tV2lkdGgod2lkdGgpLCBsZWZ0TWFyZ2luV2lkdGggPSBmaXJzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24sIHJpZ2h0TWFyZ2luV2lkdGgxID0gY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoIC0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmFkZExlZnRNYXJnaW4obGVmdE1hcmdpbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aDEpO1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlLmFkZExlZnRNYXJnaW4obGVmdE1hcmdpbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZS5hZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlID0gX3ZlcnRpY2FsQnJhbmNoLmRlZmF1bHQuZnJvbURlcHRoQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihDaGlsZE5vZGVzUGFyc2VUcmVlLCBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGgsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzMS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTm9kZVBhcnNlVHJlZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpLCBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUgPSBjaGlsZE5vZGVQYXJzZVRyZWUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGNoaWxkTm9kZVBhcnNlVHJlZXNMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0TWFyZ2luV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZENoaWxkTm9kZVBhcnNlVHJlZS5hZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA8IGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21NYXJnaW5EZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCAtIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZENoaWxkTm9kZVBhcnNlVHJlZS5hZGRCb3R0b21NYXJnaW4oYm90dG9tTWFyZ2luRGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZS5hcHBlbmRUb1JpZ2h0KGNsb25lZENoaWxkTm9kZVBhcnNlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvVG9wKGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXNQYXJzZVRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ2hpbGROb2Rlc1BhcnNlVHJlZTtcbn0oX3ZlcnRpY2FsQnJhbmNoLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hpbGROb2Rlc1BhcnNlVHJlZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYSnpaVlJ5WldVdlkyaHBiR1JPYjJSbGN5NXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZabGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxJR1p5YjIwZ1hDSXVMM1psY25ScFkyRnNRbkpoYm1Ob1hDSTdYRzVwYlhCdmNuUWdTRzl5YVhwdmJuUmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTQm1jbTl0SUZ3aUxpOW9iM0pwZW05dWRHRnNRbkpoYm1Ob1hDSTdYRzVjYm1sdGNHOXlkQ0I3SUdacGNuTjBJSDBnWm5KdmJTQmNJaTR1TDNWMGFXeHBkR2xsY3k5aGNuSmhlVndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJEYUdsc1pFNXZaR1Z6VUdGeWMyVlVjbVZsSUdWNGRHVnVaSE1nVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWdlMXh1SUNCemRHRjBhV01nWm5KdmJVTm9hV3hrVG05a1pYTkJibVJVYjJ0bGJuTW9ZMmhwYkdST2IyUmxjeXdnZEc5clpXNXpLU0I3WEc0Z0lDQWdiR1YwSUdOb2FXeGtUbTlrWlhOUVlYSnpaVlJ5WldVN1hHNWNiaUFnSUNCamIyNXpkQ0JqYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1Z6SUQwZ1kyaHBiR1JPYjJSbGN5NXlaV1IxWTJVb0tHTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpYTXNJR05vYVd4a1RtOWtaU2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxJRDBnWTJocGJHUk9iMlJsTG1GelVHRnljMlZVY21WbEtIUnZhMlZ1Y3lrN1hHNWNiaUFnSUNBZ0lDQWdJQ0FnSUdOb2FXeGtUbTlrWlZCaGNuTmxWSEpsWlhNdWNIVnphQ2hqYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1VwTzF4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxjenRjYmlBZ0lDQWdJQ0FnSUNCOUxDQmJYU2tzWEc0Z0lDQWdJQ0FnSUNBZ1kyaHBiR1JPYjJSbFVHRnljMlZVY21WbGMweGxibWQwYUNBOUlHTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpYTXViR1Z1WjNSb08xeHVYRzRnSUNBZ2FXWWdLR05vYVd4a1RtOWtaVkJoY25ObFZISmxaWE5NWlc1bmRHZ2dQVDA5SURFcElIdGNiaUFnSUNBZ0lHTnZibk4wSUdacGNuTjBRMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxJRDBnWm1seWMzUW9ZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxjeWs3WEc1Y2JpQWdJQ0FnSUdOb2FXeGtUbTlrWlhOUVlYSnpaVlJ5WldVZ1BTQm1hWEp6ZEVOb2FXeGtUbTlrWlZCaGNuTmxWSEpsWlRzZ0lDOHZMMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCc1pYUWdabWx5YzNSV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJRDBnZFc1a1pXWnBibVZrTEZ4dUlDQWdJQ0FnSUNBZ0lHeGhjM1JXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUlEMGdNQ3hjYmlBZ0lDQWdJQ0FnSUNCamFHbHNaRTV2WkdWUVlYSnpaVlJ5WldWelYybGtkR2dnUFNBd0xGeHVJQ0FnSUNBZ0lDQWdJR05vYVd4a1RtOWtaVkJoY25ObFZISmxaWE5FWlhCMGFDQTlJREE3WEc1Y2JpQWdJQ0FnSUdOb2FXeGtUbTlrWlZCaGNuTmxWSEpsWlhNdVptOXlSV0ZqYUNnb1kyaHBiR1JPYjJSbFVHRnljMlZVY21WbExDQnBibVJsZUNrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQmphR2xzWkU1dlpHVlFZWEp6WlZSeVpXVlhhV1IwYUNBOUlHTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpTNW5aWFJYYVdSMGFDZ3BMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmphR2xzWkU1dlpHVlFZWEp6WlZSeVpXVkVaWEIwYUNBOUlHTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpTNW5aWFJFWlhCMGFDZ3BPMXh1WEc0Z0lDQWdJQ0FnSUdsbUlDaHBibVJsZUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUdacGNuTjBRMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxJRDBnWTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdacGNuTjBRMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlBOUlHWnBjbk4wUTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsTG1kbGRGWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRvS1R0Y2JseHVJQ0FnSUNBZ0lDQWdJR1pwY25OMFZtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaUE5SUdacGNuTjBRMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2Ymp0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJR2xtSUNocGJtUmxlQ0E5UFQwZ1kyaHBiR1JPYjJSbFVHRnljMlZVY21WbGMweGxibWQwYUNBdElERXBJSHRjYmlBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JzWVhOMFEyaHBiR1JPYjJSbFVHRnljMlZVY21WbElEMGdZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3hoYzNSRGFHbHNaRTV2WkdWUVlYSnpaVlJ5WldWV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJRDBnYkdGemRFTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpTNW5aWFJXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUtDazdYRzVjYmlBZ0lDQWdJQ0FnSUNCc1lYTjBWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlBclBTQnNZWE4wUTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJqdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUdsbUlDaHBibVJsZUNBOElHTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpYTk1aVzVuZEdnZ0xTQXhLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2JHRnpkRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0Z0t6MGdZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxWMmxrZEdnN1hHNGdJQ0FnSUNBZ0lDQWdiR0Z6ZEZabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNGdLejBnTVR0Y2JseHVJQ0FnSUNBZ0lDQWdJR05vYVd4a1RtOWtaVkJoY25ObFZISmxaWE5YYVdSMGFDQXJQU0F4TzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxjMWRwWkhSb0lDczlJR05vYVd4a1RtOWtaVkJoY25ObFZISmxaVmRwWkhSb08xeHVJQ0FnSUNBZ0lDQmphR2xzWkU1dlpHVlFZWEp6WlZSeVpXVnpSR1Z3ZEdnZ1BTQk5ZWFJvTG0xaGVDaGphR2xzWkU1dlpHVlFZWEp6WlZSeVpXVnpSR1Z3ZEdnc0lHTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpVUmxjSFJvS1R0Y2JpQWdJQ0FnSUgwcE8xeHVYRzRnSUNBZ0lDQmpiMjV6ZENCM2FXUjBhQ0E5SUd4aGMzUldaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1SUMwZ1ptbHljM1JXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUlDc2dNU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsSUQwZ1ZtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1V1Wm5KdmJWZHBaSFJvS0hkcFpIUm9LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHaHZjbWw2YjI1MFlXeENjbUZ1WTJoUVlYSnpaVlJ5WldVZ1BTQkliM0pwZW05dWRHRnNRbkpoYm1Ob1VHRnljMlZVY21WbExtWnliMjFYYVdSMGFDaDNhV1IwYUNrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JzWldaMFRXRnlaMmx1VjJsa2RHZ2dQU0JtYVhKemRGWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnlhV2RvZEUxaGNtZHBibGRwWkhSb0lEMGdZMmhwYkdST2IyUmxVR0Z5YzJWVWNtVmxjMWRwWkhSb0lDMGdkMmxrZEdnZ0xTQnNaV1owVFdGeVoybHVWMmxrZEdnN1hHNWNiaUFnSUNBZ0lIWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsTG1Ga1pFeGxablJOWVhKbmFXNG9iR1ZtZEUxaGNtZHBibGRwWkhSb0tUdGNiaUFnSUNBZ0lIWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsTG1Ga1pGSnBaMmgwVFdGeVoybHVLSEpwWjJoMFRXRnlaMmx1VjJsa2RHZ3BPMXh1SUNBZ0lDQWdhRzl5YVhwdmJuUmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTNWhaR1JNWldaMFRXRnlaMmx1S0d4bFpuUk5ZWEpuYVc1WGFXUjBhQ2s3WEc0Z0lDQWdJQ0JvYjNKcGVtOXVkR0ZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxMbUZrWkZKcFoyaDBUV0Z5WjJsdUtISnBaMmgwVFdGeVoybHVWMmxrZEdncE8xeHVYRzRnSUNBZ0lDQmpiMjV6ZENCMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJRDBnZG1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVXVaMlYwVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpZ3BPMXh1WEc0Z0lDQWdJQ0JqYUdsc1pFNXZaR1Z6VUdGeWMyVlVjbVZsSUQwZ1ZtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1V1Wm5KdmJVUmxjSFJvUVc1a1ZtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaWhEYUdsc1pFNXZaR1Z6VUdGeWMyVlVjbVZsTENCamFHbHNaRTV2WkdWUVlYSnpaVlJ5WldWelJHVndkR2dzSUhabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNHBPMXh1WEc0Z0lDQWdJQ0JqYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1Z6TG1admNrVmhZMmdvS0dOb2FXeGtUbTlrWlZCaGNuTmxWSEpsWlN3Z2FXNWtaWGdwSUQwK0lIdGNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1kyaHBiR1JPYjJSbFVHRnljMlZVY21WbFJHVndkR2dnUFNCamFHbHNaRTV2WkdWUVlYSnpaVlJ5WldVdVoyVjBSR1Z3ZEdnb0tTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kyeHZibVZrUTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsSUQwZ1kyaHBiR1JPYjJSbFVHRnljMlZVY21WbExtTnNiMjVsS0NrN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0dsdVpHVjRJRHdnWTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsYzB4bGJtZDBhQ0F0SURFcElIdGNiaUFnSUNBZ0lDQWdJQ0JqYjI1emRDQnlhV2RvZEUxaGNtZHBibGRwWkhSb0lEMGdNVHRjYmx4dUlDQWdJQ0FnSUNBZ0lHTnNiMjVsWkVOb2FXeGtUbTlrWlZCaGNuTmxWSEpsWlM1aFpHUlNhV2RvZEUxaGNtZHBiaWh5YVdkb2RFMWhjbWRwYmxkcFpIUm9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hqYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1ZFWlhCMGFDQThJR05vYVd4a1RtOWtaVkJoY25ObFZISmxaWE5FWlhCMGFDa2dlMXh1SUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR0p2ZEhSdmJVMWhjbWRwYmtSbGNIUm9JRDBnWTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsYzBSbGNIUm9JQzBnWTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsUkdWd2RHZzdYRzVjYmlBZ0lDQWdJQ0FnSUNCamJHOXVaV1JEYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1V1WVdSa1FtOTBkRzl0VFdGeVoybHVLR0p2ZEhSdmJVMWhjbWRwYmtSbGNIUm9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lHTm9hV3hrVG05a1pYTlFZWEp6WlZSeVpXVXVZWEJ3Wlc1a1ZHOVNhV2RvZENoamJHOXVaV1JEYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1VwTzF4dUlDQWdJQ0FnZlNrN1hHNWNiaUFnSUNBZ0lHTm9hV3hrVG05a1pYTlFZWEp6WlZSeVpXVXVZWEJ3Wlc1a1ZHOVViM0FvYUc5eWFYcHZiblJoYkVKeVlXNWphRkJoY25ObFZISmxaU2s3WEc0Z0lDQWdJQ0JqYUdsc1pFNXZaR1Z6VUdGeWMyVlVjbVZsTG1Gd2NHVnVaRlJ2Vkc5d0tIWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdYRzRnSUNBZ2NtVjBkWEp1SUdOb2FXeGtUbTlrWlhOUVlYSnpaVlJ5WldVN1hHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpEYUdsc1pFNXZaR1Z6VUdGeWMyVlVjbVZsSWl3aVpuSnZiVU5vYVd4a1RtOWtaWE5CYm1SVWIydGxibk1pTENKamFHbHNaRTV2WkdWeklpd2lkRzlyWlc1eklpd2lZMmhwYkdST2IyUmxjMUJoY25ObFZISmxaU0lzSW1Ob2FXeGtUbTlrWlZCaGNuTmxWSEpsWlhNaUxDSnlaV1IxWTJVaUxDSmphR2xzWkU1dlpHVWlMQ0pqYUdsc1pFNXZaR1ZRWVhKelpWUnlaV1VpTENKaGMxQmhjbk5sVkhKbFpTSXNJbkIxYzJnaUxDSmphR2xzWkU1dlpHVlFZWEp6WlZSeVpXVnpUR1Z1WjNSb0lpd2liR1Z1WjNSb0lpd2labWx5YzNSRGFHbHNaRTV2WkdWUVlYSnpaVlJ5WldVaUxDSm1hWEp6ZENJc0ltWnBjbk4wVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpSXNJblZ1WkdWbWFXNWxaQ0lzSW14aGMzUldaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1SWl3aVkyaHBiR1JPYjJSbFVHRnljMlZVY21WbGMxZHBaSFJvSWl3aVkyaHBiR1JPYjJSbFVHRnljMlZVY21WbGMwUmxjSFJvSWl3aVptOXlSV0ZqYUNJc0ltbHVaR1Y0SWl3aVkyaHBiR1JPYjJSbFVHRnljMlZVY21WbFYybGtkR2dpTENKblpYUlhhV1IwYUNJc0ltTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpVUmxjSFJvSWl3aVoyVjBSR1Z3ZEdnaUxDSm1hWEp6ZEVOb2FXeGtUbTlrWlZCaGNuTmxWSEpsWlZabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNGlMQ0puWlhSV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJaXdpYkdGemRFTm9hV3hrVG05a1pWQmhjbk5sVkhKbFpTSXNJbXhoYzNSRGFHbHNaRTV2WkdWUVlYSnpaVlJ5WldWV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJaXdpVFdGMGFDSXNJbTFoZUNJc0luZHBaSFJvSWl3aWRtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1VpTENKV1pYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0lzSW1aeWIyMVhhV1IwYUNJc0ltaHZjbWw2YjI1MFlXeENjbUZ1WTJoUVlYSnpaVlJ5WldVaUxDSkliM0pwZW05dWRHRnNRbkpoYm1Ob1VHRnljMlZVY21WbElpd2liR1ZtZEUxaGNtZHBibGRwWkhSb0lpd2ljbWxuYUhSTllYSm5hVzVYYVdSMGFDSXNJbUZrWkV4bFpuUk5ZWEpuYVc0aUxDSmhaR1JTYVdkb2RFMWhjbWRwYmlJc0luWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRpTENKbWNtOXRSR1Z3ZEdoQmJtUldaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1SWl3aVkyeHZibVZrUTJocGJHUk9iMlJsVUdGeWMyVlVjbVZsSWl3aVkyeHZibVVpTENKaWIzUjBiMjFOWVhKbmFXNUVaWEIwYUNJc0ltRmtaRUp2ZEhSdmJVMWhjbWRwYmlJc0ltRndjR1Z1WkZSdlVtbG5hSFFpTENKaGNIQmxibVJVYjFSdmNDSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnZReXhKUVVGQkxHVkJRV3RDTEd0RFFVRnNRaXhyUWtGQmEwSXNSVUZCUVR0QlFVTm9RaXhKUVVGQkxHbENRVUZ2UWl4clEwRkJjRUlzYjBKQlFXOUNMRVZCUVVFN1FVRkZjRU1zU1VGQlFTeE5RVUZ2UWl4WFFVRndRaXh2UWtGQmIwSXNRMEZCUVRzN096czdPenM3T3pzN096czdPemhFUVV3eFF6dHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlBaU3hKUVVGQkxFRkJRVTFCTEcxQ1FVRnRRaXhwUWtOUWNrTXNRVVJQV1RzeVJFRlFaanM3WVVGUGNVSkJMRzFDUVVGdFFqdHJSRUZRZUVNN096czdPMWxCVVZORExFZEJRWFZDTEVWQlFYWkNRU3g1UWtGQmRVSTdXVVZTYUVNc1QwWlJSU3hUUVVGUFFTeDFRa0ZCZFVJc1EwRkJRME1zVlVGQlZTeEZRVUZGUXl4TlFVRk5MRVZCUVVVN1owSkJRMnBFTEVsQlFVbERMRzFDUVVGdFFpeEJRVUZETzJkQ1FVVjRRaXhKUVVGTlF5eHZRa0ZCYlVJc1IwRkJSMGdzVlVGQlZTeERRVUZEU1N4TlFVRk5MRU5CUVVNc1UwRkJRMFFzYlVKQlFXMUNMRVZCUVVWRkxGTkJRVk1zUlVGQlN6dHZRa0ZETVVVc1NVRkJUVU1zYTBKQlFXdENMRWRCUVVkRUxGTkJRVk1zUTBGQlEwVXNWMEZCVnl4RFFVRkRUaXhOUVVGTkxFTkJRVU1zUVVGQlF6dHZRa0ZGZWtSRkxHMUNRVUZ0UWl4RFFVRkRTeXhKUVVGSkxFTkJRVU5HTEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03YjBKQlJUZERMRTlCUVU5SUxHMUNRVUZ0UWl4RFFVRkRPMmxDUVVNMVFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVTk9UU3g1UWtGQmVVSXNSMEZCUjA0c2IwSkJRVzFDTEVOQlFVTlBMRTFCUVUwc1FVRkJRenRuUWtGRk4wUXNTVUZCU1VRc2VVSkJRWGxDTEV0QlFVc3NRMEZCUXl4RlFVRkZPMjlDUVVOdVF5eEpRVUZOUlN4MVFrRkJkVUlzUjBGQlIwTXNRMEZCUVVFc1IwRkJRVUVzVFVGQlN5eEJRVUZ4UWl4RFFVRkJMRTlCUVhCQ1ZDeHZRa0ZCYlVJc1EwRkJReXhCUVVGRE8yOUNRVVV6UkVRc2JVSkJRVzFDTEVkQlFVZFRMSFZDUVVGMVFpeERRVUZETEVOQlFVVXNSMEZCUnp0cFFrRkRjRVFzVFVGQlRUdHZRa0ZEVEN4SlFVRkpSU3d5UWtGQk1rSXNSMEZCUjBNc1UwRkJVeXhGUVVOMlEwTXNNRUpCUVRCQ0xFZEJRVWNzUTBGQlF5eEZRVU01UWtNc2QwSkJRWGRDTEVkQlFVY3NRMEZCUXl4RlFVTTFRa01zZDBKQlFYZENMRWRCUVVjc1EwRkJReXhCUVVGRE8yOUNRVVZxUTJRc2IwSkJRVzFDTEVOQlFVTmxMRTlCUVU4c1EwRkJReXhUUVVGRFdpeHJRa0ZCYTBJc1JVRkJSV0VzUzBGQlN5eEZRVUZMTzNkQ1FVTjZSQ3hKUVVGTlF5eDFRa0ZCZFVJc1IwRkJSMlFzYTBKQlFXdENMRU5CUVVObExGRkJRVkVzUlVGQlJTeEZRVU4yUkVNc2RVSkJRWFZDTEVkQlFVZG9RaXhyUWtGQmEwSXNRMEZCUTJsQ0xGRkJRVkVzUlVGQlJTeEJRVUZETzNkQ1FVVTVSQ3hKUVVGSlNpeExRVUZMTEV0QlFVc3NRMEZCUXl4RlFVRkZPelJDUVVObUxFbEJRVTFTTEhWQ1FVRjFRaXhIUVVGSFRDeHJRa0ZCYTBJc1JVRkROVU5yUWl3MlEwRkJOa01zUjBGQlIySXNkVUpCUVhWQ0xFTkJRVU5qTEhsQ1FVRjVRaXhGUVVGRkxFRkJRVU03TkVKQlJURkhXaXd5UWtGQk1rSXNSMEZCUjFjc05rTkJRVFpETEVOQlFVTTdlVUpCUXpkRk8zZENRVVZFTEVsQlFVbE1MRXRCUVVzc1MwRkJTMVlzZVVKQlFYbENMRWRCUVVjc1EwRkJReXhGUVVGRk96UkNRVU16UXl4SlFVRk5hVUlzYzBKQlFYTkNMRWRCUVVkd1FpeHJRa0ZCYTBJc1JVRkRNME54UWl3MFEwRkJORU1zUjBGQlIwUXNjMEpCUVhOQ0xFTkJRVU5FTEhsQ1FVRjVRaXhGUVVGRkxFRkJRVU03TkVKQlJYaEhWaXd3UWtGQk1FSXNTVUZCU1Zrc05FTkJRVFJETEVOQlFVTTdlVUpCUXpWRk8zZENRVVZFTEVsQlFVbFNMRXRCUVVzc1IwRkJSMVlzZVVKQlFYbENMRWRCUVVjc1EwRkJReXhGUVVGRk96UkNRVU42UTAwc01FSkJRVEJDTEVsQlFVbExMSFZDUVVGMVFpeERRVUZET3pSQ1FVTjBSRXdzTUVKQlFUQkNMRWxCUVVrc1EwRkJReXhEUVVGRE96UkNRVVZvUTBNc2QwSkJRWGRDTEVsQlFVa3NRMEZCUXl4RFFVRkRPM2xDUVVNdlFqdDNRa0ZGUkVFc2QwSkJRWGRDTEVsQlFVbEpMSFZDUVVGMVFpeERRVUZETzNkQ1FVTndSRWdzZDBKQlFYZENMRWRCUVVkWExFbEJRVWtzUTBGQlEwTXNSMEZCUnl4RFFVRkRXaXgzUWtGQmQwSXNSVUZCUlVzc2RVSkJRWFZDTEVOQlFVTXNRMEZCUXp0eFFrRkRlRVlzUTBGQlF5eERRVUZETzI5Q1FVVklMRWxCUVUxUkxFdEJRVXNzUjBGQlIyWXNNRUpCUVRCQ0xFZEJRVWRHTERKQ1FVRXlRaXhIUVVGSExFTkJRVU1zUlVGRGNFVnJRaXgxUWtGQmRVSXNSMEZCUjBNc1pVRkJkVUlzVTBGQlEwTXNVMEZCVXl4RFFVRkRTQ3hMUVVGTExFTkJRVU1zUlVGRGJFVkpMSGxDUVVGNVFpeEhRVUZIUXl4cFFrRkJlVUlzVTBGQlEwWXNVMEZCVXl4RFFVRkRTQ3hMUVVGTExFTkJRVU1zUlVGRGRFVk5MR1ZCUVdVc1IwRkJSM1pDTERKQ1FVRXlRaXhGUVVNM1EzZENMR2xDUVVGblFpeEhRVUZIY2tJc2QwSkJRWGRDTEVkQlFVZGpMRXRCUVVzc1IwRkJSMDBzWlVGQlpTeEJRVUZETzI5Q1FVVTFSVXdzZFVKQlFYVkNMRU5CUVVOUExHRkJRV0VzUTBGQlEwWXNaVUZCWlN4RFFVRkRMRU5CUVVNN2IwSkJRM1pFVEN4MVFrRkJkVUlzUTBGQlExRXNZMEZCWXl4RFFVRkRSaXhwUWtGQlowSXNRMEZCUXl4RFFVRkRPMjlDUVVONlJFZ3NlVUpCUVhsQ0xFTkJRVU5KTEdGQlFXRXNRMEZCUTBZc1pVRkJaU3hEUVVGRExFTkJRVU03YjBKQlEzcEVSaXg1UWtGQmVVSXNRMEZCUTBzc1kwRkJZeXhEUVVGRFJpeHBRa0ZCWjBJc1EwRkJReXhEUVVGRE8yOUNRVVV6UkN4SlFVRk5SeXh6UWtGQmMwSXNSMEZCUjFRc2RVSkJRWFZDTEVOQlFVTk9MSGxDUVVGNVFpeEZRVUZGTEVGQlFVTTdiMEpCUlc1R2RrSXNiVUpCUVcxQ0xFZEJRVWM0UWl4bFFVRjFRaXhUUVVGRFV5eHJRMEZCYTBNc1EwRkJRek5ETEcxQ1FVRnRRaXhGUVVGRmJVSXNkMEpCUVhkQ0xFVkJRVVYxUWl4elFrRkJjMElzUTBGQlF5eERRVUZETzI5Q1FVVjRTbkpETEc5Q1FVRnRRaXhEUVVGRFpTeFBRVUZQTEVOQlFVTXNVMEZCUTFvc2EwSkJRV3RDTEVWQlFVVmhMRXRCUVVzc1JVRkJTenQzUWtGRGVrUXNTVUZCVFVjc2RVSkJRWFZDTEVkQlFVZG9RaXhyUWtGQmEwSXNRMEZCUTJsQ0xGRkJRVkVzUlVGQlJTeEZRVU4yUkcxQ0xIZENRVUYzUWl4SFFVRkhjRU1zYTBKQlFXdENMRU5CUVVOeFF5eExRVUZMTEVWQlFVVXNRVUZCUXp0M1FrRkZOVVFzU1VGQlNYaENMRXRCUVVzc1IwRkJSMVlzZVVKQlFYbENMRWRCUVVjc1EwRkJReXhGUVVGRk96UkNRVU42UXl4SlFVRk5ORUlzWjBKQlFXZENMRWRCUVVjc1EwRkJReXhCUVVGRE96UkNRVVV6UWtzc2QwSkJRWGRDTEVOQlFVTklMR05CUVdNc1EwRkJRMFlzWjBKQlFXZENMRU5CUVVNc1EwRkJRenQ1UWtGRE0wUTdkMEpCUlVRc1NVRkJTV1lzZFVKQlFYVkNMRWRCUVVkTUxIZENRVUYzUWl4RlFVRkZPelJDUVVOMFJDeEpRVUZOTWtJc2FVSkJRV2xDTEVkQlFVY3pRaXgzUWtGQmQwSXNSMEZCUjBzc2RVSkJRWFZDTEVGQlFVTTdORUpCUlRkRmIwSXNkMEpCUVhkQ0xFTkJRVU5ITEdWQlFXVXNRMEZCUTBRc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXp0NVFrRkROMFE3ZDBKQlJVUXhReXh0UWtGQmJVSXNRMEZCUXpSRExHRkJRV0VzUTBGQlEwb3NkMEpCUVhkQ0xFTkJRVU1zUTBGQlF6dHhRa0ZETjBRc1EwRkJReXhEUVVGRE8yOUNRVVZJZUVNc2JVSkJRVzFDTEVOQlFVTTJReXhYUVVGWExFTkJRVU5pTEhsQ1FVRjVRaXhEUVVGRExFTkJRVU03YjBKQlF6TkVhRU1zYlVKQlFXMUNMRU5CUVVNMlF5eFhRVUZYTEVOQlFVTm9RaXgxUWtGQmRVSXNRMEZCUXl4RFFVRkRPMmxDUVVNeFJEdG5Ra0ZGUkN4UFFVRlBOMElzYlVKQlFXMUNMRU5CUVVNN1lVRkROVUk3TzAxQmJFZElPenREUVcxSFF5eERRVFZHWjBRNFFpeGxRVUYxUWl4VFFUUkdka1U3YTBKQk5VWnZRbXhETEcxQ1FVRnRRaXhCUVZCNFF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGVOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ydWxlTmFtZVwiKSk7XG52YXIgX2NoaWxkTm9kZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NoaWxkTm9kZXNcIikpO1xudmFyIF92ZXJ0aWNhbEJyYW5jaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVydGljYWxCcmFuY2hcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgTm9uVGVybWluYWxOb2RlUGFyc2VUcmVlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSkge1xuICAgIF9pbmhlcml0cyhOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUsIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSk7XG4gICAgZnVuY3Rpb24gTm9uVGVybWluYWxOb2RlUGFyc2VUcmVlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9uVGVybWluYWxOb2RlUGFyc2VUcmVlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoTm9uVGVybWluYWxOb2RlUGFyc2VUcmVlLCBudWxsLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSwgcnVsZU5hbWVQYXJzZVRyZWUgPSBfcnVsZU5hbWUuZGVmYXVsdC5mcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKSwgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IF9jaGlsZE5vZGVzLmRlZmF1bHQuZnJvbUNoaWxkTm9kZXNBbmRUb2tlbnMoY2hpbGROb2RlcywgdG9rZW5zKTtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uc0RpZmZlcmVuY2UgPSBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24gLSBjaGlsZE5vZGVzUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdE1hcmdpbldpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vL1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSAtdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZVBhcnNlVHJlZS5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uc0RpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRNYXJnaW5XaWR0aCA9ICt2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uc0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcnVsZU5hbWVQYXJzZVRyZWVXaWR0aCA9IHJ1bGVOYW1lUGFyc2VUcmVlLmdldFdpZHRoKCksIGNoaWxkTm9kZXNQYXJzZVRyZWVXaWR0aCA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0V2lkdGgoKSwgd2lkdGhzRGlmZmVyZW5jZSA9IHJ1bGVOYW1lUGFyc2VUcmVlV2lkdGggLSBjaGlsZE5vZGVzUGFyc2VUcmVlV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0TWFyZ2luV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8vXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aHNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gLXdpZHRoc0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGhzRGlmZmVyZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRNYXJnaW5XaWR0aCA9ICt3aWR0aHNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZS5nZXREZXB0aCgpLCBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWVEZXB0aCA9IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGgsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24sIG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IF92ZXJ0aWNhbEJyYW5jaC5kZWZhdWx0LmZyb21EZXB0aEFuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oTm9uVGVybWluYWxOb2RlUGFyc2VUcmVlLCBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWVEZXB0aCwgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQocnVsZU5hbWVQYXJzZVRyZWUpO1xuICAgICAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb0JvdHRvbShjaGlsZE5vZGVzUGFyc2VUcmVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZTtcbn0oX3ZlcnRpY2FsQnJhbmNoLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9uVGVybWluYWxOb2RlUGFyc2VUcmVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl3WVhKelpWUnlaV1V2Ym05dVZHVnliV2x1WVd4T2IyUmxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1VuVnNaVTVoYldWUVlYSnpaVlJ5WldVZ1puSnZiU0JjSWk0dmNuVnNaVTVoYldWY0lqdGNibWx0Y0c5eWRDQkRhR2xzWkU1dlpHVnpVR0Z5YzJWVWNtVmxJR1p5YjIwZ1hDSXVMMk5vYVd4a1RtOWtaWE5jSWp0Y2JtbHRjRzl5ZENCV1pYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0JtY205dElGd2lMaTkyWlhKMGFXTmhiRUp5WVc1amFGd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5Qk9iMjVVWlhKdGFXNWhiRTV2WkdWUVlYSnpaVlJ5WldVZ1pYaDBaVzVrY3lCV1pYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0I3WEc0Z0lITjBZWFJwWXlCbWNtOXRUbTl1VkdWeWJXbHVZV3hPYjJSbFFXNWtWRzlyWlc1ektHNXZibFJsY20xcGJtRnNUbTlrWlN3Z2RHOXJaVzV6S1NCN1hHNGdJQ0FnWTI5dWMzUWdZMmhwYkdST2IyUmxjeUE5SUc1dmJsUmxjbTFwYm1Gc1RtOWtaUzVuWlhSRGFHbHNaRTV2WkdWektDa3NYRzRnSUNBZ0lDQWdJQ0FnY25Wc1pVNWhiV1ZRWVhKelpWUnlaV1VnUFNCU2RXeGxUbUZ0WlZCaGNuTmxWSEpsWlM1bWNtOXRUbTl1VkdWeWJXbHVZV3hPYjJSbFFXNWtWRzlyWlc1ektHNXZibFJsY20xcGJtRnNUbTlrWlN3Z2RHOXJaVzV6S1N4Y2JpQWdJQ0FnSUNBZ0lDQmphR2xzWkU1dlpHVnpVR0Z5YzJWVWNtVmxJRDBnUTJocGJHUk9iMlJsYzFCaGNuTmxWSEpsWlM1bWNtOXRRMmhwYkdST2IyUmxjMEZ1WkZSdmEyVnVjeWhqYUdsc1pFNXZaR1Z6TENCMGIydGxibk1wTzF4dUlDQWdJRnh1SUNBZ0lHeGxkQ0J5ZFd4bFRtRnRaVkJoY25ObFZISmxaVlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0Z1BTQnlkV3hsVG1GdFpWQmhjbk5sVkhKbFpTNW5aWFJXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUtDazdYRzRnSUNBZ1hHNGdJQ0FnWTI5dWMzUWdZMmhwYkdST2IyUmxjMUJoY25ObFZISmxaVlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0Z1BTQmphR2xzWkU1dlpHVnpVR0Z5YzJWVWNtVmxMbWRsZEZabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNG9LU3hjYmlBZ0lDQWdJQ0FnSUNCMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVjMFJwWm1abGNtVnVZMlVnUFNCeWRXeGxUbUZ0WlZCaGNuTmxWSEpsWlZabGNuUnBZMkZzUW5KaGJtTm9VRzl6YVhScGIyNGdMU0JqYUdsc1pFNXZaR1Z6VUdGeWMyVlVjbVZsVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJqdGNiaUFnSUNCY2JpQWdJQ0JzWlhRZ2JHVm1kRTFoY21kcGJsZHBaSFJvSUQwZ2RXNWtaV1pwYm1Wa08xeHVYRzRnSUNBZ2FXWWdLR1poYkhObEtTQjdYRzRnSUNBZ0lDQXZMeTljYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI1elJHbG1abVZ5Wlc1alpTQThJREFwSUh0Y2JpQWdJQ0FnSUd4bFpuUk5ZWEpuYVc1WGFXUjBhQ0E5SUMxMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVjMFJwWm1abGNtVnVZMlU3WEc1Y2JpQWdJQ0FnSUhKMWJHVk9ZVzFsVUdGeWMyVlVjbVZsTG1Ga1pFeGxablJOWVhKbmFXNG9iR1ZtZEUxaGNtZHBibGRwWkhSb0tUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tIWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjV6UkdsbVptVnlaVzVqWlNBK0lEQXBJSHRjYmlBZ0lDQWdJR3hsWm5STllYSm5hVzVYYVdSMGFDQTlJQ3QyWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dWMwUnBabVpsY21WdVkyVTdYRzVjYmlBZ0lDQWdJR05vYVd4a1RtOWtaWE5RWVhKelpWUnlaV1V1WVdSa1RHVm1kRTFoY21kcGJpaHNaV1owVFdGeVoybHVWMmxrZEdncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdOdmJuTjBJSEoxYkdWT1lXMWxVR0Z5YzJWVWNtVmxWMmxrZEdnZ1BTQnlkV3hsVG1GdFpWQmhjbk5sVkhKbFpTNW5aWFJYYVdSMGFDZ3BMRnh1SUNBZ0lDQWdJQ0FnSUdOb2FXeGtUbTlrWlhOUVlYSnpaVlJ5WldWWGFXUjBhQ0E5SUdOb2FXeGtUbTlrWlhOUVlYSnpaVlJ5WldVdVoyVjBWMmxrZEdnb0tTeGNiaUFnSUNBZ0lDQWdJQ0IzYVdSMGFITkVhV1ptWlhKbGJtTmxJRDBnY25Wc1pVNWhiV1ZRWVhKelpWUnlaV1ZYYVdSMGFDQXRJR05vYVd4a1RtOWtaWE5RWVhKelpWUnlaV1ZYYVdSMGFEdGNiaUFnSUNCY2JpQWdJQ0JzWlhRZ2NtbG5hSFJOWVhKbmFXNVhhV1IwYUNBOUlIVnVaR1ZtYVc1bFpEdGNibHh1SUNBZ0lHbG1JQ2htWVd4elpTa2dlMXh1SUNBZ0lDQWdMeTh2WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2gzYVdSMGFITkVhV1ptWlhKbGJtTmxJRHdnTUNrZ2UxeHVJQ0FnSUNBZ2NtbG5hSFJOWVhKbmFXNVhhV1IwYUNBOUlDMTNhV1IwYUhORWFXWm1aWEpsYm1ObE8xeHVJQ0FnSUNBZ1hHNGdJQ0FnSUNCeWRXeGxUbUZ0WlZCaGNuTmxWSEpsWlM1aFpHUlNhV2RvZEUxaGNtZHBiaWh5YVdkb2RFMWhjbWRwYmxkcFpIUm9LVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLSGRwWkhSb2MwUnBabVpsY21WdVkyVWdQaUF3S1NCN1hHNGdJQ0FnSUNCeWFXZG9kRTFoY21kcGJsZHBaSFJvSUQwZ0szZHBaSFJvYzBScFptWmxjbVZ1WTJVN1hHNWNiaUFnSUNBZ0lHTm9hV3hrVG05a1pYTlFZWEp6WlZSeVpXVXVZV1JrVW1sbmFIUk5ZWEpuYVc0b2NtbG5hSFJOWVhKbmFXNVhhV1IwYUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY25Wc1pVNWhiV1ZRWVhKelpWUnlaV1ZXWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUlEMGdjblZzWlU1aGJXVlFZWEp6WlZSeVpXVXVaMlYwVm1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpZ3BPMXh1WEc0Z0lDQWdZMjl1YzNRZ2NuVnNaVTVoYldWUVlYSnpaVlJ5WldWRVpYQjBhQ0E5SUhKMWJHVk9ZVzFsVUdGeWMyVlVjbVZsTG1kbGRFUmxjSFJvS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdibTl1VkdWeWJXbHVZV3hPYjJSbFVHRnljMlZVY21WbFJHVndkR2dnUFNCeWRXeGxUbUZ0WlZCaGNuTmxWSEpsWlVSbGNIUm9MQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQjJaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1SUQwZ2NuVnNaVTVoYldWUVlYSnpaVlJ5WldWV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVMQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnViMjVVWlhKdGFXNWhiRTV2WkdWUVlYSnpaVlJ5WldVZ1BTQldaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlM1bWNtOXRSR1Z3ZEdoQmJtUldaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1S0U1dmJsUmxjbTFwYm1Gc1RtOWtaVkJoY25ObFZISmxaU3dnYm05dVZHVnliV2x1WVd4T2IyUmxVR0Z5YzJWVWNtVmxSR1Z3ZEdnc0lIWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRwTzF4dVhHNGdJQ0FnYm05dVZHVnliV2x1WVd4T2IyUmxVR0Z5YzJWVWNtVmxMbUZ3Y0dWdVpGUnZVbWxuYUhRb2NuVnNaVTVoYldWUVlYSnpaVlJ5WldVcE8xeHVJQ0FnSUc1dmJsUmxjbTFwYm1Gc1RtOWtaVkJoY25ObFZISmxaUzVoY0hCbGJtUlViMEp2ZEhSdmJTaGphR2xzWkU1dlpHVnpVR0Z5YzJWVWNtVmxLVHRjYmx4dUlDQWdJSEpsZEhWeWJpQnViMjVVWlhKdGFXNWhiRTV2WkdWUVlYSnpaVlJ5WldVN1hHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpPYjI1VVpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVWlMQ0ptY205dFRtOXVWR1Z5YldsdVlXeE9iMlJsUVc1a1ZHOXJaVzV6SWl3aWJtOXVWR1Z5YldsdVlXeE9iMlJsSWl3aWRHOXJaVzV6SWl3aVkyaHBiR1JPYjJSbGN5SXNJbWRsZEVOb2FXeGtUbTlrWlhNaUxDSnlkV3hsVG1GdFpWQmhjbk5sVkhKbFpTSXNJbEoxYkdWT1lXMWxVR0Z5YzJWVWNtVmxJaXdpWTJocGJHUk9iMlJsYzFCaGNuTmxWSEpsWlNJc0lrTm9hV3hrVG05a1pYTlFZWEp6WlZSeVpXVWlMQ0ptY205dFEyaHBiR1JPYjJSbGMwRnVaRlJ2YTJWdWN5SXNJbkoxYkdWT1lXMWxVR0Z5YzJWVWNtVmxWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlJc0ltZGxkRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0aUxDSmphR2xzWkU1dlpHVnpVR0Z5YzJWVWNtVmxWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlJc0luWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjV6UkdsbVptVnlaVzVqWlNJc0lteGxablJOWVhKbmFXNVhhV1IwYUNJc0luVnVaR1ZtYVc1bFpDSXNJbUZrWkV4bFpuUk5ZWEpuYVc0aUxDSnlkV3hsVG1GdFpWQmhjbk5sVkhKbFpWZHBaSFJvSWl3aVoyVjBWMmxrZEdnaUxDSmphR2xzWkU1dlpHVnpVR0Z5YzJWVWNtVmxWMmxrZEdnaUxDSjNhV1IwYUhORWFXWm1aWEpsYm1ObElpd2ljbWxuYUhSTllYSm5hVzVYYVdSMGFDSXNJbUZrWkZKcFoyaDBUV0Z5WjJsdUlpd2ljblZzWlU1aGJXVlFZWEp6WlZSeVpXVkVaWEIwYUNJc0ltZGxkRVJsY0hSb0lpd2libTl1VkdWeWJXbHVZV3hPYjJSbFVHRnljMlZVY21WbFJHVndkR2dpTENKMlpYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJaXdpYm05dVZHVnliV2x1WVd4T2IyUmxVR0Z5YzJWVWNtVmxJaXdpVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWlMQ0ptY205dFJHVndkR2hCYm1SV1pYSjBhV05oYkVKeVlXNWphRkJ2YzJsMGFXOXVJaXdpWVhCd1pXNWtWRzlTYVdkb2RDSXNJbUZ3Y0dWdVpGUnZRbTkwZEc5dElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJUaENMRWxCUVVFc1UwRkJXU3hyUTBGQldpeFpRVUZaTEVWQlFVRTdRVUZEVml4SlFVRkJMRmRCUVdNc2EwTkJRV1FzWTBGQll5eEZRVUZCTzBGQlExWXNTVUZCUVN4bFFVRnJRaXhyUTBGQmJFSXNhMEpCUVd0Q0xFVkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZLZEVRN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlRXVXNTVUZCUVN4QlFVRk5RU3gzUWtGQmQwSXNhVUpEVGpGRExFRkVUVms3WjBWQlRtWTdPMkZCVFhGQ1FTeDNRa0ZCZDBJN2RVUkJUamRET3pzN096dFpRVTlUUXl4SFFVRTBRaXhGUVVFMVFrRXNPRUpCUVRSQ08xbEZVSEpETEU5R1QwVXNVMEZCVDBFc05FSkJRVFJDTEVOQlFVTkRMR1ZCUVdVc1JVRkJSVU1zVFVGQlRTeEZRVUZGTzJkQ1FVTXpSQ3hKUVVGTlF5eFZRVUZWTEVkQlFVZEdMR1ZCUVdVc1EwRkJRMGNzWVVGQllTeEZRVUZGTEVWQlF6VkRReXhwUWtGQmFVSXNSMEZCUjBNc1UwRkJhVUlzVTBGQlEwNHNORUpCUVRSQ0xFTkJRVU5ETEdWQlFXVXNSVUZCUlVNc1RVRkJUU3hEUVVGRExFVkJRek5HU3l4dFFrRkJiVUlzUjBGQlIwTXNWMEZCYlVJc1UwRkJRME1zZFVKQlFYVkNMRU5CUVVOT0xGVkJRVlVzUlVGQlJVUXNUVUZCVFN4RFFVRkRMRUZCUVVNN1owSkJSVFZHTEVsQlFVbFJMSFZEUVVGMVF5eEhRVUZIVEN4cFFrRkJhVUlzUTBGQlEwMHNlVUpCUVhsQ0xFVkJRVVVzUVVGQlF6dG5Ra0ZGTlVZc1NVRkJUVU1zZVVOQlFYbERMRWRCUVVkTUxHMUNRVUZ0UWl4RFFVRkRTU3g1UWtGQmVVSXNSVUZCUlN4RlFVTXpSa1VzYVVOQlFXbERMRWRCUVVkSUxIVkRRVUYxUXl4SFFVRkhSU3g1UTBGQmVVTXNRVUZCUXp0blFrRkZPVWdzU1VGQlNVVXNaVUZCWlN4SFFVRkhReXhUUVVGVExFRkJRVU03WjBKQlJXaERMRWxCUVVrc1MwRkJTeXhGUVVGRk8yZENRVU5VTEVkQlFVYzdhVUpCUTBvc1RVRkJUU3hKUVVGSlJpeHBRMEZCYVVNc1IwRkJSeXhEUVVGRExFVkJRVVU3YjBKQlEyaEVReXhsUVVGbExFZEJRVWNzUTBGQlEwUXNhVU5CUVdsRExFTkJRVU03YjBKQlJYSkVVaXhwUWtGQmFVSXNRMEZCUTFjc1lVRkJZU3hEUVVGRFJpeGxRVUZsTEVOQlFVTXNRMEZCUXp0cFFrRkRiRVFzVFVGQlRTeEpRVUZKUkN4cFEwRkJhVU1zUjBGQlJ5eERRVUZETEVWQlFVVTdiMEpCUTJoRVF5eGxRVUZsTEVkQlFVY3NRMEZCUTBRc2FVTkJRV2xETEVOQlFVTTdiMEpCUlhKRVRpeHRRa0ZCYlVJc1EwRkJRMU1zWVVGQllTeERRVUZEUml4bFFVRmxMRU5CUVVNc1EwRkJRenRwUWtGRGNFUTdaMEpCUlVRc1NVRkJUVWNzYzBKQlFYTkNMRWRCUVVkYUxHbENRVUZwUWl4RFFVRkRZU3hSUVVGUkxFVkJRVVVzUlVGRGNrUkRMSGRDUVVGM1FpeEhRVUZIV2l4dFFrRkJiVUlzUTBGQlExY3NVVUZCVVN4RlFVRkZMRVZCUTNwRVJTeG5Ra0ZCWjBJc1IwRkJSMGdzYzBKQlFYTkNMRWRCUVVkRkxIZENRVUYzUWl4QlFVRkRPMmRDUVVVelJTeEpRVUZKUlN4blFrRkJaMElzUjBGQlIwNHNVMEZCVXl4QlFVRkRPMmRDUVVWcVF5eEpRVUZKTEV0QlFVc3NSVUZCUlR0blFrRkRWQ3hIUVVGSE8ybENRVU5LTEUxQlFVMHNTVUZCU1Vzc1owSkJRV2RDTEVkQlFVY3NRMEZCUXl4RlFVRkZPMjlDUVVNdlFrTXNaMEpCUVdkQ0xFZEJRVWNzUTBGQlEwUXNaMEpCUVdkQ0xFTkJRVU03YjBKQlJYSkRaaXhwUWtGQmFVSXNRMEZCUTJsQ0xHTkJRV01zUTBGQlEwUXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dHBRa0ZEY0VRc1RVRkJUU3hKUVVGSlJDeG5Ra0ZCWjBJc1IwRkJSeXhEUVVGRExFVkJRVVU3YjBKQlF5OUNReXhuUWtGQlowSXNSMEZCUnl4RFFVRkRSQ3huUWtGQlowSXNRMEZCUXp0dlFrRkZja05pTEcxQ1FVRnRRaXhEUVVGRFpTeGpRVUZqTEVOQlFVTkVMR2RDUVVGblFpeERRVUZETEVOQlFVTTdhVUpCUTNSRU8yZENRVVZFV0N4MVEwRkJkVU1zUjBGQlIwd3NhVUpCUVdsQ0xFTkJRVU5OTEhsQ1FVRjVRaXhGUVVGRkxFTkJRVU03WjBKQlJYaEdMRWxCUVUxWkxITkNRVUZ6UWl4SFFVRkhiRUlzYVVKQlFXbENMRU5CUVVOdFFpeFJRVUZSTEVWQlFVVXNSVUZEY2tSRExEWkNRVUUyUWl4SFFVRkhSaXh6UWtGQmMwSXNSVUZEZEVSSExITkNRVUZ6UWl4SFFVRkhhRUlzZFVOQlFYVkRMRVZCUTJoRmFVSXNkMEpCUVhkQ0xFZEJRVWRETEdWQlFYVkNMRk5CUVVORExHdERRVUZyUXl4RFFVRkRPVUlzZDBKQlFYZENMRVZCUVVVd1FpdzJRa0ZCTmtJc1JVRkJSVU1zYzBKQlFYTkNMRU5CUVVNc1FVRkJRenRuUWtGRk4wdERMSGRDUVVGM1FpeERRVUZEUnl4aFFVRmhMRU5CUVVONlFpeHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8yZENRVU14UkhOQ0xIZENRVUYzUWl4RFFVRkRTU3hqUVVGakxFTkJRVU40UWl4dFFrRkJiVUlzUTBGQlF5eERRVUZETzJkQ1FVVTNSQ3hQUVVGUGIwSXNkMEpCUVhkQ0xFTkJRVU03WVVGRGFrTTdPMDFCTlVSSU96dERRVFpFUXl4RFFYWkVjVVJETEdWQlFYVkNMRk5CZFVRMVJUdHJRa0YyUkc5Q04wSXNkMEpCUVhkQ0xFRkJUamRESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uVGVybWluYWxOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFyc2VUcmVlL25vblRlcm1pbmFsTm9kZVwiKSk7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uL3V0aWxpdGllcy9hcnJheVwiKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxudmFyIE5vblRlcm1pbmFsTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9uVGVybWluYWxOb2RlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25UZXJtaW5hbE5vZGUpO1xuICAgICAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IGNoaWxkTm9kZXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhOb25UZXJtaW5hbE5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzVGVybWluYWxOb2RlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc05vblRlcm1pbmFsTm9kZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTm9uVGVybWluYWxOb2RlKCkge1xuICAgICAgICAgICAgICAgIHZhciBub25UZXJtaW5hbE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRSdWxlTmFtZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGVOYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0Q2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkTm9kZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldEZpcnN0U2lnbmlmaWNhbnRUb2tlblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RTaWduaWZpY2FudFRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAoMCwgX2FycmF5KS5mb3J3YXJkc1NvbWUodGhpcy5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RTaWduaWZpY2FudFRva2VuID0gY2hpbGROb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RTaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFNpZ25pZmljYW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRMYXN0U2lnbmlmaWNhbnRUb2tlblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhc3RTaWduaWZpY2FudFRva2VuKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgKDAsIF9hcnJheSkuYmFja3dhcmRzU29tZSh0aGlzLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2lnbmlmaWNhbnRUb2tlbiA9IGNoaWxkTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RTaWduaWZpY2FudFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2V0UnVsZU5hbWVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSdWxlTmFtZShydWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNldENoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGlsZE5vZGVzKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNQYXJzZVRyZWVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1BhcnNlVHJlZSh0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9uVGVybWluYWxOb2RlID0gdGhpcywgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlID0gX25vblRlcm1pbmFsTm9kZS5kZWZhdWx0LmZyb21Ob25UZXJtaW5hbE5vZGVBbmRUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpLCBwYXJzZVRyZWUgPSBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBydWxlTmFtZTsgLy8vXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gQ2xhc3M7IC8vL1xuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IE5vblRlcm1pbmFsTm9kZTsgLy8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgYXJlIG5vIGNoaWxkIG5vZGVzIGF0IHJ1bGUgJ1wiLmNvbmNhdChydWxlTmFtZSwgXCInLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub25UZXJtaW5hbE5vZGUgPSBuZXcgQ2xhc3MocnVsZU5hbWUsIGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9uVGVybWluYWxOb2RlO1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9uVGVybWluYWxOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl1YjJSbEwyNXZibFJsY20xcGJtRnNMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeE9iMlJsVUdGeWMyVlVjbVZsSUdaeWIyMGdYQ0l1TGk5d1lYSnpaVlJ5WldVdmJtOXVWR1Z5YldsdVlXeE9iMlJsWENJN1hHNWNibWx0Y0c5eWRDQjdJR1p2Y25kaGNtUnpVMjl0WlN3Z1ltRmphM2RoY21SelUyOXRaU0I5SUdaeWIyMGdYQ0l1TGk5MWRHbHNhWFJwWlhNdllYSnlZWGxjSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVG05dVZHVnliV2x1WVd4T2IyUmxJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9jblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wSUh0Y2JpQWdJQ0IwYUdsekxuSjFiR1ZPWVcxbElEMGdjblZzWlU1aGJXVTdYRzRnSUNBZ2RHaHBjeTVqYUdsc1pFNXZaR1Z6SUQwZ1kyaHBiR1JPYjJSbGN6dGNiaUFnZlZ4dVhHNGdJR2x6VkdWeWJXbHVZV3hPYjJSbEtDa2dlMXh1SUNBZ0lHTnZibk4wSUhSbGNtMXBibUZzVG05a1pTQTlJR1poYkhObE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhSbGNtMXBibUZzVG05a1pUdGNiaUFnZlZ4dVhHNGdJR2x6VG05dVZHVnliV2x1WVd4T2IyUmxLQ2tnZTF4dUlDQWdJR052Ym5OMElHNXZibFJsY20xcGJtRnNUbTlrWlNBOUlIUnlkV1U3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdibTl1VkdWeWJXbHVZV3hPYjJSbE8xeHVJQ0I5WEc1Y2JpQWdaMlYwVW5Wc1pVNWhiV1VvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdWNuVnNaVTVoYldVN1hHNGdJSDFjYmx4dUlDQm5aWFJEYUdsc1pFNXZaR1Z6S0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxtTm9hV3hrVG05a1pYTTdYRzRnSUgxY2JseHVJQ0JuWlhSR2FYSnpkRk5wWjI1cFptbGpZVzUwVkc5clpXNG9LU0I3WEc0Z0lDQWdiR1YwSUdacGNuTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpQTlJRzUxYkd3N1hHNWNiaUFnSUNCbWIzSjNZWEprYzFOdmJXVW9kR2hwY3k1amFHbHNaRTV2WkdWekxDQW9ZMmhwYkdST2IyUmxLU0E5UGlCN1hHNGdJQ0FnSUNCbWFYSnpkRk5wWjI1cFptbGpZVzUwVkc5clpXNGdQU0JqYUdsc1pFNXZaR1V1WjJWMFJtbHljM1JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVLQ2s3WEc1Y2JpQWdJQ0FnSUdsbUlDaG1hWEp6ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRnSVQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSeWRXVTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTazdYRzVjYmlBZ0lDQnlaWFIxY200Z1ptbHljM1JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVPMXh1SUNCOVhHNWNiaUFnWjJWMFRHRnpkRk5wWjI1cFptbGpZVzUwVkc5clpXNG9LU0I3WEc0Z0lDQWdiR1YwSUd4aGMzUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlEMGdiblZzYkR0Y2JseHVJQ0FnSUdKaFkydDNZWEprYzFOdmJXVW9kR2hwY3k1amFHbHNaRTV2WkdWekxDQW9ZMmhwYkdST2IyUmxLU0E5UGlCN1hHNGdJQ0FnSUNCc1lYTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpQTlJR05vYVd4a1RtOWtaUzVuWlhSTVlYTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpZ3BPMXh1WEc0Z0lDQWdJQ0JwWmlBb2JHRnpkRk5wWjI1cFptbGpZVzUwVkc5clpXNGdJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNrN1hHNWNiaUFnSUNCeVpYUjFjbTRnYkdGemRGTnBaMjVwWm1sallXNTBWRzlyWlc0N1hHNGdJSDFjYmlBZ1hHNGdJSE5sZEZKMWJHVk9ZVzFsS0hKMWJHVk9ZVzFsS1NCN1hHNGdJQ0FnZEdocGN5NXlkV3hsVG1GdFpTQTlJSEoxYkdWT1lXMWxPMXh1SUNCOVhHNWNiaUFnYzJWMFEyaHBiR1JPYjJSbGN5aGphR2xzWkU1dlpHVnpLU0I3WEc0Z0lDQWdkR2hwY3k1amFHbHNaRTV2WkdWeklEMGdZMmhwYkdST2IyUmxjenRjYmlBZ2ZWeHVJQ0JjYmlBZ1lYTlFZWEp6WlZSeVpXVW9kRzlyWlc1ektTQjdYRzRnSUNBZ1kyOXVjM1FnYm05dVZHVnliV2x1WVd4T2IyUmxJRDBnZEdocGN5d2dJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lHNXZibFJsY20xcGJtRnNUbTlrWlZCaGNuTmxWSEpsWlNBOUlFNXZibFJsY20xcGJtRnNUbTlrWlZCaGNuTmxWSEpsWlM1bWNtOXRUbTl1VkdWeWJXbHVZV3hPYjJSbFFXNWtWRzlyWlc1ektHNXZibFJsY20xcGJtRnNUbTlrWlN3Z2RHOXJaVzV6S1N4Y2JpQWdJQ0FnSUNBZ0lDQndZWEp6WlZSeVpXVWdQU0J1YjI1VVpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVTdJQ0F2THk5Y2JseHVJQ0FnSUhKbGRIVnliaUJ3WVhKelpWUnlaV1U3WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeWhEYkdGemN5d2djblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wSUh0Y2JpQWdJQ0JwWmlBb1kyaHBiR1JPYjJSbGN5QTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnSUNCamFHbHNaRTV2WkdWeklEMGdjblZzWlU1aGJXVTdJQ0F2THk5Y2JpQWdJQ0FnSUhKMWJHVk9ZVzFsSUQwZ1EyeGhjM003SUM4dkwxeHVJQ0FnSUNBZ1EyeGhjM01nUFNCT2IyNVVaWEp0YVc1aGJFNXZaR1U3SUNBdkx5OWNiaUFnSUNCOVhHNWNiaUFnSUNCamIyNXpkQ0JqYUdsc1pFNXZaR1Z6VEdWdVozUm9JRDBnWTJocGJHUk9iMlJsY3k1c1pXNW5kR2c3WEc1Y2JpQWdJQ0JwWmlBb1kyaHBiR1JPYjJSbGMweGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLR0JVYUdWeVpTQmhjbVVnYm04Z1kyaHBiR1FnYm05a1pYTWdZWFFnY25Wc1pTQW5KSHR5ZFd4bFRtRnRaWDBuTG1BcE8xeHVJQ0FnSUgxY2JpQWdJQ0JjYmlBZ0lDQmpiMjV6ZENCdWIyNVVaWEp0YVc1aGJFNXZaR1VnUFNCdVpYY2dRMnhoYzNNb2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHNXZibFJsY20xcGJtRnNUbTlrWlR0Y2JpQWdmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJazV2YmxSbGNtMXBibUZzVG05a1pTSXNJbkoxYkdWT1lXMWxJaXdpWTJocGJHUk9iMlJsY3lJc0ltbHpWR1Z5YldsdVlXeE9iMlJsSWl3aWRHVnliV2x1WVd4T2IyUmxJaXdpYVhOT2IyNVVaWEp0YVc1aGJFNXZaR1VpTENKdWIyNVVaWEp0YVc1aGJFNXZaR1VpTENKblpYUlNkV3hsVG1GdFpTSXNJbWRsZEVOb2FXeGtUbTlrWlhNaUxDSm5aWFJHYVhKemRGTnBaMjVwWm1sallXNTBWRzlyWlc0aUxDSm1hWEp6ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKbWIzSjNZWEprYzFOdmJXVWlMQ0pqYUdsc1pFNXZaR1VpTENKblpYUk1ZWE4wVTJsbmJtbG1hV05oYm5SVWIydGxiaUlzSW14aGMzUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2lZbUZqYTNkaGNtUnpVMjl0WlNJc0luTmxkRkoxYkdWT1lXMWxJaXdpYzJWMFEyaHBiR1JPYjJSbGN5SXNJbUZ6VUdGeWMyVlVjbVZsSWl3aWRHOXJaVzV6SWl3aWJtOXVWR1Z5YldsdVlXeE9iMlJsVUdGeWMyVlVjbVZsSWl3aVRtOXVWR1Z5YldsdVlXeE9iMlJsVUdGeWMyVlVjbVZsSWl3aVpuSnZiVTV2YmxSbGNtMXBibUZzVG05a1pVRnVaRlJ2YTJWdWN5SXNJbkJoY25ObFZISmxaU0lzSW1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1pTENKRGJHRnpjeUlzSW5WdVpHVm1hVzVsWkNJc0ltTm9hV3hrVG05a1pYTk1aVzVuZEdnaUxDSnNaVzVuZEdnaUxDSkZjbkp2Y2lKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWeFF5eEpRVUZCTEdkQ1FVRTRRaXhyUTBGQk9VSXNPRUpCUVRoQ0xFVkJRVUU3UVVGRmRrSXNTVUZCUVN4TlFVRnZRaXhYUVVGd1FpeHZRa0ZCYjBJc1EwRkJRVHM3T3pzN096czdPemhFUVVwb1JUdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPenM3UVVGTlpTeEpRVUZCTEVGQlFVMUJMR1ZCUVdVc2FVSkRUbXBETEVGRVRWazdZVUZCVFVFc1pVRkJaU3hEUVVOMFFrTXNVVUZCVVN4RlFVRkZReXhWUVVGVk96aERRVkJzUXp0UlFWRkpMRWxCUVVrc1EwRkJRMFFzVVVGQlVTeEhRVUZIUVN4UlFVRlJMRU5CUVVNN1VVRkRla0lzU1VGQlNTeERRVUZEUXl4VlFVRlZMRWRCUVVkQkxGVkJRVlVzUTBGQlF6czdPenRaUVVjdlFrTXNSMEZCWXl4RlFVRmtRU3huUWtGQll6dFpSVnBvUWl4UFJsbEZRU3hUUVVGQlFTeGpRVUZqTEVkQlFVYzdaMEpCUTJZc1NVRkJUVU1zV1VGQldTeEhRVUZITEV0QlFVc3NRVUZCUXp0blFrRkZNMElzVDBGQlQwRXNXVUZCV1N4RFFVRkRPMkZCUTNKQ096czdXVUZGUkVNc1IwRkJhVUlzUlVGQmFrSkJMRzFDUVVGcFFqdFpSV3hDYmtJc1QwWnJRa1ZCTEZOQlFVRkJMR2xDUVVGcFFpeEhRVUZITzJkQ1FVTnNRaXhKUVVGTlF5eGxRVUZsTEVkQlFVY3NTVUZCU1N4QlFVRkRPMmRDUVVVM1FpeFBRVUZQUVN4bFFVRmxMRU5CUVVNN1lVRkRlRUk3T3p0WlFVVkVReXhIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVY0UW1Jc1QwWjNRa1ZCTEZOQlFVRkJMRmRCUVZjc1IwRkJSenRuUWtGRFdpeFBRVUZQTEVsQlFVa3NRMEZCUTA0c1VVRkJVU3hEUVVGRE8yRkJRM1JDT3pzN1dVRkZSRThzUjBGQllTeEZRVUZpUVN4bFFVRmhPMWxGTlVKbUxFOUdORUpGUVN4VFFVRkJRU3hoUVVGaExFZEJRVWM3WjBKQlEyUXNUMEZCVHl4SlFVRkpMRU5CUVVOT0xGVkJRVlVzUTBGQlF6dGhRVU40UWpzN08xbEJSVVJQTEVkQlFYZENMRVZCUVhoQ1FTd3dRa0ZCZDBJN1dVVm9RekZDTEU5R1owTkZRU3hUUVVGQlFTeDNRa0ZCZDBJc1IwRkJSenRuUWtGRGVrSXNTVUZCU1VNc2NVSkJRWEZDTEVkQlFVY3NTVUZCU1N4QlFVRkRPMmRDUVVWcVEwTXNRMEZCUVVFc1IwRkJRVUVzVFVGQldTeEJRVTFXTEVOQlFVRXNZMEZPVnl4SlFVRkpMRU5CUVVOVUxGVkJRVlVzUlVGQlJTeFRRVUZEVlN4VFFVRlRMRVZCUVVzN2IwSkJRek5EUml4eFFrRkJjVUlzUjBGQlIwVXNVMEZCVXl4RFFVRkRTQ3gzUWtGQmQwSXNSVUZCUlN4RFFVRkRPMjlDUVVVM1JDeEpRVUZKUXl4eFFrRkJjVUlzUzBGQlN5eEpRVUZKTEVWQlFVVTdkMEpCUTJ4RExFOUJRVThzU1VGQlNTeERRVUZETzNGQ1FVTmlPMmxDUVVOR0xFTkJRVU1zUTBGQlF6dG5Ra0ZGU0N4UFFVRlBRU3h4UWtGQmNVSXNRMEZCUXp0aFFVTTVRanM3TzFsQlJVUkhMRWRCUVhWQ0xFVkJRWFpDUVN4NVFrRkJkVUk3V1VVNVEzcENMRTlHT0VORlFTeFRRVUZCUVN4MVFrRkJkVUlzUjBGQlJ6dG5Ra0ZEZUVJc1NVRkJTVU1zYjBKQlFXOUNMRWRCUVVjc1NVRkJTU3hCUVVGRE8yZENRVVZvUTBNc1EwRkJRVUVzUjBGQlFVRXNUVUZCWVN4QlFVMVlMRU5CUVVFc1pVRk9XU3hKUVVGSkxFTkJRVU5pTEZWQlFWVXNSVUZCUlN4VFFVRkRWU3hUUVVGVExFVkJRVXM3YjBKQlF6VkRSU3h2UWtGQmIwSXNSMEZCUjBZc1UwRkJVeXhEUVVGRFF5eDFRa0ZCZFVJc1JVRkJSU3hEUVVGRE8yOUNRVVV6UkN4SlFVRkpReXh2UWtGQmIwSXNTMEZCU3l4SlFVRkpMRVZCUVVVN2QwSkJRMnBETEU5QlFVOHNTVUZCU1N4RFFVRkRPM0ZDUVVOaU8ybENRVU5HTEVOQlFVTXNRMEZCUXp0blFrRkZTQ3hQUVVGUFFTeHZRa0ZCYjBJc1EwRkJRenRoUVVNM1FqczdPMWxCUlVSRkxFZEJRVmNzUlVGQldFRXNZVUZCVnp0WlJUVkVZaXhQUmpSRVJVRXNVMEZCUVVFc1YwRkJWeXhEUVVGRFppeFJRVUZSTEVWQlFVVTdaMEpCUTNCQ0xFbEJRVWtzUTBGQlEwRXNVVUZCVVN4SFFVRkhRU3hSUVVGUkxFTkJRVU03WVVGRE1VSTdPenRaUVVWRVowSXNSMEZCWVN4RlFVRmlRU3hsUVVGaE8xbEZhRVZtTEU5R1owVkZRU3hUUVVGQlFTeGhRVUZoTEVOQlFVTm1MRlZCUVZVc1JVRkJSVHRuUWtGRGVFSXNTVUZCU1N4RFFVRkRRU3hWUVVGVkxFZEJRVWRCTEZWQlFWVXNRMEZCUXp0aFFVTTVRanM3TzFsQlJVUm5RaXhIUVVGWExFVkJRVmhCTEdGQlFWYzdXVVZ3UldJc1QwWnZSVVZCTEZOQlFVRkJMRmRCUVZjc1EwRkJRME1zVFVGQlRTeEZRVUZGTzJkQ1FVTnNRaXhKUVVGTllpeGxRVUZsTEVkQlFVY3NTVUZCU1N4RlFVTjBRbU1zZDBKQlFYZENMRWRCUVVkRExHZENRVUYzUWl4VFFVRkRReXcwUWtGQk5FSXNRMEZCUTJoQ0xHVkJRV1VzUlVGQlJXRXNUVUZCVFN4RFFVRkRMRVZCUTNwSFNTeFRRVUZUTEVkQlFVZElMSGRDUVVGM1FpeEJRVUZETEVWQlFVVXNSMEZCUnp0blFrRkZhRVFzVDBGQlQwY3NVMEZCVXl4RFFVRkRPMkZCUTJ4Q096czdPMWxCUlUxRExFZEJRWGxDTEVWQlFYcENRU3d5UWtGQmVVSTdXVVUxUld4RExFOUdORVZGTEZOQlFVOUJMSGxDUVVGNVFpeERRVUZEUXl4TFFVRkxMRVZCUVVWNFFpeFJRVUZSTEVWQlFVVkRMRlZCUVZVc1JVRkJSVHRuUWtGRE5VUXNTVUZCU1VFc1ZVRkJWU3hMUVVGTGQwSXNVMEZCVXl4RlFVRkZPMjlDUVVNMVFuaENMRlZCUVZVc1IwRkJSMFFzVVVGQlVTeERRVUZETEVOQlFVVXNSMEZCUnp0dlFrRkRNMEpCTEZGQlFWRXNSMEZCUjNkQ0xFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVYzdiMEpCUTNKQ1FTeExRVUZMTEVkQlFVZDZRaXhsUVVGbExFTkJRVU1zUTBGQlJTeEhRVUZITzJsQ1FVTTVRanRuUWtGRlJDeEpRVUZOTWtJc1owSkJRV2RDTEVkQlFVZDZRaXhWUVVGVkxFTkJRVU13UWl4TlFVRk5MRUZCUVVNN1owSkJSVE5ETEVsQlFVbEVMR2RDUVVGblFpeExRVUZMTEVOQlFVTXNSVUZCUlR0dlFrRkRNVUlzVFVGQlRTeEpRVUZKUlN4TFFVRkxMRU5CUVVNc1FVRkJReXh2UTBGQmEwTXNRMEZCVnl4TlFVRkZMRU5CUVZnMVFpeFJRVUZSTEVWQlFVTXNTVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRwUWtGRGNFVTdaMEpCUlVRc1NVRkJUVXNzWlVGQlpTeEhRVUZITEVsQlFVbHRRaXhMUVVGTExFTkJRVU40UWl4UlFVRlJMRVZCUVVWRExGVkJRVlVzUTBGQlF5eEJRVUZETzJkQ1FVVjRSQ3hQUVVGUFNTeGxRVUZsTEVOQlFVTTdZVUZEZUVJN08wMUJOVVpJT3p0RFFUWkdReXhGUVVGQk8ydENRWFpHYjBKT0xHVkJRV1VzUVVGT2NFTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIikpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBOYW1lQk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKE5hbWVCTkZOb2RlLCBOb25UZXJtaW5hbE5vZGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTmFtZUJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIE5hbWVCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmFtZUJORk5vZGUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhOYW1lQk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgZmlyc3RDaGlsZE5vZGUgPSAoMCwgX2FycmF5KS5maXJzdChjaGlsZE5vZGVzKSwgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLCBuYW1lID0gdGVybWluYWxOb2RlQ29udGVudDsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhydWxlTmFtZSwgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uVGVybWluYWwuZGVmYXVsdC5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKE5hbWVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTmFtZUJORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5hbWVCTkZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5dVlXMWxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUdaeWIyMGdYQ0l1TGk4dUxpOXViMlJsTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVjYm1sdGNHOXlkQ0I3SUdacGNuTjBJSDBnWm5KdmJTQmNJaTR1THk0dUwzVjBhV3hwZEdsbGN5OWhjbkpoZVZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCT1lXMWxRazVHVG05a1pTQmxlSFJsYm1SeklFNXZibFJsY20xcGJtRnNUbTlrWlNCN1hHNGdJR2RsZEU1aGJXVW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ1kyaHBiR1JPYjJSbGN5QTlJSFJvYVhNdVoyVjBRMmhwYkdST2IyUmxjeWdwTEZ4dUlDQWdJQ0FnSUNBZ0lHWnBjbk4wUTJocGJHUk9iMlJsSUQwZ1ptbHljM1FvWTJocGJHUk9iMlJsY3lrc1hHNGdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeE9iMlJsSUQwZ1ptbHljM1JEYUdsc1pFNXZaR1VzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRTV2WkdWRGIyNTBaVzUwSUQwZ2RHVnliV2x1WVd4T2IyUmxMbWRsZEVOdmJuUmxiblFvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnVZVzFsSUQwZ2RHVnliV2x1WVd4T2IyUmxRMjl1ZEdWdWREc2dMeTh2WEc0Z0lDQWdYRzRnSUNBZ2NtVjBkWEp1SUc1aGJXVTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aHlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWtnZXlCeVpYUjFjbTRnVG05dVZHVnliV2x1WVd4T2IyUmxMbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9UbUZ0WlVKT1JrNXZaR1VzSUhKMWJHVk9ZVzFsTENCamFHbHNaRTV2WkdWektUc2dmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJazVoYldWQ1RrWk9iMlJsSWl3aVoyVjBUbUZ0WlNJc0ltTm9hV3hrVG05a1pYTWlMQ0puWlhSRGFHbHNaRTV2WkdWeklpd2labWx5YzNSRGFHbHNaRTV2WkdVaUxDSm1hWEp6ZENJc0luUmxjbTFwYm1Gc1RtOWtaU0lzSW5SbGNtMXBibUZzVG05a1pVTnZiblJsYm5RaUxDSm5aWFJEYjI1MFpXNTBJaXdpYm1GdFpTSXNJbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTWlMQ0p5ZFd4bFRtRnRaU0lzSWs1dmJsUmxjbTFwYm1Gc1RtOWtaU0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVUwUWl4SlFVRkJMRmxCUVhkQ0xHdERRVUY0UWl4M1FrRkJkMElzUlVGQlFUdEJRVVU1UWl4SlFVRkJMRTFCUVhWQ0xGZEJRWFpDTEhWQ1FVRjFRaXhEUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlNqZERPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVTFsTEVsQlFVRXNRVUZCVFVFc1YwRkJWeXhwUWtOT04wSXNRVVJOV1RzeVEwRk9aanM3WVVGTmNVSkJMRmRCUVZjN01FTkJUbWhET3pzN096dFpRVTlGUXl4SFFVRlBMRVZCUVZCQkxGTkJRVTg3V1VWUVZDeFBSazlGUVN4VFFVRkJRU3hQUVVGUExFZEJRVWM3WjBKQlExSXNTVUZCVFVNc1ZVRkJWU3hIUVVGSExFbEJRVWtzUTBGQlEwTXNZVUZCWVN4RlFVRkZMRVZCUTJwRFF5eGpRVUZqTEVkQlFVZERMRU5CUVVGQkxFZEJRVUZCTEUxQlFVc3NRVUZCV1N4RFFVRkJMRTlCUVZoSUxGVkJRVlVzUTBGQlF5eEZRVU5zUTBrc1dVRkJXU3hIUVVGSFJpeGpRVUZqTEVWQlF6ZENSeXh0UWtGQmJVSXNSMEZCUjBRc1dVRkJXU3hEUVVGRFJTeFZRVUZWTEVWQlFVVXNSVUZETDBORExFbEJRVWtzUjBGQlIwWXNiVUpCUVcxQ0xFRkJRVU1zUlVGQlF5eEhRVUZITzJkQ1FVVnlReXhQUVVGUFJTeEpRVUZKTEVOQlFVTTdZVUZEWWpzN096dFpRVVZOUXl4SFFVRjVRaXhGUVVGNlFrRXNNa0pCUVhsQ08xbEZha0pzUXl4UFJtbENSU3hUUVVGUFFTeDVRa0ZCZVVJc1EwRkJRME1zVVVGQlVTeEZRVUZGVkN4VlFVRlZMRVZCUVVVN1owSkJRVVVzVDBGQlQxVXNXVUZCWlN4VFFVRkRSaXg1UWtGQmVVSXNRMEZCUTFZc1YwRkJWeXhGUVVGRlZ5eFJRVUZSTEVWQlFVVlVMRlZCUVZVc1EwRkJReXhEUVVGRE8yRkJRVVU3TzAxQmFrSnFTanM3UTBGclFrTXNRMEZhZDBOVkxGbEJRV1VzVTBGWmRrUTdhMEpCV205Q1dpeFhRVUZYTEVGQlRtaERJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJ0UnVsZU5hbWVQYXJ0V2l0aExvb2tBaGVhZChwYXJ0KSB7XG4gIGxldCBwYXJ0UnVsZU5hbWVQYXJ0V2l0aExvb2tBaGVhZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHBhcnRSdWxlTmFtZVBhcnQgPSBpc1BhcnRSdWxlTmFtZVBhcnQocGFydCk7XG5cbiAgaWYgKHBhcnRSdWxlTmFtZVBhcnQpIHtcbiAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBwYXJ0LCAgLy8vXG4gICAgICAgICAgbG9va0FoZWFkID0gcnVsZU5hbWVQYXJ0LmlzTG9va0FoZWFkKCk7XG5cbiAgICBpZiAobG9va0FoZWFkKSB7XG4gICAgICBwYXJ0UnVsZU5hbWVQYXJ0V2l0aExvb2tBaGVhZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRSdWxlTmFtZVBhcnRXaXRoTG9va0FoZWFkO1xufVxuXG5mdW5jdGlvbiBpc1BhcnRSdWxlTmFtZVBhcnQocGFydCkge1xuICBsZXQgcGFydFJ1bGVOYW1lUGFydCA9IGZhbHNlO1xuXG4gIGNvbnN0IHBhcnRUZXJtaW5hbFBhcnQgPSBwYXJ0LmlzVGVybWluYWxQYXJ0KCksXG4gICAgICAgIHBhcnROb25UZXJtaW5hbFBhcnQgPSAhcGFydFRlcm1pbmFsUGFydDtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsXG4gICAgICAgICAgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LmlzUnVsZU5hbWVQYXJ0KCk7XG5cbiAgICBwYXJ0UnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0OyAvLy9cbiAgfVxuXG4gIHJldHVybiBwYXJ0UnVsZU5hbWVQYXJ0O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwdXNoIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgaXNQYXJ0UnVsZU5hbWVQYXJ0V2l0aExvb2tBaGVhZCB9IGZyb20gXCIuL3BhcnRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFydHMocGFydHMsIG5vZGVzLCBpbmRleCwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgY29uc3QgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG5cbiAgaWYgKGluZGV4ID09PSBwYXJ0c0xlbmd0aCkge1xuICAgIHBhcnNlZCA9IChjYWxsYmFjayAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCkgOlxuICAgICAgICAgICAgICAgICAgdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuXG4gICAgcGFyc2VkID0gcGFyc2VQYXJ0T2ZQYXJ0cyhwYXJ0LCBwYXJ0cywgbm9kZXMsIGluZGV4LCBzdGF0ZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0T2ZQYXJ0cyhwYXJ0LCBwYXJ0cywgbm9kZXMsIGluZGV4LCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgbGV0IHBhcnNlZDtcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICBjb25zdCBwYXJ0c05vZGVzID0gW107XG5cbiAgICBpbmRleCsrO1xuXG4gICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsICgpID0+IHBhcnNlUGFydHMocGFydHMsIHBhcnRzTm9kZXMsIGluZGV4LCBzdGF0ZSwgY2FsbGJhY2spKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHB1c2gobm9kZXMsIHBhcnRzTm9kZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0V2l0aExvb2tBaGVhZCA9IGlzUGFydFJ1bGVOYW1lUGFydFdpdGhMb29rQWhlYWQocGFydCk7XG5cbiAgICBpZiAocGFydFJ1bGVOYW1lUGFydFdpdGhMb29rQWhlYWQpIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgICAgcGFydHNOb2RlcyA9IFtdO1xuXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBwYXJzZWQgPSBydWxlTmFtZVBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCAoKSA9PiBwYXJzZVBhcnRzKHBhcnRzLCBwYXJ0c05vZGVzLCBpbmRleCwgc3RhdGUsIGNhbGxiYWNrKSk7XG5cbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgcHVzaChub2RlcywgcGFydHNOb2Rlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHBhcnRzLCBub2RlcywgaW5kZXgsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfYXJyYXkgPSByZXF1aXJlKFwiLi91dGlsaXRpZXMvYXJyYXlcIik7XG52YXIgX2xvb2tBaGVhZCA9IHJlcXVpcmUoXCIuL3V0aWxpdGllcy9sb29rQWhlYWRcIik7XG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxudmFyIERlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIERlZmluaXRpb24ocGFydHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmluaXRpb24pO1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhEZWZpbml0aW9uLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRQYXJ0c1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcnRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0Rmlyc3RQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rmlyc3RQYXJ0KCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBhcnQgPSAoMCwgX2FycmF5KS5maXJzdCh0aGlzLnBhcnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0UGFydHNMZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJ0c0xlbmd0aCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHNMZW5ndGggPSB0aGlzLnBhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhZGRQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUGFydChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9ICgwLCBfbG9va0FoZWFkKS5wYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBpbmRleCwgc3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHNTdHJpbmcxID0gdGhpcy5wYXJ0cy5yZWR1Y2UoZnVuY3Rpb24ocGFydHNTdHJpbmcsIHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRTdHJpbmcgPSBwYXJ0LmFzU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1N0cmluZyA9PT0gX2NvbnN0YW50cy5FTVBUWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gcGFydFN0cmluZzsgLy8vXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1N0cmluZyA9IFwiXCIuY29uY2F0KHBhcnRzU3RyaW5nLCBcIiBcIikuY29uY2F0KHBhcnRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c1N0cmluZztcbiAgICAgICAgICAgICAgICB9LCBfY29uc3RhbnRzLkVNUFRZX1NUUklORyksIHN0cmluZyA9IHBhcnRzU3RyaW5nMTsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBEZWZpbml0aW9uO1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlrWldacGJtbDBhVzl1TG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdleUJtYVhKemRDQjlJR1p5YjIwZ1hDSXVMM1YwYVd4cGRHbGxjeTloY25KaGVWd2lPMXh1YVcxd2IzSjBJSHNnY0dGeWMyVlFZWEowY3lCOUlHWnliMjBnWENJdUwzVjBhV3hwZEdsbGN5OXNiMjlyUVdobFlXUmNJanRjYm1sdGNHOXlkQ0I3SUVWTlVGUlpYMU5VVWtsT1J5QjlJR1p5YjIwZ1hDSXVMMk52Ym5OMFlXNTBjMXdpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJFWldacGJtbDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY0dGeWRITXBJSHRjYmlBZ0lDQjBhR2x6TG5CaGNuUnpJRDBnY0dGeWRITTdYRzRnSUgxY2JseHVJQ0JuWlhSUVlYSjBjeWdwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1d1lYSjBjenRjYmlBZ2ZWeHVYRzRnSUdkbGRFWnBjbk4wVUdGeWRDZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCbWFYSnpkRkJoY25RZ1BTQm1hWEp6ZENoMGFHbHpMbkJoY25SektUdGNibHh1SUNBZ0lISmxkSFZ5YmlCbWFYSnpkRkJoY25RN1hHNGdJSDFjYmx4dUlDQm5aWFJRWVhKMGMweGxibWQwYUNncElIdGNiaUFnSUNCamIyNXpkQ0J3WVhKMGMweGxibWQwYUNBOUlIUm9hWE11Y0dGeWRITXViR1Z1WjNSb08xeHVYRzRnSUNBZ2NtVjBkWEp1SUhCaGNuUnpUR1Z1WjNSb08xeHVJQ0I5WEc1Y2JpQWdZV1JrVUdGeWRDaHdZWEowS1NCN1hHNGdJQ0FnZEdocGN5NXdZWEowY3k1d2RYTm9LSEJoY25RcE8xeHVJQ0I5WEc1Y2JpQWdjR0Z5YzJVb2JtOWtaWE1zSUhOMFlYUmxMQ0JqWVd4c1ltRmpheWtnZTF4dUlDQWdJR3hsZENCd1lYSnpaV1E3WEc1Y2JpQWdJQ0JqYjI1emRDQnBibVJsZUNBOUlEQTdYRzVjYmlBZ0lDQndZWEp6WldRZ1BTQndZWEp6WlZCaGNuUnpLSFJvYVhNdWNHRnlkSE1zSUc1dlpHVnpMQ0JwYm1SbGVDd2djM1JoZEdVc0lHTmhiR3hpWVdOcktUdGNibHh1SUNBZ0lISmxkSFZ5YmlCd1lYSnpaV1E3WEc0Z0lIMWNibHh1SUNCaGMxTjBjbWx1WnlncElIdGNiaUFnSUNCamIyNXpkQ0J3WVhKMGMxTjBjbWx1WnlBOUlIUm9hWE11Y0dGeWRITXVjbVZrZFdObEtDaHdZWEowYzFOMGNtbHVaeXdnY0dGeWRDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUhCaGNuUlRkSEpwYm1jZ1BTQndZWEowTG1GelUzUnlhVzVuS0NrN1hHNWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2NHRnlkSE5UZEhKcGJtY2dQVDA5SUVWTlVGUlpYMU5VVWtsT1J5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnlkSE5UZEhKcGJtY2dQU0J3WVhKMFUzUnlhVzVuT3lBdkx5OWNiaUFnSUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnlkSE5UZEhKcGJtY2dQU0JnSkh0d1lYSjBjMU4wY21sdVozMGdKSHR3WVhKMFUzUnlhVzVuZldBN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhCaGNuUnpVM1J5YVc1bk8xeHVJQ0FnSUNBZ0lDQjlMQ0JGVFZCVVdWOVRWRkpKVGtjcExGeHVJQ0FnSUNBZ0lDQnpkSEpwYm1jZ1BTQndZWEowYzFOMGNtbHVaenNnTHk4dlhHNWNiaUFnSUNCeVpYUjFjbTRnYzNSeWFXNW5PMXh1SUNCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVJHVm1hVzVwZEdsdmJpSXNJbkJoY25Seklpd2laMlYwVUdGeWRITWlMQ0puWlhSR2FYSnpkRkJoY25RaUxDSm1hWEp6ZEZCaGNuUWlMQ0ptYVhKemRDSXNJbWRsZEZCaGNuUnpUR1Z1WjNSb0lpd2ljR0Z5ZEhOTVpXNW5kR2dpTENKc1pXNW5kR2dpTENKaFpHUlFZWEowSWl3aWNHRnlkQ0lzSW5CMWMyZ2lMQ0p3WVhKelpTSXNJbTV2WkdWeklpd2ljM1JoZEdVaUxDSmpZV3hzWW1GamF5SXNJbkJoY25ObFpDSXNJbWx1WkdWNElpd2ljR0Z5YzJWUVlYSjBjeUlzSW1GelUzUnlhVzVuSWl3aWNHRnlkSE5UZEhKcGJtY2lMQ0p5WldSMVkyVWlMQ0p3WVhKMFUzUnlhVzVuSWl3aVJVMVFWRmxmVTFSU1NVNUhJaXdpYzNSeWFXNW5JbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSWE5DTEVsQlFVRXNUVUZCYlVJc1YwRkJia0lzYlVKQlFXMUNMRU5CUVVFN1FVRkRaQ3hKUVVGQkxGVkJRWFZDTEZkQlFYWkNMSFZDUVVGMVFpeERRVUZCTzBGQlEzSkNMRWxCUVVFc1ZVRkJZU3hYUVVGaUxHRkJRV0VzUTBGQlFUczdPenM3T3pzN096aEVRVW94UXp0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3TzBGQlRXVXNTVUZCUVN4QlFVRk5RU3hWUVVGVkxHbENRMDQxUWl4QlJFMVpPMkZCUVUxQkxGVkJRVlVzUTBGRGFrSkRMRXRCUVVzN2VVTkJVRzVDTzFGQlVVa3NTVUZCU1N4RFFVRkRRU3hMUVVGTExFZEJRVWRCTEV0QlFVc3NRMEZCUXpzN096dFpRVWR5UWtNc1IwRkJVU3hGUVVGU1FTeFZRVUZSTzFsRldGWXNUMFpYUlVFc1UwRkJRVUVzVVVGQlVTeEhRVUZITzJkQ1FVTlVMRTlCUVU4c1NVRkJTU3hEUVVGRFJDeExRVUZMTEVOQlFVTTdZVUZEYmtJN096dFpRVVZFUlN4SFFVRlpMRVZCUVZwQkxHTkJRVms3V1VWbVpDeFBSbVZGUVN4VFFVRkJRU3haUVVGWkxFZEJRVWM3WjBKQlEySXNTVUZCVFVNc1UwRkJVeXhIUVVGSFF5eERRVUZCUVN4SFFVRkJRU3hOUVVGTExFRkJRVmtzUTBGQlFTeFBRVUZZTEVsQlFVa3NRMEZCUTBvc1MwRkJTeXhEUVVGRExFRkJRVU03WjBKQlJYQkRMRTlCUVU5SExGTkJRVk1zUTBGQlF6dGhRVU5zUWpzN08xbEJSVVJGTEVkQlFXTXNSVUZCWkVFc1owSkJRV003V1VWeVFtaENMRTlHY1VKRlFTeFRRVUZCUVN4alFVRmpMRWRCUVVjN1owSkJRMllzU1VGQlRVTXNWMEZCVnl4SFFVRkhMRWxCUVVrc1EwRkJRMDRzUzBGQlN5eERRVUZEVHl4TlFVRk5MRUZCUVVNN1owSkJSWFJETEU5QlFVOUVMRmRCUVZjc1EwRkJRenRoUVVOd1FqczdPMWxCUlVSRkxFZEJRVThzUlVGQlVFRXNVMEZCVHp0WlJUTkNWQ3hQUmpKQ1JVRXNVMEZCUVVFc1QwRkJUeXhEUVVGRFF5eEpRVUZKTEVWQlFVVTdaMEpCUTFvc1NVRkJTU3hEUVVGRFZDeExRVUZMTEVOQlFVTlZMRWxCUVVrc1EwRkJRMFFzU1VGQlNTeERRVUZETEVOQlFVTTdZVUZEZGtJN096dFpRVVZFUlN4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VVdlFsQXNUMFlyUWtWQkxGTkJRVUZCTEV0QlFVc3NRMEZCUTBNc1MwRkJTeXhGUVVGRlF5eExRVUZMTEVWQlFVVkRMRkZCUVZFc1JVRkJSVHRuUWtGRE5VSXNTVUZCU1VNc1RVRkJUU3hCUVVGRE8yZENRVVZZTEVsQlFVMURMRXRCUVVzc1IwRkJSeXhEUVVGRExFRkJRVU03WjBKQlJXaENSQ3hOUVVGTkxFZEJRVWRGTEVOQlFVRkJMRWRCUVVGQkxGVkJRVlVzUVVGQk1rTXNRMEZCUVN4WlFVRXhReXhKUVVGSkxFTkJRVU5xUWl4TFFVRkxMRVZCUVVWWkxFdEJRVXNzUlVGQlJVa3NTMEZCU3l4RlFVRkZTQ3hMUVVGTExFVkJRVVZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMmRDUVVVdlJDeFBRVUZQUXl4TlFVRk5MRU5CUVVNN1lVRkRaanM3TzFsQlJVUkhMRWRCUVZFc1JVRkJVa0VzVlVGQlVUdFpSWHBEVml4UFJubERSVUVzVTBGQlFVRXNVVUZCVVN4SFFVRkhPMmRDUVVOVUxFbEJRVTFETEZsQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVOdVFpeExRVUZMTEVOQlFVTnZRaXhOUVVGTkxFTkJRVU1zVTBGQlEwUXNWMEZCVnl4RlFVRkZWaXhKUVVGSkxFVkJRVXM3YjBKQlEzWkVMRWxCUVUxWkxGVkJRVlVzUjBGQlIxb3NTVUZCU1N4RFFVRkRVeXhSUVVGUkxFVkJRVVVzUVVGQlF6dHZRa0ZGYmtNc1NVRkJTVU1zVjBGQlZ5eExRVUZMUnl4VlFVRlpMR0ZCUVVFc1JVRkJSVHQzUWtGRGFFTklMRmRCUVZjc1IwRkJSMFVzVlVGQlZTeERRVUZETEVOQlFVTXNSMEZCUnp0eFFrRkRPVUlzVFVGQlRUdDNRa0ZEVEVZc1YwRkJWeXhIUVVGSExFRkJRVU1zUlVGQlFTeERRVUZwUWtVc1RVRkJWU3hEUVVGNlFrWXNWMEZCVnl4RlFVRkRMRWRCUVVNc1EwRkJZU3hEUVVGQkxFMUJRVUVzUTBGQldFVXNWVUZCVlN4RFFVRkZMRU5CUVVNN2NVSkJRemxETzI5Q1FVVkVMRTlCUVU5R0xGZEJRVmNzUTBGQlF6dHBRa0ZEY0VJc1JVRkJSVWNzVlVGQldTeGpRVUZETEVWQlEyaENReXhOUVVGTkxFZEJRVWRLTEZsQlFWY3NRVUZCUXl4RlFVRkRMRWRCUVVjN1owSkJSVGRDTEU5QlFVOUpMRTFCUVUwc1EwRkJRenRoUVVObU96dE5RWGhFU0RzN1EwRjVSRU1zUlVGQlFUdHJRa0Z1Ukc5Q2VFSXNWVUZCVlN4QlFVNHZRaUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gW1xuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbnZhciBUZXJtaW5hbFBhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsUGFydCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlcm1pbmFsUGFydCk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhUZXJtaW5hbFBhcnQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzTm9uVGVybWluYWxQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNOb25UZXJtaW5hbFBhcnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vblRlcm1pbmFsUGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub25UZXJtaW5hbFBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc1Rlcm1pbmFsUGFydFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGVybWluYWxQYXJ0KCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFBhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hbFBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc05vV2hpdGVzcGFjZVBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc05vV2hpdGVzcGFjZVBhcnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vV2hpdGVzcGFjZVBhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoUGFydCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmluZ0FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoUGFydCwgX3RvQ29uc3VtYWJsZUFycmF5KHJlbWFpbmluZ0FyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFRlcm1pbmFsUGFydDtcbn0oKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlcm1pbmFsUGFydDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYSjBMM1JsY20xcGJtRnNMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJVWlhKdGFXNWhiRkJoY25RZ2UxeHVJQ0JwYzA1dmJsUmxjbTFwYm1Gc1VHRnlkQ2dwSUh0Y2JpQWdJQ0JqYjI1emRDQnViMjVVWlhKdGFXNWhiRkJoY25RZ1BTQm1ZV3h6WlR0Y2JseHVJQ0FnSUhKbGRIVnliaUJ1YjI1VVpYSnRhVzVoYkZCaGNuUTdYRzRnSUgxY2JseHVJQ0JwYzFSbGNtMXBibUZzVUdGeWRDZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCMFpYSnRhVzVoYkZCaGNuUWdQU0IwY25WbE8xeHVJQ0FnSUZ4dUlDQWdJSEpsZEhWeWJpQjBaWEp0YVc1aGJGQmhjblE3WEc0Z0lIMWNibHh1SUNCcGMwNXZWMmhwZEdWemNHRmpaVkJoY25Rb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYm05WGFHbDBaWE53WVdObFVHRnlkQ0E5SUdaaGJITmxPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHNXZWMmhwZEdWemNHRmpaVkJoY25RN1hHNGdJSDFjYmx4dUlDQmpiRzl1WlNoUVlYSjBMQ0F1TGk1eVpXMWhhVzVwYm1kQmNtZDFiV1Z1ZEhNcElIc2djbVYwZFhKdUlHNWxkeUJRWVhKMEtDNHVMbkpsYldGcGJtbHVaMEZ5WjNWdFpXNTBjeWs3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKVVpYSnRhVzVoYkZCaGNuUWlMQ0pwYzA1dmJsUmxjbTFwYm1Gc1VHRnlkQ0lzSW01dmJsUmxjbTFwYm1Gc1VHRnlkQ0lzSW1selZHVnliV2x1WVd4UVlYSjBJaXdpZEdWeWJXbHVZV3hRWVhKMElpd2lhWE5PYjFkb2FYUmxjM0JoWTJWUVlYSjBJaXdpYm05WGFHbDBaWE53WVdObFVHRnlkQ0lzSW1Oc2IyNWxJaXdpVUdGeWRDSXNJbkpsYldGcGJtbHVaMEZ5WjNWdFpXNTBjeUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUczdlVVJCUVVFN2RVVkJRVUU3T3pzN096czdPenM3T3pzN096czdaMFpCUVVFN096czdPenM3TzNORFFVRkJPenM3T3pzN2FVTkJRVUU3T3p0cFJVRkJRVHM3VTBGQlFUczdPenM3T3pzNFJFRkJRVHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN096czdPenM3SzBSQlFVRTdPenM3UVVGRlpTeEpRVUZCTEVGQlFVMUJMRmxCUVZrc2FVSkRSamxDTEVGRVJWazdZVUZCVFVFc1dVRkJXVHN5UTBGR2FrTTdPenM3V1VGSFJVTXNSMEZCYVVJc1JVRkJha0pCTEcxQ1FVRnBRanRaUlVodVFpeFBSa2RGUVN4VFFVRkJRU3hwUWtGQmFVSXNSMEZCUnp0blFrRkRiRUlzU1VGQlRVTXNaVUZCWlN4SFFVRkhMRXRCUVVzc1FVRkJRenRuUWtGRk9VSXNUMEZCVDBFc1pVRkJaU3hEUVVGRE8yRkJRM2hDT3pzN1dVRkZSRU1zUjBGQll5eEZRVUZrUVN4blFrRkJZenRaUlZSb1FpeFBSbE5GUVN4VFFVRkJRU3hqUVVGakxFZEJRVWM3WjBKQlEyWXNTVUZCVFVNc1dVRkJXU3hIUVVGSExFbEJRVWtzUVVGQlF6dG5Ra0ZGTVVJc1QwRkJUMEVzV1VGQldTeERRVUZETzJGQlEzSkNPenM3V1VGRlJFTXNSMEZCYTBJc1JVRkJiRUpCTEc5Q1FVRnJRanRaUldad1FpeFBSbVZGUVN4VFFVRkJRU3hyUWtGQmEwSXNSMEZCUnp0blFrRkRia0lzU1VGQlRVTXNaMEpCUVdkQ0xFZEJRVWNzUzBGQlN5eEJRVUZETzJkQ1FVVXZRaXhQUVVGUFFTeG5Ra0ZCWjBJc1EwRkJRenRoUVVONlFqczdPMWxCUlVSRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJYSkNVQ3hQUm5GQ1JVRXNVMEZCUVVFc1MwRkJTeXhEUVVGRFF5eEpRVUZKTEVWQlFYbENPMmRDUVVGMlFpeEpRVUZCTEVsQlFVRXNTVUZCY1VJc1IwRkJja0lzVTBGQmNVSXNRMEZCY2tJc1RVRkJjVUlzUlVGQmNrSXNRVUZCUjBNc2EwSkJRV3RDTEVkQlFYSkNMRlZCUVVFc1NVRkJjVUlzUjBGQmNrSXNRMEZCY1VJc1IwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQlFTeERRVUZCTEVWQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRVZCUVhKQ0xFbEJRWEZDTEVkQlFYSkNMRWxCUVhGQ0xFVkJRWEpDTEVsQlFYRkNMRVZCUVVFc1EwRkJja0k3YjBKQlFVRXNRVUZCUjBFc2EwSkJRV3RDTEVOQlFYSkNMRWxCUVhGQ0xFZEJRWEpDTEVOQlFYRkNMRWxCUVhKQ0xGTkJRWEZDTEVGQlFYSkNMRU5CUVVFc1NVRkJjVUlzUTBGQlFTeEJSWEpDYmtNc1EwWnhRbTFETzJsQ1FVRkJPMmRDUVVGSkxFOUJRVThzVjBGQlNVUXNTVUZCU1N4RlFVRkRMRzFDUVVGSFF5eHJRa0ZCYTBJc1EwRkJiRUpCTEVOQlFXMUNMRU5CUVVNN1lVRkJSVHM3VFVGeVFtaEdPenREUVhOQ1F5eEZRVUZCTzJ0Q1FYQkNiMEpVTEZsQlFWa3NRVUZHYWtNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3ZlcnRpY2FsQnJhbmNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92ZXJ0aWNhbEJyYW5jaFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBUZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKSB7XG4gICAgX2luaGVyaXRzKFRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGVybWluYWxOb2RlUGFyc2VUcmVlKTtcbiAgICBmdW5jdGlvbiBUZXJtaW5hbE5vZGVQYXJzZVRyZWUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXJtaW5hbE5vZGVQYXJzZVRyZWUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhUZXJtaW5hbE5vZGVQYXJzZVRyZWUsIG51bGwsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21UZXJtaW5hbE5vZGVBbmRUb2tlbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tVGVybWluYWxOb2RlQW5kVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ25pZmljYW50VG9rZW4gPSB0ZXJtaW5hbE5vZGUuZ2V0U2lnbmlmaWNhbnRUb2tlbigpLCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSwgdHlwZSA9IHNpZ25pZmljYW50VG9rZW4uZ2V0VHlwZSgpLCB0b2tlbkluZGV4ID0gdG9rZW5zLmluZGV4T2Yoc2lnbmlmaWNhbnRUb2tlbiksIHN0cmluZyA9IFwiXCIuY29uY2F0KGNvbnRlbnQsIFwiW1wiKS5jb25jYXQodHlwZSwgXCJdKFwiKS5jb25jYXQodG9rZW5JbmRleCwgXCIpXCIpLCBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLCB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IF92ZXJ0aWNhbEJyYW5jaC5kZWZhdWx0LmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSwgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSwgdGVybWluYWxOb2RlUGFyc2VUcmVlID0gX3ZlcnRpY2FsQnJhbmNoLmRlZmF1bHQuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oVGVybWluYWxOb2RlUGFyc2VUcmVlLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmFsTm9kZVBhcnNlVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBUZXJtaW5hbE5vZGVQYXJzZVRyZWU7XG59KF92ZXJ0aWNhbEJyYW5jaC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlcm1pbmFsTm9kZVBhcnNlVHJlZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYSnpaVlJ5WldVdmRHVnliV2x1WVd4T2IyUmxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1ZtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1VnWm5KdmJTQmNJaTR2ZG1WeWRHbGpZV3hDY21GdVkyaGNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdWR1Z5YldsdVlXeE9iMlJsVUdGeWMyVlVjbVZsSUdWNGRHVnVaSE1nVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWdlMXh1SUNCemRHRjBhV01nWm5KdmJWUmxjbTFwYm1Gc1RtOWtaVUZ1WkZSdmEyVnVjeWgwWlhKdGFXNWhiRTV2WkdVc0lIUnZhMlZ1Y3lrZ2UxeHVJQ0FnSUdOdmJuTjBJSE5wWjI1cFptbGpZVzUwVkc5clpXNGdQU0IwWlhKdGFXNWhiRTV2WkdVdVoyVjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpZ3BMRnh1SUNBZ0lDQWdJQ0FnSUdOdmJuUmxiblFnUFNCMFpYSnRhVzVoYkU1dlpHVXVaMlYwUTI5dWRHVnVkQ2dwTEZ4dUlDQWdJQ0FnSUNBZ0lIUjVjR1VnUFNCemFXZHVhV1pwWTJGdWRGUnZhMlZ1TG1kbGRGUjVjR1VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQjBiMnRsYmtsdVpHVjRJRDBnZEc5clpXNXpMbWx1WkdWNFQyWW9jMmxuYm1sbWFXTmhiblJVYjJ0bGJpa3NYRzRnSUNBZ0lDQWdJQ0FnYzNSeWFXNW5JRDBnWUNSN1kyOXVkR1Z1ZEgxYkpIdDBlWEJsZlYwb0pIdDBiMnRsYmtsdVpHVjRmU2xnTEZ4dUlDQWdJQ0FnSUNBZ0lITjBjbWx1WjB4bGJtZDBhQ0E5SUhOMGNtbHVaeTVzWlc1bmRHZ3NYRzRnSUNBZ0lDQWdJQ0FnZG1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVlhhV1IwYUNBOUlITjBjbWx1WjB4bGJtZDBhQ3dnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdkbVZ5ZEdsallXeENjbUZ1WTJoUVlYSnpaVlJ5WldVZ1BTQldaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlM1bWNtOXRWMmxrZEdnb2RtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1ZYYVdSMGFDa3NYRzRnSUNBZ0lDQWdJQ0FnZG1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpQTlJSFpsY25ScFkyRnNRbkpoYm1Ob1VHRnljMlZVY21WbExtZGxkRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0b0tTeGNiaUFnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRTV2WkdWUVlYSnpaVlJ5WldVZ1BTQldaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlM1bWNtOXRVM1J5YVc1blFXNWtWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmloVVpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVXNJSE4wY21sdVp5d2dkbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlrN1hHNWNiaUFnSUNCMFpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVXVZWEJ3Wlc1a1ZHOVViM0FvZG1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlIUmxjbTFwYm1Gc1RtOWtaVkJoY25ObFZISmxaVHRjYmlBZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklsUmxjbTFwYm1Gc1RtOWtaVkJoY25ObFZISmxaU0lzSW1aeWIyMVVaWEp0YVc1aGJFNXZaR1ZCYm1SVWIydGxibk1pTENKMFpYSnRhVzVoYkU1dlpHVWlMQ0owYjJ0bGJuTWlMQ0p6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpWjJWMFUybG5ibWxtYVdOaGJuUlViMnRsYmlJc0ltTnZiblJsYm5RaUxDSm5aWFJEYjI1MFpXNTBJaXdpZEhsd1pTSXNJbWRsZEZSNWNHVWlMQ0owYjJ0bGJrbHVaR1Y0SWl3aWFXNWtaWGhQWmlJc0luTjBjbWx1WnlJc0luTjBjbWx1WjB4bGJtZDBhQ0lzSW14bGJtZDBhQ0lzSW5abGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxWMmxrZEdnaUxDSjJaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlNJc0lsWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsSWl3aVpuSnZiVmRwWkhSb0lpd2lkbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlJc0ltZGxkRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0aUxDSjBaWEp0YVc1aGJFNXZaR1ZRWVhKelpWUnlaV1VpTENKbWNtOXRVM1J5YVc1blFXNWtWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlJc0ltRndjR1Z1WkZSdlZHOXdJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSVzlETEVsQlFVRXNaVUZCYTBJc2EwTkJRV3hDTEd0Q1FVRnJRaXhGUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlJuUkVPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVWxsTEVsQlFVRXNRVUZCVFVFc2NVSkJRWEZDTEdsQ1EwcDJReXhCUkVsWk96WkVRVXBtT3p0aFFVbHhRa0VzY1VKQlFYRkNPMjlFUVVveFF6czdPenM3V1VGTFUwTXNSMEZCZVVJc1JVRkJla0pCTERKQ1FVRjVRanRaUlV4c1F5eFBSa3RGTEZOQlFVOUJMSGxDUVVGNVFpeERRVUZEUXl4WlFVRlpMRVZCUVVWRExFMUJRVTBzUlVGQlJUdG5Ra0ZEY2tRc1NVRkJUVU1zWjBKQlFXZENMRWRCUVVkR0xGbEJRVmtzUTBGQlEwY3NiVUpCUVcxQ0xFVkJRVVVzUlVGRGNrUkRMRTlCUVU4c1IwRkJSMG9zV1VGQldTeERRVUZEU3l4VlFVRlZMRVZCUVVVc1JVRkRia05ETEVsQlFVa3NSMEZCUjBvc1owSkJRV2RDTEVOQlFVTkxMRTlCUVU4c1JVRkJSU3hGUVVOcVEwTXNWVUZCVlN4SFFVRkhVQ3hOUVVGTkxFTkJRVU5STEU5QlFVOHNRMEZCUTFBc1owSkJRV2RDTEVOQlFVTXNSVUZETjBOUkxFMUJRVTBzUjBGQlJ5eEJRVUZETEVWQlFVRXNRMEZCWVVvc1RVRkJTU3hEUVVGbVJpeFBRVUZQTEVWQlFVTXNSMEZCUXl4RFFVRlBMRU5CUVVsSkxFMUJRVlVzUTBGQmJrSkdMRWxCUVVrc1JVRkJReXhKUVVGRkxFTkJRV0VzUTBGQlFTeE5RVUZETEVOQlFWcEZMRlZCUVZVc1JVRkJReXhIUVVGRExFTkJRVU1zUlVGRE4wTkhMRmxCUVZrc1IwRkJSMFFzVFVGQlRTeERRVUZEUlN4TlFVRk5MRVZCUXpWQ1F5dzBRa0ZCTkVJc1IwRkJSMFlzV1VGQldTeEZRVU16UTBjc2RVSkJRWFZDTEVkQlFVZERMR1ZCUVhWQ0xGTkJRVU5ETEZOQlFWTXNRMEZCUTBnc05FSkJRVFJDTEVOQlFVTXNSVUZEZWtaSkxITkNRVUZ6UWl4SFFVRkhTQ3gxUWtGQmRVSXNRMEZCUTBrc2VVSkJRWGxDTEVWQlFVVXNSVUZETlVWRExIRkNRVUZ4UWl4SFFVRkhTaXhsUVVGMVFpeFRRVUZEU3l4dFEwRkJiVU1zUTBGQlEzUkNMSEZDUVVGeFFpeEZRVUZGV1N4TlFVRk5MRVZCUVVWUExITkNRVUZ6UWl4RFFVRkRMRUZCUVVNN1owSkJSV3BLUlN4eFFrRkJjVUlzUTBGQlEwVXNWMEZCVnl4RFFVRkRVQ3gxUWtGQmRVSXNRMEZCUXl4RFFVRkRPMmRDUVVVelJDeFBRVUZQU3l4eFFrRkJjVUlzUTBGQlF6dGhRVU01UWpzN1RVRndRa2c3TzBOQmNVSkRMRU5CYWtKclJFb3NaVUZCZFVJc1UwRnBRbnBGTzJ0Q1FXcENiMEpxUWl4eFFrRkJjVUlzUVVGS01VTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF90ZXJtaW5hbE5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJzZVRyZWUvdGVybWluYWxOb2RlXCIpKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxudmFyIFRlcm1pbmFsTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVGVybWluYWxOb2RlKHNpZ25pZmljYW50VG9rZW4pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlcm1pbmFsTm9kZSk7XG4gICAgICAgIHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9IHNpZ25pZmljYW50VG9rZW47XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhUZXJtaW5hbE5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFNpZ25pZmljYW50VG9rZW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaWduaWZpY2FudFRva2VuKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25pZmljYW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRGaXJzdFNpZ25pZmljYW50VG9rZW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdFNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0U2lnbmlmaWNhbnRUb2tlbiA9IHRoaXMuc2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldExhc3RTaWduaWZpY2FudFRva2VuXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFzdFNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RTaWduaWZpY2FudFRva2VuID0gdGhpcy5zaWduaWZpY2FudFRva2VuOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFNpZ25pZmljYW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc05vV2hpdGVzcGFjZU5vZGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc05vV2hpdGVzcGFjZU5vZGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vV2hpdGVzcGFjZU5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9XaGl0ZXNwYWNlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzVGVybWluYWxOb2RlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmFsTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzTm9uVGVybWluYWxOb2RlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vblRlcm1pbmFsTm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRUeXBlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuLmdldFR5cGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldENvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25pZmljYW50VG9rZW4uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2V0U2lnbmlmaWNhbnRUb2tlblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9IHNpZ25pZmljYW50VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1BhcnNlVHJlZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbE5vZGUgPSB0aGlzLCB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBfdGVybWluYWxOb2RlLmRlZmF1bHQuZnJvbVRlcm1pbmFsTm9kZUFuZFRva2Vucyh0ZXJtaW5hbE5vZGUsIHRva2VucyksIHBhcnNlVHJlZSA9IHRlcm1pbmFsTm9kZVBhcnNlVHJlZTsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21TaWduaWZpY2FudFRva2VuXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNpZ25pZmljYW50VG9rZW4oQ2xhc3MsIHNpZ25pZmljYW50VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBDbGFzczsgLy8vXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gVGVybWluYWxOb2RlOyAvLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFRlcm1pbmFsTm9kZTtcbn0oKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlcm1pbmFsTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5dWIyUmxMM1JsY20xcGJtRnNMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4T2IyUmxVR0Z5YzJWVWNtVmxJR1p5YjIwZ1hDSXVMaTl3WVhKelpWUnlaV1V2ZEdWeWJXbHVZV3hPYjJSbFhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGUmxjbTFwYm1Gc1RtOWtaU0I3WEc0Z0lHTnZibk4wY25WamRHOXlLSE5wWjI1cFptbGpZVzUwVkc5clpXNHBJSHRjYmlBZ0lDQjBhR2x6TG5OcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCemFXZHVhV1pwWTJGdWRGUnZhMlZ1TzF4dUlDQjlYRzVjYmlBZ1oyVjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpZ3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeTV6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVPMXh1SUNCOVhHNWNiaUFnWjJWMFJtbHljM1JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVLQ2tnZTF4dUlDQWdJR052Ym5OMElHWnBjbk4wVTJsbmJtbG1hV05oYm5SVWIydGxiaUE5SUhSb2FYTXVjMmxuYm1sbWFXTmhiblJVYjJ0bGJqc2dJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJR1pwY25OMFUybG5ibWxtYVdOaGJuUlViMnRsYmp0Y2JpQWdmVnh1WEc0Z0lHZGxkRXhoYzNSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1S0NrZ2UxeHVJQ0FnSUdOdmJuTjBJR3hoYzNSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SUQwZ2RHaHBjeTV6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVPeUFnTHk4dlhHNWNiaUFnSUNCeVpYUjFjbTRnYkdGemRGTnBaMjVwWm1sallXNTBWRzlyWlc0N1hHNGdJSDFjYmx4dUlDQnBjMDV2VjJocGRHVnpjR0ZqWlU1dlpHVW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2JtOVhhR2wwWlhOd1lXTmxUbTlrWlNBOUlHWmhiSE5sTzF4dVhHNGdJQ0FnY21WMGRYSnVJRzV2VjJocGRHVnpjR0ZqWlU1dlpHVTdYRzRnSUgxY2JseHVJQ0JwYzFSbGNtMXBibUZzVG05a1pTZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCMFpYSnRhVzVoYkU1dlpHVWdQU0IwY25WbE8xeHVJQ0FnSUZ4dUlDQWdJSEpsZEhWeWJpQjBaWEp0YVc1aGJFNXZaR1U3WEc0Z0lIMWNibHh1SUNCcGMwNXZibFJsY20xcGJtRnNUbTlrWlNncElIdGNiaUFnSUNCamIyNXpkQ0J1YjI1VVpYSnRhVzVoYkU1dlpHVWdQU0JtWVd4elpUdGNibHh1SUNBZ0lISmxkSFZ5YmlCdWIyNVVaWEp0YVc1aGJFNXZaR1U3WEc0Z0lIMWNibHh1SUNCblpYUlVlWEJsS0NrZ2V5QnlaWFIxY200Z2RHaHBjeTV6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVMbWRsZEZSNWNHVW9LVHNnZlZ4dVhHNGdJR2RsZEVOdmJuUmxiblFvS1NCN0lISmxkSFZ5YmlCMGFHbHpMbk5wWjI1cFptbGpZVzUwVkc5clpXNHVaMlYwUTI5dWRHVnVkQ2dwT3lCOVhHNWNiaUFnYzJWMFUybG5ibWxtYVdOaGJuUlViMnRsYmloemFXZHVhV1pwWTJGdWRGUnZhMlZ1S1NCN1hHNGdJQ0FnZEdocGN5NXphV2R1YVdacFkyRnVkRlJ2YTJWdUlEMGdjMmxuYm1sbWFXTmhiblJVYjJ0bGJqdGNiaUFnZlZ4dVhHNGdJR0Z6VUdGeWMyVlVjbVZsS0hSdmEyVnVjeWtnZTF4dUlDQWdJR052Ym5OMElIUmxjbTFwYm1Gc1RtOWtaU0E5SUhSb2FYTXNJQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQjBaWEp0YVc1aGJFNXZaR1ZRWVhKelpWUnlaV1VnUFNCVVpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVXVabkp2YlZSbGNtMXBibUZzVG05a1pVRnVaRlJ2YTJWdWN5aDBaWEp0YVc1aGJFNXZaR1VzSUhSdmEyVnVjeWtzWEc0Z0lDQWdJQ0FnSUNBZ2NHRnljMlZVY21WbElEMGdkR1Z5YldsdVlXeE9iMlJsVUdGeWMyVlVjbVZsT3lBZ0x5OHZYRzVjYmlBZ0lDQnlaWFIxY200Z2NHRnljMlZVY21WbE8xeHVJQ0I5WEc1Y2JpQWdjM1JoZEdsaklHWnliMjFUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVLRU5zWVhOekxDQnphV2R1YVdacFkyRnVkRlJ2YTJWdUtTQjdYRzRnSUNBZ2FXWWdLSE5wWjI1cFptbGpZVzUwVkc5clpXNGdQVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUNBZ2MybG5ibWxtYVdOaGJuUlViMnRsYmlBOUlFTnNZWE56T3lBdkx5OWNiaUFnSUNBZ0lFTnNZWE56SUQwZ1ZHVnliV2x1WVd4T2IyUmxPeUF2THk5Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JqYjI1emRDQjBaWEp0YVc1aGJFNXZaR1VnUFNCdVpYY2dRMnhoYzNNb2MybG5ibWxtYVdOaGJuUlViMnRsYmlrN1hHNGdJQ0FnWEc0Z0lDQWdjbVYwZFhKdUlIUmxjbTFwYm1Gc1RtOWtaVHRjYmlBZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklsUmxjbTFwYm1Gc1RtOWtaU0lzSW5OcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKblpYUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2laMlYwUm1seWMzUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2labWx5YzNSVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aVoyVjBUR0Z6ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRpTENKc1lYTjBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbWx6VG05WGFHbDBaWE53WVdObFRtOWtaU0lzSW01dlYyaHBkR1Z6Y0dGalpVNXZaR1VpTENKcGMxUmxjbTFwYm1Gc1RtOWtaU0lzSW5SbGNtMXBibUZzVG05a1pTSXNJbWx6VG05dVZHVnliV2x1WVd4T2IyUmxJaXdpYm05dVZHVnliV2x1WVd4T2IyUmxJaXdpWjJWMFZIbHdaU0lzSW1kbGRFTnZiblJsYm5RaUxDSnpaWFJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpWVhOUVlYSnpaVlJ5WldVaUxDSjBiMnRsYm5NaUxDSjBaWEp0YVc1aGJFNXZaR1ZRWVhKelpWUnlaV1VpTENKVVpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVWlMQ0ptY205dFZHVnliV2x1WVd4T2IyUmxRVzVrVkc5clpXNXpJaXdpY0dGeWMyVlVjbVZsSWl3aVpuSnZiVk5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0pEYkdGemN5SXNJblZ1WkdWbWFXNWxaQ0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVZyUXl4SlFVRkJMR0ZCUVRKQ0xHdERRVUV6UWl3eVFrRkJNa0lzUlVGQlFUczdPenM3T3pzN096aEVRVVkzUkR0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN096czdRVUZKWlN4SlFVRkJMRUZCUVUxQkxGbEJRVmtzYVVKRFNqbENMRUZFU1ZrN1lVRkJUVUVzV1VGQldTeERRVU51UWtNc1owSkJRV2RDT3pKRFFVdzVRanRSUVUxSkxFbEJRVWtzUTBGQlEwRXNaMEpCUVdkQ0xFZEJRVWRCTEdkQ1FVRm5RaXhEUVVGRE96czdPMWxCUnpORFF5eEhRVUZ0UWl4RlFVRnVRa0VzY1VKQlFXMUNPMWxGVkhKQ0xFOUdVMFZCTEZOQlFVRkJMRzFDUVVGdFFpeEhRVUZITzJkQ1FVTndRaXhQUVVGUExFbEJRVWtzUTBGQlEwUXNaMEpCUVdkQ0xFTkJRVU03WVVGRE9VSTdPenRaUVVWRVJTeEhRVUYzUWl4RlFVRjRRa0VzTUVKQlFYZENPMWxGWWpGQ0xFOUdZVVZCTEZOQlFVRkJMSGRDUVVGM1FpeEhRVUZITzJkQ1FVTjZRaXhKUVVGTlF5eHhRa0ZCY1VJc1IwRkJSeXhKUVVGSkxFTkJRVU5JTEdkQ1FVRm5RaXhCUVVGRExFVkJRVVVzUjBGQlJ6dG5Ra0ZGZWtRc1QwRkJUMGNzY1VKQlFYRkNMRU5CUVVNN1lVRkRPVUk3T3p0WlFVVkVReXhIUVVGMVFpeEZRVUYyUWtFc2VVSkJRWFZDTzFsRmJrSjZRaXhQUm0xQ1JVRXNVMEZCUVVFc2RVSkJRWFZDTEVkQlFVYzdaMEpCUTNoQ0xFbEJRVTFETEc5Q1FVRnZRaXhIUVVGSExFbEJRVWtzUTBGQlEwd3NaMEpCUVdkQ0xFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVjRSQ3hQUVVGUFN5eHZRa0ZCYjBJc1EwRkJRenRoUVVNM1FqczdPMWxCUlVSRExFZEJRV3RDTEVWQlFXeENRU3h2UWtGQmEwSTdXVVY2UW5CQ0xFOUdlVUpGUVN4VFFVRkJRU3hyUWtGQmEwSXNSMEZCUnp0blFrRkRia0lzU1VGQlRVTXNaMEpCUVdkQ0xFZEJRVWNzUzBGQlN5eEJRVUZETzJkQ1FVVXZRaXhQUVVGUFFTeG5Ra0ZCWjBJc1EwRkJRenRoUVVONlFqczdPMWxCUlVSRExFZEJRV01zUlVGQlpFRXNaMEpCUVdNN1dVVXZRbWhDTEU5R0swSkZRU3hUUVVGQlFTeGpRVUZqTEVkQlFVYzdaMEpCUTJZc1NVRkJUVU1zV1VGQldTeEhRVUZITEVsQlFVa3NRVUZCUXp0blFrRkZNVUlzVDBGQlQwRXNXVUZCV1N4RFFVRkRPMkZCUTNKQ096czdXVUZGUkVNc1IwRkJhVUlzUlVGQmFrSkJMRzFDUVVGcFFqdFpSWEpEYmtJc1QwWnhRMFZCTEZOQlFVRkJMR2xDUVVGcFFpeEhRVUZITzJkQ1FVTnNRaXhKUVVGTlF5eGxRVUZsTEVkQlFVY3NTMEZCU3l4QlFVRkRPMmRDUVVVNVFpeFBRVUZQUVN4bFFVRmxMRU5CUVVNN1lVRkRlRUk3T3p0WlFVVkVReXhIUVVGUExFVkJRVkJCTEZOQlFVODdXVVV6UTFRc1QwWXlRMFZCTEZOQlFVRkJMRTlCUVU4c1IwRkJSenRuUWtGQlJTeFBRVUZQTEVsQlFVa3NRMEZCUTFvc1owSkJRV2RDTEVOQlFVTlpMRTlCUVU4c1JVRkJSU3hEUVVGRE8yRkJRVVU3T3p0WlFVVnlSRU1zUjBGQlZTeEZRVUZXUVN4WlFVRlZPMWxGTjBOYUxFOUdOa05GUVN4VFFVRkJRU3hWUVVGVkxFZEJRVWM3WjBKQlFVVXNUMEZCVHl4SlFVRkpMRU5CUVVOaUxHZENRVUZuUWl4RFFVRkRZU3hWUVVGVkxFVkJRVVVzUTBGQlF6dGhRVUZGT3pzN1dVRkZNMFJETEVkQlFXMUNMRVZCUVc1Q1FTeHhRa0ZCYlVJN1dVVXZRM0pDTEU5R0swTkZRU3hUUVVGQlFTeHRRa0ZCYlVJc1EwRkJRMlFzWjBKQlFXZENMRVZCUVVVN1owSkJRM0JETEVsQlFVa3NRMEZCUTBFc1owSkJRV2RDTEVkQlFVZEJMR2RDUVVGblFpeERRVUZETzJGQlF6RkRPenM3V1VGRlJHVXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZia1JpTEU5R2JVUkZRU3hUUVVGQlFTeFhRVUZYTEVOQlFVTkRMRTFCUVUwc1JVRkJSVHRuUWtGRGJFSXNTVUZCVFZBc1dVRkJXU3hIUVVGSExFbEJRVWtzUlVGRGJrSlJMSEZDUVVGeFFpeEhRVUZIUXl4aFFVRnhRaXhUUVVGRFF5eDVRa0ZCZVVJc1EwRkJRMVlzV1VGQldTeEZRVUZGVHl4TlFVRk5MRU5CUVVNc1JVRkROMFpKTEZOQlFWTXNSMEZCUjBnc2NVSkJRWEZDTEVGQlFVTXNSVUZCUlN4SFFVRkhPMmRDUVVVM1F5eFBRVUZQUnl4VFFVRlRMRU5CUVVNN1lVRkRiRUk3T3pzN1dVRkZUVU1zUjBGQmIwSXNSVUZCY0VKQkxITkNRVUZ2UWp0WlJUTkVOMElzVDBZeVJFVXNVMEZCVDBFc2IwSkJRVzlDTEVOQlFVTkRMRXRCUVVzc1JVRkJSWFJDTEdkQ1FVRm5RaXhGUVVGRk8yZENRVU51UkN4SlFVRkpRU3huUWtGQlowSXNTMEZCUzNWQ0xGTkJRVk1zUlVGQlJUdHZRa0ZEYkVOMlFpeG5Ra0ZCWjBJc1IwRkJSM05DTEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjN2IwSkJRemRDUVN4TFFVRkxMRWRCUVVkMlFpeFpRVUZaTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmxDUVVNeFFqdG5Ra0ZGUkN4SlFVRk5WU3haUVVGWkxFZEJRVWNzU1VGQlNXRXNTMEZCU3l4RFFVRkRkRUlzWjBKQlFXZENMRU5CUVVNc1FVRkJRenRuUWtGRmFrUXNUMEZCVDFNc1dVRkJXU3hEUVVGRE8yRkJRM0pDT3p0TlFYQkZTRHM3UTBGeFJVTXNSVUZCUVR0clFrRnFSVzlDVml4WlFVRlpMRUZCU21wREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3Rlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiKSk7XG52YXIgX3Rlcm1pbmFsMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvdGVybWluYWxcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKXtcbiAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihUZXJtaW5hbFBhcnQpIHtcbiAgICBfaW5oZXJpdHMoU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LCBUZXJtaW5hbFBhcnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KTtcbiAgICBmdW5jdGlvbiBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCk7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgX3RoaXMuc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBzaWduaWZpY2FudFRva2VuVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwYXJzZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkO1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLCBuZXh0U2lnbmlmaWNhbnRUb2tlbiA9IHN0YXRlLmdldE5leHRTaWduaWZpY2FudFRva2VuKCksIHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudFRva2VuVHlwZSA9PT0gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxOb2RlID0gX3Rlcm1pbmFsMS5kZWZhdWx0LmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHRlcm1pbmFsTm9kZSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2godGVybWluYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBcIltcIi5jb25jYXQodGhpcy5zaWduaWZpY2FudFRva2VuVHlwZSwgXCJdXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihTaWduaWZpY2FudFRva2VuVHlwZVBhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCwgdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0O1xufShfdGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl3WVhKMEwzUmxjbTFwYm1Gc0wzTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4UVlYSjBJR1p5YjIwZ1hDSXVMaTh1TGk5d1lYSjBMM1JsY20xcGJtRnNYQ0k3WEc1cGJYQnZjblFnVkdWeWJXbHVZV3hPYjJSbElHWnliMjBnWENJdUxpOHVMaTl1YjJSbEwzUmxjbTFwYm1Gc1hDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxVR0Z5ZENCbGVIUmxibVJ6SUZSbGNtMXBibUZzVUdGeWRDQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtITnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxLU0I3WEc0Z0lDQWdjM1Z3WlhJb0tUdGNiaUFnSUNCY2JpQWdJQ0IwYUdsekxuTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxJRDBnYzJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dVN1hHNGdJSDFjYmx4dUlDQndZWEp6WlNodWIyUmxjeXdnYzNSaGRHVXNJR05oYkd4aVlXTnJLU0I3WEc0Z0lDQWdiR1YwSUhCaGNuTmxaRHRjYmx4dUlDQWdJR3hsZENCMFpYSnRhVzVoYkU1dlpHVWdQU0J1ZFd4c08xeHVJQ0FnSUZ4dUlDQWdJR052Ym5OMElITmhkbVZrU1c1a1pYZ2dQU0J6ZEdGMFpTNW5aWFJUWVhabFpFbHVaR1Y0S0Nrc1hHNWNkRngwSUNBZ0lDQWdibVY0ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCemRHRjBaUzVuWlhST1pYaDBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpZ3BMRnh1WEhSY2RGeDBYSFJjZEhOcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCdVpYaDBVMmxuYm1sbWFXTmhiblJVYjJ0bGJqc2dMeTh2WEc1Y2JpQWdJQ0JwWmlBb2MybG5ibWxtYVdOaGJuUlViMnRsYmlBaFBUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ1kyOXVjM1FnYzJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dVZ1BTQnphV2R1YVdacFkyRnVkRlJ2YTJWdUxtZGxkRlI1Y0dVb0tUdGNibHh1SUNBZ0lDQWdhV1lnS0hOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbElEMDlQU0IwYUdsekxuTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxLU0I3WEc0Z0lDQWdJQ0FnSUhSbGNtMXBibUZzVG05a1pTQTlJRlJsY20xcGJtRnNUbTlrWlM1bWNtOXRVMmxuYm1sbWFXTmhiblJVYjJ0bGJpaHphV2R1YVdacFkyRnVkRlJ2YTJWdUtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNCd1lYSnpaV1FnUFNBb2RHVnliV2x1WVd4T2IyUmxJQ0U5UFNCdWRXeHNLVHRjYmx4dUlDQWdJR2xtSUNod1lYSnpaV1FwSUh0Y2JpQWdJQ0FnSUc1dlpHVnpMbkIxYzJnb2RHVnliV2x1WVd4T2IyUmxLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tHTmhiR3hpWVdOcklDRTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQWdJSEJoY25ObFpDQTlJR05oYkd4aVlXTnJLQ2s3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0Z3WVhKelpXUXBJSHRjYmlBZ0lDQWdJQ0FnSUNCdWIyUmxjeTV3YjNBb0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2doY0dGeWMyVmtLU0I3WEc0Z0lDQWdJQ0J6ZEdGMFpTNWlZV05yZEhKaFkyc29jMkYyWldSSmJtUmxlQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlIQmhjbk5sWkR0Y2JpQWdmVnh1WEc0Z0lHRnpVM1J5YVc1bktDa2dlMXh1SUNBZ0lHTnZibk4wSUhOMGNtbHVaeUE5SUdCYkpIdDBhR2x6TG5OcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbGZWMWdPMXh1SUNBZ0lGeHVJQ0FnSUhKbGRIVnliaUJ6ZEhKcGJtYzdYRzRnSUgxY2JseHVJQ0JqYkc5dVpTZ3BJSHNnY21WMGRYSnVJSE4xY0dWeUxtTnNiMjVsS0ZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFVHRnlkQ3dnZEdocGN5NXphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaU2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pWQmhjblFpTENKemFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pTSXNJbkJoY25ObElpd2libTlrWlhNaUxDSnpkR0YwWlNJc0ltTmhiR3hpWVdOcklpd2ljR0Z5YzJWa0lpd2lkR1Z5YldsdVlXeE9iMlJsSWl3aWMyRjJaV1JKYm1SbGVDSXNJbWRsZEZOaGRtVmtTVzVrWlhnaUxDSnVaWGgwVTJsbmJtbG1hV05oYm5SVWIydGxiaUlzSW1kbGRFNWxlSFJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpYzJsbmJtbG1hV05oYm5SVWIydGxiaUlzSW1kbGRGUjVjR1VpTENKVVpYSnRhVzVoYkU1dlpHVWlMQ0ptY205dFUybG5ibWxtYVdOaGJuUlViMnRsYmlJc0luQjFjMmdpTENKd2IzQWlMQ0ppWVdOcmRISmhZMnNpTENKaGMxTjBjbWx1WnlJc0luTjBjbWx1WnlJc0ltTnNiMjVsSWl3aVZHVnliV2x1WVd4UVlYSjBJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSWGxDTEVsQlFVRXNVMEZCY1VJc2EwTkJRWEpDTEhGQ1FVRnhRaXhGUVVGQk8wRkJRM0pDTEVsQlFVRXNWVUZCY1VJc2EwTkJRWEpDTEhGQ1FVRnhRaXhGUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlNEbERPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenN3UWtGQlFUczdPenM3T3pzN096dFRRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3p0M1EwRkJRVHM3T3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZMWlN4SlFVRkJMRUZCUVUxQkxIZENRVUYzUWl4cFFrTk1NVU1zUVVSTFdUdHhSRUZNWmpzN1lVRkxjVUpCTEhkQ1FVRjNRaXhEUVVNdlFrTXNiMEpCUVc5Q08zVkVRVTVzUXpzN2FVTkZRVUVzUTBaUFdUdFJRVVZTTEUxQlFVdEJMRzlDUVVGdlFpeEhRVUZIUVN4dlFrRkJiMElzUTBGQlF6czdPenM3V1VGSGJrUkRMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSVnBRTEU5R1dVVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwTXNTMEZCU3l4RlFVRkZReXhMUVVGTExFVkJRVVZETEZGQlFWRXNSVUZCUlR0blFrRkROVUlzU1VGQlNVTXNUVUZCVFN4QlFVRkRPMmRDUVVWWUxFbEJRVWxETEZsQlFWa3NSMEZCUnl4SlFVRkpMRUZCUVVNN1owSkJSWGhDTEVsQlFVMURMRlZCUVZVc1IwRkJSMG9zUzBGQlN5eERRVUZEU3l4aFFVRmhMRVZCUVVVc1JVRkRjRU5ETEc5Q1FVRnZRaXhIUVVGSFRpeExRVUZMTEVOQlFVTlBMSFZDUVVGMVFpeEZRVUZGTEVWQlEzcEVReXhuUWtGQlowSXNSMEZCUjBZc2IwSkJRVzlDTEVGQlFVTXNSVUZCUXl4SFFVRkhPMmRDUVVVM1F5eEpRVUZKUlN4blFrRkJaMElzUzBGQlN5eEpRVUZKTEVWQlFVVTdiMEpCUXpkQ0xFbEJRVTFZTEc5Q1FVRnZRaXhIUVVGSFZ5eG5Ra0ZCWjBJc1EwRkJRME1zVDBGQlR5eEZRVUZGTEVGQlFVTTdiMEpCUlhoRUxFbEJRVWxhTEc5Q1FVRnZRaXhMUVVGTExFbEJRVWtzUTBGQlEwRXNiMEpCUVc5Q0xFVkJRVVU3ZDBKQlEzUkVUU3haUVVGWkxFZEJRVWRQTEZWQlFWa3NVMEZCUTBNc2IwSkJRVzlDTEVOQlFVTklMR2RDUVVGblFpeERRVUZETEVOQlFVTTdjVUpCUTNCRk8ybENRVU5HTzJkQ1FVVkVUaXhOUVVGTkxFZEJRVWxETEZsQlFWa3NTMEZCU3l4SlFVRkpMRUZCUVVNc1EwRkJRenRuUWtGRmFrTXNTVUZCU1VRc1RVRkJUU3hGUVVGRk8yOUNRVU5XU0N4TFFVRkxMRU5CUVVOaExFbEJRVWtzUTBGQlExUXNXVUZCV1N4RFFVRkRMRU5CUVVNN2IwSkJSWHBDTEVsQlFVbEdMRkZCUVZFc1MwRkJTeXhKUVVGSkxFVkJRVVU3ZDBKQlEzSkNReXhOUVVGTkxFZEJRVWRFTEZGQlFWRXNSVUZCUlN4RFFVRkRPM2RDUVVWd1FpeEpRVUZKTEVOQlFVTkRMRTFCUVUwc1JVRkJSVHMwUWtGRFdFZ3NTMEZCU3l4RFFVRkRZeXhIUVVGSExFVkJRVVVzUTBGQlF6dDVRa0ZEWWp0eFFrRkRSanRwUWtGRFJqdG5Ra0ZGUkN4SlFVRkpMRU5CUVVOWUxFMUJRVTBzUlVGQlJUdHZRa0ZEV0VZc1MwRkJTeXhEUVVGRFl5eFRRVUZUTEVOQlFVTldMRlZCUVZVc1EwRkJReXhEUVVGRE8ybENRVU0zUWp0blFrRkZSQ3hQUVVGUFJpeE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJoTEVkQlFWRXNSVUZCVWtFc1ZVRkJVVHRaUld4RVZpeFBSbXRFUlVFc1UwRkJRVUVzVVVGQlVTeEhRVUZITzJkQ1FVTlVMRWxCUVUxRExFMUJRVTBzUjBGQlJ5eEJRVUZETEVkQlFVTXNRMEZCTkVJc1RVRkJReXhEUVVFelFpeEpRVUZKTEVOQlFVTnVRaXh2UWtGQmIwSXNSVUZCUXl4SFFVRkRMRU5CUVVNc1FVRkJRenRuUWtGRmFFUXNUMEZCVDIxQ0xFMUJRVTBzUTBGQlF6dGhRVU5tT3pzN1dVRkZSRU1zUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxGZUVSUUxFOUdkMFJGUVN4VFFVRkJRU3hMUVVGTExFZEJRVWM3WjBKQlFVVXNUMEZCVHl4eFFrRnVSRVZ5UWl4M1FrRkJkMElzWVVGdFJIQkNjVUlzVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBja0lzZDBKQlFYZENMRVZCUVVVc1NVRkJTU3hEUVVGRFF5eHZRa0ZCYjBJc1JVRkJSVHRoUVVGRk96dE5RWGhFZEVZN08wTkJlVVJETEVOQmNFUnhSSEZDTEZOQlFWa3NVMEZ2UkdwRk8ydENRWEJFYjBKMFFpeDNRa0ZCZDBJc1FVRk1OME1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfb2NjYW1MZXhlcnMgPSByZXF1aXJlKFwib2NjYW0tbGV4ZXJzXCIpO1xudmFyIF9kZWZpbml0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvblwiKSk7XG52YXIgX3NpZ25pZmljYW50VG9rZW5UeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZVwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgbmFtZVR5cGUgPSBfb2NjYW1MZXhlcnMudHlwZXMubmFtZVR5cGU7XG52YXIgTmFtZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoTmFtZURlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTmFtZURlZmluaXRpb24pO1xuICAgIGZ1bmN0aW9uIE5hbWVEZWZpbml0aW9uKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmFtZURlZmluaXRpb24pO1xuICAgICAgICB2YXIgbmFtZVNpZ25pZmljYW50VG9rZW5UeXBlID0gbmFtZVR5cGUsIG5hbWVTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBuZXcgX3NpZ25pZmljYW50VG9rZW5UeXBlLmRlZmF1bHQobmFtZVNpZ25pZmljYW50VG9rZW5UeXBlKSwgcGFydHMgPSBbXG4gICAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBOYW1lRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwyNWhiV1V1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJSFI1Y0dWeklIMGdabkp2YlNCY0ltOWpZMkZ0TFd4bGVHVnljMXdpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZibHdpTzF4dWFXMXdiM0owSUZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFVHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOXphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVndpTzF4dVhHNWpiMjV6ZENCN0lHNWhiV1ZVZVhCbElIMGdQU0IwZVhCbGN6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1RtRnRaVVJsWm1sdWFYUnBiMjRnWlhoMFpXNWtjeUJFWldacGJtbDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdibUZ0WlZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbElEMGdibUZ0WlZSNWNHVXNJQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnVZVzFsVTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dWUVlYSjBJRDBnYm1WM0lGTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxVR0Z5ZENodVlXMWxVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1VwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYm1GdFpWTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxVR0Z5ZEZ4dUlDQWdJQ0FnSUNBZ0lGMDdYRzVjYmlBZ0lDQnpkWEJsY2lod1lYSjBjeWxjYmlBZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYkltNWhiV1ZVZVhCbElpd2lkSGx3WlhNaUxDSk9ZVzFsUkdWbWFXNXBkR2x2YmlJc0ltNWhiV1ZUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlNJc0ltNWhiV1ZUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZCaGNuUWlMQ0pUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZCaGNuUWlMQ0p3WVhKMGN5SXNJa1JsWm1sdWFYUnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGYzBJc1NVRkJRU3haUVVGakxGZEJRV1FzWTBGQll5eERRVUZCTzBGQlJXSXNTVUZCUVN4WFFVRmxMR3REUVVGbUxHVkJRV1VzUlVGQlFUdEJRVU5FTEVsQlFVRXNjVUpCUVhWRExHdERRVUYyUXl4MVEwRkJkVU1zUlVGQlFUczdPenM3T3pzN096czdPenM3TzB0QlREVkZPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVDBFc1NVRkJUU3hCUVVGRlFTeFJRVUZSTEVkQlFVdERMRmxCUVVzc1QwRkJiRUpFTEZGQlFWRXNRVUZCVlN4QlFVRkRPMEZCUlZvc1NVRkJRU3hCUVVGTlJTeGpRVUZqTEdsQ1ExUm9ReXhCUkZOWk8zbERRVlJtT3p0aFFWTnhRa0VzWTBGQll6czJRMEZVYmtNN1VVRlhTU3hKUVVGTlF5eDNRa0ZCZDBJc1IwRkJSMGdzVVVGQlVTeEZRVU51UTBrc05FSkJRVFJDTEVkQlFVY3NTVUZCU1VNc2NVSkJRWGRDTEZOQlFVTkdMSGRDUVVGM1FpeERRVUZETEVWQlEzSkdSeXhMUVVGTExFZEJRVWM3V1VGRFRrWXNORUpCUVRSQ08xTkJRemRDTEVGQlFVTTdhVU5CUlVaRkxFdEJRVXM3T3p0RFFVVmtMRU5CVmpKRFF5eFhRVUZWTEZOQlZYSkVPMnRDUVZadlFrd3NZMEZCWXl4QlFWUnVReUo5IiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgTmFtZVJ1bGVOYW1lID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgUGFydFJ1bGVOYW1lID0gXCJwYXJ0XCI7XG5leHBvcnQgY29uc3QgUnVsZVJ1bGVOYW1lID0gXCJydWxlXCI7XG5leHBvcnQgY29uc3QgRXJyb3JSdWxlTmFtZSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBSdWxlTmFtZVJ1bGVOYW1lID0gXCJydWxlTmFtZVwiO1xuZXhwb3J0IGNvbnN0IERvY3VtZW50UnVsZU5hbWUgPSBcImRvY3VtZW50XCI7XG5leHBvcnQgY29uc3QgV2lsZGNhcmRSdWxlTmFtZSA9IFwid2lsZGNhcmRcIjtcbmV4cG9ydCBjb25zdCBFbmRPZkxpbmVSdWxlTmFtZSA9IFwiZW5kT2ZMaW5lXCI7XG5leHBvcnQgY29uc3QgRGVmaW5pdGlvblJ1bGVOYW1lID0gXCJkZWZpbml0aW9uXCI7XG5leHBvcnQgY29uc3QgUXVhbnRpZmllclJ1bGVOYW1lID0gXCJxdWFudGlmaWVyXCI7XG5leHBvcnQgY29uc3QgRGVmaW5pdGlvbnNSdWxlTmFtZSA9IFwiZGVmaW5pdGlvbnNcIjtcbmV4cG9ydCBjb25zdCBUZXJtaW5hbFBhcnRSdWxlTmFtZSA9IFwidGVybWluYWxQYXJ0XCI7XG5leHBvcnQgY29uc3QgQ2hvaWNlT2ZQYXJ0c1J1bGVOYW1lID0gXCJjaG9pY2VPZlBhcnRzXCI7XG5leHBvcnQgY29uc3QgVGVybWluYWxTeW1ib2xSdWxlTmFtZSA9IFwidGVybWluYWxTeW1ib2xcIjtcbmV4cG9ydCBjb25zdCBOb25UZXJtaW5hbFBhcnRSdWxlTmFtZSA9IFwibm9uVGVybWluYWxQYXJ0XCI7XG5leHBvcnQgY29uc3QgU2VxdWVuY2VPZlBhcnRzUnVsZU5hbWUgPSBcInNlcXVlbmNlT2ZQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IE5vV2hpdGVzcGFjZVBhcnRSdWxlTmFtZSA9IFwibm9XaGl0ZXNwYWNlUGFydFwiO1xuZXhwb3J0IGNvbnN0IExvb2tBaGVhZE1vZGlmaWVyUnVsZU5hbWUgPSBcImxvb2tBaGVhZE1vZGlmaWVyXCI7XG5leHBvcnQgY29uc3QgQW1iaWd1b3VzTW9kaWZpZXJSdWxlTmFtZSA9IFwiQW1iaWd1b3VzTW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBSZWd1bGFyRXhwcmVzc2lvblJ1bGVOYW1lID0gXCJyZWd1bGFyRXhwcmVzc2lvblwiO1xuZXhwb3J0IGNvbnN0IE9wdGlvbmFsUXVhbnRpZmllclJ1bGVOYW1lID0gXCJvcHRpb25hbFF1YW50aWZpZXJcIjtcbmV4cG9ydCBjb25zdCBPbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWUgPSBcIm9uZU9yTW9yZVF1YW50aWZpZXJcIjtcbmV4cG9ydCBjb25zdCBaZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lID0gXCJ6ZXJvT3JNb3JlUXVhbnRpZmllclwiO1xuZXhwb3J0IGNvbnN0IFNpZ25pZmljYW50VG9rZW5UeXBlUnVsZU5hbWUgPSBcInNpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9uYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9kZS9ibmYvbmFtZVwiKSk7XG52YXIgX25hbWUxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9uYW1lXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBOYW1lUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhOYW1lUnVsZSwgUnVsZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOYW1lUnVsZSk7XG4gICAgZnVuY3Rpb24gTmFtZVJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOYW1lUnVsZSk7XG4gICAgICAgIHZhciBuYW1lRGVmaW5pdGlvbiA9IG5ldyBfbmFtZTEuZGVmYXVsdCgpLCBuYW1lID0gX3J1bGVOYW1lcy5OYW1lUnVsZU5hbWUsIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG5hbWVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfbmFtZS5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBOYW1lUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMMjVoYldVdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JTZFd4bElHWnliMjBnWENJdUxpOXlkV3hsWENJN1hHNXBiWEJ2Y25RZ1RtRnRaVUpPUms1dlpHVWdabkp2YlNCY0lpNHVMMjV2WkdVdlltNW1MMjVoYldWY0lqdGNibWx0Y0c5eWRDQk9ZVzFsUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dlpHVm1hVzVwZEdsdmJpOXVZVzFsWENJN1hHNWNibWx0Y0c5eWRDQjdJRTVoYldWU2RXeGxUbUZ0WlNCOUlHWnliMjBnWENJdUxpOXlkV3hsVG1GdFpYTmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdUbUZ0WlZKMWJHVWdaWGgwWlc1a2N5QlNkV3hsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdibUZ0WlVSbFptbHVhWFJwYjI0Z1BTQnVaWGNnVG1GdFpVUmxabWx1YVhScGIyNG9LU3hjYmlBZ0lDQWdJQ0FnSUNCdVlXMWxJRDBnVG1GdFpWSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJR0Z0WW1sbmRXOTFjeUE5SUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0FnSUdSbFptbHVhWFJwYjI1eklEMGdXMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JtRnRaVVJsWm1sdWFYUnBiMjVjYmlBZ0lDQWdJQ0FnSUNCZExGeHVJQ0FnSUNBZ0lDQWdJRTV2WkdVZ1BTQk9ZVzFsUWs1R1RtOWtaVHRjYmlBZ0lDQmNiaUFnSUNCemRYQmxjaWh1WVcxbExDQmhiV0pwWjNWdmRYTXNJR1JsWm1sdWFYUnBiMjV6TENCT2IyUmxLVnh1SUNCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVRtRnRaVkoxYkdVaUxDSnVZVzFsUkdWbWFXNXBkR2x2YmlJc0lrNWhiV1ZFWldacGJtbDBhVzl1SWl3aWJtRnRaU0lzSWs1aGJXVlNkV3hsVG1GdFpTSXNJbUZ0WW1sbmRXOTFjeUlzSW1SbFptbHVhWFJwYjI1eklpd2lUbTlrWlNJc0lrNWhiV1ZDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBZc1NVRkJRU3hMUVVGclFpeHJRMEZCYkVJc2EwSkJRV3RDTEVWQlFVRTdRVUZEWml4SlFVRkJMRTFCUVc5Q0xHdERRVUZ3UWl4dlFrRkJiMElzUlVGQlFUdEJRVVZzUWl4SlFVRkJMRlZCUVdNc1YwRkJaQ3hqUVVGakxFTkJRVUU3T3pzN096czdPenM3T3pzN096dExRVTR6UXpzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFWRmxMRWxCUVVFc1FVRkJUVUVzVVVGQlVTeHBRa05TTVVJc1FVUlJXVHMyUWtGU1pqczdZVUZSY1VKQkxGRkJRVkU3ZFVOQlVqZENPMUZCVlVrc1NVRkJUVU1zWTBGQll5eEhRVUZITEVsQlFVbERMRTFCUVdNc1ZVRkJSU3hGUVVOeVEwTXNTVUZCU1N4SFFVRkhReXhWUVVGWkxHRkJRVUVzUlVGRGJrSkRMRk5CUVZNc1IwRkJSeXhMUVVGTExFVkJRMnBDUXl4WFFVRlhMRWRCUVVjN1dVRkRXa3dzWTBGQll6dFRRVU5tTEVWQlEwUk5MRWxCUVVrc1IwRkJSME1zUzBGQlZ5eFJRVUZCTEVGQlFVTTdhVU5CUlc1Q1RDeEpRVUZKTEVWQlFVVkZMRk5CUVZNc1JVRkJSVU1zVjBGQlZ5eEZRVUZGUXl4SlFVRkpPenM3UTBGRk0wTXNRMEZhY1VORkxFdEJRVWtzVTBGWmVrTTdhMEpCV205Q1ZDeFJRVUZSTEVGQlVqZENJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gW1xuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbnZhciBOb25UZXJtaW5hbFBhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vblRlcm1pbmFsUGFydCh0eXBlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25UZXJtaW5hbFBhcnQpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoTm9uVGVybWluYWxQYXJ0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRUeXBlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNOb25UZXJtaW5hbFBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc05vblRlcm1pbmFsUGFydCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9uVGVybWluYWxQYXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9uVGVybWluYWxQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNUZXJtaW5hbFBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Rlcm1pbmFsUGFydCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxQYXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmFsUGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzUnVsZU5hbWVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNSdWxlTmFtZVBhcnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVOYW1lUGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKFBhcnQpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZW1haW5pbmdBcmd1bWVudHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0FyZ3VtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfY29uc3RydWN0KFBhcnQsIF90b0NvbnN1bWFibGVBcnJheShyZW1haW5pbmdBcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBOb25UZXJtaW5hbFBhcnQ7XG59KCk7XG5leHBvcnRzLmRlZmF1bHQgPSBOb25UZXJtaW5hbFBhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWEowTDI1dmJsUmxjbTFwYm1Gc0xtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5Qk9iMjVVWlhKdGFXNWhiRkJoY25RZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2loMGVYQmxLU0I3WEc0Z0lDQWdkR2hwY3k1MGVYQmxJRDBnZEhsd1pUc2dJRnh1SUNCOVhHNGdJRnh1SUNCblpYUlVlWEJsS0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxuUjVjR1U3WEc0Z0lIMWNibHh1SUNCcGMwNXZibFJsY20xcGJtRnNVR0Z5ZENncElIdGNiaUFnSUNCamIyNXpkQ0J1YjI1VVpYSnRhVzVoYkZCaGNuUWdQU0IwY25WbE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUc1dmJsUmxjbTFwYm1Gc1VHRnlkRHRjYmlBZ2ZWeHVYRzRnSUdselZHVnliV2x1WVd4UVlYSjBLQ2tnZTF4dUlDQWdJR052Ym5OMElIUmxjbTFwYm1Gc1VHRnlkQ0E5SUdaaGJITmxPMXh1SUNBZ0lGeHVJQ0FnSUhKbGRIVnliaUIwWlhKdGFXNWhiRkJoY25RN1hHNGdJSDFjYmx4dUlDQnBjMUoxYkdWT1lXMWxVR0Z5ZENncElIdGNiaUFnSUNCamIyNXpkQ0J5ZFd4bFRtRnRaVkJoY25RZ1BTQm1ZV3h6WlR0Y2JseHVJQ0FnSUhKbGRIVnliaUJ5ZFd4bFRtRnRaVkJoY25RN1hHNGdJSDFjYmx4dUlDQmpiRzl1WlNoUVlYSjBMQ0F1TGk1eVpXMWhhVzVwYm1kQmNtZDFiV1Z1ZEhNcElIc2djbVYwZFhKdUlHNWxkeUJRWVhKMEtDNHVMbkpsYldGcGJtbHVaMEZ5WjNWdFpXNTBjeWs3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKT2IyNVVaWEp0YVc1aGJGQmhjblFpTENKMGVYQmxJaXdpWjJWMFZIbHdaU0lzSW1selRtOXVWR1Z5YldsdVlXeFFZWEowSWl3aWJtOXVWR1Z5YldsdVlXeFFZWEowSWl3aWFYTlVaWEp0YVc1aGJGQmhjblFpTENKMFpYSnRhVzVoYkZCaGNuUWlMQ0pwYzFKMWJHVk9ZVzFsVUdGeWRDSXNJbkoxYkdWT1lXMWxVR0Z5ZENJc0ltTnNiMjVsSWl3aVVHRnlkQ0lzSW5KbGJXRnBibWx1WjBGeVozVnRaVzUwY3lKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHM3ZVVSQlFVRTdkVVZCUVVFN096czdPenM3T3pzN096czdPenM3WjBaQlFVRTdPenM3T3pzN08zTkRRVUZCT3pzN096czdhVU5CUVVFN096dHBSVUZCUVRzN1UwRkJRVHM3T3pzN096czRSRUZCUVR0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPenM3T3pzN0swUkJRVUU3T3pzN1FVRkZaU3hKUVVGQkxFRkJRVTFCTEdWQlFXVXNhVUpEUm1wRExFRkVSVms3WVVGQlRVRXNaVUZCWlN4RFFVTjBRa01zU1VGQlNUczRRMEZJYkVJN1VVRkpTU3hKUVVGSkxFTkJRVU5CTEVsQlFVa3NSMEZCUjBFc1NVRkJTU3hEUVVGRE96czdPMWxCUjI1Q1F5eEhRVUZQTEVWQlFWQkJMRk5CUVU4N1dVVlFWQ3hQUms5RlFTeFRRVUZCUVN4UFFVRlBMRWRCUVVjN1owSkJRMUlzVDBGQlR5eEpRVUZKTEVOQlFVTkVMRWxCUVVrc1EwRkJRenRoUVVOc1FqczdPMWxCUlVSRkxFZEJRV2xDTEVWQlFXcENRU3h0UWtGQmFVSTdXVVZZYmtJc1QwWlhSVUVzVTBGQlFVRXNhVUpCUVdsQ0xFZEJRVWM3WjBKQlEyeENMRWxCUVUxRExHVkJRV1VzUjBGQlJ5eEpRVUZKTEVGQlFVTTdaMEpCUlRkQ0xFOUJRVTlCTEdWQlFXVXNRMEZCUXp0aFFVTjRRanM3TzFsQlJVUkRMRWRCUVdNc1JVRkJaRUVzWjBKQlFXTTdXVVZxUW1oQ0xFOUdhVUpGUVN4VFFVRkJRU3hqUVVGakxFZEJRVWM3WjBKQlEyWXNTVUZCVFVNc1dVRkJXU3hIUVVGSExFdEJRVXNzUVVGQlF6dG5Ra0ZGTTBJc1QwRkJUMEVzV1VGQldTeERRVUZETzJGQlEzSkNPenM3V1VGRlJFTXNSMEZCWXl4RlFVRmtRU3huUWtGQll6dFpSWFpDYUVJc1QwWjFRa1ZCTEZOQlFVRkJMR05CUVdNc1IwRkJSenRuUWtGRFppeEpRVUZOUXl4WlFVRlpMRWRCUVVjc1MwRkJTeXhCUVVGRE8yZENRVVV6UWl4UFFVRlBRU3haUVVGWkxFTkJRVU03WVVGRGNrSTdPenRaUVVWRVF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVVTNRbEFzVDBZMlFrVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwTXNTVUZCU1N4RlFVRjVRanRuUWtGQmRrSXNTVUZCUVN4SlFVRkJMRWxCUVhGQ0xFZEJRWEpDTEZOQlFYRkNMRU5CUVhKQ0xFMUJRWEZDTEVWQlFYSkNMRUZCUVVkRExHdENRVUZyUWl4SFFVRnlRaXhWUVVGQkxFbEJRWEZDTEVkQlFYSkNMRU5CUVhGQ0xFZEJRWEpDTEVsQlFYRkNMRWRCUVhKQ0xFTkJRWEZDTEVsQlFVRXNRMEZCUVN4RlFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4RFFVRnhRaXhGUVVGeVFpeEpRVUZ4UWl4SFFVRnlRaXhKUVVGeFFpeEZRVUZ5UWl4SlFVRnhRaXhGUVVGQkxFTkJRWEpDTzI5Q1FVRkJMRUZCUVVkQkxHdENRVUZyUWl4RFFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4RFFVRnhRaXhKUVVGeVFpeFRRVUZ4UWl4QlFVRnlRaXhEUVVGQkxFbEJRWEZDTEVOQlFVRXNRVVUzUW01RExFTkdOa0p0UXp0cFFrRkJRVHRuUWtGQlNTeFBRVUZQTEZkQlFVbEVMRWxCUVVrc1JVRkJReXh0UWtGQlIwTXNhMEpCUVd0Q0xFTkJRV3hDUVN4RFFVRnRRaXhEUVVGRE8yRkJRVVU3TzAxQk4wSm9SanM3UTBFNFFrTXNSVUZCUVR0clFrRTFRbTlDV0N4bFFVRmxMRUZCUm5CREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBSdWxlTmFtZVBhcnRUeXBlID0gXCJydWxlTmFtZVBhcnRcIjtcbmV4cG9ydCBjb25zdCBPcHRpb25hbFBhcnRQYXJ0VHlwZSA9IFwib3B0aW9uYWxQYXJ0XCI7XG5leHBvcnQgY29uc3QgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlID0gXCJjaG9pY2VPZlBhcnRzXCI7XG5leHBvcnQgY29uc3QgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSA9IFwib25lT3JNb3JlUGFydHNcIjtcbmV4cG9ydCBjb25zdCBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSA9IFwiemVyb09yTW9yZVBhcnRzXCI7XG5leHBvcnQgY29uc3QgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUgPSBcInNlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFJ1bGVOYW1lUGFydFR5cGUsXG4gIE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICBDaG9pY2VPZlBhcnRzUGFydFR5cGUsXG4gIE9uZU9yTW9yZVBhcnRzUGFydFR5cGUsXG4gIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlLFxuICBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfb2NjYW1MZXhlcnMgPSByZXF1aXJlKFwib2NjYW0tbGV4ZXJzXCIpO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvbm9uVGVybWluYWxcIikpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIik7XG52YXIgX3BhcnRUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9wYXJ0VHlwZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBxdWVzdGlvbk1hcmsgPSBfb2NjYW1MZXhlcnMuc3BlY2lhbFN5bWJvbHMucXVlc3Rpb25NYXJrO1xudmFyIE9wdGlvbmFsUGFydFBhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsUGFydCkge1xuICAgIF9pbmhlcml0cyhPcHRpb25hbFBhcnRQYXJ0LCBOb25UZXJtaW5hbFBhcnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoT3B0aW9uYWxQYXJ0UGFydCk7XG4gICAgZnVuY3Rpb24gT3B0aW9uYWxQYXJ0UGFydChwYXJ0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25hbFBhcnRQYXJ0KTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICB2YXIgdHlwZSA9IF9wYXJ0VHlwZXMuT3B0aW9uYWxQYXJ0UGFydFR5cGU7IC8vL1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICBfdGhpcy5wYXJ0ID0gcGFydDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoT3B0aW9uYWxQYXJ0UGFydCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0UGFydFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSB0aGlzLmdldFBhcnQoKSwgcGFydE5vZGVzID0gW10sIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VQYXJ0KHBhcnQsIHBhcnROb2Rlcywgc3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfYXJyYXkpLnB1c2gobm9kZXMsIHBhcnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzU3RyaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNTdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yU3RyaW5nID0gcXVlc3Rpb25NYXJrLCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCksIHN0cmluZyA9IFwiXCIuY29uY2F0KHBhcnRTdHJpbmcpLmNvbmNhdChvcGVyYXRvclN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE9wdGlvbmFsUGFydFBhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIE9wdGlvbmFsUGFydFBhcnQsIHRoaXMucGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gT3B0aW9uYWxQYXJ0UGFydDtcbn0oX25vblRlcm1pbmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3B0aW9uYWxQYXJ0UGFydDtcbmZ1bmN0aW9uIHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgcGFyc2VkID0gY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDI5d2RHbHZibUZzVUdGeWRDNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUhzZ2MzQmxZMmxoYkZONWJXSnZiSE1nZlNCbWNtOXRJRndpYjJOallXMHRiR1Y0WlhKelhDSTdYRzVjYm1sdGNHOXlkQ0JPYjI1VVpYSnRhVzVoYkZCaGNuUWdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUXZibTl1VkdWeWJXbHVZV3hjSWp0Y2JseHVhVzF3YjNKMElIc2djSFZ6YUNCOUlHWnliMjBnWENJdUxpOHVMaTkxZEdsc2FYUnBaWE12WVhKeVlYbGNJanRjYm1sdGNHOXlkQ0I3SUU5d2RHbHZibUZzVUdGeWRGQmhjblJVZVhCbElIMGdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUlVlWEJsYzF3aU8xeHVYRzVqYjI1emRDQjdJSEYxWlhOMGFXOXVUV0Z5YXlCOUlEMGdjM0JsWTJsaGJGTjViV0p2YkhNN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUU5d2RHbHZibUZzVUdGeWRGQmhjblFnWlhoMFpXNWtjeUJPYjI1VVpYSnRhVzVoYkZCaGNuUWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaHdZWEowS1NCN1hHNGdJQ0FnWTI5dWMzUWdkSGx3WlNBOUlFOXdkR2x2Ym1Gc1VHRnlkRkJoY25SVWVYQmxPeUF2THk5Y2JseHVJQ0FnSUhOMWNHVnlLSFI1Y0dVcE8xeHVYRzRnSUNBZ2RHaHBjeTV3WVhKMElEMGdjR0Z5ZER0Y2JpQWdmVnh1WEc0Z0lHZGxkRkJoY25Rb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjR0Z5ZER0Y2JpQWdmVnh1WEc0Z0lIQmhjbk5sS0c1dlpHVnpMQ0J6ZEdGMFpTd2dZMkZzYkdKaFkyc3BJSHRjYmlBZ0lDQnNaWFFnY0dGeWMyVmtPMXh1WEc0Z0lDQWdZMjl1YzNRZ2NHRnlkQ0E5SUhSb2FYTXVaMlYwVUdGeWRDZ3BMRnh1SUNBZ0lDQWdJQ0FnSUhCaGNuUk9iMlJsY3lBOUlGdGRMRnh1SUNBZ0lDQWdJQ0FnSUhOaGRtVmtTVzVrWlhnZ1BTQnpkR0YwWlM1blpYUlRZWFpsWkVsdVpHVjRLQ2s3WEc1Y2JpQWdJQ0J3WVhKelpXUWdQU0J3WVhKelpWQmhjblFvY0dGeWRDd2djR0Z5ZEU1dlpHVnpMQ0J6ZEdGMFpTd2dZMkZzYkdKaFkyc3BPMXh1WEc0Z0lDQWdhV1lnS0hCaGNuTmxaQ2tnZTF4dUlDQWdJQ0FnY0hWemFDaHViMlJsY3l3Z2NHRnlkRTV2WkdWektUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9JWEJoY25ObFpDa2dlMXh1SUNBZ0lDQWdjM1JoZEdVdVltRmphM1J5WVdOcktITmhkbVZrU1c1a1pYZ3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCd1lYSnpaV1E3WEc0Z0lIMWNibHh1SUNCaGMxTjBjbWx1WnlncElIdGNiaUFnSUNCamIyNXpkQ0J2Y0dWeVlYUnZjbE4wY21sdVp5QTlJSEYxWlhOMGFXOXVUV0Z5YXl3Z0lDOHZMMXh1SUNBZ0lDQWdJQ0FnSUhCaGNuUlRkSEpwYm1jZ1BTQjBhR2x6TG5CaGNuUXVZWE5UZEhKcGJtY29LU3hjYmlBZ0lDQWdJQ0FnSUNCemRISnBibWNnUFNCZ0pIdHdZWEowVTNSeWFXNW5mU1I3YjNCbGNtRjBiM0pUZEhKcGJtZDlZRHRjYmx4dUlDQWdJSEpsZEhWeWJpQnpkSEpwYm1jN1hHNGdJSDFjYmx4dUlDQmpiRzl1WlNncElIc2djbVYwZFhKdUlITjFjR1Z5TG1Oc2IyNWxLRTl3ZEdsdmJtRnNVR0Z5ZEZCaGNuUXNJSFJvYVhNdWNHRnlkQ2s3SUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnY0dGeWMyVlFZWEowS0hCaGNuUXNJRzV2WkdWekxDQnpkR0YwWlN3Z1kyRnNiR0poWTJzcElIdGNiaUFnYkdWMElIQmhjbk5sWkR0Y2JseHVJQ0JwWmlBb1kyRnNiR0poWTJzZ0lUMDlJRzUxYkd3cElIdGNiaUFnSUNCd1lYSnpaV1FnUFNCallXeHNZbUZqYXlncE8xeHVYRzRnSUNBZ2FXWWdLQ0Z3WVhKelpXUXBJSHRjYmlBZ0lDQWdJSEJoY25ObFpDQTlJSEJoY25RdWNHRnljMlVvYm05a1pYTXNJSE4wWVhSbExDQmpZV3hzWW1GamF5azdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lIQmhjblF1Y0dGeWMyVW9ibTlrWlhNc0lITjBZWFJsTENCallXeHNZbUZqYXlrN1hHNWNiaUFnSUNCd1lYSnpaV1FnUFNCMGNuVmxPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSEJoY25ObFpEdGNibjFjYmlKZExDSnVZVzFsY3lJNld5SnhkV1Z6ZEdsdmJrMWhjbXNpTENKemNHVmphV0ZzVTNsdFltOXNjeUlzSWs5d2RHbHZibUZzVUdGeWRGQmhjblFpTENKd1lYSjBJaXdpZEhsd1pTSXNJazl3ZEdsdmJtRnNVR0Z5ZEZCaGNuUlVlWEJsSWl3aVoyVjBVR0Z5ZENJc0luQmhjbk5sSWl3aWJtOWtaWE1pTENKemRHRjBaU0lzSW1OaGJHeGlZV05ySWl3aWNHRnljMlZrSWl3aWNHRnlkRTV2WkdWeklpd2ljMkYyWldSSmJtUmxlQ0lzSW1kbGRGTmhkbVZrU1c1a1pYZ2lMQ0p3WVhKelpWQmhjblFpTENKd2RYTm9JaXdpWW1GamEzUnlZV05ySWl3aVlYTlRkSEpwYm1jaUxDSnZjR1Z5WVhSdmNsTjBjbWx1WnlJc0luQmhjblJUZEhKcGJtY2lMQ0p6ZEhKcGJtY2lMQ0pqYkc5dVpTSXNJazV2YmxSbGNtMXBibUZzVUdGeWRDSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXJRaXhKUVVGQkxGbEJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdRVUZGYWtJc1NVRkJRU3haUVVGM1FpeHJRMEZCZUVJc2QwSkJRWGRDTEVWQlFVRTdRVUZGTDBJc1NVRkJRU3hOUVVGMVFpeFhRVUYyUWl4MVFrRkJkVUlzUTBGQlFUdEJRVU5RTEVsQlFVRXNWVUZCYVVJc1YwRkJha0lzYVVKQlFXbENMRU5CUVVFN096czdPenM3T3pzN096czdPenM0UkVGUWRFUTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPekJDUVVGQk96czdPenM3T3pzN08xTkJRVUU3T3pzN096czdTMEZCUVRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TzNkRFFVRkJPenM3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVk5CTEVsQlFVMHNRVUZCUlVFc1dVRkJXU3hIUVVGTFF5eFpRVUZqTEdkQ1FVRXZRa1FzV1VGQldTeEJRVUZ0UWl4QlFVRkRPMEZCUlhwQ0xFbEJRVUVzUVVGQlRVVXNaMEpCUVdkQ0xHbENRVFJEYkVNc1FVRTFRMWs3WjBSQldHWTdPMkZCVjNGQ1FTeG5Ra0ZCWjBJc1EwRkRka0pETEVsQlFVazdLME5CV214Q096dFJRV0ZKTEVsQlFVMURMRWxCUVVrc1IwRkJSME1zVlVGQmIwSXNjVUpCUVVFc1FVRkJReXhGUVVGRExFZEJRVWM3YTBOQlJXaERSQ3hKUVVGSkxFTkRabVFzUTBSbFowSTdVVUZGV2l4TlFVRkxSQ3hKUVVGSkxFZEJRVWRCTEVsQlFVa3NRMEZCUXpzN096czdXVUZIYmtKSExFZEJRVThzUlVGQlVFRXNVMEZCVHp0WlEzQkNWQ3hQUkc5Q1JVRXNVMEZCUVVFc1QwRkJUeXhIUVVGSE8yZENRVU5TTEU5QlFVOHNTVUZCU1N4RFFVRkRTQ3hKUVVGSkxFTkJRVU03WVVGRGJFSTdPenRaUVVWRVNTeEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVTjRRbEFzVDBSM1FrVkJMRk5CUVVGQkxFdEJRVXNzUTBGQlEwTXNTMEZCU3l4RlFVRkZReXhMUVVGTExFVkJRVVZETEZGQlFWRXNSVUZCUlR0blFrRkROVUlzU1VGQlNVTXNUVUZCVFN4QlFVRkRPMmRDUVVWWUxFbEJRVTFTTEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVOSExFOUJRVThzUlVGQlJTeEZRVU55UWswc1UwRkJVeXhIUVVGSExFVkJRVVVzUlVGRFpFTXNWVUZCVlN4SFFVRkhTaXhMUVVGTExFTkJRVU5MTEdGQlFXRXNSVUZCUlN4QlFVRkRPMmRDUVVWNlEwZ3NUVUZCVFN4SFFVRkhTU3hUUVVGVExFTkJRVU5hTEVsQlFVa3NSVUZCUlZNc1UwRkJVeXhGUVVGRlNDeExRVUZMTEVWQlFVVkRMRkZCUVZFc1EwRkJReXhEUVVGRE8yZENRVVZ5UkN4SlFVRkpReXhOUVVGTkxFVkJRVVU3YjBKQlExWkxMRU5CUVVGQkxFZEJRVUZCTEUxQlFVa3NRVUZCYTBJc1EwRkJRU3hOUVVGcVFsSXNTMEZCU3l4RlFVRkZTU3hUUVVGVExFTkJRVU1zUTBGQlF6dHBRa0ZEZUVJN1owSkJSVVFzU1VGQlNTeERRVUZEUkN4TlFVRk5MRVZCUVVVN2IwSkJRMWhHTEV0QlFVc3NRMEZCUTFFc1UwRkJVeXhEUVVGRFNpeFZRVUZWTEVOQlFVTXNRMEZCUXp0cFFrRkROMEk3WjBKQlJVUXNUMEZCVDBZc1RVRkJUU3hEUVVGRE8yRkJRMlk3T3p0WlFVVkVUeXhIUVVGUkxFVkJRVkpCTEZWQlFWRTdXVU0xUTFZc1QwUTBRMFZCTEZOQlFVRkJMRkZCUVZFc1IwRkJSenRuUWtGRFZDeEpRVUZOUXl4alFVRmpMRWRCUVVkdVFpeFpRVUZaTEVWQlF6ZENiMElzVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTJwQ0xFbEJRVWtzUTBGQlEyVXNVVUZCVVN4RlFVRkZMRVZCUTJwRFJ5eE5RVUZOTEVkQlFVY3NRVUZCUXl4RlFVRkJMRU5CUVdWR0xFMUJRV01zUTBGQk0wSkRMRlZCUVZVc1EwRkJhMElzUTBGQlFTeE5RVUZCTEVOQlFXWkVMR05CUVdNc1EwRkJSU3hCUVVGRE8yZENRVVZvUkN4UFFVRlBSU3hOUVVGTkxFTkJRVU03WVVGRFpqczdPMWxCUlVSRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlEzQkVVQ3hQUkc5RVJVRXNVMEZCUVVFc1MwRkJTeXhIUVVGSE8yZENRVUZGTEU5QlFVOHNjVUpCZWtORmNFSXNaMEpCUVdkQ0xHRkJlVU5hYjBJc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQY0VJc1owSkJRV2RDTEVWQlFVVXNTVUZCU1N4RFFVRkRReXhKUVVGSkxFVkJRVVU3WVVGQlJUczdUVUZ3UkRsRU96dERRWEZFUXl4RFFURkROa052UWl4WlFVRmxMRk5CTUVNMVJEdHJRa0V4UTI5Q2NrSXNaMEpCUVdkQ0xFRkJXSEpETzBGQmRVUkJMRk5CUVZOaExGTkJRVk1zUTBGQlExb3NTVUZCU1N4RlFVRkZTeXhMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8wbEJReTlETEVsQlFVbERMRTFCUVUwc1FVRkJRenRKUVVWWUxFbEJRVWxFTEZGQlFWRXNTMEZCU3l4SlFVRkpMRVZCUVVVN1VVRkRja0pETEUxQlFVMHNSMEZCUjBRc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRmNFSXNTVUZCU1N4RFFVRkRReXhOUVVGTkxFVkJRVVU3V1VGRFdFRXNUVUZCVFN4SFFVRkhVaXhKUVVGSkxFTkJRVU5KTEV0QlFVc3NRMEZCUTBNc1MwRkJTeXhGUVVGRlF5eExRVUZMTEVWQlFVVkRMRkZCUVZFc1EwRkJReXhEUVVGRE8xTkJRemRETzB0QlEwWXNUVUZCVFR0UlFVTk1VQ3hKUVVGSkxFTkJRVU5KTEV0QlFVc3NRMEZCUTBNc1MwRkJTeXhGUVVGRlF5eExRVUZMTEVWQlFVVkRMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJSVzVEUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE8wdEJRMlk3U1VGRlJDeFBRVUZQUVN4TlFVRk5MRU5CUVVNN1EwRkRaaUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvbm9uVGVybWluYWxcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKXtcbiAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgQ29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbFBhcnQpIHtcbiAgICBfaW5oZXJpdHMoQ29sbGVjdGlvbk9mUGFydHNQYXJ0LCBOb25UZXJtaW5hbFBhcnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ29sbGVjdGlvbk9mUGFydHNQYXJ0KTtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uT2ZQYXJ0c1BhcnQodHlwZSwgcGFydCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGVjdGlvbk9mUGFydHNQYXJ0KTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICBfdGhpcy5wYXJ0ID0gcGFydDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbk9mUGFydHNQYXJ0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFydCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1N0cmluZyhvcGVyYXRvclN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCksIHN0cmluZyA9IFwiXCIuY29uY2F0KHBhcnRTdHJpbmcpLmNvbmNhdChvcGVyYXRvclN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoUGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDb2xsZWN0aW9uT2ZQYXJ0c1BhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIFBhcnQsIHRoaXMucGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ29sbGVjdGlvbk9mUGFydHNQYXJ0O1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl3WVhKMEwyNXZibFJsY20xcGJtRnNMMk52Ykd4bFkzUnBiMjVQWmxCaGNuUnpMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeFFZWEowSUdaeWIyMGdYQ0l1TGk4dUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklFTnZiR3hsWTNScGIyNVBabEJoY25SelVHRnlkQ0JsZUhSbGJtUnpJRTV2YmxSbGNtMXBibUZzVUdGeWRDQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtIUjVjR1VzSUhCaGNuUXBJSHRjYmlBZ0lDQnpkWEJsY2loMGVYQmxLVHRjYmx4dUlDQWdJSFJvYVhNdWNHRnlkQ0E5SUhCaGNuUTdYRzRnSUgxY2JseHVJQ0JuWlhSUVlYSjBLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TG5CaGNuUTdYRzRnSUgxY2JpQWdYRzRnSUdGelUzUnlhVzVuS0c5d1pYSmhkRzl5VTNSeWFXNW5LU0I3WEc0Z0lDQWdZMjl1YzNRZ2NHRnlkRk4wY21sdVp5QTlJSFJvYVhNdWNHRnlkQzVoYzFOMGNtbHVaeWdwTEZ4dUlDQWdJQ0FnSUNBZ0lITjBjbWx1WnlBOUlHQWtlM0JoY25SVGRISnBibWQ5Skh0dmNHVnlZWFJ2Y2xOMGNtbHVaMzFnTzF4dVhHNGdJQ0FnY21WMGRYSnVJSE4wY21sdVp6dGNiaUFnZlZ4dVhHNGdJR05zYjI1bEtGQmhjblFwSUhzZ2NtVjBkWEp1SUhOMWNHVnlMbU5zYjI1bEtGQmhjblFzSUhSb2FYTXVjR0Z5ZENrN0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SkRiMnhzWldOMGFXOXVUMlpRWVhKMGMxQmhjblFpTENKMGVYQmxJaXdpY0dGeWRDSXNJbWRsZEZCaGNuUWlMQ0poYzFOMGNtbHVaeUlzSW05d1pYSmhkRzl5VTNSeWFXNW5JaXdpY0dGeWRGTjBjbWx1WnlJc0luTjBjbWx1WnlJc0ltTnNiMjVsSWl3aVVHRnlkQ0lzSWs1dmJsUmxjbTFwYm1Gc1VHRnlkQ0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVUwUWl4SlFVRkJMRmxCUVhkQ0xHdERRVUY0UWl4M1FrRkJkMElzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVWndSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3TUVKQlFVRTdPenM3T3pzN096czdVMEZCUVRzN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzN2QwTkJRVUU3T3pzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCU1dVc1NVRkJRU3hCUVVGTlFTeHhRa0ZCY1VJc2FVSkRTblpETEVGRVNWazdjVVJCU21ZN08yRkJTWEZDUVN4eFFrRkJjVUlzUTBGRE5VSkRMRWxCUVVrc1JVRkJSVU1zU1VGQlNUdHZSRUZNZUVJN08ydERRVTFWUkN4SlFVRkpMRU5GVG1Rc1EwWk5aMEk3VVVGRldpeE5RVUZMUXl4SlFVRkpMRWRCUVVkQkxFbEJRVWtzUTBGQlF6czdPenM3V1VGSGJrSkRMRWRCUVU4c1JVRkJVRUVzVTBGQlR6dFpSVmhVTEU5R1YwVkJMRk5CUVVGQkxFOUJRVThzUjBGQlJ6dG5Ra0ZEVWl4UFFVRlBMRWxCUVVrc1EwRkJRMFFzU1VGQlNTeERRVUZETzJGQlEyeENPenM3V1VGRlJFVXNSMEZCVVN4RlFVRlNRU3hWUVVGUk8xbEZabFlzVDBabFJVRXNVMEZCUVVFc1VVRkJVU3hEUVVGRFF5eGpRVUZqTEVWQlFVVTdaMEpCUTNaQ0xFbEJRVTFETEZWQlFWVXNSMEZCUnl4SlFVRkpMRU5CUVVOS0xFbEJRVWtzUTBGQlEwVXNVVUZCVVN4RlFVRkZMRVZCUTJwRFJ5eE5RVUZOTEVkQlFVY3NRVUZCUXl4RlFVRkJMRU5CUVdWR0xFMUJRV01zUTBGQk0wSkRMRlZCUVZVc1EwRkJhMElzUTBGQlFTeE5RVUZCTEVOQlFXWkVMR05CUVdNc1EwRkJSU3hCUVVGRE8yZENRVVZvUkN4UFFVRlBSU3hOUVVGTkxFTkJRVU03WVVGRFpqczdPMWxCUlVSRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJYUkNVQ3hQUm5OQ1JVRXNVMEZCUVVFc1MwRkJTeXhEUVVGRFF5eEpRVUZKTEVWQlFVVTdaMEpCUVVVc1QwRkJUeXh4UWtGc1FrWlVMSEZDUVVGeFFpeGhRV3RDWWxFc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRFVDeEpRVUZKTEVWQlFVVTdZVUZCUlRzN1RVRjBRblJFT3p0RFFYVkNReXhEUVc1Q2EwUlJMRmxCUVdVc1UwRnRRbXBGTzJ0Q1FXNUNiMEpXTEhGQ1FVRnhRaXhCUVVveFF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfY29sbGVjdGlvbk9mUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25PZlBhcnRzXCIpKTtcbnZhciBfYXJyYXkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbGl0aWVzL2FycmF5XCIpO1xudmFyIF9wYXJ0VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcGFydFR5cGVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKXtcbiAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgcGx1cyA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy5wbHVzO1xudmFyIE9uZU9yTW9yZVBhcnRzUGFydCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29sbGVjdGlvbk9mUGFydHNQYXJ0KSB7XG4gICAgX2luaGVyaXRzKE9uZU9yTW9yZVBhcnRzUGFydCwgQ29sbGVjdGlvbk9mUGFydHNQYXJ0KTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE9uZU9yTW9yZVBhcnRzUGFydCk7XG4gICAgZnVuY3Rpb24gT25lT3JNb3JlUGFydHNQYXJ0KHBhcnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9uZU9yTW9yZVBhcnRzUGFydCk7XG4gICAgICAgIHZhciB0eXBlID0gX3BhcnRUeXBlcy5PbmVPck1vcmVQYXJ0c1BhcnRUeXBlOyAvLy9cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHBhcnQpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoT25lT3JNb3JlUGFydHNQYXJ0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwYXJzZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkO1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gdGhpcy5nZXRQYXJ0KCksIHBhcnROb2RlcyA9IFtdLCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlUGFydChwYXJ0LCBwYXJ0Tm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2FycmF5KS5wdXNoKG5vZGVzLCBwYXJ0Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvclN0cmluZyA9IHBsdXMsIHN0cmluZyA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE9uZU9yTW9yZVBhcnRzUGFydC5wcm90b3R5cGUpLCBcImFzU3RyaW5nXCIsIHRoaXMpLmNhbGwodGhpcywgb3BlcmF0b3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihPbmVPck1vcmVQYXJ0c1BhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIE9uZU9yTW9yZVBhcnRzUGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gT25lT3JNb3JlUGFydHNQYXJ0O1xufShfY29sbGVjdGlvbk9mUGFydHMuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBPbmVPck1vcmVQYXJ0c1BhcnQ7XG5mdW5jdGlvbiBwYXJzZVBhcnQocGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJzZWQxO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBwYXJzZWQxID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZDEgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICBpZiAocGFyc2VkMSkge1xuICAgICAgICAgICAgcGFyc2VQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQxO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDI5dVpVOXlUVzl5WlZCaGNuUnpMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ2V5QnpjR1ZqYVdGc1UzbHRZbTlzY3lCOUlHWnliMjBnWENKdlkyTmhiUzFzWlhobGNuTmNJanRjYmx4dWFXMXdiM0owSUVOdmJHeGxZM1JwYjI1UFpsQmhjblJ6VUdGeWRDQm1jbTl0SUZ3aUxpOWpiMnhzWldOMGFXOXVUMlpRWVhKMGMxd2lPMXh1WEc1cGJYQnZjblFnZXlCd2RYTm9JSDBnWm5KdmJTQmNJaTR1THk0dUwzVjBhV3hwZEdsbGN5OWhjbkpoZVZ3aU8xeHVhVzF3YjNKMElIc2dUMjVsVDNKTmIzSmxVR0Z5ZEhOUVlYSjBWSGx3WlNCOUlHWnliMjBnWENJdUxpOHVMaTl3WVhKMFZIbHdaWE5jSWp0Y2JseHVZMjl1YzNRZ2V5QndiSFZ6SUgwZ1BTQnpjR1ZqYVdGc1UzbHRZbTlzY3p0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVDI1bFQzSk5iM0psVUdGeWRITlFZWEowSUdWNGRHVnVaSE1nUTI5c2JHVmpkR2x2Yms5bVVHRnlkSE5RWVhKMElIdGNiaUFnWTI5dWMzUnlkV04wYjNJb2NHRnlkQ2tnZTF4dUlDQWdJR052Ym5OMElIUjVjR1VnUFNCUGJtVlBjazF2Y21WUVlYSjBjMUJoY25SVWVYQmxPeUF2THk5Y2JseHVJQ0FnSUhOMWNHVnlLSFI1Y0dVc0lIQmhjblFwTzF4dUlDQjlYRzVjYmlBZ2NHRnljMlVvYm05a1pYTXNJSE4wWVhSbExDQmpZV3hzWW1GamF5a2dlMXh1SUNBZ0lHeGxkQ0J3WVhKelpXUTdYRzVjYmlBZ0lDQmpiMjV6ZENCd1lYSjBJRDBnZEdocGN5NW5aWFJRWVhKMEtDa3NYRzRnSUNBZ0lDQWdJQ0FnY0dGeWRFNXZaR1Z6SUQwZ1cxMHNYRzRnSUNBZ0lDQWdJQ0FnYzJGMlpXUkpibVJsZUNBOUlITjBZWFJsTG1kbGRGTmhkbVZrU1c1a1pYZ29LVHRjYmx4dUlDQWdJSEJoY25ObFpDQTlJSEJoY25ObFVHRnlkQ2h3WVhKMExDQndZWEowVG05a1pYTXNJSE4wWVhSbExDQmpZV3hzWW1GamF5azdYRzVjYmlBZ0lDQnBaaUFvY0dGeWMyVmtLU0I3WEc0Z0lDQWdJQ0J3ZFhOb0tHNXZaR1Z6TENCd1lYSjBUbTlrWlhNcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDZ2hjR0Z5YzJWa0tTQjdYRzRnSUNBZ0lDQnpkR0YwWlM1aVlXTnJkSEpoWTJzb2MyRjJaV1JKYm1SbGVDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUhCaGNuTmxaRHRjYmlBZ2ZWeHVYRzRnSUdGelUzUnlhVzVuS0NrZ2UxeHVJQ0FnSUdOdmJuTjBJRzl3WlhKaGRHOXlVM1J5YVc1bklEMGdjR3gxY3l3Z0lDOHZMMXh1SUNBZ0lDQWdJQ0FnSUhOMGNtbHVaeUE5SUhOMWNHVnlMbUZ6VTNSeWFXNW5LRzl3WlhKaGRHOXlVM1J5YVc1bktUdGNibHh1SUNBZ0lISmxkSFZ5YmlCemRISnBibWM3WEc0Z0lIMWNibHh1SUNCamJHOXVaU2dwSUhzZ2NtVjBkWEp1SUhOMWNHVnlMbU5zYjI1bEtFOXVaVTl5VFc5eVpWQmhjblJ6VUdGeWRDazdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdjR0Z5YzJWUVlYSjBLSEJoY25Rc0lHNXZaR1Z6TENCemRHRjBaU3dnWTJGc2JHSmhZMnNwSUh0Y2JpQWdiR1YwSUhCaGNuTmxaRHRjYmx4dUlDQnBaaUFvWTJGc2JHSmhZMnNnSVQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0J3WVhKelpXUWdQU0J3WVhKMExuQmhjbk5sS0c1dlpHVnpMQ0J6ZEdGMFpTd2dLQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ2JHVjBJSEJoY25ObFpDQTlJR05oYkd4aVlXTnJLQ2s3WEc1Y2JpQWdJQ0FnSUdsbUlDZ2hjR0Z5YzJWa0tTQjdYRzRnSUNBZ0lDQWdJSEJoY25ObFpDQTlJSEJoY25ObFVHRnlkQ2h3WVhKMExDQnViMlJsY3l3Z2MzUmhkR1VzSUdOaGJHeGlZV05yS1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2NtVjBkWEp1SUhCaGNuTmxaRHRjYmlBZ0lDQjlLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J3WVhKelpXUWdQU0J3WVhKMExuQmhjbk5sS0c1dlpHVnpMQ0J6ZEdGMFpTd2dZMkZzYkdKaFkyc3BPMXh1WEc0Z0lDQWdhV1lnS0hCaGNuTmxaQ2tnZTF4dUlDQWdJQ0FnY0dGeWMyVlFZWEowS0hCaGNuUXNJRzV2WkdWekxDQnpkR0YwWlN3Z1kyRnNiR0poWTJzcFhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhCaGNuTmxaRHRjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUp3YkhWeklpd2ljM0JsWTJsaGJGTjViV0p2YkhNaUxDSlBibVZQY2sxdmNtVlFZWEowYzFCaGNuUWlMQ0p3WVhKMElpd2lkSGx3WlNJc0lrOXVaVTl5VFc5eVpWQmhjblJ6VUdGeWRGUjVjR1VpTENKd1lYSnpaU0lzSW01dlpHVnpJaXdpYzNSaGRHVWlMQ0pqWVd4c1ltRmpheUlzSW5CaGNuTmxaQ0lzSW1kbGRGQmhjblFpTENKd1lYSjBUbTlrWlhNaUxDSnpZWFpsWkVsdVpHVjRJaXdpWjJWMFUyRjJaV1JKYm1SbGVDSXNJbkJoY25ObFVHRnlkQ0lzSW5CMWMyZ2lMQ0ppWVdOcmRISmhZMnNpTENKaGMxTjBjbWx1WnlJc0ltOXdaWEpoZEc5eVUzUnlhVzVuSWl3aWMzUnlhVzVuSWl3aVkyeHZibVVpTENKRGIyeHNaV04wYVc5dVQyWlFZWEowYzFCaGNuUWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZLMElzU1VGQlFTeFpRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPMEZCUlZnc1NVRkJRU3hyUWtGQmNVSXNhME5CUVhKQ0xIRkNRVUZ4UWl4RlFVRkJPMEZCUld4RExFbEJRVUVzVFVGQmRVSXNWMEZCZGtJc2RVSkJRWFZDTEVOQlFVRTdRVUZEVEN4SlFVRkJMRlZCUVdsQ0xGZEJRV3BDTEdsQ1FVRnBRaXhEUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlVIaEVPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenN3UWtGQlFUczdPenM3T3pzN096dFRRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3p0M1EwRkJRVHM3T3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZUUVN4SlFVRk5MRUZCUVVWQkxFbEJRVWtzUjBGQlMwTXNXVUZCWXl4blFrRkJka0pFTEVsQlFVa3NRVUZCYlVJc1FVRkJRenRCUVVWcVFpeEpRVUZCTEVGQlFVMUZMR3RDUVVGclFpeHBRa0Z4UTNCRExFRkJja05aTzNkRVFWaG1PenRoUVZkeFFrRXNhMEpCUVd0Q0xFTkJRM3BDUXl4SlFVRkpPMmxFUVZwc1FqdFJRV0ZKTEVsQlFVMURMRWxCUVVrc1IwRkJSME1zVlVGQmMwSXNkVUpCUVVFc1FVRkJReXhGUVVGRExFZEJRVWM3YVVOQlJXeERSQ3hKUVVGSkxFVkJRVVZFTEVsQlFVazdPenM3V1VGSGJFSkhMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpRMnhDVUN4UFJHdENSVUVzVTBGQlFVRXNTMEZCU3l4RFFVRkRReXhMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8yZENRVU0xUWl4SlFVRkpReXhOUVVGTkxFRkJRVU03WjBKQlJWZ3NTVUZCVFZBc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlExRXNUMEZCVHl4RlFVRkZMRVZCUTNKQ1F5eFRRVUZUTEVkQlFVY3NSVUZCUlN4RlFVTmtReXhWUVVGVkxFZEJRVWRNTEV0QlFVc3NRMEZCUTAwc1lVRkJZU3hGUVVGRkxFRkJRVU03WjBKQlJYcERTaXhOUVVGTkxFZEJRVWRMTEZOQlFWTXNRMEZCUTFvc1NVRkJTU3hGUVVGRlV5eFRRVUZUTEVWQlFVVktMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeERRVUZETEVOQlFVTTdaMEpCUlhKRUxFbEJRVWxETEUxQlFVMHNSVUZCUlR0dlFrRkRWazBzUTBGQlFVRXNSMEZCUVVFc1RVRkJTU3hCUVVGclFpeERRVUZCTEUxQlFXcENWQ3hMUVVGTExFVkJRVVZMTEZOQlFWTXNRMEZCUXl4RFFVRkRPMmxDUVVONFFqdG5Ra0ZGUkN4SlFVRkpMRU5CUVVOR0xFMUJRVTBzUlVGQlJUdHZRa0ZEV0VZc1MwRkJTeXhEUVVGRFV5eFRRVUZUTEVOQlFVTktMRlZCUVZVc1EwRkJReXhEUVVGRE8ybENRVU0zUWp0blFrRkZSQ3hQUVVGUFNDeE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJSTEVkQlFWRXNSVUZCVWtFc1ZVRkJVVHRaUTNSRFZpeFBSSE5EUlVFc1UwRkJRVUVzVVVGQlVTeEhRVUZITzJkQ1FVTlVMRWxCUVUxRExHTkJRV01zUjBGQlIyNUNMRWxCUVVrc1JVRkRja0p2UWl4TlFVRk5MRWRCUVVjc2NVSkJOMEpGYkVJc2EwSkJRV3RDTEdGQk5rSmtaMElzVlVGQlVTeEZRVUZrTEVsQlFVc3NRMEZCUVN4WlFVRlZReXhqUVVGakxFTkJRVU1zUVVGQlF6dG5Ra0ZGT1VNc1QwRkJUME1zVFVGQlRTeERRVUZETzJGQlEyWTdPenRaUVVWRVF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVTTNRMUFzVDBRMlEwVkJMRk5CUVVGQkxFdEJRVXNzUjBGQlJ6dG5Ra0ZCUlN4UFFVRlBMSEZDUVd4RFJXNUNMR3RDUVVGclFpeGhRV3REWkcxQ0xFOUJRVXNzUlVGQldDeEpRVUZMTEVOQlFVRXNXVUZCVDI1Q0xHdENRVUZyUWl4RlFVRkZPMkZCUVVVN08wMUJOME55UkRzN1EwRTRRME1zUTBGdVF5dERiMElzYTBKQlFYRkNMRk5CYlVOd1JUdHJRa0Z1UTI5Q2NFSXNhMEpCUVd0Q0xFRkJXSFpETzBGQlowUkJMRk5CUVZOaExGTkJRVk1zUTBGQlExb3NTVUZCU1N4RlFVRkZTU3hMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8wbEJReTlETEVsQlFVbERMRTlCUVUwc1FVRkJRenRKUVVWWUxFbEJRVWxFTEZGQlFWRXNTMEZCU3l4SlFVRkpMRVZCUVVVN1VVRkRja0pETEU5QlFVMHNSMEZCUjFBc1NVRkJTU3hEUVVGRFJ5eExRVUZMTEVOQlFVTkRMRXRCUVVzc1JVRkJSVU1zUzBGQlN5eEZRVUZGTEZkQlFVMDdXVUZEZEVNc1NVRkJTVVVzVFVGQlRTeEhRVUZIUkN4UlFVRlJMRVZCUVVVc1FVRkJRenRaUVVWNFFpeEpRVUZKTEVOQlFVTkRMRTFCUVUwc1JVRkJSVHRuUWtGRFdFRXNUVUZCVFN4SFFVRkhTeXhUUVVGVExFTkJRVU5hTEVsQlFVa3NSVUZCUlVrc1MwRkJTeXhGUVVGRlF5eExRVUZMTEVWQlFVVkRMRkZCUVZFc1EwRkJReXhEUVVGRE8yRkJRMnhFTzFsQlJVUXNUMEZCVDBNc1RVRkJUU3hEUVVGRE8xTkJRMllzUTBGQlF5eERRVUZETzB0QlEwb3NUVUZCVFR0UlFVTk1RU3hQUVVGTkxFZEJRVWRRTEVsQlFVa3NRMEZCUTBjc1MwRkJTeXhEUVVGRFF5eExRVUZMTEVWQlFVVkRMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeERRVUZETEVOQlFVTTdVVUZGTlVNc1NVRkJTVU1zVDBGQlRTeEZRVUZGTzFsQlExWkxMRk5CUVZNc1EwRkJRMW9zU1VGQlNTeEZRVUZGU1N4TFFVRkxMRVZCUVVWRExFdEJRVXNzUlVGQlJVTXNVVUZCVVN4RFFVRkRMRUZCYWtVM1F6dFRRV3RGU3p0TFFVTkdPMGxCUlVRc1QwRkJUME1zVDBGQlRTeERRVUZETzBOQlEyWWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX2NvbGxlY3Rpb25PZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsZWN0aW9uT2ZQYXJ0c1wiKSk7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxpdGllcy9hcnJheVwiKTtcbnZhciBfcGFydFR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3BhcnRUeXBlc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIGFzdGVyaXNrID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmFzdGVyaXNrO1xudmFyIFplcm9Pck1vcmVQYXJ0c1BhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbGxlY3Rpb25PZlBhcnRzUGFydCkge1xuICAgIF9pbmhlcml0cyhaZXJvT3JNb3JlUGFydHNQYXJ0LCBDb2xsZWN0aW9uT2ZQYXJ0c1BhcnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoWmVyb09yTW9yZVBhcnRzUGFydCk7XG4gICAgZnVuY3Rpb24gWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBaZXJvT3JNb3JlUGFydHNQYXJ0KTtcbiAgICAgICAgdmFyIHR5cGUgPSBfcGFydFR5cGVzLlplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOyAvLy9cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHBhcnQpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoWmVyb09yTW9yZVBhcnRzUGFydCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHRoaXMuZ2V0UGFydCgpLCBwYXJ0Tm9kZXMgPSBbXSwgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVBhcnQocGFydCwgcGFydE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9hcnJheSkucHVzaChub2RlcywgcGFydE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3JTdHJpbmcgPSBhc3Rlcmlzaywgc3RyaW5nID0gX2dldChfZ2V0UHJvdG90eXBlT2YoWmVyb09yTW9yZVBhcnRzUGFydC5wcm90b3R5cGUpLCBcImFzU3RyaW5nXCIsIHRoaXMpLmNhbGwodGhpcywgb3BlcmF0b3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihaZXJvT3JNb3JlUGFydHNQYXJ0LnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBaZXJvT3JNb3JlUGFydHNQYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBaZXJvT3JNb3JlUGFydHNQYXJ0O1xufShfY29sbGVjdGlvbk9mUGFydHMuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBaZXJvT3JNb3JlUGFydHNQYXJ0O1xuZnVuY3Rpb24gcGFyc2VQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyc2VkO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBwYXJzZWQgPSBjYWxsYmFjaygpO1xuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBhcnQocGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDNwbGNtOVBjazF2Y21WUVlYSjBjeTVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElIc2djM0JsWTJsaGJGTjViV0p2YkhNZ2ZTQm1jbTl0SUZ3aWIyTmpZVzB0YkdWNFpYSnpYQ0k3WEc1Y2JtbHRjRzl5ZENCRGIyeHNaV04wYVc5dVQyWlFZWEowYzFCaGNuUWdabkp2YlNCY0lpNHZZMjlzYkdWamRHbHZiazltVUdGeWRITmNJanRjYmx4dWFXMXdiM0owSUhzZ2NIVnphQ0I5SUdaeWIyMGdYQ0l1TGk4dUxpOTFkR2xzYVhScFpYTXZZWEp5WVhsY0lqdGNibWx0Y0c5eWRDQjdJRnBsY205UGNrMXZjbVZRWVhKMGMxQmhjblJVZVhCbElIMGdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUlVlWEJsYzF3aU8xeHVYRzVqYjI1emRDQjdJR0Z6ZEdWeWFYTnJJSDBnUFNCemNHVmphV0ZzVTNsdFltOXNjenRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdXbVZ5YjA5eVRXOXlaVkJoY25SelVHRnlkQ0JsZUhSbGJtUnpJRU52Ykd4bFkzUnBiMjVQWmxCaGNuUnpVR0Z5ZENCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0hCaGNuUXBJSHRjYmlBZ0lDQmpiMjV6ZENCMGVYQmxJRDBnV21WeWIwOXlUVzl5WlZCaGNuUnpVR0Z5ZEZSNWNHVTdJQzh2TDF4dVhHNGdJQ0FnYzNWd1pYSW9kSGx3WlN3Z2NHRnlkQ2s3WEc0Z0lIMWNibHh1SUNCd1lYSnpaU2h1YjJSbGN5d2djM1JoZEdVc0lHTmhiR3hpWVdOcktTQjdYRzRnSUNBZ2JHVjBJSEJoY25ObFpEdGNibHh1SUNBZ0lHTnZibk4wSUhCaGNuUWdQU0IwYUdsekxtZGxkRkJoY25Rb0tTeGNiaUFnSUNBZ0lDQWdJQ0J3WVhKMFRtOWtaWE1nUFNCYlhTeGNiaUFnSUNBZ0lDQWdJQ0J6WVhabFpFbHVaR1Y0SUQwZ2MzUmhkR1V1WjJWMFUyRjJaV1JKYm1SbGVDZ3BPMXh1WEc0Z0lDQWdjR0Z5YzJWa0lEMGdjR0Z5YzJWUVlYSjBLSEJoY25Rc0lIQmhjblJPYjJSbGN5d2djM1JoZEdVc0lHTmhiR3hpWVdOcktUdGNibHh1SUNBZ0lHbG1JQ2h3WVhKelpXUXBJSHRjYmlBZ0lDQWdJSEIxYzJnb2JtOWtaWE1zSUhCaGNuUk9iMlJsY3lrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tDRndZWEp6WldRcElIdGNiaUFnSUNBZ0lITjBZWFJsTG1KaFkydDBjbUZqYXloellYWmxaRWx1WkdWNEtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCeVpYUjFjbTRnY0dGeWMyVmtPMXh1SUNCOVhHNWNiaUFnWVhOVGRISnBibWNvS1NCN1hHNGdJQ0FnWTI5dWMzUWdiM0JsY21GMGIzSlRkSEpwYm1jZ1BTQmhjM1JsY21semF5d2dJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lITjBjbWx1WnlBOUlITjFjR1Z5TG1GelUzUnlhVzVuS0c5d1pYSmhkRzl5VTNSeWFXNW5LVHRjYmx4dUlDQWdJSEpsZEhWeWJpQnpkSEpwYm1jN1hHNGdJSDFjYmx4dUlDQmpiRzl1WlNncElIc2djbVYwZFhKdUlITjFjR1Z5TG1Oc2IyNWxLRnBsY205UGNrMXZjbVZRWVhKMGMxQmhjblFwT3lCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUhCaGNuTmxVR0Z5ZENod1lYSjBMQ0J1YjJSbGN5d2djM1JoZEdVc0lHTmhiR3hpWVdOcktTQjdYRzRnSUd4bGRDQndZWEp6WldRN1hHNWNiaUFnYVdZZ0tHTmhiR3hpWVdOcklDRTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ2NHRnljMlZrSUQwZ1kyRnNiR0poWTJzb0tUdGNibHh1SUNBZ0lHbG1JQ2doY0dGeWMyVmtLU0I3WEc0Z0lDQWdJQ0J3WVhKelpXUWdQU0J3WVhKMExuQmhjbk5sS0c1dlpHVnpMQ0J6ZEdGMFpTd2dLQ2tnUFQ0Z2NHRnljMlZRWVhKMEtIQmhjblFzSUc1dlpHVnpMQ0J6ZEdGMFpTd2dZMkZzYkdKaFkyc3BLVHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdjR0Z5YzJWa0lEMGdjR0Z5ZEM1d1lYSnpaU2h1YjJSbGN5d2djM1JoZEdVc0lHTmhiR3hpWVdOcktUdGNibHh1SUNBZ0lHbG1JQ2h3WVhKelpXUXBJSHRjYmlBZ0lDQWdJSEJoY25ObFVHRnlkQ2h3WVhKMExDQnViMlJsY3l3Z2MzUmhkR1VzSUdOaGJHeGlZV05yS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J3WVhKelpXUWdQU0IwY25WbE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIQmhjbk5sWkR0Y2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKaGMzUmxjbWx6YXlJc0luTndaV05wWVd4VGVXMWliMnh6SWl3aVdtVnliMDl5VFc5eVpWQmhjblJ6VUdGeWRDSXNJbkJoY25RaUxDSjBlWEJsSWl3aVdtVnliMDl5VFc5eVpWQmhjblJ6VUdGeWRGUjVjR1VpTENKd1lYSnpaU0lzSW01dlpHVnpJaXdpYzNSaGRHVWlMQ0pqWVd4c1ltRmpheUlzSW5CaGNuTmxaQ0lzSW1kbGRGQmhjblFpTENKd1lYSjBUbTlrWlhNaUxDSnpZWFpsWkVsdVpHVjRJaXdpWjJWMFUyRjJaV1JKYm1SbGVDSXNJbkJoY25ObFVHRnlkQ0lzSW5CMWMyZ2lMQ0ppWVdOcmRISmhZMnNpTENKaGMxTjBjbWx1WnlJc0ltOXdaWEpoZEc5eVUzUnlhVzVuSWl3aWMzUnlhVzVuSWl3aVkyeHZibVVpTENKRGIyeHNaV04wYVc5dVQyWlFZWEowYzFCaGNuUWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZLMElzU1VGQlFTeFpRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPMEZCUlZnc1NVRkJRU3hyUWtGQmNVSXNhME5CUVhKQ0xIRkNRVUZ4UWl4RlFVRkJPMEZCUld4RExFbEJRVUVzVFVGQmRVSXNWMEZCZGtJc2RVSkJRWFZDTEVOQlFVRTdRVUZEU2l4SlFVRkJMRlZCUVdsQ0xGZEJRV3BDTEdsQ1FVRnBRaXhEUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlVIcEVPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenN3UWtGQlFUczdPenM3T3pzN096dFRRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3p0M1EwRkJRVHM3T3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZUUVN4SlFVRk5MRUZCUVVWQkxGRkJRVkVzUjBGQlMwTXNXVUZCWXl4blFrRkJNMEpFTEZGQlFWRXNRVUZCYlVJc1FVRkJRenRCUVVWeVFpeEpRVUZCTEVGQlFVMUZMRzFDUVVGdFFpeHBRa0Z4UTNKRExFRkJja05aTzNsRVFWaG1PenRoUVZkeFFrRXNiVUpCUVcxQ0xFTkJRekZDUXl4SlFVRkpPMnRFUVZwc1FqdFJRV0ZKTEVsQlFVMURMRWxCUVVrc1IwRkJSME1zVlVGQmRVSXNkMEpCUVVFc1FVRkJReXhGUVVGRExFZEJRVWM3YVVOQlJXNURSQ3hKUVVGSkxFVkJRVVZFTEVsQlFVazdPenM3V1VGSGJFSkhMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpRMnhDVUN4UFJHdENSVUVzVTBGQlFVRXNTMEZCU3l4RFFVRkRReXhMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8yZENRVU0xUWl4SlFVRkpReXhOUVVGTkxFRkJRVU03WjBKQlJWZ3NTVUZCVFZBc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlExRXNUMEZCVHl4RlFVRkZMRVZCUTNKQ1F5eFRRVUZUTEVkQlFVY3NSVUZCUlN4RlFVTmtReXhWUVVGVkxFZEJRVWRNTEV0QlFVc3NRMEZCUTAwc1lVRkJZU3hGUVVGRkxFRkJRVU03WjBKQlJYcERTaXhOUVVGTkxFZEJRVWRMTEZOQlFWTXNRMEZCUTFvc1NVRkJTU3hGUVVGRlV5eFRRVUZUTEVWQlFVVktMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeERRVUZETEVOQlFVTTdaMEpCUlhKRUxFbEJRVWxETEUxQlFVMHNSVUZCUlR0dlFrRkRWazBzUTBGQlFVRXNSMEZCUVVFc1RVRkJTU3hCUVVGclFpeERRVUZCTEUxQlFXcENWQ3hMUVVGTExFVkJRVVZMTEZOQlFWTXNRMEZCUXl4RFFVRkRPMmxDUVVONFFqdG5Ra0ZGUkN4SlFVRkpMRU5CUVVOR0xFMUJRVTBzUlVGQlJUdHZRa0ZEV0VZc1MwRkJTeXhEUVVGRFV5eFRRVUZUTEVOQlFVTktMRlZCUVZVc1EwRkJReXhEUVVGRE8ybENRVU0zUWp0blFrRkZSQ3hQUVVGUFNDeE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJSTEVkQlFWRXNSVUZCVWtFc1ZVRkJVVHRaUTNSRFZpeFBSSE5EUlVFc1UwRkJRVUVzVVVGQlVTeEhRVUZITzJkQ1FVTlVMRWxCUVUxRExHTkJRV01zUjBGQlIyNUNMRkZCUVZFc1JVRkRla0p2UWl4TlFVRk5MRWRCUVVjc2NVSkJOMEpGYkVJc2JVSkJRVzFDTEdGQk5rSm1aMElzVlVGQlVTeEZRVUZrTEVsQlFVc3NRMEZCUVN4WlFVRlZReXhqUVVGakxFTkJRVU1zUVVGQlF6dG5Ra0ZGT1VNc1QwRkJUME1zVFVGQlRTeERRVUZETzJGQlEyWTdPenRaUVVWRVF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVTTNRMUFzVDBRMlEwVkJMRk5CUVVGQkxFdEJRVXNzUjBGQlJ6dG5Ra0ZCUlN4UFFVRlBMSEZDUVd4RFJXNUNMRzFDUVVGdFFpeGhRV3REWm0xQ0xFOUJRVXNzUlVGQldDeEpRVUZMTEVOQlFVRXNXVUZCVDI1Q0xHMUNRVUZ0UWl4RlFVRkZPMkZCUVVVN08wMUJOME4wUkRzN1EwRTRRME1zUTBGdVEyZEViMElzYTBKQlFYRkNMRk5CYlVOeVJUdHJRa0Z1UTI5Q2NFSXNiVUpCUVcxQ0xFRkJXSGhETzBGQlowUkJMRk5CUVZOaExGTkJRVk1zUTBGQlExb3NTVUZCU1N4RlFVRkZTU3hMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8wbEJReTlETEVsQlFVbERMRTFCUVUwc1FVRkJRenRKUVVWWUxFbEJRVWxFTEZGQlFWRXNTMEZCU3l4SlFVRkpMRVZCUVVVN1VVRkRja0pETEUxQlFVMHNSMEZCUjBRc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRmNFSXNTVUZCU1N4RFFVRkRReXhOUVVGTkxFVkJRVVU3V1VGRFdFRXNUVUZCVFN4SFFVRkhVQ3hKUVVGSkxFTkJRVU5ITEV0QlFVc3NRMEZCUTBNc1MwRkJTeXhGUVVGRlF5eExRVUZMTEVWQlFVVTdkVUpCUVUxUExGTkJRVk1zUTBGQlExb3NTVUZCU1N4RlFVRkZTU3hMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hEUVVGRE8yRkJRVUVzUTBGQlF5eERRVUZETzFOQlEyeEdPMHRCUTBZc1RVRkJUVHRSUVVOTVF5eE5RVUZOTEVkQlFVZFFMRWxCUVVrc1EwRkJRMGNzUzBGQlN5eERRVUZEUXl4TFFVRkxMRVZCUVVWRExFdEJRVXNzUlVGQlJVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1VVRkZOVU1zU1VGQlNVTXNUVUZCVFN4RlFVRkZPMWxCUTFaTExGTkJRVk1zUTBGQlExb3NTVUZCU1N4RlFVRkZTU3hMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hEUVVGRExFTkJRVU03VTBGRGVrTTdVVUZGUkVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF6dExRVU5tTzBsQlJVUXNUMEZCVDBFc1RVRkJUU3hEUVVGRE8wTkJRMllpZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBMb29rQWhlYWRNb2RpZmllclJ1bGVOYW1lLCBRdWFudGlmaWVyUnVsZU5hbWUsIFJ1bGVOYW1lUnVsZU5hbWUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDaG9pY2VOb2RlKG5vZGUpIHtcbiAgbGV0IG5vZGVOb0Nob2ljZU5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgbm9kZU5vQ2hvaWNlTm9kZSA9ICh0ZXJtaW5hbE5vZGVDb250ZW50ID09PSBcInxcIik7XG4gIH1cblxuICByZXR1cm4gbm9kZU5vQ2hvaWNlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVJ1bGVOYW1lTm9kZShub2RlKSB7XG4gIGxldCBub2RlUnVsZU5hbWVOb2RlID0gZmFsc2U7XG5cbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgbm9kZU5vblRlcm1pbmFsTm9kZSA9ICFub2RlVGVybWluYWxOb2RlO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgIG5vZGVSdWxlTmFtZU5vZGUgPSAobm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPT09IFJ1bGVOYW1lUnVsZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVSdWxlTmFtZU5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVRdWFudGlmaWVyTm9kZShub2RlKSB7XG4gIGxldCBub2RlUXVhbnRpZmllck5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZVF1YW50aWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gUXVhbnRpZmllclJ1bGVOYW1lKTtcblxuICAgIG5vZGVRdWFudGlmaWVyTm9kZSA9IHJ1bGVOYW1lUXVhbnRpZmllclJ1bGVOYW1lOyAgLy8vXG4gIH1cblxuICByZXR1cm4gbm9kZVF1YW50aWZpZXJOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlTG9va0FoZWFkTW9kaWZpZXJOb2RlKG5vZGUpIHtcbiAgbGV0IG5vZGVMb29rQWhlYWRNb2RpZmllck5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZUxvb2tBaGVhZE1vZGlmaWVyUnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IExvb2tBaGVhZE1vZGlmaWVyUnVsZU5hbWUpO1xuXG4gICAgbm9kZUxvb2tBaGVhZE1vZGlmaWVyTm9kZSA9IHJ1bGVOYW1lTG9va0FoZWFkTW9kaWZpZXJSdWxlTmFtZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG5vZGVMb29rQWhlYWRNb2RpZmllck5vZGU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbVF1YW50aWZpZXJOb2RlKHF1YW50aWZpZXJOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcXVhbnRpZmllck5vZGU7IC8vL1xuXG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpO1xuXG4gIG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgY29uc3QgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG52YXIgX29wdGlvbmFsUGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCIpKTtcbnZhciBfb25lT3JNb3JlUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCIpKTtcbnZhciBfemVyb09yTW9yZVBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC96ZXJvT3JNb3JlUGFydHNcIikpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIik7XG52YXIgX2JuZiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvYm5mXCIpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgUGFydEJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhQYXJ0Qk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBhcnRCTkZOb2RlKTtcbiAgICBmdW5jdGlvbiBQYXJ0Qk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnRCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUGFydEJORk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdlbmVyYXRlUGFydFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlUGFydChsb29rQWhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLCBub2RlcyA9IGNoaWxkTm9kZXMuc2xpY2UoKSwgcGFydCA9IHBhcnRGcm9tTm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhQYXJ0Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFBhcnRCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBQYXJ0Qk5GTm9kZTtcbmZ1bmN0aW9uIHBhcnRGcm9tTm9kZXMobm9kZXMpIHtcbiAgICB2YXIgcGFydCA9IG51bGw7XG4gICAgdmFyIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICAgIGlmIChub2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzLnBvcCgpLCBsb29rQWhlYWQgPSBmYWxzZTtcbiAgICAgICAgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxhc3ROb2RlUXVhbnRpZmllck5vZGUgPSBpc0xhc3ROb2RlUXVhbnRpZmllck5vZGUobm9kZXMpO1xuICAgICAgICBpZiAobGFzdE5vZGVRdWFudGlmaWVyTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUxID0gbm9kZXMucG9wKCksIHF1YW50aWZpZXJOb2RlID0gbm9kZTE7IC8vL1xuICAgICAgICAgICAgcGFydCA9IHBhcnRGcm9tTm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgdmFyIHJ1bGVOYW1lID0gKDAsIF9ibmYpLnJ1bGVOYW1lRnJvbVF1YW50aWZpZXJOb2RlKHF1YW50aWZpZXJOb2RlKSwgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gY29sbGVjdGlvbk9mUGFydHNQYXJ0RnJvbVBhcnRBbmRSdWxlTmFtZShwYXJ0LCBydWxlTmFtZSk7XG4gICAgICAgICAgICBwYXJ0ID0gY29sbGVjdGlvbk9mUGFydHNQYXJ0OyAvLy9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnQ7XG59XG5mdW5jdGlvbiBpc0xhc3ROb2RlUXVhbnRpZmllck5vZGUobm9kZXMpIHtcbiAgICB2YXIgbGFzdE5vZGUgPSAoMCwgX2FycmF5KS5sYXN0KG5vZGVzKSwgbGFzdE5vZGVRdWFudGlmaWVyTm9kZSA9ICgwLCBfYm5mKS5pc05vZGVRdWFudGlmaWVyTm9kZShsYXN0Tm9kZSk7XG4gICAgcmV0dXJuIGxhc3ROb2RlUXVhbnRpZmllck5vZGU7XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnRGcm9tUGFydEFuZFJ1bGVOYW1lKHBhcnQsIHJ1bGVOYW1lKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25PZlBhcnRzUGFydDtcbiAgICBzd2l0Y2gocnVsZU5hbWUpe1xuICAgICAgICBjYXNlIF9ydWxlTmFtZXMuT3B0aW9uYWxRdWFudGlmaWVyUnVsZU5hbWU6XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJ0UGFydCA9IG5ldyBfb3B0aW9uYWxQYXJ0LmRlZmF1bHQocGFydCk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQgPSBvcHRpb25hbFBhcnRQYXJ0OyAvLy9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9ydWxlTmFtZXMuT25lT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lOlxuICAgICAgICAgICAgdmFyIG9uZU9yTW9yZVBhcnRzUGFydCA9IG5ldyBfb25lT3JNb3JlUGFydHMuZGVmYXVsdChwYXJ0KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydDsgLy8vXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfcnVsZU5hbWVzLlplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWU6XG4gICAgICAgICAgICB2YXIgemVyb09yTW9yZVBhcnRzUGFydCA9IG5ldyBfemVyb09yTW9yZVBhcnRzLmRlZmF1bHQocGFydCk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0OyAvLy9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbk9mUGFydHNQYXJ0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5d1lYSjBMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUdaeWIyMGdYQ0l1TGk4dUxpOXViMlJsTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVwYlhCdmNuUWdUM0IwYVc5dVlXeFFZWEowVUdGeWRDQm1jbTl0SUZ3aUxpNHZMaTR2Y0dGeWRDOXViMjVVWlhKdGFXNWhiQzl2Y0hScGIyNWhiRkJoY25SY0lqdGNibWx0Y0c5eWRDQlBibVZQY2sxdmNtVlFZWEowYzFCaGNuUWdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUXZibTl1VkdWeWJXbHVZV3d2YjI1bFQzSk5iM0psVUdGeWRITmNJanRjYm1sdGNHOXlkQ0JhWlhKdlQzSk5iM0psVUdGeWRITlFZWEowSUdaeWIyMGdYQ0l1TGk4dUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wzcGxjbTlQY2sxdmNtVlFZWEowYzF3aU8xeHVYRzVwYlhCdmNuUWdleUJzWVhOMElIMGdabkp2YlNCY0lpNHVMeTR1TDNWMGFXeHBkR2xsY3k5aGNuSmhlVndpTzF4dWFXMXdiM0owSUhzZ2FYTk9iMlJsVVhWaGJuUnBabWxsY2s1dlpHVXNJSEoxYkdWT1lXMWxSbkp2YlZGMVlXNTBhV1pwWlhKT2IyUmxJSDBnWm5KdmJTQmNJaTR1THk0dUwzVjBhV3hwZEdsbGN5OWlibVpjSWp0Y2JtbHRjRzl5ZENCN0lFOXdkR2x2Ym1Gc1VYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbExDQlBibVZQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVXNJRnBsY205UGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1VnZlNCbWNtOXRJRndpTGk0dkxpNHZjblZzWlU1aGJXVnpYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRkJoY25SQ1RrWk9iMlJsSUdWNGRHVnVaSE1nVG05dVZHVnliV2x1WVd4T2IyUmxJSHRjYmlBZ1oyVnVaWEpoZEdWUVlYSjBLR3h2YjJ0QmFHVmhaQ2tnZTF4dUlDQWdJR052Ym5OMElHTm9hV3hrVG05a1pYTWdQU0IwYUdsekxtZGxkRU5vYVd4a1RtOWtaWE1vS1N4Y2JpQWdJQ0FnSUNBZ0lDQnViMlJsY3lBOUlHTm9hV3hrVG05a1pYTXVjMnhwWTJVb0tTeGNiaUFnSUNBZ0lDQWdJQ0J3WVhKMElEMGdjR0Z5ZEVaeWIyMU9iMlJsY3lodWIyUmxjeWs3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjR0Z5ZER0Y2JpQWdmVnh1WEc0Z0lITjBZWFJwWXlCbWNtOXRVblZzWlU1aGJXVkJibVJEYUdsc1pFNXZaR1Z6S0hKMWJHVk9ZVzFsTENCamFHbHNaRTV2WkdWektTQjdJSEpsZEhWeWJpQk9iMjVVWlhKdGFXNWhiRTV2WkdVdVpuSnZiVkoxYkdWT1lXMWxRVzVrUTJocGJHUk9iMlJsY3loUVlYSjBRazVHVG05a1pTd2djblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wT3lCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUhCaGNuUkdjbTl0VG05a1pYTW9ibTlrWlhNcElIdGNiaUFnYkdWMElIQmhjblFnUFNCdWRXeHNPMXh1WEc0Z0lHTnZibk4wSUc1dlpHVnpUR1Z1WjNSb0lEMGdibTlrWlhNdWJHVnVaM1JvTzF4dVhHNGdJR2xtSUNodWIyUmxjMHhsYm1kMGFDQTlQVDBnTVNrZ2UxeHVJQ0FnSUdOdmJuTjBJRzV2WkdVZ1BTQnViMlJsY3k1d2IzQW9LU3hjYmlBZ0lDQWdJQ0FnSUNCc2IyOXJRV2hsWVdRZ1BTQm1ZV3h6WlR0Y2JseHVJQ0FnSUhCaGNuUWdQU0J1YjJSbExtZGxibVZ5WVhSbFVHRnlkQ2hzYjI5clFXaGxZV1FwTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdOdmJuTjBJR3hoYzNST2IyUmxVWFZoYm5ScFptbGxjazV2WkdVZ1BTQnBjMHhoYzNST2IyUmxVWFZoYm5ScFptbGxjazV2WkdVb2JtOWtaWE1wTzF4dVhHNGdJQ0FnYVdZZ0tHeGhjM1JPYjJSbFVYVmhiblJwWm1sbGNrNXZaR1VwSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJRzV2WkdVZ1BTQnViMlJsY3k1d2IzQW9LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIRjFZVzUwYVdacFpYSk9iMlJsSUQwZ2JtOWtaVHNnSUM4dkwxeHVYRzRnSUNBZ0lDQndZWEowSUQwZ2NHRnlkRVp5YjIxT2IyUmxjeWh1YjJSbGN5azdYRzVjYmlBZ0lDQWdJR052Ym5OMElISjFiR1ZPWVcxbElEMGdjblZzWlU1aGJXVkdjbTl0VVhWaGJuUnBabWxsY2s1dlpHVW9jWFZoYm5ScFptbGxjazV2WkdVcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5c2JHVmpkR2x2Yms5bVVHRnlkSE5RWVhKMElEMGdZMjlzYkdWamRHbHZiazltVUdGeWRITlFZWEowUm5KdmJWQmhjblJCYm1SU2RXeGxUbUZ0WlNod1lYSjBMQ0J5ZFd4bFRtRnRaU2s3WEc1Y2JpQWdJQ0FnSUhCaGNuUWdQU0JqYjJ4c1pXTjBhVzl1VDJaUVlYSjBjMUJoY25RN0lDOHZMMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCdWIyUmxjeTV6YUdsbWRDZ3BPMXh1WEc0Z0lDQWdJQ0J3WVhKMElEMGdjR0Z5ZEVaeWIyMU9iMlJsY3lodWIyUmxjeWs3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSEJoY25RN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdselRHRnpkRTV2WkdWUmRXRnVkR2xtYVdWeVRtOWtaU2h1YjJSbGN5a2dlMXh1SUNCamIyNXpkQ0JzWVhOMFRtOWtaU0E5SUd4aGMzUW9ibTlrWlhNcExGeHVJQ0FnSUNBZ0lDQnNZWE4wVG05a1pWRjFZVzUwYVdacFpYSk9iMlJsSUQwZ2FYTk9iMlJsVVhWaGJuUnBabWxsY2s1dlpHVW9iR0Z6ZEU1dlpHVXBPMXh1WEc0Z0lISmxkSFZ5YmlCc1lYTjBUbTlrWlZGMVlXNTBhV1pwWlhKT2IyUmxPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpiMnhzWldOMGFXOXVUMlpRWVhKMGMxQmhjblJHY205dFVHRnlkRUZ1WkZKMWJHVk9ZVzFsS0hCaGNuUXNJSEoxYkdWT1lXMWxLU0I3WEc0Z0lHeGxkQ0JqYjJ4c1pXTjBhVzl1VDJaUVlYSjBjMUJoY25RN1hHNWNiaUFnYzNkcGRHTm9JQ2h5ZFd4bFRtRnRaU2tnZTF4dUlDQWdJR05oYzJVZ1QzQjBhVzl1WVd4UmRXRnVkR2xtYVdWeVVuVnNaVTVoYldVZ09seHVJQ0FnSUNBZ1kyOXVjM1FnYjNCMGFXOXVZV3hRWVhKMFVHRnlkQ0E5SUc1bGR5QlBjSFJwYjI1aGJGQmhjblJRWVhKMEtIQmhjblFwTzF4dVhHNGdJQ0FnSUNCamIyeHNaV04wYVc5dVQyWlFZWEowYzFCaGNuUWdQU0J2Y0hScGIyNWhiRkJoY25SUVlYSjBPeUF2THk5Y2JpQWdJQ0FnSUdKeVpXRnJPMXh1WEc0Z0lDQWdZMkZ6WlNCUGJtVlBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaVTVoYldVZ09seHVJQ0FnSUNBZ1kyOXVjM1FnYjI1bFQzSk5iM0psVUdGeWRITlFZWEowSUQwZ2JtVjNJRTl1WlU5eVRXOXlaVkJoY25SelVHRnlkQ2h3WVhKMEtUdGNibHh1SUNBZ0lDQWdZMjlzYkdWamRHbHZiazltVUdGeWRITlFZWEowSUQwZ2IyNWxUM0pOYjNKbFVHRnlkSE5RWVhKME95QXZMeTljYmlBZ0lDQWdJR0p5WldGck8xeHVYRzRnSUNBZ1kyRnpaU0JhWlhKdlQzSk5iM0psVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsSURwY2JpQWdJQ0FnSUdOdmJuTjBJSHBsY205UGNrMXZjbVZRWVhKMGMxQmhjblFnUFNCdVpYY2dXbVZ5YjA5eVRXOXlaVkJoY25SelVHRnlkQ2h3WVhKMEtUdGNibHh1SUNBZ0lDQWdZMjlzYkdWamRHbHZiazltVUdGeWRITlFZWEowSUQwZ2VtVnliMDl5VFc5eVpWQmhjblJ6VUdGeWREc2dJQzh2TDF4dUlDQWdJQ0FnWW5KbFlXczdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdZMjlzYkdWamRHbHZiazltVUdGeWRITlFZWEowTzF4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxCaGNuUkNUa1pPYjJSbElpd2laMlZ1WlhKaGRHVlFZWEowSWl3aWJHOXZhMEZvWldGa0lpd2lZMmhwYkdST2IyUmxjeUlzSW1kbGRFTm9hV3hrVG05a1pYTWlMQ0p1YjJSbGN5SXNJbk5zYVdObElpd2ljR0Z5ZENJc0luQmhjblJHY205dFRtOWtaWE1pTENKbWNtOXRVblZzWlU1aGJXVkJibVJEYUdsc1pFNXZaR1Z6SWl3aWNuVnNaVTVoYldVaUxDSk9iMjVVWlhKdGFXNWhiRTV2WkdVaUxDSnViMlJsYzB4bGJtZDBhQ0lzSW14bGJtZDBhQ0lzSW01dlpHVWlMQ0p3YjNBaUxDSnNZWE4wVG05a1pWRjFZVzUwYVdacFpYSk9iMlJsSWl3aWFYTk1ZWE4wVG05a1pWRjFZVzUwYVdacFpYSk9iMlJsSWl3aWNYVmhiblJwWm1sbGNrNXZaR1VpTENKeWRXeGxUbUZ0WlVaeWIyMVJkV0Z1ZEdsbWFXVnlUbTlrWlNJc0ltTnZiR3hsWTNScGIyNVBabEJoY25SelVHRnlkQ0lzSW1OdmJHeGxZM1JwYjI1UFpsQmhjblJ6VUdGeWRFWnliMjFRWVhKMFFXNWtVblZzWlU1aGJXVWlMQ0p6YUdsbWRDSXNJbXhoYzNST2IyUmxJaXdpYkdGemRDSXNJbWx6VG05a1pWRjFZVzUwYVdacFpYSk9iMlJsSWl3aVQzQjBhVzl1WVd4UmRXRnVkR2xtYVdWeVVuVnNaVTVoYldVaUxDSnZjSFJwYjI1aGJGQmhjblJRWVhKMElpd2lUM0IwYVc5dVlXeFFZWEowVUdGeWRDSXNJazl1WlU5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU0lzSW05dVpVOXlUVzl5WlZCaGNuUnpVR0Z5ZENJc0lrOXVaVTl5VFc5eVpWQmhjblJ6VUdGeWRDSXNJbHBsY205UGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1VpTENKNlpYSnZUM0pOYjNKbFVHRnlkSE5RWVhKMElpd2lXbVZ5YjA5eVRXOXlaVkJoY25SelVHRnlkQ0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVUwUWl4SlFVRkJMRmxCUVhkQ0xHdERRVUY0UWl4M1FrRkJkMElzUlVGQlFUdEJRVU4yUWl4SlFVRkJMR0ZCUVhGRExHdERRVUZ5UXl4eFEwRkJjVU1zUlVGQlFUdEJRVU51UXl4SlFVRkJMR1ZCUVhWRExHdERRVUYyUXl4MVEwRkJkVU1zUlVGQlFUdEJRVU4wUXl4SlFVRkJMR2RDUVVGM1F5eHJRMEZCZUVNc2QwTkJRWGRETEVWQlFVRTdRVUZGYmtRc1NVRkJRU3hOUVVGMVFpeFhRVUYyUWl4MVFrRkJkVUlzUTBGQlFUdEJRVU54UWl4SlFVRkJMRWxCUVhGQ0xGZEJRWEpDTEhGQ1FVRnhRaXhEUVVGQk8wRkJRMmRDTEVsQlFVRXNWVUZCYVVJc1YwRkJha0lzYVVKQlFXbENMRU5CUVVFN096czdPenM3T3pzN096czdPenM0UkVGVWRrZzdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJWMlVzU1VGQlFTeEJRVUZOUVN4WFFVRlhMR2xDUVZrM1FpeEJRVnBaT3pKRFFWaG1PenRoUVZkeFFrRXNWMEZCVnpzd1EwRllhRU03T3pzN08xbEJXVVZETEVkQlFWa3NSVUZCV2tFc1kwRkJXVHRaUTFwa0xFOUVXVVZCTEZOQlFVRkJMRmxCUVZrc1EwRkJRME1zVTBGQlV5eEZRVUZGTzJkQ1FVTjBRaXhKUVVGTlF5eFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhoUVVGaExFVkJRVVVzUlVGRGFrTkRMRXRCUVVzc1IwRkJSMFlzVlVGQlZTeERRVUZEUnl4TFFVRkxMRVZCUVVVc1JVRkRNVUpETEVsQlFVa3NSMEZCUjBNc1lVRkJZU3hEUVVGRFNDeExRVUZMTEVOQlFVTXNRVUZCUXp0blFrRkZiRU1zVDBGQlQwVXNTVUZCU1N4RFFVRkRPMkZCUTJJN096czdXVUZGVFVVc1IwRkJlVUlzUlVGQmVrSkJMREpDUVVGNVFqdFpRM0JDYkVNc1QwUnZRa1VzVTBGQlQwRXNlVUpCUVhsQ0xFTkJRVU5ETEZGQlFWRXNSVUZCUlZBc1ZVRkJWU3hGUVVGRk8yZENRVUZGTEU5QlFVOVJMRmxCUVdVc1UwRkJRMFlzZVVKQlFYbENMRU5CUVVOVUxGZEJRVmNzUlVGQlJWVXNVVUZCVVN4RlFVRkZVQ3hWUVVGVkxFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFYQkNha283TzBOQmNVSkRMRU5CVm5kRFVTeFpRVUZsTEZOQlZYWkVPMnRDUVZadlFsZ3NWMEZCVnl4QlFWaG9RenRCUVhWQ1FTeFRRVUZUVVN4aFFVRmhMRU5CUVVOSUxFdEJRVXNzUlVGQlJUdEpRVU0xUWl4SlFVRkpSU3hKUVVGSkxFZEJRVWNzU1VGQlNTeEJRVUZETzBsQlJXaENMRWxCUVUxTExGZEJRVmNzUjBGQlIxQXNTMEZCU3l4RFFVRkRVU3hOUVVGTkxFRkJRVU03U1VGRmFrTXNTVUZCU1VRc1YwRkJWeXhMUVVGTExFTkJRVU1zUlVGQlJUdFJRVU55UWl4SlFVRk5SU3hKUVVGSkxFZEJRVWRVTEV0QlFVc3NRMEZCUTFVc1IwRkJSeXhGUVVGRkxFVkJRMnhDWWl4VFFVRlRMRWRCUVVjc1MwRkJTeXhCUVVGRE8xRkJSWGhDU3l4SlFVRkpMRWRCUVVkUExFbEJRVWtzUTBGQlEySXNXVUZCV1N4RFFVRkRReXhUUVVGVExFTkJRVU1zUTBGQlF6dExRVU55UXl4TlFVRk5PMUZCUTB3c1NVRkJUV01zYzBKQlFYTkNMRWRCUVVkRExIZENRVUYzUWl4RFFVRkRXaXhMUVVGTExFTkJRVU1zUVVGQlF6dFJRVVV2UkN4SlFVRkpWeXh6UWtGQmMwSXNSVUZCUlR0WlFVTXhRaXhKUVVGTlJpeExRVUZKTEVkQlFVZFVMRXRCUVVzc1EwRkJRMVVzUjBGQlJ5eEZRVUZGTEVWQlEyeENSeXhqUVVGakxFZEJRVWRLTEV0QlFVa3NRVUZCUXl4RlFVRkZMRWRCUVVjN1dVRkZha05RTEVsQlFVa3NSMEZCUjBNc1lVRkJZU3hEUVVGRFNDeExRVUZMTEVOQlFVTXNRMEZCUXp0WlFVVTFRaXhKUVVGTlN5eFJRVUZSTEVkQlFVZFRMRU5CUVVGQkxFZEJRVUZCTEVsQlFUQkNMRUZCUVdkQ0xFTkJRVUVzTkVKQlFXWkVMR05CUVdNc1EwRkJReXhGUVVOeVJFVXNjVUpCUVhGQ0xFZEJRVWRETEhkRFFVRjNReXhEUVVGRFpDeEpRVUZKTEVWQlFVVkhMRkZCUVZFc1EwRkJReXhCUVVGRE8xbEJSWFpHU0N4SlFVRkpMRWRCUVVkaExIRkNRVUZ4UWl4RFFVRkRMRU5CUVVNc1IwRkJSenRUUVVOc1F5eE5RVUZOTzFsQlEweG1MRXRCUVVzc1EwRkJRMmxDTEV0QlFVc3NSVUZCUlN4RFFVRkRPMWxCUldSbUxFbEJRVWtzUjBGQlIwTXNZVUZCWVN4RFFVRkRTQ3hMUVVGTExFTkJRVU1zUTBGQlF6dFRRVU0zUWp0TFFVTkdPMGxCUlVRc1QwRkJUMFVzU1VGQlNTeERRVUZETzBOQlEySTdRVUZGUkN4VFFVRlRWU3gzUWtGQmQwSXNRMEZCUTFvc1MwRkJTeXhGUVVGRk8wbEJRM1pETEVsQlFVMXJRaXhSUVVGUkxFZEJRVWRETEVOQlFVRkJMRWRCUVVGQkxFMUJRVWtzUVVGQlR5eERRVUZCTEUxQlFVNXVRaXhMUVVGTExFTkJRVU1zUlVGRGRFSlhMSE5DUVVGelFpeEhRVUZIVXl4RFFVRkJRU3hIUVVGQlFTeEpRVUZ2UWl4QlFVRlZMRU5CUVVFc2MwSkJRVlJHTEZGQlFWRXNRMEZCUXl4QlFVRkRPMGxCUlRsRUxFOUJRVTlRTEhOQ1FVRnpRaXhEUVVGRE8wTkJReTlDTzBGQlJVUXNVMEZCVTBzc2QwTkJRWGRETEVOQlFVTmtMRWxCUVVrc1JVRkJSVWNzVVVGQlVTeEZRVUZGTzBsQlEyaEZMRWxCUVVsVkxIRkNRVUZ4UWl4QlFVRkRPMGxCUlRGQ0xFOUJRVkZXTEZGQlFWRTdVVUZEWkN4TFFVRkxaMElzVlVGQk1FSTdXVUZETjBJc1NVRkJUVU1zWjBKQlFXZENMRWRCUVVjc1NVRkJTVU1zWVVGQlowSXNVMEZCUTNKQ0xFbEJRVWtzUTBGQlF5eEJRVUZETzFsQlJYQkVZU3h4UWtGQmNVSXNSMEZCUjA4c1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4SFFVRkhPMWxCUXpkRExFMUJRVTA3VVVGRlVpeExRVUZMUlN4VlFVRXlRanRaUVVNNVFpeEpRVUZOUXl4clFrRkJhMElzUjBGQlJ5eEpRVUZKUXl4bFFVRnJRaXhUUVVGRGVFSXNTVUZCU1N4RFFVRkRMRUZCUVVNN1dVRkZlRVJoTEhGQ1FVRnhRaXhIUVVGSFZTeHJRa0ZCYTBJc1EwRkJReXhEUVVGRExFZEJRVWM3V1VGREwwTXNUVUZCVFR0UlFVVlNMRXRCUVV0RkxGVkJRVFJDTzFsQlF5OUNMRWxCUVUxRExHMUNRVUZ0UWl4SFFVRkhMRWxCUVVsRExHZENRVUZ0UWl4VFFVRkRNMElzU1VGQlNTeERRVUZETEVGQlFVTTdXVUZGTVVSaExIRkNRVUZ4UWl4SFFVRkhZU3h0UWtGQmJVSXNRMEZCUXl4RFFVRkZMRWRCUVVjN1dVRkRha1FzVFVGQlRUdExRVU5VTzBsQlJVUXNUMEZCVDJJc2NVSkJRWEZDTEVOQlFVTTdRMEZET1VJaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCIpKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcbnZhciBfcGFydFR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3BhcnRUeXBlc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIGVsbGlwc2lzID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmVsbGlwc2lzO1xudmFyIFJ1bGVOYW1lUGFydCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxQYXJ0KSB7XG4gICAgX2luaGVyaXRzKFJ1bGVOYW1lUGFydCwgTm9uVGVybWluYWxQYXJ0KTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJ1bGVOYW1lUGFydCk7XG4gICAgZnVuY3Rpb24gUnVsZU5hbWVQYXJ0KHJ1bGVOYW1lKSB7XG4gICAgICAgIHZhciBsb29rQWhlYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZU5hbWVQYXJ0KTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICB2YXIgdHlwZSA9IF9wYXJ0VHlwZXMuUnVsZU5hbWVQYXJ0VHlwZTsgLy8vXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIF90aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgICAgIF90aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUnVsZU5hbWVQYXJ0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRSdWxlTmFtZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGVOYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNMb29rQWhlYWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xvb2tBaGVhZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rQWhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc1J1bGVOYW1lUGFydFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUnVsZU5hbWVQYXJ0KCkge1xuICAgICAgICAgICAgICAgIHZhciBydWxlTmFtZVBhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJzZXRMb29rQWhlYWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmaW5kUnVsZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRSdWxlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVNYXAgPSBzdGF0ZS5nZXRSdWxlTWFwKCksIHJ1bGUgPSBydWxlTWFwW3RoaXMucnVsZU5hbWVdIHx8IG51bGw7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMuZmluZFJ1bGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChydWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydWxlTm9kZSA9IHJ1bGUucGFyc2Uoc3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gcnVsZU5vZGUgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gocnVsZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBsb29rQWhlYWRTdHJpbmcgPSB0aGlzLmxvb2tBaGVhZCA/IGVsbGlwc2lzIDogX2NvbnN0YW50cy5FTVBUWV9TVFJJTkcsIHN0cmluZyA9IFwiXCIuY29uY2F0KHRoaXMucnVsZU5hbWUpLmNvbmNhdChsb29rQWhlYWRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihSdWxlTmFtZVBhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIFJ1bGVOYW1lUGFydCwgdGhpcy5ydWxlTmFtZSwgdGhpcy5sb29rQWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJ1bGVOYW1lUGFydDtcbn0oX25vblRlcm1pbmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUnVsZU5hbWVQYXJ0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDNKMWJHVk9ZVzFsTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdleUJ6Y0dWamFXRnNVM2x0WW05c2N5QjlJR1p5YjIwZ1hDSnZZMk5oYlMxc1pYaGxjbk5jSWp0Y2JseHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNVR0Z5ZENCbWNtOXRJRndpTGk0dkxpNHZjR0Z5ZEM5dWIyNVVaWEp0YVc1aGJGd2lPMXh1WEc1cGJYQnZjblFnZXlCRlRWQlVXVjlUVkZKSlRrY2dmU0JtY205dElGd2lMaTR2TGk0dlkyOXVjM1JoYm5SelhDSTdYRzVwYlhCdmNuUWdleUJTZFd4bFRtRnRaVkJoY25SVWVYQmxJSDBnWm5KdmJTQmNJaTR1THk0dUwzQmhjblJVZVhCbGMxd2lPMXh1WEc1amIyNXpkQ0I3SUdWc2JHbHdjMmx6SUgwZ1BTQnpjR1ZqYVdGc1UzbHRZbTlzY3p0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVW5Wc1pVNWhiV1ZRWVhKMElHVjRkR1Z1WkhNZ1RtOXVWR1Z5YldsdVlXeFFZWEowSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY25Wc1pVNWhiV1VzSUd4dmIydEJhR1ZoWkNBOUlHWmhiSE5sS1NCN1hHNGdJQ0FnWTI5dWMzUWdkSGx3WlNBOUlGSjFiR1ZPWVcxbFVHRnlkRlI1Y0dVN0lDOHZMMXh1WEc0Z0lDQWdjM1Z3WlhJb2RIbHdaU2s3WEc1Y2JpQWdJQ0IwYUdsekxuSjFiR1ZPWVcxbElEMGdjblZzWlU1aGJXVTdYRzVjYmlBZ0lDQjBhR2x6TG14dmIydEJhR1ZoWkNBOUlHeHZiMnRCYUdWaFpEdGNiaUFnZlZ4dUlDQmNiaUFnWjJWMFVuVnNaVTVoYldVb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjblZzWlU1aGJXVTdYRzRnSUgxY2JseHVJQ0JwYzB4dmIydEJhR1ZoWkNncElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NXNiMjlyUVdobFlXUTdYRzRnSUgxY2JseHVJQ0JwYzFKMWJHVk9ZVzFsVUdGeWRDZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCeWRXeGxUbUZ0WlZCaGNuUWdQU0IwY25WbE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhKMWJHVk9ZVzFsVUdGeWREdGNiaUFnZlZ4dVhHNGdJSE5sZEV4dmIydEJhR1ZoWkNoc2IyOXJRV2hsWVdRcElIdGNiaUFnSUNCMGFHbHpMbXh2YjJ0QmFHVmhaQ0E5SUd4dmIydEJhR1ZoWkR0Y2JpQWdmVnh1WEc0Z0lHWnBibVJTZFd4bEtITjBZWFJsS1NCN1hHNGdJQ0FnWTI5dWMzUWdjblZzWlUxaGNDQTlJSE4wWVhSbExtZGxkRkoxYkdWTllYQW9LU3hjYmlBZ0lDQWdJQ0FnSUNCeWRXeGxJRDBnY25Wc1pVMWhjRnQwYUdsekxuSjFiR1ZPWVcxbFhTQjhmQ0J1ZFd4c095QWdMeTh2WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjblZzWlR0Y2JpQWdmVnh1WEc0Z0lIQmhjbk5sS0c1dlpHVnpMQ0J6ZEdGMFpTd2dZMkZzYkdKaFkyc3BJSHRjYmlBZ0lDQnNaWFFnY0dGeWMyVmtPMXh1WEc0Z0lDQWdZMjl1YzNRZ2NuVnNaU0E5SUhSb2FYTXVabWx1WkZKMWJHVW9jM1JoZEdVcE8xeHVYRzRnSUNBZ2FXWWdLSEoxYkdVZ1BUMDlJRzUxYkd3cElIdGNiaUFnSUNBZ0lIQmhjbk5sWkNBOUlHWmhiSE5sTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmpiMjV6ZENCeWRXeGxUbTlrWlNBOUlISjFiR1V1Y0dGeWMyVW9jM1JoZEdVc0lHTmhiR3hpWVdOcktUdGNibHh1SUNBZ0lDQWdjR0Z5YzJWa0lEMGdLSEoxYkdWT2IyUmxJQ0U5UFNCdWRXeHNLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tIQmhjbk5sWkNrZ2UxeHVJQ0FnSUNBZ0lDQnViMlJsY3k1d2RYTm9LSEoxYkdWT2IyUmxLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200Z2NHRnljMlZrTzF4dUlDQjlYRzVjYmlBZ1lYTlRkSEpwYm1jb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYkc5dmEwRm9aV0ZrVTNSeWFXNW5JRDBnZEdocGN5NXNiMjlyUVdobFlXUWdQMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1pXeHNhWEJ6YVhNZ09seHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCRlRWQlVXVjlUVkZKSlRrY3NYRzRnSUNBZ0lDQWdJQ0FnYzNSeWFXNW5JRDBnWUNSN2RHaHBjeTV5ZFd4bFRtRnRaWDBrZTJ4dmIydEJhR1ZoWkZOMGNtbHVaMzFnTzF4dVhHNGdJQ0FnY21WMGRYSnVJSE4wY21sdVp6dGNiaUFnZlZ4dVhHNGdJR05zYjI1bEtDa2dleUJ5WlhSMWNtNGdjM1Z3WlhJdVkyeHZibVVvVW5Wc1pVNWhiV1ZRWVhKMExDQjBhR2x6TG5KMWJHVk9ZVzFsTENCMGFHbHpMbXh2YjJ0QmFHVmhaQ2s3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKbGJHeHBjSE5wY3lJc0luTndaV05wWVd4VGVXMWliMnh6SWl3aVVuVnNaVTVoYldWUVlYSjBJaXdpY25Wc1pVNWhiV1VpTENKc2IyOXJRV2hsWVdRaUxDSjBlWEJsSWl3aVVuVnNaVTVoYldWUVlYSjBWSGx3WlNJc0ltZGxkRkoxYkdWT1lXMWxJaXdpYVhOTWIyOXJRV2hsWVdRaUxDSnBjMUoxYkdWT1lXMWxVR0Z5ZENJc0luSjFiR1ZPWVcxbFVHRnlkQ0lzSW5ObGRFeHZiMnRCYUdWaFpDSXNJbVpwYm1SU2RXeGxJaXdpYzNSaGRHVWlMQ0p5ZFd4bFRXRndJaXdpWjJWMFVuVnNaVTFoY0NJc0luSjFiR1VpTENKd1lYSnpaU0lzSW01dlpHVnpJaXdpWTJGc2JHSmhZMnNpTENKd1lYSnpaV1FpTENKeWRXeGxUbTlrWlNJc0luQjFjMmdpTENKaGMxTjBjbWx1WnlJc0lteHZiMnRCYUdWaFpGTjBjbWx1WnlJc0lrVk5VRlJaWDFOVVVrbE9SeUlzSW5OMGNtbHVaeUlzSW1Oc2IyNWxJaXdpVG05dVZHVnliV2x1WVd4UVlYSjBJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSU3RDTEVsQlFVRXNXVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHRCUVVWcVFpeEpRVUZCTEZsQlFYZENMR3REUVVGNFFpeDNRa0ZCZDBJc1JVRkJRVHRCUVVWMlFpeEpRVUZCTEZWQlFXbENMRmRCUVdwQ0xHbENRVUZwUWl4RFFVRkJPMEZCUTJJc1NVRkJRU3hWUVVGcFFpeFhRVUZxUWl4cFFrRkJhVUlzUTBGQlFUczdPenM3T3pzN096czdPenM3T3poRVFWQnNSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3TUVKQlFVRTdPenM3T3pzN096czdVMEZCUVRzN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzN2QwTkJRVUU3T3pzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVTBFc1NVRkJUU3hCUVVGRlFTeFJRVUZSTEVkQlFVdERMRmxCUVdNc1owSkJRVE5DUkN4UlFVRlJMRUZCUVcxQ0xFRkJRVU03UVVGRmNrSXNTVUZCUVN4QlFVRk5SU3haUVVGWkxHbENRMWc1UWl4QlJGZFpPelJEUVZobU96dGhRVmR4UWtFc1dVRkJXU3hEUVVOdVFrTXNVVUZCVVR0WlFVRkZReXhUUVVGVExFZEJRVlJCTEN0RFFVRnBRaXhyUWtGQlRDeExRVUZMT3pKRFFWcDZRenM3VVVGaFNTeEpRVUZOUXl4SlFVRkpMRWRCUVVkRExGVkJRV2RDTEdsQ1FVRkJMRUZCUVVNc1JVRkJReXhIUVVGSE8ydERRVVUxUWtRc1NVRkJTU3hEUldaa0xFTkdaV2RDTzFGQlJWb3NUVUZCUzBZc1VVRkJVU3hIUVVGSFFTeFJRVUZSTEVOQlFVTTdVVUZGZWtJc1RVRkJTME1zVTBGQlV5eEhRVUZIUVN4VFFVRlRMRU5CUVVNN096czdPMWxCUnpkQ1J5eEhRVUZYTEVWQlFWaEJMR0ZCUVZjN1dVVjBRbUlzVDBaelFrVkJMRk5CUVVGQkxGZEJRVmNzUjBGQlJ6dG5Ra0ZEV2l4UFFVRlBMRWxCUVVrc1EwRkJRMG9zVVVGQlVTeERRVUZETzJGQlEzUkNPenM3V1VGRlJFc3NSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZNVUppTEU5R01FSkZRU3hUUVVGQlFTeFhRVUZYTEVkQlFVYzdaMEpCUTFvc1QwRkJUeXhKUVVGSkxFTkJRVU5LTEZOQlFWTXNRMEZCUXp0aFFVTjJRanM3TzFsQlJVUkxMRWRCUVdNc1JVRkJaRUVzWjBKQlFXTTdXVVU1UW1oQ0xFOUdPRUpGUVN4VFFVRkJRU3hqUVVGakxFZEJRVWM3WjBKQlEyWXNTVUZCVFVNc1dVRkJXU3hIUVVGSExFbEJRVWtzUVVGQlF6dG5Ra0ZGTVVJc1QwRkJUMEVzV1VGQldTeERRVUZETzJGQlEzSkNPenM3V1VGRlJFTXNSMEZCV1N4RlFVRmFRU3hqUVVGWk8xbEZjRU5rTEU5R2IwTkZRU3hUUVVGQlFTeFpRVUZaTEVOQlFVTlFMRk5CUVZNc1JVRkJSVHRuUWtGRGRFSXNTVUZCU1N4RFFVRkRRU3hUUVVGVExFZEJRVWRCTEZOQlFWTXNRMEZCUXp0aFFVTTFRanM3TzFsQlJVUlJMRWRCUVZFc1JVRkJVa0VzVlVGQlVUdFpSWGhEVml4UFJuZERSVUVzVTBGQlFVRXNVVUZCVVN4RFFVRkRReXhMUVVGTExFVkJRVVU3WjBKQlEyUXNTVUZCVFVNc1QwRkJUeXhIUVVGSFJDeExRVUZMTEVOQlFVTkZMRlZCUVZVc1JVRkJSU3hGUVVNMVFrTXNTVUZCU1N4SFFVRkhSaXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZEV0N4UlFVRlJMRU5CUVVNc1NVRkJTU3hKUVVGSkxFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVnFSQ3hQUVVGUFlTeEpRVUZKTEVOQlFVTTdZVUZEWWpzN08xbEJSVVJETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlM5RFVDeFBSaXREUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4TFFVRkxMRVZCUVVWTUxFdEJRVXNzUlVGQlJVMHNVVUZCVVN4RlFVRkZPMmRDUVVNMVFpeEpRVUZKUXl4TlFVRk5MRUZCUVVNN1owSkJSVmdzU1VGQlRVb3NTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJRMG9zVVVGQlVTeERRVUZEUXl4TFFVRkxMRU5CUVVNc1FVRkJRenRuUWtGRmJFTXNTVUZCU1Vjc1NVRkJTU3hMUVVGTExFbEJRVWtzUlVGQlJUdHZRa0ZEYWtKSkxFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTTdhVUpCUTJoQ0xFMUJRVTA3YjBKQlEwd3NTVUZCVFVNc1VVRkJVU3hIUVVGSFRDeEpRVUZKTEVOQlFVTkRMRXRCUVVzc1EwRkJRMG9zUzBGQlN5eEZRVUZGVFN4UlFVRlJMRU5CUVVNc1FVRkJRenR2UWtGRk4wTkRMRTFCUVUwc1IwRkJTVU1zVVVGQlVTeExRVUZMTEVsQlFVa3NRVUZCUXl4RFFVRkRPMjlDUVVVM1FpeEpRVUZKUkN4TlFVRk5MRVZCUVVVN2QwSkJRMVpHTEV0QlFVc3NRMEZCUTBrc1NVRkJTU3hEUVVGRFJDeFJRVUZSTEVOQlFVTXNRMEZCUXp0eFFrRkRkRUk3YVVKQlEwWTdaMEpCUlVRc1QwRkJUMFFzVFVGQlRTeERRVUZETzJGQlEyWTdPenRaUVVWRVJ5eEhRVUZSTEVWQlFWSkJMRlZCUVZFN1dVVnVSVllzVDBadFJVVkJMRk5CUVVGQkxGRkJRVkVzUjBGQlJ6dG5Ra0ZEVkN4SlFVRk5ReXhsUVVGbExFZEJRVWNzU1VGQlNTeERRVUZEY0VJc1UwRkJVeXhIUVVOYVNpeFJRVUZSTEVkQlEwNTVRaXhWUVVGWkxHRkJRVUVzUlVGRGJFTkRMRTFCUVUwc1IwRkJSeXhCUVVGRExFVkJRVUVzUTBGQmEwSkdMRTFCUVdVc1EwRkJMMElzU1VGQlNTeERRVUZEY2tJc1VVRkJVU3hEUVVGdFFpeERRVUZCTEUxQlFVRXNRMEZCYUVKeFFpeGxRVUZsTEVOQlFVVXNRVUZCUXp0blFrRkZjRVFzVDBGQlQwVXNUVUZCVFN4RFFVRkRPMkZCUTJZN096dFpRVVZFUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VVMVJWQXNUMFkwUlVWQkxGTkJRVUZCTEV0QlFVc3NSMEZCUnp0blFrRkJSU3hQUVVGUExIRkNRV3BGUlhwQ0xGbEJRVmtzWVVGcFJWSjVRaXhQUVVGTExFVkJRVmdzU1VGQlN5eERRVUZCTEZsQlFVOTZRaXhaUVVGWkxFVkJRVVVzU1VGQlNTeERRVUZEUXl4UlFVRlJMRVZCUVVVc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVWQlFVVTdZVUZCUlRzN1RVRTFSVGxGT3p0RFFUWkZReXhEUVd4RmVVTjNRaXhaUVVGbExGTkJhMFY0UkR0clFrRnNSVzlDTVVJc1dVRkJXU3hCUVZocVF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfcnVsZU5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBSdWxlTmFtZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoUnVsZU5hbWVEZWZpbml0aW9uLCBEZWZpbml0aW9uKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJ1bGVOYW1lRGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gUnVsZU5hbWVEZWZpbml0aW9uKHJ1bGVOYW1lKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdWxlTmFtZURlZmluaXRpb24pO1xuICAgICAgICB2YXIgcnVsZU5hbWVSdWxlTmFtZVBhcnQgPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQocnVsZU5hbWUpLCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHJ1bGVOYW1lUnVsZU5hbWVQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBSdWxlTmFtZURlZmluaXRpb247XG59KF9kZWZpbml0aW9uLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUnVsZU5hbWVEZWZpbml0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrWldacGJtbDBhVzl1TDNKMWJHVk9ZVzFsTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdSR1ZtYVc1cGRHbHZiaUJtY205dElGd2lMaTR2WkdWbWFXNXBkR2x2Ymx3aU8xeHVhVzF3YjNKMElGSjFiR1ZPWVcxbFVHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOXViMjVVWlhKdGFXNWhiQzl5ZFd4bFRtRnRaVndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJTZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRnWlhoMFpXNWtjeUJFWldacGJtbDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY25Wc1pVNWhiV1VwSUh0Y2JpQWdJQ0JqYjI1emRDQnlkV3hsVG1GdFpWSjFiR1ZPWVcxbFVHRnlkQ0E5SUc1bGR5QlNkV3hsVG1GdFpWQmhjblFvY25Wc1pVNWhiV1VwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnY25Wc1pVNWhiV1ZTZFd4bFRtRnRaVkJoY25SY2JpQWdJQ0FnSUNBZ0lDQmRPMXh1SUNBZ0lGeHVJQ0FnSUhOMWNHVnlLSEJoY25SektWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1SWl3aWNuVnNaVTVoYldVaUxDSnlkV3hsVG1GdFpWSjFiR1ZPWVcxbFVHRnlkQ0lzSWxKMWJHVk9ZVzFsVUdGeWRDSXNJbkJoY25Seklpd2lSR1ZtYVc1cGRHbHZiaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVYxUWl4SlFVRkJMRmRCUVdVc2EwTkJRV1lzWlVGQlpTeEZRVUZCTzBGQlEySXNTVUZCUVN4VFFVRTRRaXhyUTBGQk9VSXNPRUpCUVRoQ0xFVkJRVUU3T3pzN096czdPenM3T3pzN096dExRVWgyUkRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVdGxMRWxCUVVFc1FVRkJUVUVzYTBKQlFXdENMR2xDUTB4d1F5eEJSRXRaT3paRFFVeG1PenRoUVV0eFFrRXNhMEpCUVd0Q0xFTkJRM3BDUXl4UlFVRlJPMmxFUVU1MFFqdFJRVTlKTEVsQlFVMURMRzlDUVVGdlFpeEhRVUZITEVsQlFVbERMRk5CUVZrc1UwRkJRMFlzVVVGQlVTeERRVUZETEVWQlEycEVSeXhMUVVGTExFZEJRVWM3V1VGRFRrWXNiMEpCUVc5Q08xTkJRM0pDTEVGQlFVTTdhVU5CUlVaRkxFdEJRVXM3T3p0RFFVVmtMRU5CVkN0RFF5eFhRVUZWTEZOQlUzcEVPMnRDUVZSdlFrd3NhMEpCUVd0Q0xFRkJUSFpESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2RlZmluaXRpb25cIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIikpO1xudmFyIF96ZXJvT3JNb3JlUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi8uLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24pO1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24pO1xuICAgICAgICB2YXIgcXVhbnRpZmllclJ1bGVOYW1lID0gX3J1bGVOYW1lcy5RdWFudGlmaWVyUnVsZU5hbWUsIHRlcm1pbmFsUGFydFJ1bGVOYW1lID0gX3J1bGVOYW1lcy5UZXJtaW5hbFBhcnRSdWxlTmFtZSwgcXVhbnRpZmllclJ1bGVOYW1lUGFydCA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChxdWFudGlmaWVyUnVsZU5hbWUpLCB0ZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQgPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQodGVybWluYWxQYXJ0UnVsZU5hbWUpLCB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0ID0gbmV3IF96ZXJvT3JNb3JlUGFydHMuZGVmYXVsdChxdWFudGlmaWVyUnVsZU5hbWVQYXJ0KSwgcGFydHMgPSBbXG4gICAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBUZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMM0JoY25SU2RXeGxMM1JsY20xcGJtRnNMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZMaTR2WkdWbWFXNXBkR2x2Ymx3aU8xeHVhVzF3YjNKMElGSjFiR1ZPWVcxbFVHRnlkQ0JtY205dElGd2lMaTR2TGk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5eWRXeGxUbUZ0WlZ3aU8xeHVhVzF3YjNKMElGcGxjbTlQY2sxdmNtVlFZWEowYzFCaGNuUWdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUXZibTl1VkdWeWJXbHVZV3d2ZW1WeWIwOXlUVzl5WlZCaGNuUnpYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTd2dWR1Z5YldsdVlXeFFZWEowVW5Wc1pVNWhiV1VnZlNCbWNtOXRJRndpTGk0dkxpNHZjblZzWlU1aGJXVnpYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRlJsY20xcGJtRnNVR0Z5ZEZKMWJHVkVaV1pwYm1sMGFXOXVJR1Y0ZEdWdVpITWdSR1ZtYVc1cGRHbHZiaUI3WEc0Z0lHTnZibk4wY25WamRHOXlLQ2tnZTF4dUlDQWdJR052Ym5OMElIRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTQTlJRkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNCMFpYSnRhVzVoYkZCaGNuUlNkV3hsVG1GdFpTQTlJRlJsY20xcGJtRnNVR0Z5ZEZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lIRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblFnUFNCdVpYY2dVblZzWlU1aGJXVlFZWEowS0hGMVlXNTBhV1pwWlhKU2RXeGxUbUZ0WlNrc1hHNGdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeFFZWEowVW5Wc1pVNWhiV1ZRWVhKMElEMGdibVYzSUZKMWJHVk9ZVzFsVUdGeWRDaDBaWEp0YVc1aGJGQmhjblJTZFd4bFRtRnRaU2tzWEc0Z0lDQWdJQ0FnSUNBZ2VtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblJ6VUdGeWRDQTlJRzVsZHlCYVpYSnZUM0pOYjNKbFVHRnlkSE5RWVhKMEtIRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblFwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdWeWJXbHVZV3hRWVhKMFVuVnNaVTVoYldWUVlYSjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2VtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblJ6VUdGeWRGeHVJQ0FnSUNBZ0lDQWdJRjA3WEc0Z0lDQWdYRzRnSUNBZ2MzVndaWElvY0dGeWRITXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKVVpYSnRhVzVoYkZCaGNuUlNkV3hsUkdWbWFXNXBkR2x2YmlJc0luRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTSXNJbEYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU0lzSW5SbGNtMXBibUZzVUdGeWRGSjFiR1ZPWVcxbElpd2lWR1Z5YldsdVlXeFFZWEowVW5Wc1pVNWhiV1VpTENKeGRXRnVkR2xtYVdWeVVuVnNaVTVoYldWUVlYSjBJaXdpVW5Wc1pVNWhiV1ZRWVhKMElpd2lkR1Z5YldsdVlXeFFZWEowVW5Wc1pVNWhiV1ZRWVhKMElpd2llbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaVkJoY25SelVHRnlkQ0lzSWxwbGNtOVBjazF2Y21WUVlYSjBjMUJoY25RaUxDSndZWEowY3lJc0lrUmxabWx1YVhScGIyNGlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZkVUlzU1VGQlFTeFhRVUZyUWl4clEwRkJiRUlzYTBKQlFXdENMRVZCUVVFN1FVRkRhRUlzU1VGQlFTeFRRVUZwUXl4clEwRkJha01zYVVOQlFXbERMRVZCUVVFN1FVRkRNVUlzU1VGQlFTeG5Ra0ZCZDBNc2EwTkJRWGhETEhkRFFVRjNReXhGUVVGQk8wRkJSV1lzU1VGQlFTeFZRVUZwUWl4WFFVRnFRaXhwUWtGQmFVSXNRMEZCUVRzN096czdPenM3T3pzN096czdPMHRCVGpGRk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJVV1VzU1VGQlFTeEJRVUZOUVN3d1FrRkJNRUlzYVVKRFVqVkRMRUZFVVZrN2NVUkJVbVk3TzJGQlVYRkNRU3d3UWtGQk1FSTdlVVJCVWk5RE8xRkJWVWtzU1VGQlRVTXNhMEpCUVd0Q0xFZEJRVWRETEZWQlFXdENMRzFDUVVGQkxFVkJRM1pEUXl4dlFrRkJiMElzUjBGQlIwTXNWVUZCYjBJc2NVSkJRVUVzUlVGRE0wTkRMSE5DUVVGelFpeEhRVUZITEVsQlFVbERMRk5CUVZrc1UwRkJRMHdzYTBKQlFXdENMRU5CUVVNc1JVRkROMFJOTEhkQ1FVRjNRaXhIUVVGSExFbEJRVWxFTEZOQlFWa3NVMEZCUTBnc2IwSkJRVzlDTEVOQlFVTXNSVUZEYWtWTExIRkRRVUZ4UXl4SFFVRkhMRWxCUVVsRExHZENRVUZ0UWl4VFFVRkRTaXh6UWtGQmMwSXNRMEZCUXl4RlFVTjJSa3NzUzBGQlN5eEhRVUZITzFsQlEwNUlMSGRDUVVGM1FqdFpRVU40UWtNc2NVTkJRWEZETzFOQlEzUkRMRUZCUVVNN2FVTkJSVVpGTEV0QlFVczdPenREUVVWa0xFTkJaSFZFUXl4WFFVRlZMRk5CWTJwRk8ydENRV1J2UWxnc01FSkJRVEJDTEVGQlVpOURJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZpbml0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vZGVmaW5pdGlvblwiKSk7XG52YXIgX3J1bGVOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiKSk7XG52YXIgX3plcm9Pck1vcmVQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uLy4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiwgRGVmaW5pdGlvbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBxdWFudGlmaWVyUnVsZU5hbWUgPSBfcnVsZU5hbWVzLlF1YW50aWZpZXJSdWxlTmFtZSwgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWUgPSBfcnVsZU5hbWVzLk5vblRlcm1pbmFsUGFydFJ1bGVOYW1lLCBxdWFudGlmaWVyUnVsZU5hbWVQYXJ0ID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KHF1YW50aWZpZXJSdWxlTmFtZSksIG5vblRlcm1pbmFsUGFydFJ1bGVOYW1lUGFydCA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChub25UZXJtaW5hbFBhcnRSdWxlTmFtZSksIHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWVQYXJ0c1BhcnQgPSBuZXcgX3plcm9Pck1vcmVQYXJ0cy5kZWZhdWx0KHF1YW50aWZpZXJSdWxlTmFtZVBhcnQpLCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG5vblRlcm1pbmFsUGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWVQYXJ0c1BhcnRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uO1xufShfZGVmaW5pdGlvbi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwzQmhjblJTZFd4bEwyNXZibFJsY20xcGJtRnNMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZMaTR2WkdWbWFXNXBkR2x2Ymx3aU8xeHVhVzF3YjNKMElGSjFiR1ZPWVcxbFVHRnlkQ0JtY205dElGd2lMaTR2TGk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5eWRXeGxUbUZ0WlZ3aU8xeHVhVzF3YjNKMElGcGxjbTlQY2sxdmNtVlFZWEowYzFCaGNuUWdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUXZibTl1VkdWeWJXbHVZV3d2ZW1WeWIwOXlUVzl5WlZCaGNuUnpYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTd2dUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaVTVoYldVZ2ZTQm1jbTl0SUZ3aUxpNHZMaTR2Y25Wc1pVNWhiV1Z6WENJN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUU1dmJsUmxjbTFwYm1Gc1VHRnlkRkoxYkdWRVpXWnBibWwwYVc5dUlHVjRkR1Z1WkhNZ1JHVm1hVzVwZEdsdmJpQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtDa2dlMXh1SUNBZ0lHTnZibk4wSUhGMVlXNTBhV1pwWlhKU2RXeGxUbUZ0WlNBOUlGRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0J1YjI1VVpYSnRhVzVoYkZCaGNuUlNkV3hsVG1GdFpTQTlJRTV2YmxSbGNtMXBibUZzVUdGeWRGSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJSEYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaVkJoY25RZ1BTQnVaWGNnVW5Wc1pVNWhiV1ZRWVhKMEtIRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTa3NYRzRnSUNBZ0lDQWdJQ0FnYm05dVZHVnliV2x1WVd4UVlYSjBVblZzWlU1aGJXVlFZWEowSUQwZ2JtVjNJRkoxYkdWT1lXMWxVR0Z5ZENodWIyNVVaWEp0YVc1aGJGQmhjblJTZFd4bFRtRnRaU2tzWEc0Z0lDQWdJQ0FnSUNBZ2VtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblJ6VUdGeWRDQTlJRzVsZHlCYVpYSnZUM0pOYjNKbFVHRnlkSE5RWVhKMEtIRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblFwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYm05dVZHVnliV2x1WVd4UVlYSjBVblZzWlU1aGJXVlFZWEowTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdlbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaVkJoY25SelVHRnlkRnh1SUNBZ0lDQWdJQ0FnSUYwN1hHNGdJQ0FnWEc0Z0lDQWdjM1Z3WlhJb2NHRnlkSE1wWEc0Z0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5Sk9iMjVVWlhKdGFXNWhiRkJoY25SU2RXeGxSR1ZtYVc1cGRHbHZiaUlzSW5GMVlXNTBhV1pwWlhKU2RXeGxUbUZ0WlNJc0lsRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTSXNJbTV2YmxSbGNtMXBibUZzVUdGeWRGSjFiR1ZPWVcxbElpd2lUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaVTVoYldVaUxDSnhkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVlFZWEowSWl3aVVuVnNaVTVoYldWUVlYSjBJaXdpYm05dVZHVnliV2x1WVd4UVlYSjBVblZzWlU1aGJXVlFZWEowSWl3aWVtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpWQmhjblJ6VUdGeWRDSXNJbHBsY205UGNrMXZjbVZRWVhKMGMxQmhjblFpTENKd1lYSjBjeUlzSWtSbFptbHVhWFJwYjI0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRmRVSXNTVUZCUVN4WFFVRnJRaXhyUTBGQmJFSXNhMEpCUVd0Q0xFVkJRVUU3UVVGRGFFSXNTVUZCUVN4VFFVRnBReXhyUTBGQmFrTXNhVU5CUVdsRExFVkJRVUU3UVVGRE1VSXNTVUZCUVN4blFrRkJkME1zYTBOQlFYaERMSGREUVVGM1F5eEZRVUZCTzBGQlJWb3NTVUZCUVN4VlFVRnBRaXhYUVVGcVFpeHBRa0ZCYVVJc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJUamRGT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlVXVXNTVUZCUVN4QlFVRk5RU3cyUWtGQk5rSXNhVUpEVWk5RExFRkVVVms3ZDBSQlVtWTdPMkZCVVhGQ1FTdzJRa0ZCTmtJN05FUkJVbXhFTzFGQlZVa3NTVUZCVFVNc2EwSkJRV3RDTEVkQlFVZERMRlZCUVd0Q0xHMUNRVUZCTEVWQlEzWkRReXgxUWtGQmRVSXNSMEZCUjBNc1ZVRkJkVUlzZDBKQlFVRXNSVUZEYWtSRExITkNRVUZ6UWl4SFFVRkhMRWxCUVVsRExGTkJRVmtzVTBGQlEwd3NhMEpCUVd0Q0xFTkJRVU1zUlVGRE4wUk5MREpDUVVFeVFpeEhRVUZITEVsQlFVbEVMRk5CUVZrc1UwRkJRMGdzZFVKQlFYVkNMRU5CUVVNc1JVRkRka1ZMTEhGRFFVRnhReXhIUVVGSExFbEJRVWxETEdkQ1FVRnRRaXhUUVVGRFNpeHpRa0ZCYzBJc1EwRkJReXhGUVVOMlJrc3NTMEZCU3l4SFFVRkhPMWxCUTA1SUxESkNRVUV5UWp0WlFVTXpRa01zY1VOQlFYRkRPMU5CUTNSRExFRkJRVU03YVVOQlJVWkZMRXRCUVVzN096dERRVVZrTEVOQlpEQkVReXhYUVVGVkxGTkJZM0JGTzJ0Q1FXUnZRbGdzTmtKQlFUWkNMRUZCVW14RUluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfcGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3BhcnRcIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcnVsZU5hbWVcIikpO1xudmFyIF90ZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWxcIikpO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWxcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFBhcnRSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSdWxlKSB7XG4gICAgX2luaGVyaXRzKFBhcnRSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBhcnRSdWxlKTtcbiAgICBmdW5jdGlvbiBQYXJ0UnVsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnRSdWxlKTtcbiAgICAgICAgdmFyIG5hbWUgPSBfcnVsZU5hbWVzLlBhcnRSdWxlTmFtZSwgdGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSBuZXcgX3Rlcm1pbmFsLmRlZmF1bHQoKSwgbm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSBuZXcgX25vblRlcm1pbmFsLmRlZmF1bHQoKSwgbm9XaGl0ZXNwYWNlUGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChfcnVsZU5hbWVzLk5vV2hpdGVzcGFjZVBhcnRSdWxlTmFtZSksIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uLFxuICAgICAgICAgICAgdGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24sXG4gICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0UnVsZU5hbWVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfcGFydC5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0UnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBQYXJ0UnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMM0JoY25RdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JTZFd4bElHWnliMjBnWENJdUxpOXlkV3hsWENJN1hHNXBiWEJ2Y25RZ1VHRnlkRUpPUms1dlpHVWdabkp2YlNCY0lpNHVMMjV2WkdVdlltNW1MM0JoY25SY0lqdGNibWx0Y0c5eWRDQlNkV3hsVG1GdFpVUmxabWx1YVhScGIyNGdabkp2YlNCY0lpNHVMMlJsWm1sdWFYUnBiMjR2Y25Wc1pVNWhiV1ZjSWp0Y2JtbHRjRzl5ZENCVVpYSnRhVzVoYkZCaGNuUlNkV3hsUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dlpHVm1hVzVwZEdsdmJpOXdZWEowVW5Wc1pTOTBaWEp0YVc1aGJGd2lPMXh1YVcxd2IzSjBJRTV2YmxSbGNtMXBibUZzVUdGeWRGSjFiR1ZFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dUwzQmhjblJTZFd4bEwyNXZibFJsY20xcGJtRnNYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGQmhjblJTZFd4bFRtRnRaU3dnVG05WGFHbDBaWE53WVdObFVHRnlkRkoxYkdWT1lXMWxJSDBnWm5KdmJTQmNJaTR1TDNKMWJHVk9ZVzFsYzF3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCUVlYSjBVblZzWlNCbGVIUmxibVJ6SUZKMWJHVWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCdVlXMWxJRDBnVUdGeWRGSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJSFJsY20xcGJtRnNVR0Z5ZEZKMWJHVkVaV1pwYm1sMGFXOXVJRDBnYm1WM0lGUmxjbTFwYm1Gc1VHRnlkRkoxYkdWRVpXWnBibWwwYVc5dUtDa3NYRzRnSUNBZ0lDQWdJQ0FnYm05dVZHVnliV2x1WVd4UVlYSjBVblZzWlVSbFptbHVhWFJwYjI0Z1BTQnVaWGNnVG05dVZHVnliV2x1WVd4UVlYSjBVblZzWlVSbFptbHVhWFJwYjI0b0tTeGNiaUFnSUNBZ0lDQWdJQ0J1YjFkb2FYUmxjM0JoWTJWUVlYSjBVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVJRDBnYm1WM0lGSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpaE9iMWRvYVhSbGMzQmhZMlZRWVhKMFVuVnNaVTVoYldVcExGeHVJQ0FnSUNBZ0lDQWdJR0Z0WW1sbmRXOTFjeUE5SUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0FnSUdSbFptbHVhWFJwYjI1eklEMGdXMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JtOXVWR1Z5YldsdVlXeFFZWEowVW5Wc1pVUmxabWx1YVhScGIyNHNYRzRnSUNBZ0lDQWdJQ0FnSUNCMFpYSnRhVzVoYkZCaGNuUlNkV3hsUkdWbWFXNXBkR2x2Yml4Y2JpQWdJQ0FnSUNBZ0lDQWdJRzV2VjJocGRHVnpjR0ZqWlZCaGNuUlNkV3hsVG1GdFpVUmxabWx1YVhScGIyNWNiaUFnSUNBZ0lDQWdJQ0JkTEZ4dUlDQWdJQ0FnSUNBZ0lFNXZaR1VnUFNCUVlYSjBRazVHVG05a1pUdGNiaUFnSUNCY2JpQWdJQ0J6ZFhCbGNpaHVZVzFsTENCaGJXSnBaM1Z2ZFhNc0lHUmxabWx1YVhScGIyNXpMQ0JPYjJSbEtWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVUdGeWRGSjFiR1VpTENKdVlXMWxJaXdpVUdGeWRGSjFiR1ZPWVcxbElpd2lkR1Z5YldsdVlXeFFZWEowVW5Wc1pVUmxabWx1YVhScGIyNGlMQ0pVWlhKdGFXNWhiRkJoY25SU2RXeGxSR1ZtYVc1cGRHbHZiaUlzSW01dmJsUmxjbTFwYm1Gc1VHRnlkRkoxYkdWRVpXWnBibWwwYVc5dUlpd2lUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaVVJsWm1sdWFYUnBiMjRpTENKdWIxZG9hWFJsYzNCaFkyVlFZWEowVW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1SWl3aVVuVnNaVTVoYldWRVpXWnBibWwwYVc5dUlpd2lUbTlYYUdsMFpYTndZV05sVUdGeWRGSjFiR1ZPWVcxbElpd2lZVzFpYVdkMWIzVnpJaXdpWkdWbWFXNXBkR2x2Ym5NaUxDSk9iMlJsSWl3aVVHRnlkRUpPUms1dlpHVWlMQ0pTZFd4bElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJXbENMRWxCUVVFc1MwRkJVeXhyUTBGQlZDeFRRVUZUTEVWQlFVRTdRVUZEUml4SlFVRkJMRXRCUVd0Q0xHdERRVUZzUWl4clFrRkJhMElzUlVGQlFUdEJRVU5ZTEVsQlFVRXNVMEZCZDBJc2EwTkJRWGhDTEhkQ1FVRjNRaXhGUVVGQk8wRkJRMmhDTEVsQlFVRXNVMEZCYVVNc2EwTkJRV3BETEdsRFFVRnBReXhGUVVGQk8wRkJRemxDTEVsQlFVRXNXVUZCYjBNc2EwTkJRWEJETEc5RFFVRnZReXhGUVVGQk8wRkJSWFpDTEVsQlFVRXNWVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJVbkpGT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlZXVXNTVUZCUVN4QlFVRk5RU3hSUVVGUkxHbENRMVl4UWl4QlJGVlpPelpDUVZabU96dGhRVlZ4UWtFc1VVRkJVVHQxUTBGV04wSTdVVUZaU1N4SlFVRk5ReXhKUVVGSkxFZEJRVWRETEZWQlFWa3NZVUZCUVN4RlFVTnVRa01zTUVKQlFUQkNMRWRCUVVjc1NVRkJTVU1zVTBGQk1FSXNWVUZCUlN4RlFVTTNSRU1zTmtKQlFUWkNMRWRCUVVjc1NVRkJTVU1zV1VGQk5rSXNWVUZCUlN4RlFVTnVSVU1zYTBOQlFXdERMRWRCUVVjc1NVRkJTVU1zVTBGQmEwSXNVMEZCUTBNc1ZVRkJkMElzTUVKQlFVTXNSVUZEY2taRExGTkJRVk1zUjBGQlJ5eExRVUZMTEVWQlEycENReXhYUVVGWExFZEJRVWM3V1VGRFdrNHNOa0pCUVRaQ08xbEJRemRDUml3d1FrRkJNRUk3V1VGRE1VSkpMR3REUVVGclF6dFRRVU51UXl4RlFVTkVTeXhKUVVGSkxFZEJRVWRETEV0QlFWY3NVVUZCUVN4QlFVRkRPMmxEUVVWdVFsb3NTVUZCU1N4RlFVRkZVeXhUUVVGVExFVkJRVVZETEZkQlFWY3NSVUZCUlVNc1NVRkJTVHM3TzBOQlJUTkRMRU5CYUVKeFEwVXNTMEZCU1N4VFFXZENla003YTBKQmFFSnZRbVFzVVVGQlVTeEJRVlkzUWlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCIpKTtcbnZhciBfYXJyYXkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbGl0aWVzL2FycmF5XCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgUnVsZUJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhSdWxlQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJ1bGVCTkZOb2RlKTtcbiAgICBmdW5jdGlvbiBSdWxlQk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJ1bGVCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUnVsZUJORk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdlbmVyYXRlUnVsZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlUnVsZShSdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoKSwgYW1iaWd1b3VzID0gdGhpcy5pc0FtYmlndW91cygpLCBkZWZpbml0aW9ucyA9IHRoaXMuZ2VuZXJhdGVEZWZpbml0aW9ucygpLCBOb2RlID0gX25vblRlcm1pbmFsLmRlZmF1bHQsIHJ1bGUgPSBuZXcgUnVsZShuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzQW1iaWd1b3VzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNBbWJpZ3VvdXMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgc2Vjb25kQ2hpbGROb2RlID0gKDAsIF9hcnJheSkuc2Vjb25kKGNoaWxkTm9kZXMpLCBzZWNvbmRDaGlsZE5vZGVUZXJtaW5hbE5vZGUgPSBzZWNvbmRDaGlsZE5vZGUuaXNUZXJtaW5hbE5vZGUoKSwgYW1iaWd1b3VzID0gIXNlY29uZENoaWxkTm9kZVRlcm1pbmFsTm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW1iaWd1b3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgZmlyc3RDaGlsZE5vZGUgPSAoMCwgX2FycmF5KS5maXJzdChjaGlsZE5vZGVzKSwgbmFtZUJORk5vZGUgPSBmaXJzdENoaWxkTm9kZSwgbmFtZSA9IG5hbWVCTkZOb2RlLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdlbmVyYXRlRGVmaW5pdGlvbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZURlZmluaXRpb25zKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksIGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aCwgdGhpcmRDaGlsZE5vZGUgPSAoMCwgX2FycmF5KS50aGlyZChjaGlsZE5vZGVzKSwgZm91cnRoQ2hpbGROb2RlID0gKDAsIF9hcnJheSkuZm91cnRoKGNoaWxkTm9kZXMpLCBkZWZpbml0aW9uc0JORk5vZGUgPSBjaGlsZE5vZGVzTGVuZ3RoID09PSA0ID8gdGhpcmRDaGlsZE5vZGUgOiBmb3VydGhDaGlsZE5vZGUsIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnNCTkZOb2RlLmdlbmVyYXRlRGVmaW5pdGlvbnMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhydWxlTmFtZSwgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uVGVybWluYWwuZGVmYXVsdC5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKFJ1bGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUnVsZUJORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJ1bGVCTkZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5eWRXeGxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUdaeWIyMGdYQ0l1TGk4dUxpOXViMlJsTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVjYm1sdGNHOXlkQ0I3SUdacGNuTjBMQ0J6WldOdmJtUXNJSFJvYVhKa0xDQm1iM1Z5ZEdnZ2ZTQm1jbTl0SUZ3aUxpNHZMaTR2ZFhScGJHbDBhV1Z6TDJGeWNtRjVYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRkoxYkdWQ1RrWk9iMlJsSUdWNGRHVnVaSE1nVG05dVZHVnliV2x1WVd4T2IyUmxJSHRjYmlBZ1oyVnVaWEpoZEdWU2RXeGxLRkoxYkdVcElIdGNiaUFnSUNCamIyNXpkQ0J1WVcxbElEMGdkR2hwY3k1blpYUk9ZVzFsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdZVzFpYVdkMWIzVnpJRDBnZEdocGN5NXBjMEZ0WW1sbmRXOTFjeWdwTEZ4dUlDQWdJQ0FnSUNBZ0lHUmxabWx1YVhScGIyNXpJRDBnZEdocGN5NW5aVzVsY21GMFpVUmxabWx1YVhScGIyNXpLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ1RtOWtaU0E5SUU1dmJsUmxjbTFwYm1Gc1RtOWtaU3hjYmlBZ0lDQWdJQ0FnSUNCeWRXeGxJRDBnYm1WM0lGSjFiR1VvYm1GdFpTd2dZVzFpYVdkMWIzVnpMQ0JrWldacGJtbDBhVzl1Y3l3Z1RtOWtaU2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjblZzWlR0Y2JpQWdmVnh1WEc0Z0lHbHpRVzFpYVdkMWIzVnpLQ2tnZTF4dUlDQWdJR052Ym5OMElHTm9hV3hrVG05a1pYTWdQU0IwYUdsekxtZGxkRU5vYVd4a1RtOWtaWE1vS1N4Y2JpQWdJQ0FnSUNBZ0lDQnpaV052Ym1SRGFHbHNaRTV2WkdVZ1BTQnpaV052Ym1Rb1kyaHBiR1JPYjJSbGN5a3NYRzRnSUNBZ0lDQWdJQ0FnYzJWamIyNWtRMmhwYkdST2IyUmxWR1Z5YldsdVlXeE9iMlJsSUQwZ2MyVmpiMjVrUTJocGJHUk9iMlJsTG1selZHVnliV2x1WVd4T2IyUmxLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ1lXMWlhV2QxYjNWeklEMGdJWE5sWTI5dVpFTm9hV3hrVG05a1pWUmxjbTFwYm1Gc1RtOWtaVHRjYmx4dUlDQWdJSEpsZEhWeWJpQmhiV0pwWjNWdmRYTTdYRzRnSUgxY2JseHVJQ0JuWlhST1lXMWxLQ2tnZTF4dUlDQWdJR052Ym5OMElHTm9hV3hrVG05a1pYTWdQU0IwYUdsekxtZGxkRU5vYVd4a1RtOWtaWE1vS1N4Y2JpQWdJQ0FnSUNBZ0lDQm1hWEp6ZEVOb2FXeGtUbTlrWlNBOUlHWnBjbk4wS0dOb2FXeGtUbTlrWlhNcExGeHVJQ0FnSUNBZ0lDQWdJRzVoYldWQ1RrWk9iMlJsSUQwZ1ptbHljM1JEYUdsc1pFNXZaR1VzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0J1WVcxbElEMGdibUZ0WlVKT1JrNXZaR1V1WjJWMFRtRnRaU2dwTzF4dUlDQWdJRnh1SUNBZ0lISmxkSFZ5YmlCdVlXMWxPMXh1SUNCOVhHNGdJRnh1SUNCblpXNWxjbUYwWlVSbFptbHVhWFJwYjI1ektDa2dlMXh1SUNBZ0lHTnZibk4wSUdOb2FXeGtUbTlrWlhNZ1BTQjBhR2x6TG1kbGRFTm9hV3hrVG05a1pYTW9LU3hjYmlBZ0lDQWdJQ0FnSUNCamFHbHNaRTV2WkdWelRHVnVaM1JvSUQwZ1kyaHBiR1JPYjJSbGN5NXNaVzVuZEdnc1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY21SRGFHbHNaRTV2WkdVZ1BTQjBhR2x5WkNoamFHbHNaRTV2WkdWektTeGNiaUFnSUNBZ0lDQWdJQ0JtYjNWeWRHaERhR2xzWkU1dlpHVWdQU0JtYjNWeWRHZ29ZMmhwYkdST2IyUmxjeWtzWEc0Z0lDQWdJQ0FnSUNBZ1pHVm1hVzVwZEdsdmJuTkNUa1pPYjJSbElEMGdLR05vYVd4a1RtOWtaWE5NWlc1bmRHZ2dQVDA5SURRcElEOWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWEprUTJocGJHUk9iMlJsSURvZ0lDOHZMMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNWeWRHaERhR2xzWkU1dlpHVXNJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lHUmxabWx1YVhScGIyNXpJRDBnWkdWbWFXNXBkR2x2Ym5OQ1RrWk9iMlJsTG1kbGJtVnlZWFJsUkdWbWFXNXBkR2x2Ym5Nb0tUdGNiaUFnSUNCY2JpQWdJQ0J5WlhSMWNtNGdaR1ZtYVc1cGRHbHZibk03WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeWh5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrZ2V5QnlaWFIxY200Z1RtOXVWR1Z5YldsdVlXeE9iMlJsTG1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1vVW5Wc1pVSk9SazV2WkdVc0lISjFiR1ZPWVcxbExDQmphR2xzWkU1dlpHVnpLVHNnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxKMWJHVkNUa1pPYjJSbElpd2laMlZ1WlhKaGRHVlNkV3hsSWl3aVVuVnNaU0lzSW01aGJXVWlMQ0puWlhST1lXMWxJaXdpWVcxaWFXZDFiM1Z6SWl3aWFYTkJiV0pwWjNWdmRYTWlMQ0prWldacGJtbDBhVzl1Y3lJc0ltZGxibVZ5WVhSbFJHVm1hVzVwZEdsdmJuTWlMQ0pPYjJSbElpd2lUbTl1VkdWeWJXbHVZV3hPYjJSbElpd2ljblZzWlNJc0ltTm9hV3hrVG05a1pYTWlMQ0puWlhSRGFHbHNaRTV2WkdWeklpd2ljMlZqYjI1a1EyaHBiR1JPYjJSbElpd2ljMlZqYjI1a0lpd2ljMlZqYjI1a1EyaHBiR1JPYjJSbFZHVnliV2x1WVd4T2IyUmxJaXdpYVhOVVpYSnRhVzVoYkU1dlpHVWlMQ0ptYVhKemRFTm9hV3hrVG05a1pTSXNJbVpwY25OMElpd2libUZ0WlVKT1JrNXZaR1VpTENKamFHbHNaRTV2WkdWelRHVnVaM1JvSWl3aWJHVnVaM1JvSWl3aWRHaHBjbVJEYUdsc1pFNXZaR1VpTENKMGFHbHlaQ0lzSW1admRYSjBhRU5vYVd4a1RtOWtaU0lzSW1admRYSjBhQ0lzSW1SbFptbHVhWFJwYjI1elFrNUdUbTlrWlNJc0ltWnliMjFTZFd4bFRtRnRaVUZ1WkVOb2FXeGtUbTlrWlhNaUxDSnlkV3hsVG1GdFpTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVTBRaXhKUVVGQkxGbEJRWGRDTEd0RFFVRjRRaXgzUWtGQmQwSXNSVUZCUVR0QlFVVlFMRWxCUVVFc1RVRkJkVUlzVjBGQmRrSXNkVUpCUVhWQ0xFTkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZLY0VVN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlRXVXNTVUZCUVN4QlFVRk5RU3hYUVVGWExHbENRMDQzUWl4QlJFMVpPekpEUVU1bU96dGhRVTF4UWtFc1YwRkJWenN3UTBGT2FFTTdPenM3TzFsQlQwVkRMRWRCUVZrc1JVRkJXa0VzWTBGQldUdFpSVkJrTEU5R1QwVkJMRk5CUVVGQkxGbEJRVmtzUTBGQlEwTXNTVUZCU1N4RlFVRkZPMmRDUVVOcVFpeEpRVUZOUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRFF5eFBRVUZQTEVWQlFVVXNSVUZEY2tKRExGTkJRVk1zUjBGQlJ5eEpRVUZKTEVOQlFVTkRMRmRCUVZjc1JVRkJSU3hGUVVNNVFrTXNWMEZCVnl4SFFVRkhMRWxCUVVrc1EwRkJRME1zYlVKQlFXMUNMRVZCUVVVc1JVRkRlRU5ETEVsQlFVa3NSMEZCUjBNc1dVRkJaU3hSUVVGQkxFVkJRM1JDUXl4SlFVRkpMRWRCUVVjc1NVRkJTVlFzU1VGQlNTeERRVUZEUXl4SlFVRkpMRVZCUVVWRkxGTkJRVk1zUlVGQlJVVXNWMEZCVnl4RlFVRkZSU3hKUVVGSkxFTkJRVU1zUVVGQlF6dG5Ra0ZGTVVRc1QwRkJUMFVzU1VGQlNTeERRVUZETzJGQlEySTdPenRaUVVWRVRDeEhRVUZYTEVWQlFWaEJMR0ZCUVZjN1dVVnFRbUlzVDBacFFrVkJMRk5CUVVGQkxGZEJRVmNzUjBGQlJ6dG5Ra0ZEV2l4SlFVRk5UU3hWUVVGVkxFZEJRVWNzU1VGQlNTeERRVUZEUXl4aFFVRmhMRVZCUVVVc1JVRkRha05ETEdWQlFXVXNSMEZCUjBNc1EwRkJRVUVzUjBGQlFVRXNUVUZCVFN4QlFVRlpMRU5CUVVFc1VVRkJXRWdzVlVGQlZTeERRVUZETEVWQlEzQkRTU3d5UWtGQk1rSXNSMEZCUjBZc1pVRkJaU3hEUVVGRFJ5eGpRVUZqTEVWQlFVVXNSVUZET1VSYUxGTkJRVk1zUjBGQlJ5eERRVUZEVnl3eVFrRkJNa0lzUVVGQlF6dG5Ra0ZGTDBNc1QwRkJUMWdzVTBGQlV5eERRVUZETzJGQlEyeENPenM3V1VGRlJFUXNSMEZCVHl4RlFVRlFRU3hUUVVGUE8xbEZNVUpVTEU5R01FSkZRU3hUUVVGQlFTeFBRVUZQTEVkQlFVYzdaMEpCUTFJc1NVRkJUVkVzVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEU3l4alFVRmpMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTFCUVVzc1FVRkJXU3hEUVVGQkxFOUJRVmhRTEZWQlFWVXNRMEZCUXl4RlFVTnNRMUVzVjBGQlZ5eEhRVUZIUml4alFVRmpMRVZCUXpWQ1ppeEpRVUZKTEVkQlFVZHBRaXhYUVVGWExFTkJRVU5vUWl4UFFVRlBMRVZCUVVVc1FVRkJRenRuUWtGRmJrTXNUMEZCVDBRc1NVRkJTU3hEUVVGRE8yRkJRMkk3T3p0WlFVVkVTeXhIUVVGdFFpeEZRVUZ1UWtFc2NVSkJRVzFDTzFsRmJrTnlRaXhQUm0xRFJVRXNVMEZCUVVFc2JVSkJRVzFDTEVkQlFVYzdaMEpCUTNCQ0xFbEJRVTFKTEZWQlFWVXNSMEZCUnl4SlFVRkpMRU5CUVVORExHRkJRV0VzUlVGQlJTeEZRVU5xUTFFc1owSkJRV2RDTEVkQlFVZFVMRlZCUVZVc1EwRkJRMVVzVFVGQlRTeEZRVU53UTBNc1kwRkJZeXhIUVVGSFF5eERRVUZCUVN4SFFVRkJRU3hOUVVGTExFRkJRVmtzUTBGQlFTeFBRVUZZV2l4VlFVRlZMRU5CUVVNc1JVRkRiRU5oTEdWQlFXVXNSMEZCUjBNc1EwRkJRVUVzUjBGQlFVRXNUVUZCVFN4QlFVRlpMRU5CUVVFc1VVRkJXR1FzVlVGQlZTeERRVUZETEVWQlEzQkRaU3hyUWtGQmEwSXNSMEZCUnl4QlFVRkRUaXhuUWtGQlowSXNTMEZCU3l4RFFVRkRMRWRCUTNKQ1JTeGpRVUZqTEVkQlExcEZMR1ZCUVdVc1JVRkRlRU5zUWl4WFFVRlhMRWRCUVVkdlFpeHJRa0ZCYTBJc1EwRkJRMjVDTEcxQ1FVRnRRaXhGUVVGRkxFRkJRVU03WjBKQlJUZEVMRTlCUVU5RUxGZEJRVmNzUTBGQlF6dGhRVU53UWpzN096dFpRVVZOY1VJc1IwRkJlVUlzUlVGQmVrSkJMREpDUVVGNVFqdFpSV2hFYkVNc1QwWm5SRVVzVTBGQlQwRXNlVUpCUVhsQ0xFTkJRVU5ETEZGQlFWRXNSVUZCUldwQ0xGVkJRVlVzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBSaXhaUVVGbExGTkJRVU5yUWl4NVFrRkJlVUlzUTBGQlF6VkNMRmRCUVZjc1JVRkJSVFpDTEZGQlFWRXNSVUZCUldwQ0xGVkJRVlVzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCYUVScVNqczdRMEZwUkVNc1EwRXpRM2REUml4WlFVRmxMRk5CTWtOMlJEdHJRa0V6UTI5Q1ZpeFhRVUZYTEVGQlRtaERJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF90ZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvdGVybWluYWxcIikpO1xudmFyIF90ZXJtaW5hbDEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9ub2RlL3Rlcm1pbmFsXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFRlcm1pbmFsU3ltYm9sUGFydCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oVGVybWluYWxQYXJ0KSB7XG4gICAgX2luaGVyaXRzKFRlcm1pbmFsU3ltYm9sUGFydCwgVGVybWluYWxQYXJ0KTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRlcm1pbmFsU3ltYm9sUGFydCk7XG4gICAgZnVuY3Rpb24gVGVybWluYWxTeW1ib2xQYXJ0KGNvbnRlbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlcm1pbmFsU3ltYm9sUGFydCk7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgX3RoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFRlcm1pbmFsU3ltYm9sUGFydCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSwgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLCBzaWduaWZpY2FudFRva2VuID0gbmV4dFNpZ25pZmljYW50VG9rZW47IC8vL1xuICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50ID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IF90ZXJtaW5hbDEuZGVmYXVsdC5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0ZXJtaW5hbE5vZGUgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHRlcm1pbmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudC5yZXBsYWNlKC9cXFxcLywgXCJcXFxcXFxcXFwiKSwgc3RyaW5nID0gXCJcXFwiXCIuY29uY2F0KGNvbnRlbnQsIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoVGVybWluYWxTeW1ib2xQYXJ0LnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBUZXJtaW5hbFN5bWJvbFBhcnQsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gVGVybWluYWxTeW1ib2xQYXJ0O1xufShfdGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZXJtaW5hbFN5bWJvbFBhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl3WVhKMEwzUmxjbTFwYm1Gc0wzUmxjbTFwYm1Gc1UzbHRZbTlzTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdWR1Z5YldsdVlXeFFZWEowSUdaeWIyMGdYQ0l1TGk4dUxpOXdZWEowTDNSbGNtMXBibUZzWENJN1hHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4T2IyUmxJR1p5YjIwZ1hDSXVMaTh1TGk5dWIyUmxMM1JsY20xcGJtRnNYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRlJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ0JsZUhSbGJtUnpJRlJsY20xcGJtRnNVR0Z5ZENCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0dOdmJuUmxiblFwSUh0Y2JpQWdJQ0J6ZFhCbGNpZ3BPMXh1SUNBZ0lGeHVJQ0FnSUhSb2FYTXVZMjl1ZEdWdWRDQTlJR052Ym5SbGJuUTdYRzRnSUgxY2JseHVJQ0J3WVhKelpTaHViMlJsY3l3Z2MzUmhkR1VzSUdOaGJHeGlZV05yS1NCN1hHNGdJQ0FnYkdWMElIQmhjbk5sWkR0Y2JseHVJQ0FnSUd4bGRDQjBaWEp0YVc1aGJFNXZaR1VnUFNCdWRXeHNPMXh1SUNBZ0lGeHVJQ0FnSUdOdmJuTjBJSE5oZG1Wa1NXNWtaWGdnUFNCemRHRjBaUzVuWlhSVFlYWmxaRWx1WkdWNEtDa3NYRzVjZEZ4MElDQWdJQ0FnYm1WNGRGTnBaMjVwWm1sallXNTBWRzlyWlc0Z1BTQnpkR0YwWlM1blpYUk9aWGgwVTJsbmJtbG1hV05oYm5SVWIydGxiaWdwTEZ4dVhIUmNkRngwWEhSY2RITnBaMjVwWm1sallXNTBWRzlyWlc0Z1BTQnVaWGgwVTJsbmJtbG1hV05oYm5SVWIydGxianNnTHk4dlhHNWNiaUFnSUNCcFppQW9jMmxuYm1sbWFXTmhiblJVYjJ0bGJpQWhQVDBnYm5Wc2JDa2dlMXh1SUNBZ0lDQWdZMjl1YzNRZ1kyOXVkR1Z1ZENBOUlITnBaMjVwWm1sallXNTBWRzlyWlc0dVoyVjBRMjl1ZEdWdWRDZ3BPMXh1WEc0Z0lDQWdJQ0JwWmlBb1kyOXVkR1Z1ZENBOVBUMGdkR2hwY3k1amIyNTBaVzUwS1NCN1hHNGdJQ0FnSUNBZ0lIUmxjbTFwYm1Gc1RtOWtaU0E5SUZSbGNtMXBibUZzVG05a1pTNW1jbTl0VTJsbmJtbG1hV05oYm5SVWIydGxiaWh6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQndZWEp6WldRZ1BTQW9kR1Z5YldsdVlXeE9iMlJsSUNFOVBTQnVkV3hzS1R0Y2JseHVJQ0FnSUdsbUlDaHdZWEp6WldRcElIdGNiaUFnSUNBZ0lHNXZaR1Z6TG5CMWMyZ29kR1Z5YldsdVlXeE9iMlJsS1R0Y2JseHVJQ0FnSUNBZ2FXWWdLR05oYkd4aVlXTnJJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUhCaGNuTmxaQ0E5SUdOaGJHeGlZV05yS0NrN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0NGd1lYSnpaV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnViMlJsY3k1d2IzQW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNnaGNHRnljMlZrS1NCN1hHNGdJQ0FnSUNCemRHRjBaUzVpWVdOcmRISmhZMnNvYzJGMlpXUkpibVJsZUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJSEJoY25ObFpEdGNiaUFnZlZ4dUlDQmNiaUFnWVhOVGRISnBibWNvS1NCN1hHNGdJQ0FnWTI5dWMzUWdZMjl1ZEdWdWRDQTlJSFJvYVhNdVkyOXVkR1Z1ZEM1eVpYQnNZV05sS0M5Y1hGeGNMeXdnWENKY1hGeGNYRnhjWEZ3aUtTeGNiaUFnSUNBZ0lDQWdJQ0J6ZEhKcGJtY2dQU0JnWENJa2UyTnZiblJsYm5SOVhDSmdPMXh1SUNBZ0lGeHVJQ0FnSUhKbGRIVnliaUJ6ZEhKcGJtYzdYRzRnSUgxY2JseHVJQ0JqYkc5dVpTZ3BJSHNnY21WMGRYSnVJSE4xY0dWeUxtTnNiMjVsS0ZSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZEN3Z2RHaHBjeTVqYjI1MFpXNTBLVHNnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZENJc0ltTnZiblJsYm5RaUxDSndZWEp6WlNJc0ltNXZaR1Z6SWl3aWMzUmhkR1VpTENKallXeHNZbUZqYXlJc0luQmhjbk5sWkNJc0luUmxjbTFwYm1Gc1RtOWtaU0lzSW5OaGRtVmtTVzVrWlhnaUxDSm5aWFJUWVhabFpFbHVaR1Y0SWl3aWJtVjRkRk5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0puWlhST1pYaDBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbk5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0puWlhSRGIyNTBaVzUwSWl3aVZHVnliV2x1WVd4T2IyUmxJaXdpWm5KdmJWTnBaMjVwWm1sallXNTBWRzlyWlc0aUxDSndkWE5vSWl3aWNHOXdJaXdpWW1GamEzUnlZV05ySWl3aVlYTlRkSEpwYm1jaUxDSnlaWEJzWVdObElpd2ljM1J5YVc1bklpd2lZMnh2Ym1VaUxDSlVaWEp0YVc1aGJGQmhjblFpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGZVVJc1NVRkJRU3hUUVVGeFFpeHJRMEZCY2tJc2NVSkJRWEZDTEVWQlFVRTdRVUZEY2tJc1NVRkJRU3hWUVVGeFFpeHJRMEZCY2tJc2NVSkJRWEZDTEVWQlFVRTdPenM3T3pzN096czdPenM3T3pzNFJFRklPVU03YzBOQlFVRTdOa1JCUVVFN2FVVkJRVUU3T3pzN2QwVkJRVUU3WjBWQlFVRTdPenM3T3pCQ1FVRkJPenM3T3pzN096czdPMU5CUVVFN096czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN08zZERRVUZCT3pzN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVV0bExFbEJRVUVzUVVGQlRVRXNhMEpCUVd0Q0xHbENRMHh3UXl4QlJFdFpPeXREUVV4bU96dGhRVXR4UWtFc2EwSkJRV3RDTEVOQlEzcENReXhQUVVGUE8ybEVRVTV5UWpzN2FVTkZRVUVzUTBaUFdUdFJRVVZTTEUxQlFVdEJMRTlCUVU4c1IwRkJSMEVzVDBGQlR5eERRVUZET3pzN096dFpRVWQ2UWtNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRldsQXNUMFpaUlVFc1UwRkJRVUVzUzBGQlN5eERRVUZEUXl4TFFVRkxMRVZCUVVWRExFdEJRVXNzUlVGQlJVTXNVVUZCVVN4RlFVRkZPMmRDUVVNMVFpeEpRVUZKUXl4TlFVRk5MRUZCUVVNN1owSkJSVmdzU1VGQlNVTXNXVUZCV1N4SFFVRkhMRWxCUVVrc1FVRkJRenRuUWtGRmVFSXNTVUZCVFVNc1ZVRkJWU3hIUVVGSFNpeExRVUZMTEVOQlFVTkxMR0ZCUVdFc1JVRkJSU3hGUVVOd1EwTXNiMEpCUVc5Q0xFZEJRVWRPTEV0QlFVc3NRMEZCUTA4c2RVSkJRWFZDTEVWQlFVVXNSVUZEZWtSRExHZENRVUZuUWl4SFFVRkhSaXh2UWtGQmIwSXNRVUZCUXl4RlFVRkRMRWRCUVVjN1owSkJSVGRETEVsQlFVbEZMR2RDUVVGblFpeExRVUZMTEVsQlFVa3NSVUZCUlR0dlFrRkROMElzU1VGQlRWZ3NUMEZCVHl4SFFVRkhWeXhuUWtGQlowSXNRMEZCUTBNc1ZVRkJWU3hGUVVGRkxFRkJRVU03YjBKQlJUbERMRWxCUVVsYUxFOUJRVThzUzBGQlN5eEpRVUZKTEVOQlFVTkJMRTlCUVU4c1JVRkJSVHQzUWtGRE5VSk5MRmxCUVZrc1IwRkJSMDhzVlVGQldTeFRRVUZEUXl4dlFrRkJiMElzUTBGQlEwZ3NaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dHhRa0ZEY0VVN2FVSkJRMFk3WjBKQlJVUk9MRTFCUVUwc1IwRkJTVU1zV1VGQldTeExRVUZMTEVsQlFVa3NRVUZCUXl4RFFVRkRPMmRDUVVWcVF5eEpRVUZKUkN4TlFVRk5MRVZCUVVVN2IwSkJRMVpJTEV0QlFVc3NRMEZCUTJFc1NVRkJTU3hEUVVGRFZDeFpRVUZaTEVOQlFVTXNRMEZCUXp0dlFrRkZla0lzU1VGQlNVWXNVVUZCVVN4TFFVRkxMRWxCUVVrc1JVRkJSVHQzUWtGRGNrSkRMRTFCUVUwc1IwRkJSMFFzVVVGQlVTeEZRVUZGTEVOQlFVTTdkMEpCUlhCQ0xFbEJRVWtzUTBGQlEwTXNUVUZCVFN4RlFVRkZPelJDUVVOWVNDeExRVUZMTEVOQlFVTmpMRWRCUVVjc1JVRkJSU3hEUVVGRE8zbENRVU5pTzNGQ1FVTkdPMmxDUVVOR08yZENRVVZFTEVsQlFVa3NRMEZCUTFnc1RVRkJUU3hGUVVGRk8yOUNRVU5ZUml4TFFVRkxMRU5CUVVOakxGTkJRVk1zUTBGQlExWXNWVUZCVlN4RFFVRkRMRU5CUVVNN2FVSkJRemRDTzJkQ1FVVkVMRTlCUVU5R0xFMUJRVTBzUTBGQlF6dGhRVU5tT3pzN1dVRkZSR0VzUjBGQlVTeEZRVUZTUVN4VlFVRlJPMWxGYkVSV0xFOUdhMFJGUVN4VFFVRkJRU3hSUVVGUkxFZEJRVWM3WjBKQlExUXNTVUZCVFd4Q0xFOUJRVThzUjBGQlJ5eEpRVUZKTEVOQlFVTkJMRTlCUVU4c1EwRkJRMjFDTEU5QlFVOHNUMEZCVHl4TlFVRk5MRU5CUVVNc1JVRkROVU5ETEUxQlFVMHNSMEZCUnl4QlFVRkRMRWxCUVVNc1EwRkJWU3hOUVVGRExFTkJRVlJ3UWl4UFFVRlBMRVZCUVVNc1NVRkJReXhEUVVGRExFRkJRVU03WjBKQlJUbENMRTlCUVU5dlFpeE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlhwRVVDeFBSbmxFUlVFc1UwRkJRVUVzUzBGQlN5eEhRVUZITzJkQ1FVRkZMRTlCUVU4c2NVSkJjRVJGZEVJc2EwSkJRV3RDTEdGQmIwUmtjMElzVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBkRUlzYTBKQlFXdENMRVZCUVVVc1NVRkJTU3hEUVVGRFF5eFBRVUZQTEVWQlFVVTdZVUZCUlRzN1RVRjZSRzVGT3p0RFFUQkVReXhEUVhKRUswTnpRaXhUUVVGWkxGTkJjVVF6UkR0clFrRnlSRzlDZGtJc2EwSkJRV3RDTEVGQlRIWkRJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfcnVsZU5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCIpKTtcbnZhciBfb3B0aW9uYWxQYXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvdGVybWluYWwvdGVybWluYWxTeW1ib2xcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIHNlcGFyYXRvciA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy5zZXBhcmF0b3IsIHRlcm1pbmF0b3IgPSBfb2NjYW1MZXhlcnMuc3BlY2lhbFN5bWJvbHMudGVybWluYXRvcjtcbnZhciBSdWxlRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhSdWxlRGVmaW5pdGlvbiwgRGVmaW5pdGlvbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSdWxlRGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gUnVsZURlZmluaXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdWxlRGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBzZXBhcmF0b3JUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSBzZXBhcmF0b3IsIHRlcm1pbmF0b3JUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSB0ZXJtaW5hdG9yLCBuYW1lUnVsZU5hbWUgPSBfcnVsZU5hbWVzLk5hbWVSdWxlTmFtZSwgZGVmaW5pdGlvbnNSdWxlTmFtZSA9IF9ydWxlTmFtZXMuRGVmaW5pdGlvbnNSdWxlTmFtZSwgYW1iaWd1b3VzTW9kaWZpZXJSdWxlTmFtZSA9IF9ydWxlTmFtZXMuQW1iaWd1b3VzTW9kaWZpZXJSdWxlTmFtZSwgYW1iaWd1b3VzTW9kaWZpZXJSdWxlTmFtZVBhcnQgPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQoYW1iaWd1b3VzTW9kaWZpZXJSdWxlTmFtZSksIG5hbWVSdWxlTmFtZVBhcnQgPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQobmFtZVJ1bGVOYW1lKSwgb3B0aW9uYWxBbWJpZ3VvdXNSdWxlTmFtZVBhcnRQYXJ0ID0gbmV3IF9vcHRpb25hbFBhcnQuZGVmYXVsdChhbWJpZ3VvdXNNb2RpZmllclJ1bGVOYW1lUGFydCksIHNlcGFyYXRvclRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChzZXBhcmF0b3JUZXJtaW5hbFN5bWJvbENvbnRlbnQpLCBkZWZpbml0aW9uc1J1bGVOYW1lUGFydCA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChkZWZpbml0aW9uc1J1bGVOYW1lKSwgdGVybWluYXRvclRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdCh0ZXJtaW5hdG9yVGVybWluYWxTeW1ib2xDb250ZW50KSwgcGFydHMgPSBbXG4gICAgICAgICAgICBuYW1lUnVsZU5hbWVQYXJ0LFxuICAgICAgICAgICAgb3B0aW9uYWxBbWJpZ3VvdXNSdWxlTmFtZVBhcnRQYXJ0LFxuICAgICAgICAgICAgc2VwYXJhdG9yVGVybWluYWxTeW1ib2xQYXJ0LFxuICAgICAgICAgICAgZGVmaW5pdGlvbnNSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB0ZXJtaW5hdG9yVGVybWluYWxTeW1ib2xQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBSdWxlRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSdWxlRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwzSjFiR1V1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJSE53WldOcFlXeFRlVzFpYjJ4eklIMGdabkp2YlNCY0ltOWpZMkZ0TFd4bGVHVnljMXdpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZibHdpTzF4dWFXMXdiM0owSUZKMWJHVk9ZVzFsVUdGeWRDQm1jbTl0SUZ3aUxpNHZjR0Z5ZEM5dWIyNVVaWEp0YVc1aGJDOXlkV3hsVG1GdFpWd2lPMXh1YVcxd2IzSjBJRTl3ZEdsdmJtRnNVR0Z5ZEZCaGNuUWdabkp2YlNCY0lpNHVMM0JoY25RdmJtOXVWR1Z5YldsdVlXd3ZiM0IwYVc5dVlXeFFZWEowWENJN1hHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4VGVXMWliMnhRWVhKMElHWnliMjBnWENJdUxpOXdZWEowTDNSbGNtMXBibUZzTDNSbGNtMXBibUZzVTNsdFltOXNYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lFNWhiV1ZTZFd4bFRtRnRaU3dnUkdWbWFXNXBkR2x2Ym5OU2RXeGxUbUZ0WlN3Z1FXMWlhV2QxYjNWelRXOWthV1pwWlhKU2RXeGxUbUZ0WlNCOUlHWnliMjBnWENJdUxpOXlkV3hsVG1GdFpYTmNJanRjYmx4dVkyOXVjM1FnZXlCelpYQmhjbUYwYjNJc0lIUmxjbTFwYm1GMGIzSWdmU0E5SUhOd1pXTnBZV3hUZVcxaWIyeHpPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlNkV3hsUkdWbWFXNXBkR2x2YmlCbGVIUmxibVJ6SUVSbFptbHVhWFJwYjI0Z2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lncElIdGNiaUFnSUNCamIyNXpkQ0J6WlhCaGNtRjBiM0pVWlhKdGFXNWhiRk41YldKdmJFTnZiblJsYm5RZ1BTQnpaWEJoY21GMGIzSXNYRzRnSUNBZ0lDQWdJQ0FnZEdWeWJXbHVZWFJ2Y2xSbGNtMXBibUZzVTNsdFltOXNRMjl1ZEdWdWRDQTlJSFJsY20xcGJtRjBiM0lzWEc0Z0lDQWdJQ0FnSUNBZ2JtRnRaVkoxYkdWT1lXMWxJRDBnVG1GdFpWSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6VW5Wc1pVNWhiV1VnUFNCRVpXWnBibWwwYVc5dWMxSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJR0Z0WW1sbmRXOTFjMDF2WkdsbWFXVnlVblZzWlU1aGJXVWdQU0JCYldKcFozVnZkWE5OYjJScFptbGxjbEoxYkdWT1lXMWxMRnh1SUNBZ0lDQWdJQ0FnSUdGdFltbG5kVzkxYzAxdlpHbG1hV1Z5VW5Wc1pVNWhiV1ZRWVhKMElEMGdibVYzSUZKMWJHVk9ZVzFsVUdGeWRDaGhiV0pwWjNWdmRYTk5iMlJwWm1sbGNsSjFiR1ZPWVcxbEtTeGNiaUFnSUNBZ0lDQWdJQ0J1WVcxbFVuVnNaVTVoYldWUVlYSjBJRDBnYm1WM0lGSjFiR1ZPWVcxbFVHRnlkQ2h1WVcxbFVuVnNaVTVoYldVcExGeHVJQ0FnSUNBZ0lDQWdJRzl3ZEdsdmJtRnNRVzFpYVdkMWIzVnpVblZzWlU1aGJXVlFZWEowVUdGeWRDQTlJRzVsZHlCUGNIUnBiMjVoYkZCaGNuUlFZWEowS0dGdFltbG5kVzkxYzAxdlpHbG1hV1Z5VW5Wc1pVNWhiV1ZRWVhKMEtTeGNiaUFnSUNBZ0lDQWdJQ0J6WlhCaGNtRjBiM0pVWlhKdGFXNWhiRk41YldKdmJGQmhjblFnUFNCdVpYY2dWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBLSE5sY0dGeVlYUnZjbFJsY20xcGJtRnNVM2x0WW05c1EyOXVkR1Z1ZENrc1hHNGdJQ0FnSUNBZ0lDQWdaR1ZtYVc1cGRHbHZibk5TZFd4bFRtRnRaVkJoY25RZ1BTQnVaWGNnVW5Wc1pVNWhiV1ZRWVhKMEtHUmxabWx1YVhScGIyNXpVblZzWlU1aGJXVXBMRnh1SUNBZ0lDQWdJQ0FnSUhSbGNtMXBibUYwYjNKVVpYSnRhVzVoYkZONWJXSnZiRkJoY25RZ1BTQnVaWGNnVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowS0hSbGNtMXBibUYwYjNKVVpYSnRhVzVoYkZONWJXSnZiRU52Ym5SbGJuUXBMRnh1SUNBZ0lDQWdJQ0FnSUhCaGNuUnpJRDBnVzF4dUlDQWdJQ0FnSUNBZ0lDQWdibUZ0WlZKMWJHVk9ZVzFsVUdGeWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUc5d2RHbHZibUZzUVcxaWFXZDFiM1Z6VW5Wc1pVNWhiV1ZRWVhKMFVHRnlkQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lITmxjR0Z5WVhSdmNsUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbFptbHVhWFJwYjI1elVuVnNaVTVoYldWUVlYSjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2RHVnliV2x1WVhSdmNsUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRGeHVJQ0FnSUNBZ0lDQWdJRjA3WEc0Z0lDQWdYRzRnSUNBZ2MzVndaWElvY0dGeWRITXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKelpYQmhjbUYwYjNJaUxDSnpjR1ZqYVdGc1UzbHRZbTlzY3lJc0luUmxjbTFwYm1GMGIzSWlMQ0pTZFd4bFJHVm1hVzVwZEdsdmJpSXNJbk5sY0dGeVlYUnZjbFJsY20xcGJtRnNVM2x0WW05c1EyOXVkR1Z1ZENJc0luUmxjbTFwYm1GMGIzSlVaWEp0YVc1aGJGTjViV0p2YkVOdmJuUmxiblFpTENKdVlXMWxVblZzWlU1aGJXVWlMQ0pPWVcxbFVuVnNaVTVoYldVaUxDSmtaV1pwYm1sMGFXOXVjMUoxYkdWT1lXMWxJaXdpUkdWbWFXNXBkR2x2Ym5OU2RXeGxUbUZ0WlNJc0ltRnRZbWxuZFc5MWMwMXZaR2xtYVdWeVVuVnNaVTVoYldVaUxDSkJiV0pwWjNWdmRYTk5iMlJwWm1sbGNsSjFiR1ZPWVcxbElpd2lZVzFpYVdkMWIzVnpUVzlrYVdacFpYSlNkV3hsVG1GdFpWQmhjblFpTENKU2RXeGxUbUZ0WlZCaGNuUWlMQ0p1WVcxbFVuVnNaVTVoYldWUVlYSjBJaXdpYjNCMGFXOXVZV3hCYldKcFozVnZkWE5TZFd4bFRtRnRaVkJoY25SUVlYSjBJaXdpVDNCMGFXOXVZV3hRWVhKMFVHRnlkQ0lzSW5ObGNHRnlZWFJ2Y2xSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZENJc0lsUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDSXNJbVJsWm1sdWFYUnBiMjV6VW5Wc1pVNWhiV1ZRWVhKMElpd2lkR1Z5YldsdVlYUnZjbFJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ0lzSW5CaGNuUnpJaXdpUkdWbWFXNXBkR2x2YmlKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVclFpeEpRVUZCTEZsQlFXTXNWMEZCWkN4alFVRmpMRU5CUVVFN1FVRkZkRUlzU1VGQlFTeFhRVUZsTEd0RFFVRm1MR1ZCUVdVc1JVRkJRVHRCUVVOaUxFbEJRVUVzVTBGQk9FSXNhME5CUVRsQ0xEaENRVUU0UWl4RlFVRkJPMEZCUXpGQ0xFbEJRVUVzWVVGQmEwTXNhME5CUVd4RExHdERRVUZyUXl4RlFVRkJPMEZCUTJoRExFbEJRVUVzWlVGQmFVTXNhME5CUVdwRExHbERRVUZwUXl4RlFVRkJPMEZCUldFc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCT3pzN096czdPenM3T3pzN096czdTMEZVTTBZN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlhRU3hKUVVGUlFTeFRRVUZUTEVkQlFXbENReXhaUVVGakxHZENRVUY0UTBRc1UwRkJVeXhGUVVGRlJTeFZRVUZWTEVkQlFVdEVMRmxCUVdNc1owSkJRVGRDUXl4VlFVRlZMRUZCUVc5Q08wRkJSV3hETEVsQlFVRXNRVUZCVFVNc1kwRkJZeXhwUWtOaWFFTXNRVVJoV1R0NVEwRmlaanM3WVVGaGNVSkJMR05CUVdNN05rTkJZbTVETzFGQlpVa3NTVUZCVFVNc09FSkJRVGhDTEVkQlFVZEtMRk5CUVZNc1JVRkRNVU5MTEN0Q1FVRXJRaXhIUVVGSFNDeFZRVUZWTEVWQlF6VkRTU3haUVVGWkxFZEJRVWRETEZWQlFWa3NZVUZCUVN4RlFVTXpRa01zYlVKQlFXMUNMRWRCUVVkRExGVkJRVzFDTEc5Q1FVRkJMRVZCUTNwRFF5eDVRa0ZCZVVJc1IwRkJSME1zVlVGQmVVSXNNRUpCUVVFc1JVRkRja1JETERaQ1FVRTJRaXhIUVVGSExFbEJRVWxETEZOQlFWa3NVMEZCUTBnc2VVSkJRWGxDTEVOQlFVTXNSVUZETTBWSkxHZENRVUZuUWl4SFFVRkhMRWxCUVVsRUxGTkJRVmtzVTBGQlExQXNXVUZCV1N4RFFVRkRMRVZCUTJwRVV5eHBRMEZCYVVNc1IwRkJSeXhKUVVGSlF5eGhRVUZuUWl4VFFVRkRTaXcyUWtGQk5rSXNRMEZCUXl4RlFVTjJSa3NzTWtKQlFUSkNMRWRCUVVjc1NVRkJTVU1zWlVGQmEwSXNVMEZCUTJRc09FSkJRVGhDTEVOQlFVTXNSVUZEY0VabExIVkNRVUYxUWl4SFFVRkhMRWxCUVVsT0xGTkJRVmtzVTBGQlEwd3NiVUpCUVcxQ0xFTkJRVU1zUlVGREwwUlpMRFJDUVVFMFFpeEhRVUZITEVsQlFVbEdMR1ZCUVd0Q0xGTkJRVU5pTEN0Q1FVRXJRaXhEUVVGRExFVkJRM1JHWjBJc1MwRkJTeXhIUVVGSE8xbEJRMDVRTEdkQ1FVRm5RanRaUVVOb1FrTXNhVU5CUVdsRE8xbEJRMnBEUlN3eVFrRkJNa0k3V1VGRE0wSkZMSFZDUVVGMVFqdFpRVU4yUWtNc05FSkJRVFJDTzFOQlF6ZENMRUZCUVVNN2FVTkJSVVpETEV0QlFVczdPenREUVVWa0xFTkJka0l5UTBNc1YwRkJWU3hUUVhWQ2NrUTdhMEpCZGtKdlFtNUNMR05CUVdNc1FVRmlia01pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9ydWxlMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3J1bGVcIikpO1xudmFyIF9ydWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcnVsZVwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgUnVsZVJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoUnVsZVJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUnVsZVJ1bGUpO1xuICAgIGZ1bmN0aW9uIFJ1bGVSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZVJ1bGUpO1xuICAgICAgICB2YXIgcnVsZURlZmluaXRpb24gPSBuZXcgX3J1bGUyLmRlZmF1bHQoKSwgbmFtZSA9IF9ydWxlTmFtZXMuUnVsZVJ1bGVOYW1lLCBhbWJpZ3VvdXMgPSBmYWxzZSwgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBydWxlRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX3J1bGUxLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIFJ1bGVSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJ1bGVSdWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl5ZFd4bEwzSjFiR1V1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxYQ0k3WEc1cGJYQnZjblFnVW5Wc1pVSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwzSjFiR1ZjSWp0Y2JtbHRjRzl5ZENCU2RXeGxSR1ZtYVc1cGRHbHZiaUJtY205dElGd2lMaTR2WkdWbWFXNXBkR2x2Ymk5eWRXeGxYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGSjFiR1ZTZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1VuVnNaVkoxYkdVZ1pYaDBaVzVrY3lCU2RXeGxJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2NuVnNaVVJsWm1sdWFYUnBiMjRnUFNCdVpYY2dVblZzWlVSbFptbHVhWFJwYjI0b0tTeGNiaUFnSUNBZ0lDQWdJQ0J1WVcxbElEMGdVblZzWlZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnY25Wc1pVUmxabWx1YVhScGIyNWNiaUFnSUNBZ0lDQWdJQ0JkTEZ4dUlDQWdJQ0FnSUNBZ0lFNXZaR1VnUFNCU2RXeGxRazVHVG05a1pUdGNiaUFnSUNCY2JpQWdJQ0J6ZFhCbGNpaHVZVzFsTENCaGJXSnBaM1Z2ZFhNc0lHUmxabWx1YVhScGIyNXpMQ0JPYjJSbEtUdGNiaUFnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxKMWJHVlNkV3hsSWl3aWNuVnNaVVJsWm1sdWFYUnBiMjRpTENKU2RXeGxSR1ZtYVc1cGRHbHZiaUlzSW01aGJXVWlMQ0pTZFd4bFVuVnNaVTVoYldVaUxDSmhiV0pwWjNWdmRYTWlMQ0prWldacGJtbDBhVzl1Y3lJc0lrNXZaR1VpTENKU2RXeGxRazVHVG05a1pTSXNJbEoxYkdVaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRmFVSXNTVUZCUVN4TFFVRlRMR3REUVVGVUxGTkJRVk1zUlVGQlFUdEJRVU5HTEVsQlFVRXNUVUZCYTBJc2EwTkJRV3hDTEd0Q1FVRnJRaXhGUVVGQk8wRkJRMllzU1VGQlFTeE5RVUZ2UWl4clEwRkJjRUlzYjBKQlFXOUNMRVZCUVVFN1FVRkZiRUlzU1VGQlFTeFZRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRk9NME03T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUlpTeEpRVUZCTEVGQlFVMUJMRkZCUVZFc2FVSkRVakZDTEVGRVVWazdOa0pCVW1ZN08yRkJVWEZDUVN4UlFVRlJPM1ZEUVZJM1FqdFJRVlZKTEVsQlFVMURMR05CUVdNc1IwRkJSeXhKUVVGSlF5eE5RVUZqTEZWQlFVVXNSVUZEY2tORExFbEJRVWtzUjBGQlIwTXNWVUZCV1N4aFFVRkJMRVZCUTI1Q1F5eFRRVUZUTEVkQlFVY3NTMEZCU3l4RlFVTnFRa01zVjBGQlZ5eEhRVUZITzFsQlExcE1MR05CUVdNN1UwRkRaaXhGUVVORVRTeEpRVUZKTEVkQlFVZERMRTFCUVZjc1VVRkJRU3hCUVVGRE8ybERRVVZ1UWt3c1NVRkJTU3hGUVVGRlJTeFRRVUZUTEVWQlFVVkRMRmRCUVZjc1JVRkJSVU1zU1VGQlNUczdPME5CUlRORExFTkJXbkZEUlN4TFFVRkpMRk5CV1hwRE8ydENRVnB2UWxRc1VVRkJVU3hCUVZJM1FpSjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBFcnJvckJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhFcnJvckJORk5vZGUsIE5vblRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFcnJvckJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIEVycm9yQk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yQk5GTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEVycm9yQk5GTm9kZSwgbnVsbCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhFcnJvckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBFcnJvckJORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVycm9yQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOWxjbkp2Y2k1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJRTV2YmxSbGNtMXBibUZzVG05a1pTQm1jbTl0SUZ3aUxpNHZMaTR2Ym05a1pTOXViMjVVWlhKdGFXNWhiRndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJGY25KdmNrSk9SazV2WkdVZ1pYaDBaVzVrY3lCT2IyNVVaWEp0YVc1aGJFNXZaR1VnZTF4dUlDQnpkR0YwYVdNZ1puSnZiVkoxYkdWT1lXMWxRVzVrUTJocGJHUk9iMlJsY3loeWRXeGxUbUZ0WlN3Z1kyaHBiR1JPYjJSbGN5a2dleUJ5WlhSMWNtNGdUbTl1VkdWeWJXbHVZV3hPYjJSbExtWnliMjFTZFd4bFRtRnRaVUZ1WkVOb2FXeGtUbTlrWlhNb1JYSnliM0pDVGtaT2IyUmxMQ0J5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrN0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SkZjbkp2Y2tKT1JrNXZaR1VpTENKbWNtOXRVblZzWlU1aGJXVkJibVJEYUdsc1pFNXZaR1Z6SWl3aWNuVnNaVTVoYldVaUxDSmphR2xzWkU1dlpHVnpJaXdpVG05dVZHVnliV2x1WVd4T2IyUmxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSVFJDTEVsQlFVRXNXVUZCZDBJc2EwTkJRWGhDTEhkQ1FVRjNRaXhGUVVGQk96czdPenM3T3pzN096czdPenM3T0VSQlJuQkVPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVWxsTEVsQlFVRXNRVUZCVFVFc1dVRkJXU3hwUWtOS09VSXNRVVJKV1RzMFEwRktaanM3WVVGSmNVSkJMRmxCUVZrN01rTkJTbXBET3pzN096dFpRVXRUUXl4SFFVRjVRaXhGUVVGNlFrRXNNa0pCUVhsQ08xbEZUR3hETEU5R1MwVXNVMEZCVDBFc2VVSkJRWGxDTEVOQlFVTkRMRkZCUVZFc1JVRkJSVU1zVlVGQlZTeEZRVUZGTzJkQ1FVRkZMRTlCUVU5RExGbEJRV1VzVTBGQlEwZ3NlVUpCUVhsQ0xFTkJRVU5FTEZsQlFWa3NSVUZCUlVVc1VVRkJVU3hGUVVGRlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0aFFVRkZPenROUVV4c1NqczdRMEZOUXl4RFFVWjVRME1zV1VGQlpTeFRRVVY0UkR0clFrRkdiMEpLTEZsQlFWa3NRVUZLYWtNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfdGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCIpKTtcbnZhciBfdGVybWluYWwxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciB3aWxkY2FyZCA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy53aWxkY2FyZDtcbnZhciBXaWxkY2FyZFBhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFRlcm1pbmFsUGFydCkge1xuICAgIF9pbmhlcml0cyhXaWxkY2FyZFBhcnQsIFRlcm1pbmFsUGFydCk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXaWxkY2FyZFBhcnQpO1xuICAgIGZ1bmN0aW9uIFdpbGRjYXJkUGFydCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpbGRjYXJkUGFydCk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFdpbGRjYXJkUGFydCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSwgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLCBzaWduaWZpY2FudFRva2VuID0gbmV4dFNpZ25pZmljYW50VG9rZW47IC8vL1xuICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IF90ZXJtaW5hbDEuZGVmYXVsdC5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gdGVybWluYWxOb2RlICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzU3RyaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNTdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IHdpbGRjYXJkOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoV2lsZGNhcmRQYXJ0LnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBXaWxkY2FyZFBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFdpbGRjYXJkUGFydDtcbn0oX3Rlcm1pbmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2lsZGNhcmRQYXJ0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lYSjBMM1JsY20xcGJtRnNMM2RwYkdSallYSmtMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ2V5QnpjR1ZqYVdGc1UzbHRZbTlzY3lCOUlHWnliMjBnWENKdlkyTmhiUzFzWlhobGNuTmNJanRjYmx4dWFXMXdiM0owSUZSbGNtMXBibUZzVUdGeWRDQm1jbTl0SUZ3aUxpNHZMaTR2Y0dGeWRDOTBaWEp0YVc1aGJGd2lPMXh1YVcxd2IzSjBJRlJsY20xcGJtRnNUbTlrWlNCbWNtOXRJRndpTGk0dkxpNHZibTlrWlM5MFpYSnRhVzVoYkZ3aU8xeHVYRzVqYjI1emRDQjdJSGRwYkdSallYSmtJSDBnUFNCemNHVmphV0ZzVTNsdFltOXNjenRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdWMmxzWkdOaGNtUlFZWEowSUdWNGRHVnVaSE1nVkdWeWJXbHVZV3hRWVhKMElIdGNiaUFnY0dGeWMyVW9ibTlrWlhNc0lITjBZWFJsTENCallXeHNZbUZqYXlrZ2UxeHVJQ0FnSUd4bGRDQndZWEp6WldRN1hHNWNiaUFnSUNCc1pYUWdkR1Z5YldsdVlXeE9iMlJsSUQwZ2JuVnNiRHRjYmlBZ0lDQmNiaUFnSUNCamIyNXpkQ0J6WVhabFpFbHVaR1Y0SUQwZ2MzUmhkR1V1WjJWMFUyRjJaV1JKYm1SbGVDZ3BMRnh1WEhSY2RDQWdJQ0FnSUc1bGVIUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlEMGdjM1JoZEdVdVoyVjBUbVY0ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRvS1N4Y2JseDBYSFJjZEZ4MFhIUnphV2R1YVdacFkyRnVkRlJ2YTJWdUlEMGdibVY0ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzQ3SUM4dkwxeHVYRzRnSUNBZ2FXWWdLSE5wWjI1cFptbGpZVzUwVkc5clpXNGdJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJSFJsY20xcGJtRnNUbTlrWlNBOUlGUmxjbTFwYm1Gc1RtOWtaUzVtY205dFUybG5ibWxtYVdOaGJuUlViMnRsYmloemFXZHVhV1pwWTJGdWRGUnZhMlZ1S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J3WVhKelpXUWdQU0FvZEdWeWJXbHVZV3hPYjJSbElDRTlQU0J1ZFd4c0tUdGNibHh1SUNBZ0lHbG1JQ2h3WVhKelpXUXBJSHRjYmlBZ0lDQWdJRzV2WkdWekxuQjFjMmdvZEdWeWJXbHVZV3hPYjJSbEtUdGNibHh1SUNBZ0lDQWdhV1lnS0dOaGJHeGlZV05ySUNFOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNBZ0lIQmhjbk5sWkNBOUlHTmhiR3hpWVdOcktDazdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tDRndZWEp6WldRcElIdGNiaUFnSUNBZ0lDQWdJQ0J1YjJSbGN5NXdiM0FvS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDZ2hjR0Z5YzJWa0tTQjdYRzRnSUNBZ0lDQnpkR0YwWlM1aVlXTnJkSEpoWTJzb2MyRjJaV1JKYm1SbGVDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUhCaGNuTmxaRHRjYmlBZ2ZWeHVYRzRnSUdGelUzUnlhVzVuS0NrZ2UxeHVJQ0FnSUdOdmJuTjBJSE4wY21sdVp5QTlJSGRwYkdSallYSmtPeUFnTHk4dlhHNWNiaUFnSUNCeVpYUjFjbTRnYzNSeWFXNW5PMXh1SUNCOVhHNWNiaUFnWTJ4dmJtVW9LU0I3SUhKbGRIVnliaUJ6ZFhCbGNpNWpiRzl1WlNoWGFXeGtZMkZ5WkZCaGNuUXBPeUI5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpZDJsc1pHTmhjbVFpTENKemNHVmphV0ZzVTNsdFltOXNjeUlzSWxkcGJHUmpZWEprVUdGeWRDSXNJbkJoY25ObElpd2libTlrWlhNaUxDSnpkR0YwWlNJc0ltTmhiR3hpWVdOcklpd2ljR0Z5YzJWa0lpd2lkR1Z5YldsdVlXeE9iMlJsSWl3aWMyRjJaV1JKYm1SbGVDSXNJbWRsZEZOaGRtVmtTVzVrWlhnaUxDSnVaWGgwVTJsbmJtbG1hV05oYm5SVWIydGxiaUlzSW1kbGRFNWxlSFJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpYzJsbmJtbG1hV05oYm5SVWIydGxiaUlzSWxSbGNtMXBibUZzVG05a1pTSXNJbVp5YjIxVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWl3aWNIVnphQ0lzSW5CdmNDSXNJbUpoWTJ0MGNtRmpheUlzSW1GelUzUnlhVzVuSWl3aWMzUnlhVzVuSWl3aVkyeHZibVVpTENKVVpYSnRhVzVoYkZCaGNuUWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZLMElzU1VGQlFTeFpRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPMEZCUlhCQ0xFbEJRVUVzVTBGQmNVSXNhME5CUVhKQ0xIRkNRVUZ4UWl4RlFVRkJPMEZCUTNKQ0xFbEJRVUVzVlVGQmNVSXNhME5CUVhKQ0xIRkNRVUZ4UWl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJURGxETzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzd1FrRkJRVHM3T3pzN096czdPenRUUVVGQk96czdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096dDNRMEZCUVRzN096czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUFFTeEpRVUZOTEVGQlFVVkJMRkZCUVZFc1IwRkJTME1zV1VGQll5eG5Ra0ZCTTBKRUxGRkJRVkVzUVVGQmJVSXNRVUZCUXp0QlFVVnlRaXhKUVVGQkxFRkJRVTFGTEZsQlFWa3NhVUpEVkRsQ0xFRkVVMWs3ZVVOQlZHWTdPMkZCVTNGQ1FTeFpRVUZaT3pKRFFWUnFRenM3T3pzN1dVRlZSVU1zUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxGVmxBc1QwWlZSVUVzVTBGQlFVRXNTMEZCU3l4RFFVRkRReXhMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8yZENRVU0xUWl4SlFVRkpReXhOUVVGTkxFRkJRVU03WjBKQlJWZ3NTVUZCU1VNc1dVRkJXU3hIUVVGSExFbEJRVWtzUVVGQlF6dG5Ra0ZGZUVJc1NVRkJUVU1zVlVGQlZTeEhRVUZIU2l4TFFVRkxMRU5CUVVOTExHRkJRV0VzUlVGQlJTeEZRVU53UTBNc2IwSkJRVzlDTEVkQlFVZE9MRXRCUVVzc1EwRkJRMDhzZFVKQlFYVkNMRVZCUVVVc1JVRkRla1JETEdkQ1FVRm5RaXhIUVVGSFJpeHZRa0ZCYjBJc1FVRkJReXhGUVVGRExFZEJRVWM3WjBKQlJUZERMRWxCUVVsRkxHZENRVUZuUWl4TFFVRkxMRWxCUVVrc1JVRkJSVHR2UWtGRE4wSk1MRmxCUVZrc1IwRkJSMDBzVlVGQldTeFRRVUZEUXl4dlFrRkJiMElzUTBGQlEwWXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dHBRa0ZEY0VVN1owSkJSVVJPTEUxQlFVMHNSMEZCU1VNc1dVRkJXU3hMUVVGTExFbEJRVWtzUVVGQlF5eERRVUZETzJkQ1FVVnFReXhKUVVGSlJDeE5RVUZOTEVWQlFVVTdiMEpCUTFaSUxFdEJRVXNzUTBGQlExa3NTVUZCU1N4RFFVRkRVaXhaUVVGWkxFTkJRVU1zUTBGQlF6dHZRa0ZGZWtJc1NVRkJTVVlzVVVGQlVTeExRVUZMTEVsQlFVa3NSVUZCUlR0M1FrRkRja0pETEUxQlFVMHNSMEZCUjBRc1VVRkJVU3hGUVVGRkxFTkJRVU03ZDBKQlJYQkNMRWxCUVVrc1EwRkJRME1zVFVGQlRTeEZRVUZGT3pSQ1FVTllTQ3hMUVVGTExFTkJRVU5oTEVkQlFVY3NSVUZCUlN4RFFVRkRPM2xDUVVOaU8zRkNRVU5HTzJsQ1FVTkdPMmRDUVVWRUxFbEJRVWtzUTBGQlExWXNUVUZCVFN4RlFVRkZPMjlDUVVOWVJpeExRVUZMTEVOQlFVTmhMRk5CUVZNc1EwRkJRMVFzVlVGQlZTeERRVUZETEVOQlFVTTdhVUpCUXpkQ08yZENRVVZFTEU5QlFVOUdMRTFCUVUwc1EwRkJRenRoUVVObU96czdXVUZGUkZrc1IwRkJVU3hGUVVGU1FTeFZRVUZSTzFsRk5VTldMRTlHTkVORlFTeFRRVUZCUVN4UlFVRlJMRWRCUVVjN1owSkJRMVFzU1VGQlRVTXNUVUZCVFN4SFFVRkhjRUlzVVVGQlVTeEJRVUZETEVWQlFVVXNSMEZCUnp0blFrRkZOMElzVDBGQlQyOUNMRTFCUVUwc1EwRkJRenRoUVVObU96czdXVUZGUkVNc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRmJFUlFMRTlHYTBSRlFTeFRRVUZCUVN4TFFVRkxMRWRCUVVjN1owSkJRVVVzVDBGQlR5eHhRa0Y2UTBWdVFpeFpRVUZaTEdGQmVVTlNiVUlzVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBia0lzV1VGQldTeEZRVUZGTzJGQlFVVTdPMDFCYkVRdlF6czdRMEZ0UkVNc1EwRXhRM2xEYjBJc1UwRkJXU3hUUVRCRGNrUTdhMEpCTVVOdlFuQkNMRmxCUVZrc1FVRlVha01pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb25cIikpO1xudmFyIF93aWxkY2FyZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEVycm9yRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhFcnJvckRlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXJyb3JEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBFcnJvckRlZmluaXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcnJvckRlZmluaXRpb24pO1xuICAgICAgICB2YXIgd2lsZGNhcmRQYXJ0ID0gbmV3IF93aWxkY2FyZC5kZWZhdWx0KCksIHBhcnRzID0gW1xuICAgICAgICAgICAgd2lsZGNhcmRQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvckRlZmluaXRpb247XG59KF9kZWZpbml0aW9uLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JEZWZpbml0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrWldacGJtbDBhVzl1TDJWeWNtOXlMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZibHdpTzF4dWFXMXdiM0owSUZkcGJHUmpZWEprVUdGeWRDQm1jbTl0SUZ3aUxpNHZjR0Z5ZEM5MFpYSnRhVzVoYkM5M2FXeGtZMkZ5WkZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCRmNuSnZja1JsWm1sdWFYUnBiMjRnWlhoMFpXNWtjeUJFWldacGJtbDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdkMmxzWkdOaGNtUlFZWEowSUQwZ2JtVjNJRmRwYkdSallYSmtVR0Z5ZENncExGeHVJQ0FnSUNBZ0lDQWdJSEJoY25SeklEMGdXMXh1SUNBZ0lDQWdJQ0FnSUNBZ2QybHNaR05oY21SUVlYSjBYRzRnSUNBZ0lDQWdJQ0FnWFR0Y2JseHVJQ0FnSUhOMWNHVnlLSEJoY25SektWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpUlhKeWIzSkVaV1pwYm1sMGFXOXVJaXdpZDJsc1pHTmhjbVJRWVhKMElpd2lWMmxzWkdOaGNtUlFZWEowSWl3aWNHRnlkSE1pTENKRVpXWnBibWwwYVc5dUlsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJYVkNMRWxCUVVFc1YwRkJaU3hyUTBGQlppeGxRVUZsTEVWQlFVRTdRVUZEWWl4SlFVRkJMRk5CUVRKQ0xHdERRVUV6UWl3eVFrRkJNa0lzUlVGQlFUczdPenM3T3pzN096czdPenM3TzB0QlNIQkVPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCUzJVc1NVRkJRU3hCUVVGTlFTeGxRVUZsTEdsQ1EweHFReXhCUkV0Wk96QkRRVXhtT3p0aFFVdHhRa0VzWlVGQlpUczRRMEZNY0VNN1VVRlBTU3hKUVVGTlF5eFpRVUZaTEVkQlFVY3NTVUZCU1VNc1UwRkJXU3hWUVVGRkxFVkJRMnBEUXl4TFFVRkxMRWRCUVVjN1dVRkRUa1lzV1VGQldUdFRRVU5pTEVGQlFVTTdhVU5CUlVaRkxFdEJRVXM3T3p0RFFVVmtMRU5CVkRSRFF5eFhRVUZWTEZOQlUzUkVPMnRDUVZSdlFrb3NaVUZCWlN4QlFVeHdReUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ydWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZVwiKSk7XG52YXIgX2Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9kZS9ibmYvZXJyb3JcIikpO1xudmFyIF9lcnJvcjEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL2Vycm9yXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBFcnJvclJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoRXJyb3JSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVycm9yUnVsZSk7XG4gICAgZnVuY3Rpb24gRXJyb3JSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JSdWxlKTtcbiAgICAgICAgdmFyIGVycm9yRGVmaW5pdGlvbiA9IG5ldyBfZXJyb3IxLmRlZmF1bHQoKSwgbmFtZSA9IF9ydWxlTmFtZXMuRXJyb3JSdWxlTmFtZSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZXJyb3JEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfZXJyb3IuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVycm9yUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMMlZ5Y205eUxtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnVW5Wc1pTQm1jbTl0SUZ3aUxpNHZjblZzWlZ3aU8xeHVhVzF3YjNKMElFVnljbTl5UWs1R1RtOWtaU0JtY205dElGd2lMaTR2Ym05a1pTOWlibVl2WlhKeWIzSmNJanRjYm1sdGNHOXlkQ0JGY25KdmNrUmxabWx1YVhScGIyNGdabkp2YlNCY0lpNHVMMlJsWm1sdWFYUnBiMjR2WlhKeWIzSmNJanRjYmx4dWFXMXdiM0owSUhzZ1JYSnliM0pTZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1JYSnliM0pTZFd4bElHVjRkR1Z1WkhNZ1VuVnNaU0I3WEc0Z0lHTnZibk4wY25WamRHOXlLQ2tnZTF4dUlDQWdJR052Ym5OMElHVnljbTl5UkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJGY25KdmNrUmxabWx1YVhScGIyNG9LU3hjYmlBZ0lDQWdJQ0FnSUNCdVlXMWxJRDBnUlhKeWIzSlNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0JoYldKcFozVnZkWE1nUFNCbVlXeHpaU3hjYmlBZ0lDQWdJQ0FnSUNCa1pXWnBibWwwYVc5dWN5QTlJRnRjYmlBZ0lDQWdJQ0FnSUNBZ0lHVnljbTl5UkdWbWFXNXBkR2x2Ymx4dUlDQWdJQ0FnSUNBZ0lGMHNYRzRnSUNBZ0lDQWdJQ0FnVG05a1pTQTlJRVZ5Y205eVFrNUdUbTlrWlR0Y2JpQWdJQ0JjYmlBZ0lDQnpkWEJsY2lodVlXMWxMQ0JoYldKcFozVnZkWE1zSUdSbFptbHVhWFJwYjI1ekxDQk9iMlJsS1R0Y2JpQWdmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJa1Z5Y205eVVuVnNaU0lzSW1WeWNtOXlSR1ZtYVc1cGRHbHZiaUlzSWtWeWNtOXlSR1ZtYVc1cGRHbHZiaUlzSW01aGJXVWlMQ0pGY25KdmNsSjFiR1ZPWVcxbElpd2lZVzFpYVdkMWIzVnpJaXdpWkdWbWFXNXBkR2x2Ym5NaUxDSk9iMlJsSWl3aVJYSnliM0pDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBRc1NVRkJRU3hOUVVGdFFpeHJRMEZCYmtJc2JVSkJRVzFDTEVWQlFVRTdRVUZEYUVJc1NVRkJRU3hQUVVGeFFpeHJRMEZCY2tJc2NVSkJRWEZDTEVWQlFVRTdRVUZGYmtJc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCT3pzN096czdPenM3T3pzN096czdTMEZPTlVNN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlJaU3hKUVVGQkxFRkJRVTFCTEZOQlFWTXNhVUpEVWpOQ0xFRkVVVms3T0VKQlVtWTdPMkZCVVhGQ1FTeFRRVUZUTzNkRFFWSTVRanRSUVZWSkxFbEJRVTFETEdWQlFXVXNSMEZCUnl4SlFVRkpReXhQUVVGbExGVkJRVVVzUlVGRGRrTkRMRWxCUVVrc1IwRkJSME1zVlVGQllTeGpRVUZCTEVWQlEzQkNReXhUUVVGVExFZEJRVWNzUzBGQlN5eEZRVU5xUWtNc1YwRkJWeXhIUVVGSE8xbEJRMXBNTEdWQlFXVTdVMEZEYUVJc1JVRkRSRTBzU1VGQlNTeEhRVUZIUXl4TlFVRlpMRkZCUVVFc1FVRkJRenRwUTBGRmNFSk1MRWxCUVVrc1JVRkJSVVVzVTBGQlV5eEZRVUZGUXl4WFFVRlhMRVZCUVVWRExFbEJRVWs3T3p0RFFVVXpReXhEUVZwelEwVXNTMEZCU1N4VFFWa3hRenRyUWtGYWIwSlVMRk5CUVZNc1FVRlNPVUlpZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uLy4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIERvY3VtZW50Qk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKERvY3VtZW50Qk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERvY3VtZW50Qk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnRCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jdW1lbnRCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoRG9jdW1lbnRCTkZOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZW5lcmF0ZVJ1bGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVSdWxlcyhSdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgcnVsZU5vZGVzMSA9IGNoaWxkTm9kZXMucmVkdWNlKGZ1bmN0aW9uKHJ1bGVOb2RlcywgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgcnVsZU5hbWUgPSBjaGlsZE5vZGUuZ2V0UnVsZU5hbWUoKSwgcnVsZU5hbWVSdWxlUnVsZU5hbWUgPSBydWxlTmFtZSA9PT0gX3J1bGVOYW1lcy5SdWxlUnVsZU5hbWUsIG5vblRlcm1pbmFsTm9kZVJ1bGVOb2RlID0gcnVsZU5hbWVSdWxlUnVsZU5hbWU7IC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vblRlcm1pbmFsTm9kZVJ1bGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVOb2RlID0gbm9uVGVybWluYWxOb2RlOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlTm9kZXMucHVzaChydWxlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVOb2RlcztcbiAgICAgICAgICAgICAgICB9LCBbXSksIHJ1bGVzID0gcnVsZU5vZGVzMS5tYXAoZnVuY3Rpb24ocnVsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlTm9kZS5nZW5lcmF0ZVJ1bGUoUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25UZXJtaW5hbC5kZWZhdWx0LmZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMoRG9jdW1lbnRCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gRG9jdW1lbnRCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBEb2N1bWVudEJORk5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl1YjJSbEwySnVaaTlrYjJOMWJXVnVkQzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNUbTlrWlNCbWNtOXRYQ0l1TGk4dUxpOXViMlJsTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVjYm1sdGNHOXlkQ0I3SUZKMWJHVlNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTh1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1JHOWpkVzFsYm5SQ1RrWk9iMlJsSUdWNGRHVnVaSE1nVG05dVZHVnliV2x1WVd4T2IyUmxJSHRjYmlBZ1oyVnVaWEpoZEdWU2RXeGxjeWhTZFd4bEtTQjdYRzRnSUNBZ1kyOXVjM1FnWTJocGJHUk9iMlJsY3lBOUlIUm9hWE11WjJWMFEyaHBiR1JPYjJSbGN5Z3BMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVk9iMlJsY3lBOUlHTm9hV3hrVG05a1pYTXVjbVZrZFdObEtDaHlkV3hsVG05a1pYTXNJR05vYVd4a1RtOWtaU2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdZMmhwYkdST2IyUmxUbTl1VkdWeWJXbHVZV3hPYjJSbElEMGdZMmhwYkdST2IyUmxMbWx6VG05dVZHVnliV2x1WVd4T2IyUmxLQ2s3WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoamFHbHNaRTV2WkdWT2IyNVVaWEp0YVc1aGJFNXZaR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdibTl1VkdWeWJXbHVZV3hPYjJSbElEMGdZMmhwYkdST2IyUmxMQ0FnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEoxYkdWT1lXMWxJRDBnWTJocGJHUk9iMlJsTG1kbGRGSjFiR1ZPWVcxbEtDa3NYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKMWJHVk9ZVzFsVW5Wc1pWSjFiR1ZPWVcxbElEMGdLSEoxYkdWT1lXMWxJRDA5UFNCU2RXeGxVblZzWlU1aGJXVXBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdWIyNVVaWEp0YVc1aGJFNXZaR1ZTZFd4bFRtOWtaU0E5SUhKMWJHVk9ZVzFsVW5Wc1pWSjFiR1ZPWVcxbE95QWdMeTh2WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHNXZibFJsY20xcGJtRnNUbTlrWlZKMWJHVk9iMlJsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY25Wc1pVNXZaR1VnUFNCdWIyNVVaWEp0YVc1aGJFNXZaR1U3SUM4dkwxeHVYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjblZzWlU1dlpHVnpMbkIxYzJnb2NuVnNaVTV2WkdVcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnlkV3hsVG05a1pYTTdYRzRnSUNBZ0lDQWdJQ0FnZlN3Z1cxMHBMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVnpJRDBnY25Wc1pVNXZaR1Z6TG0xaGNDZ29jblZzWlU1dlpHVXBJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElISjFiR1VnUFNCeWRXeGxUbTlrWlM1blpXNWxjbUYwWlZKMWJHVW9VblZzWlNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCeWRXeGxPMXh1SUNBZ0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUZ4dUlDQWdJSEpsZEhWeWJpQnlkV3hsY3p0Y2JpQWdmVnh1WEc0Z0lITjBZWFJwWXlCbWNtOXRVblZzWlU1aGJXVkJibVJEYUdsc1pFNXZaR1Z6S0hKMWJHVk9ZVzFsTENCamFHbHNaRTV2WkdWektTQjdJSEpsZEhWeWJpQk9iMjVVWlhKdGFXNWhiRTV2WkdVdVpuSnZiVkoxYkdWT1lXMWxRVzVrUTJocGJHUk9iMlJsY3loRWIyTjFiV1Z1ZEVKT1JrNXZaR1VzSUhKMWJHVk9ZVzFsTENCamFHbHNaRTV2WkdWektUc2dmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJa1J2WTNWdFpXNTBRazVHVG05a1pTSXNJbWRsYm1WeVlYUmxVblZzWlhNaUxDSlNkV3hsSWl3aVkyaHBiR1JPYjJSbGN5SXNJbWRsZEVOb2FXeGtUbTlrWlhNaUxDSnlkV3hsVG05a1pYTWlMQ0p5WldSMVkyVWlMQ0pqYUdsc1pFNXZaR1VpTENKamFHbHNaRTV2WkdWT2IyNVVaWEp0YVc1aGJFNXZaR1VpTENKcGMwNXZibFJsY20xcGJtRnNUbTlrWlNJc0ltNXZibFJsY20xcGJtRnNUbTlrWlNJc0luSjFiR1ZPWVcxbElpd2laMlYwVW5Wc1pVNWhiV1VpTENKeWRXeGxUbUZ0WlZKMWJHVlNkV3hsVG1GdFpTSXNJbEoxYkdWU2RXeGxUbUZ0WlNJc0ltNXZibFJsY20xcGJtRnNUbTlrWlZKMWJHVk9iMlJsSWl3aWNuVnNaVTV2WkdVaUxDSndkWE5vSWl3aWNuVnNaWE1pTENKdFlYQWlMQ0p5ZFd4bElpd2laMlZ1WlhKaGRHVlNkV3hsSWl3aVpuSnZiVkoxYkdWT1lXMWxRVzVrUTJocGJHUk9iMlJsY3lJc0lrNXZibFJsY20xcGJtRnNUbTlrWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVeVFpeEpRVUZCTEZsQlFYZENMR3REUVVGNFFpeDNRa0ZCZDBJc1JVRkJRVHRCUVVWMFFpeEpRVUZCTEZWQlFXbENMRmRCUVdwQ0xHbENRVUZwUWl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJTamxETzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVUxbExFbEJRVUVzUVVGQlRVRXNaVUZCWlN4cFFrTk9ha01zUVVSTldUc3JRMEZPWmpzN1lVRk5jVUpCTEdWQlFXVTdPRU5CVG5CRE96czdPenRaUVU5RlF5eEhRVUZoTEVWQlFXSkJMR1ZCUVdFN1dVVlFaaXhQUms5RlFTeFRRVUZCUVN4aFFVRmhMRU5CUVVORExFbEJRVWtzUlVGQlJUdG5Ra0ZEYkVJc1NVRkJUVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEUXl4VlFVRlRMRWRCUVVkR0xGVkJRVlVzUTBGQlEwY3NUVUZCVFN4RFFVRkRMRk5CUVVORUxGTkJRVk1zUlVGQlJVVXNVMEZCVXl4RlFVRkxPMjlDUVVOMFJDeEpRVUZOUXl4M1FrRkJkMElzUjBGQlIwUXNVMEZCVXl4RFFVRkRSU3hwUWtGQmFVSXNSVUZCUlN4QlFVRkRPMjlDUVVVdlJDeEpRVUZKUkN4M1FrRkJkMElzUlVGQlJUdDNRa0ZETlVJc1NVRkJUVVVzWlVGQlpTeEhRVUZIU0N4VFFVRlRMRVZCUXpOQ1NTeFJRVUZSTEVkQlFVZEtMRk5CUVZNc1EwRkJRMHNzVjBGQlZ5eEZRVUZGTEVWQlEyeERReXh2UWtGQmIwSXNSMEZCU1VZc1VVRkJVU3hMUVVGTFJ5eFZRVUZaTEdGQlFVRXNRVUZCUXl4RlFVTnNSRU1zZFVKQlFYVkNMRWRCUVVkR0xHOUNRVUZ2UWl4QlFVRkRMRVZCUVVVc1IwRkJSenQzUWtGRk1VUXNTVUZCU1VVc2RVSkJRWFZDTEVWQlFVVTdORUpCUXpOQ0xFbEJRVTFETEZGQlFWRXNSMEZCUjA0c1pVRkJaU3hCUVVGRExFVkJRVU1zUjBGQlJ6czBRa0ZGY2tOTUxGTkJRVk1zUTBGQlExa3NTVUZCU1N4RFFVRkRSQ3hSUVVGUkxFTkJRVU1zUTBGQlF6dDVRa0ZETVVJN2NVSkJRMFk3YjBKQlJVUXNUMEZCVDFnc1UwRkJVeXhEUVVGRE8ybENRVU5zUWl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVOT1lTeExRVUZMTEVkQlFVZGlMRlZCUVZNc1EwRkJRMk1zUjBGQlJ5eERRVUZETEZOQlFVTklMRkZCUVZFc1JVRkJTenR2UWtGRGJFTXNTVUZCVFVrc1NVRkJTU3hIUVVGSFNpeFJRVUZSTEVOQlFVTkxMRmxCUVZrc1EwRkJRMjVDTEVsQlFVa3NRMEZCUXl4QlFVRkRPMjlDUVVWNlF5eFBRVUZQYTBJc1NVRkJTU3hEUVVGRE8ybENRVU5pTEVOQlFVTXNRVUZCUXp0blFrRkZWQ3hQUVVGUFJpeExRVUZMTEVOQlFVTTdZVUZEWkRzN096dFpRVVZOU1N4SFFVRjVRaXhGUVVGNlFrRXNNa0pCUVhsQ08xbEZjRU5zUXl4UFJtOURSU3hUUVVGUFFTeDVRa0ZCZVVJc1EwRkJRMWdzVVVGQlVTeEZRVUZGVWl4VlFVRlZMRVZCUVVVN1owSkJRVVVzVDBGQlQyOUNMRmxCUVdVc1UwRkJRMFFzZVVKQlFYbENMRU5CUVVOMFFpeGxRVUZsTEVWQlFVVlhMRkZCUVZFc1JVRkJSVklzVlVGQlZTeERRVUZETEVOQlFVTTdZVUZCUlRzN1RVRndRM0pLT3p0RFFYRkRReXhEUVM5Q05FTnZRaXhaUVVGbExGTkJLMEl6UkR0clFrRXZRbTlDZGtJc1pVRkJaU3hCUVU1d1F5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbFwiKSk7XG52YXIgX3BhcnRUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9wYXJ0VHlwZXNcIik7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxpdGllcy9hcnJheVwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIENob2ljZU9mUGFydHNQYXJ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbFBhcnQpIHtcbiAgICBfaW5oZXJpdHMoQ2hvaWNlT2ZQYXJ0c1BhcnQsIE5vblRlcm1pbmFsUGFydCk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDaG9pY2VPZlBhcnRzUGFydCk7XG4gICAgZnVuY3Rpb24gQ2hvaWNlT2ZQYXJ0c1BhcnQocGFydHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENob2ljZU9mUGFydHNQYXJ0KTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICB2YXIgdHlwZSA9IF9wYXJ0VHlwZXMuQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOyAvLy9cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgX3RoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQ2hvaWNlT2ZQYXJ0c1BhcnQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFBhcnRzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFydHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwYXJzZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydHMuc29tZShmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzU3RyaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNTdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzU3RyaW5nMSA9IHRoaXMucGFydHMucmVkdWNlKGZ1bmN0aW9uKHBhcnRzU3RyaW5nLCBwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0U3RyaW5nID0gcGFydC5hc1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gcGFydFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gXCJcIi5jb25jYXQocGFydHNTdHJpbmcsIFwiIHwgXCIpLmNvbmNhdChwYXJ0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNTdHJpbmc7XG4gICAgICAgICAgICAgICAgfSwgbnVsbCksIHN0cmluZyA9IFwiKCBcIi5jb25jYXQocGFydHNTdHJpbmcxLCBcIiApXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDaG9pY2VPZlBhcnRzUGFydC5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgQ2hvaWNlT2ZQYXJ0c1BhcnQsIHRoaXMucGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbU5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vZGVzKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbEJ1dEZpcnN0QW5kTGFzdE5vZGVzID0gKDAsIF9hcnJheSkuYWxsQnV0Rmlyc3RBbmRMYXN0KG5vZGVzKTtcbiAgICAgICAgICAgICAgICBub2RlcyA9IGFsbEJ1dEZpcnN0QW5kTGFzdE5vZGVzOyAvLy9cbiAgICAgICAgICAgICAgICB2YXIgZXZlbk5vZGVzID0gKDAsIF9hcnJheSkuZXZlbihub2Rlcyk7XG4gICAgICAgICAgICAgICAgbm9kZXMgPSBldmVuTm9kZXM7IC8vL1xuICAgICAgICAgICAgICAgIHZhciBsb29rQWhlYWQgPSBmYWxzZSwgcGFydHMgPSBub2Rlcy5tYXAoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgIH0pLCBjaG9pY2VPZlBhcnRzUGFydCA9IG5ldyBDaG9pY2VPZlBhcnRzUGFydChwYXJ0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNob2ljZU9mUGFydHNQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIENob2ljZU9mUGFydHNQYXJ0O1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaG9pY2VPZlBhcnRzUGFydDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wyTm9iMmxqWlU5bVVHRnlkSE11YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQk9iMjVVWlhKdGFXNWhiRkJoY25RZ1puSnZiU0JjSWk0dUx5NHVMM0JoY25RdmJtOXVWR1Z5YldsdVlXeGNJanRjYmx4dWFXMXdiM0owSUhzZ1EyaHZhV05sVDJaUVlYSjBjMUJoY25SVWVYQmxJSDBnWm5KdmJTQmNJaTR1THk0dUwzQmhjblJVZVhCbGMxd2lPMXh1YVcxd2IzSjBJSHNnWlhabGJpd2dZV3hzUW5WMFJtbHljM1JCYm1STVlYTjBJSDBnWm5KdmJTQmNJaTR1THk0dUwzVjBhV3hwZEdsbGN5OWhjbkpoZVZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCRGFHOXBZMlZQWmxCaGNuUnpVR0Z5ZENCbGVIUmxibVJ6SUU1dmJsUmxjbTFwYm1Gc1VHRnlkQ0I3WEc0Z0lHTnZibk4wY25WamRHOXlLSEJoY25SektTQjdYRzRnSUNBZ1kyOXVjM1FnZEhsd1pTQTlJRU5vYjJsalpVOW1VR0Z5ZEhOUVlYSjBWSGx3WlRzZ0x5OHZYRzVjYmlBZ0lDQnpkWEJsY2loMGVYQmxLVHRjYmlBZ0lDQmNiaUFnSUNCMGFHbHpMbkJoY25SeklEMGdjR0Z5ZEhNN1hHNGdJSDFjYmlBZ1hHNGdJR2RsZEZCaGNuUnpLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TG5CaGNuUnpPMXh1SUNCOVhHNWNiaUFnY0dGeWMyVW9ibTlrWlhNc0lITjBZWFJsTENCallXeHNZbUZqYXlrZ2UxeHVJQ0FnSUd4bGRDQndZWEp6WldRN1hHNWNiaUFnSUNCMGFHbHpMbkJoY25SekxuTnZiV1VvS0hCaGNuUXBJRDArSUh0Y2JpQWdJQ0FnSUhCaGNuTmxaQ0E5SUhCaGNuUXVjR0Z5YzJVb2JtOWtaWE1zSUhOMFlYUmxMQ0JqWVd4c1ltRmpheWs3WEc1Y2JpQWdJQ0FnSUdsbUlDaHdZWEp6WldRcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjR0Z5YzJWa08xeHVJQ0I5WEc1Y2JpQWdZWE5UZEhKcGJtY29LU0I3WEc0Z0lDQWdZMjl1YzNRZ2NHRnlkSE5UZEhKcGJtY2dQU0IwYUdsekxuQmhjblJ6TG5KbFpIVmpaU2dvY0dGeWRITlRkSEpwYm1jc0lIQmhjblFwSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJSEJoY25SVGRISnBibWNnUFNCd1lYSjBMbUZ6VTNSeWFXNW5LQ2s3WEc0Z0lDQWdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9jR0Z5ZEhOVGRISnBibWNnUFQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnY0dGeWRITlRkSEpwYm1jZ1BTQndZWEowVTNSeWFXNW5PMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnY0dGeWRITlRkSEpwYm1jZ1BTQmdKSHR3WVhKMGMxTjBjbWx1WjMwZ2ZDQWtlM0JoY25SVGRISnBibWQ5WUR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQmNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJ3WVhKMGMxTjBjbWx1Wnp0Y2JpQWdJQ0FnSUNBZ0lDQjlMQ0J1ZFd4c0tTeGNiaUFnSUNBZ0lDQWdJQ0J6ZEhKcGJtY2dQU0JnS0NBa2UzQmhjblJ6VTNSeWFXNW5mU0FwWUR0Y2JpQWdJQ0JjYmlBZ0lDQnlaWFIxY200Z2MzUnlhVzVuTzF4dUlDQjlYRzVjYmlBZ1kyeHZibVVvS1NCN0lISmxkSFZ5YmlCemRYQmxjaTVqYkc5dVpTaERhRzlwWTJWUFpsQmhjblJ6VUdGeWRDd2dkR2hwY3k1d1lYSjBjeWs3SUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlU1dlpHVnpLRzV2WkdWektTQjdYRzRnSUNBZ1kyOXVjM1FnWVd4c1FuVjBSbWx5YzNSQmJtUk1ZWE4wVG05a1pYTWdQU0JoYkd4Q2RYUkdhWEp6ZEVGdVpFeGhjM1FvYm05a1pYTXBPMXh1WEc0Z0lDQWdibTlrWlhNZ1BTQmhiR3hDZFhSR2FYSnpkRUZ1WkV4aGMzUk9iMlJsY3pzZ0lDOHZMMXh1SUNBZ0lGeHVJQ0FnSUdOdmJuTjBJR1YyWlc1T2IyUmxjeUE5SUdWMlpXNG9ibTlrWlhNcE8xeHVYRzRnSUNBZ2JtOWtaWE1nUFNCbGRtVnVUbTlrWlhNN0lDQXZMeTljYmx4dUlDQWdJR052Ym5OMElHeHZiMnRCYUdWaFpDQTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJSEJoY25SeklEMGdibTlrWlhNdWJXRndLQ2h1YjJSbEtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCd1lYSjBJRDBnYm05a1pTNW5aVzVsY21GMFpWQmhjblFvYkc5dmEwRm9aV0ZrS1R0Y2JseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSEJoY25RN1hHNGdJQ0FnSUNBZ0lDQWdmU2tzWEc0Z0lDQWdJQ0FnSUNBZ1kyaHZhV05sVDJaUVlYSjBjMUJoY25RZ1BTQnVaWGNnUTJodmFXTmxUMlpRWVhKMGMxQmhjblFvY0dGeWRITXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHTm9iMmxqWlU5bVVHRnlkSE5RWVhKME8xeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpUTJodmFXTmxUMlpRWVhKMGMxQmhjblFpTENKd1lYSjBjeUlzSW5SNWNHVWlMQ0pEYUc5cFkyVlBabEJoY25SelVHRnlkRlI1Y0dVaUxDSm5aWFJRWVhKMGN5SXNJbkJoY25ObElpd2libTlrWlhNaUxDSnpkR0YwWlNJc0ltTmhiR3hpWVdOcklpd2ljR0Z5YzJWa0lpd2ljMjl0WlNJc0luQmhjblFpTENKaGMxTjBjbWx1WnlJc0luQmhjblJ6VTNSeWFXNW5JaXdpY21Wa2RXTmxJaXdpY0dGeWRGTjBjbWx1WnlJc0luTjBjbWx1WnlJc0ltTnNiMjVsSWl3aVpuSnZiVTV2WkdWeklpd2lZV3hzUW5WMFJtbHljM1JCYm1STVlYTjBUbTlrWlhNaUxDSmhiR3hDZFhSR2FYSnpkRUZ1WkV4aGMzUWlMQ0psZG1WdVRtOWtaWE1pTENKbGRtVnVJaXdpYkc5dmEwRm9aV0ZrSWl3aWJXRndJaXdpYm05a1pTSXNJbWRsYm1WeVlYUmxVR0Z5ZENJc0ltTm9iMmxqWlU5bVVHRnlkSE5RWVhKMElpd2lUbTl1VkdWeWJXbHVZV3hRWVhKMElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJUUkNMRWxCUVVFc1dVRkJkMElzYTBOQlFYaENMSGRDUVVGM1FpeEZRVUZCTzBGQlJXUXNTVUZCUVN4VlFVRnBRaXhYUVVGcVFpeHBRa0ZCYVVJc1EwRkJRVHRCUVVOa0xFbEJRVUVzVFVGQmRVSXNWMEZCZGtJc2RVSkJRWFZDTEVOQlFVRTdPenM3T3pzN096czdPenM3T3pzNFJFRk1hRVU3YzBOQlFVRTdOa1JCUVVFN2FVVkJRVUU3T3pzN2QwVkJRVUU3WjBWQlFVRTdPenM3T3pCQ1FVRkJPenM3T3pzN096czdPMU5CUVVFN096czdPenM3UzBGQlFUczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN08zZERRVUZCT3pzN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVU5bExFbEJRVUVzUVVGQlRVRXNhVUpCUVdsQ0xHbENRMUJ1UXl4QlJFOVpPMmxFUVZCbU96dGhRVTl4UWtFc2FVSkJRV2xDTEVOQlEzaENReXhMUVVGTE8yZEVRVkp1UWpzN1VVRlRTU3hKUVVGTlF5eEpRVUZKTEVkQlFVZERMRlZCUVhGQ0xITkNRVUZCTEVGQlFVTXNSVUZCUXl4SFFVRkhPMnREUVVWcVEwUXNTVUZCU1N4RFJWaGtMRU5HVjJkQ08xRkJSVm9zVFVGQlMwUXNTMEZCU3l4SFFVRkhRU3hMUVVGTExFTkJRVU03T3pzN08xbEJSM0pDUnl4SFFVRlJMRVZCUVZKQkxGVkJRVkU3V1VWb1FsWXNUMFpuUWtWQkxGTkJRVUZCTEZGQlFWRXNSMEZCUnp0blFrRkRWQ3hQUVVGUExFbEJRVWtzUTBGQlEwZ3NTMEZCU3l4RFFVRkRPMkZCUTI1Q096czdXVUZGUkVrc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRmNFSlFMRTlHYjBKRlFTeFRRVUZCUVN4TFFVRkxMRU5CUVVORExFdEJRVXNzUlVGQlJVTXNTMEZCU3l4RlFVRkZReXhSUVVGUkxFVkJRVVU3WjBKQlF6VkNMRWxCUVVsRExFMUJRVTBzUVVGQlF6dG5Ra0ZGV0N4SlFVRkpMRU5CUVVOU0xFdEJRVXNzUTBGQlExTXNTVUZCU1N4RFFVRkRMRk5CUVVORExFbEJRVWtzUlVGQlN6dHZRa0ZEZUVKR0xFMUJRVTBzUjBGQlIwVXNTVUZCU1N4RFFVRkRUaXhMUVVGTExFTkJRVU5ETEV0QlFVc3NSVUZCUlVNc1MwRkJTeXhGUVVGRlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0dlFrRkZOVU1zU1VGQlNVTXNUVUZCVFN4RlFVRkZPM2RDUVVOV0xFOUJRVThzU1VGQlNTeERRVUZETzNGQ1FVTmlPMmxDUVVOR0xFTkJRVU1zUTBGQlF6dG5Ra0ZGU0N4UFFVRlBRU3hOUVVGTkxFTkJRVU03WVVGRFpqczdPMWxCUlVSSExFZEJRVkVzUlVGQlVrRXNWVUZCVVR0WlJXeERWaXhQUm10RFJVRXNVMEZCUVVFc1VVRkJVU3hIUVVGSE8yZENRVU5VTEVsQlFVMURMRmxCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU5hTEV0QlFVc3NRMEZCUTJFc1RVRkJUU3hEUVVGRExGTkJRVU5FTEZkQlFWY3NSVUZCUlVZc1NVRkJTU3hGUVVGTE8yOUNRVU55UkN4SlFVRk5TU3hWUVVGVkxFZEJRVWRLTEVsQlFVa3NRMEZCUTBNc1VVRkJVU3hGUVVGRkxFRkJRVU03YjBKQlJXNURMRWxCUVVsRExGZEJRVmNzUzBGQlN5eEpRVUZKTEVWQlFVVTdkMEpCUTNoQ1FTeFhRVUZYTEVkQlFVZEZMRlZCUVZVc1EwRkJRenR4UWtGRE1VSXNUVUZCVFR0M1FrRkRURVlzVjBGQlZ5eEhRVUZITEVGQlFVTXNSVUZCUVN4RFFVRnRRa1VzVFVGQlZTeERRVUV6UWtZc1YwRkJWeXhGUVVGRExFdEJRVWNzUTBGQllTeERRVUZCTEUxQlFVRXNRMEZCV0VVc1ZVRkJWU3hEUVVGRkxFTkJRVU03Y1VKQlEyaEVPMjlDUVVWRUxFOUJRVTlHTEZkQlFWY3NRMEZCUXp0cFFrRkRjRUlzUlVGQlJTeEpRVUZKTEVOQlFVTXNSVUZEVWtjc1RVRkJUU3hIUVVGSExFRkJRVU1zU1VGQlJTeERRVUZqTEUxQlFVVXNRMEZCWkVnc1dVRkJWeXhGUVVGRExFbEJRVVVzUTBGQlF5eEJRVUZETzJkQ1FVVndReXhQUVVGUFJ5eE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlc1RVVDeFBSbTFFUlVFc1UwRkJRVUVzUzBGQlN5eEhRVUZITzJkQ1FVRkZMRTlCUVU4c2NVSkJOVU5GYWtJc2FVSkJRV2xDTEdGQk5FTmlhVUlzVDBGQlN5eEZRVUZZTEVsQlFVc3NRMEZCUVN4WlFVRlBha0lzYVVKQlFXbENMRVZCUVVVc1NVRkJTU3hEUVVGRFF5eExRVUZMTEVWQlFVVTdZVUZCUlRzN096dFpRVVYyUkdsQ0xFZEJRVk1zUlVGQlZFRXNWMEZCVXp0WlJYSkViRUlzVDBaeFJFVXNVMEZCVDBFc1UwRkJVeXhEUVVGRFdpeExRVUZMTEVWQlFVVTdaMEpCUTNSQ0xFbEJRVTFoTEhWQ1FVRjFRaXhIUVVGSFF5eERRVUZCUVN4SFFVRkJRU3hOUVVGclFpeEJRVUZQTEVOQlFVRXNiMEpCUVU1a0xFdEJRVXNzUTBGQlF5eEJRVUZETzJkQ1FVVXhSRUVzUzBGQlN5eEhRVUZIWVN4MVFrRkJkVUlzUTBGQlF5eERRVUZGTEVkQlFVYzdaMEpCUlhKRExFbEJRVTFGTEZOQlFWTXNSMEZCUjBNc1EwRkJRVUVzUjBGQlFVRXNUVUZCU1N4QlFVRlBMRU5CUVVFc1RVRkJUbWhDTEV0QlFVc3NRMEZCUXl4QlFVRkRPMmRDUVVVNVFrRXNTMEZCU3l4SFFVRkhaU3hUUVVGVExFTkJRVU1zUTBGQlJTeEhRVUZITzJkQ1FVVjJRaXhKUVVGTlJTeFRRVUZUTEVkQlFVY3NTMEZCU3l4RlFVTnFRblJDTEV0QlFVc3NSMEZCUjBzc1MwRkJTeXhEUVVGRGEwSXNSMEZCUnl4RFFVRkRMRk5CUVVORExFbEJRVWtzUlVGQlN6dHZRa0ZETVVJc1NVRkJUV1FzU1VGQlNTeEhRVUZIWXl4SlFVRkpMRU5CUVVORExGbEJRVmtzUTBGQlEwZ3NVMEZCVXl4RFFVRkRMRUZCUVVNN2IwSkJSVEZETEU5QlFVOWFMRWxCUVVrc1EwRkJRenRwUWtGRFlpeERRVUZETEVWQlEwWm5RaXhwUWtGQmFVSXNSMEZCUnl4SlFVRkpNMElzYVVKQlFXbENMRU5CUVVORExFdEJRVXNzUTBGQlF5eEJRVUZETzJkQ1FVVjJSQ3hQUVVGUE1FSXNhVUpCUVdsQ0xFTkJRVU03WVVGRE1VSTdPMDFCZGtWSU96dERRWGRGUXl4RFFXcEZPRU5ETEZsQlFXVXNVMEZwUlRkRU8ydENRV3BGYjBJMVFpeHBRa0ZCYVVJc1FVRlFkRU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb25cIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIikpO1xudmFyIF9jaG9pY2VPZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC9ub25UZXJtaW5hbC9jaG9pY2VPZlBhcnRzXCIpKTtcbnZhciBfb25lT3JNb3JlUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBEb2N1bWVudERlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoRG9jdW1lbnREZWZpbml0aW9uLCBEZWZpbml0aW9uKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERvY3VtZW50RGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnREZWZpbml0aW9uKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jdW1lbnREZWZpbml0aW9uKTtcbiAgICAgICAgdmFyIHJ1bGVSdWxlTmFtZSA9IF9ydWxlTmFtZXMuUnVsZVJ1bGVOYW1lLCBlcnJvclJ1bGVOYW1lID0gX3J1bGVOYW1lcy5FcnJvclJ1bGVOYW1lLCBydWxlUnVsZU5hbWVQYXJ0ID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KHJ1bGVSdWxlTmFtZSksIGVycm9yUnVsZU5hbWVQYXJ0ID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KGVycm9yUnVsZU5hbWUpLCBydWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHMgPSBbXG4gICAgICAgICAgICBydWxlUnVsZU5hbWVQYXJ0LFxuICAgICAgICAgICAgZXJyb3JSdWxlTmFtZVBhcnRcbiAgICAgICAgXSwgY2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0ID0gbmV3IF9jaG9pY2VPZlBhcnRzLmRlZmF1bHQocnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzKSwgb25lT3JNb3JlQ2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0c1BhcnQgPSBuZXcgX29uZU9yTW9yZVBhcnRzLmRlZmF1bHQoY2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0KSwgcGFydHMgPSBbXG4gICAgICAgICAgICBvbmVPck1vcmVDaG9pY2VPZlJ1bGVSdWxlTmFtZUFuZEVycm9yUnVsZU5hbWVQYXJ0c1BhcnRzUGFydFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcGFydHMpO1xuICAgIH1cbiAgICByZXR1cm4gRG9jdW1lbnREZWZpbml0aW9uO1xufShfZGVmaW5pdGlvbi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IERvY3VtZW50RGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwyUnZZM1Z0Wlc1MExtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dlpHVm1hVzVwZEdsdmJsd2lPMXh1YVcxd2IzSjBJRkoxYkdWT1lXMWxVR0Z5ZENCbWNtOXRJRndpTGk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5eWRXeGxUbUZ0WlZ3aU8xeHVhVzF3YjNKMElFTm9iMmxqWlU5bVVHRnlkSE5RWVhKMElHWnliMjBnWENJdUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wyTm9iMmxqWlU5bVVHRnlkSE5jSWp0Y2JtbHRjRzl5ZENCUGJtVlBjazF2Y21WUVlYSjBjMUJoY25RZ1puSnZiU0JjSWk0dUwzQmhjblF2Ym05dVZHVnliV2x1WVd3dmIyNWxUM0pOYjNKbFVHRnlkSE5jSWp0Y2JseHVhVzF3YjNKMElIc2dVblZzWlZKMWJHVk9ZVzFsTENCRmNuSnZjbEoxYkdWT1lXMWxJSDBnWm5KdmJTQmNJaTR1TDNKMWJHVk9ZVzFsYzF3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCRWIyTjFiV1Z1ZEVSbFptbHVhWFJwYjI0Z1pYaDBaVzVrY3lCRVpXWnBibWwwYVc5dUlIdGNiaUFnWTI5dWMzUnlkV04wYjNJb0tTQjdYRzRnSUNBZ1kyOXVjM1FnY25Wc1pWSjFiR1ZPWVcxbElEMGdVblZzWlZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHVnljbTl5VW5Wc1pVNWhiV1VnUFNCRmNuSnZjbEoxYkdWT1lXMWxMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVlNkV3hsVG1GdFpWQmhjblFnUFNCdVpYY2dVblZzWlU1aGJXVlFZWEowS0hKMWJHVlNkV3hsVG1GdFpTa3NYRzRnSUNBZ0lDQWdJQ0FnWlhKeWIzSlNkV3hsVG1GdFpWQmhjblFnUFNCdVpYY2dVblZzWlU1aGJXVlFZWEowS0dWeWNtOXlVblZzWlU1aGJXVXBMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVlNkV3hsVG1GdFpVRnVaRVZ5Y205eVVuVnNaVTVoYldWUVlYSjBjeUE5SUZ0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEoxYkdWU2RXeGxUbUZ0WlZCaGNuUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCbGNuSnZjbEoxYkdWT1lXMWxVR0Z5ZEZ4dUlDQWdJQ0FnSUNBZ0lGMHNYRzRnSUNBZ0lDQWdJQ0FnWTJodmFXTmxUMlpTZFd4bFVuVnNaVTVoYldWQmJtUkZjbkp2Y2xKMWJHVk9ZVzFsVUdGeWRITlFZWEowSUQwZ2JtVjNJRU5vYjJsalpVOW1VR0Z5ZEhOUVlYSjBLSEoxYkdWU2RXeGxUbUZ0WlVGdVpFVnljbTl5VW5Wc1pVNWhiV1ZRWVhKMGN5a3NYRzRnSUNBZ0lDQWdJQ0FnYjI1bFQzSk5iM0psUTJodmFXTmxUMlpTZFd4bFVuVnNaVTVoYldWQmJtUkZjbkp2Y2xKMWJHVk9ZVzFsVUdGeWRITlFZWEowYzFCaGNuUWdQU0J1WlhjZ1QyNWxUM0pOYjNKbFVHRnlkSE5RWVhKMEtHTm9iMmxqWlU5bVVuVnNaVkoxYkdWT1lXMWxRVzVrUlhKeWIzSlNkV3hsVG1GdFpWQmhjblJ6VUdGeWRDa3NYRzRnSUNBZ0lDQWdJQ0FnY0dGeWRITWdQU0JiWEc0Z0lDQWdJQ0FnSUNBZ0lDQnZibVZQY2sxdmNtVkRhRzlwWTJWUFpsSjFiR1ZTZFd4bFRtRnRaVUZ1WkVWeWNtOXlVblZzWlU1aGJXVlFZWEowYzFCaGNuUnpVR0Z5ZEZ4dUlDQWdJQ0FnSUNBZ0lGMDdYRzRnSUNBZ1hHNGdJQ0FnYzNWd1pYSW9jR0Z5ZEhNcFhHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpFYjJOMWJXVnVkRVJsWm1sdWFYUnBiMjRpTENKeWRXeGxVblZzWlU1aGJXVWlMQ0pTZFd4bFVuVnNaVTVoYldVaUxDSmxjbkp2Y2xKMWJHVk9ZVzFsSWl3aVJYSnliM0pTZFd4bFRtRnRaU0lzSW5KMWJHVlNkV3hsVG1GdFpWQmhjblFpTENKU2RXeGxUbUZ0WlZCaGNuUWlMQ0psY25KdmNsSjFiR1ZPWVcxbFVHRnlkQ0lzSW5KMWJHVlNkV3hsVG1GdFpVRnVaRVZ5Y205eVVuVnNaVTVoYldWUVlYSjBjeUlzSW1Ob2IybGpaVTltVW5Wc1pWSjFiR1ZPWVcxbFFXNWtSWEp5YjNKU2RXeGxUbUZ0WlZCaGNuUnpVR0Z5ZENJc0lrTm9iMmxqWlU5bVVHRnlkSE5RWVhKMElpd2liMjVsVDNKTmIzSmxRMmh2YVdObFQyWlNkV3hsVW5Wc1pVNWhiV1ZCYm1SRmNuSnZjbEoxYkdWT1lXMWxVR0Z5ZEhOUVlYSjBjMUJoY25RaUxDSlBibVZQY2sxdmNtVlFZWEowYzFCaGNuUWlMQ0p3WVhKMGN5SXNJa1JsWm1sdWFYUnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGZFVJc1NVRkJRU3hYUVVGbExHdERRVUZtTEdWQlFXVXNSVUZCUVR0QlFVTmlMRWxCUVVFc1UwRkJPRUlzYTBOQlFUbENMRGhDUVVFNFFpeEZRVUZCTzBGQlEzcENMRWxCUVVFc1kwRkJiVU1zYTBOQlFXNURMRzFEUVVGdFF5eEZRVUZCTzBGQlEyeERMRWxCUVVFc1pVRkJiME1zYTBOQlFYQkRMRzlEUVVGdlF5eEZRVUZCTzBGQlJYWkNMRWxCUVVFc1ZVRkJZeXhYUVVGa0xHTkJRV01zUTBGQlFUczdPenM3T3pzN096czdPenM3TzB0QlVERkVPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVTJVc1NVRkJRU3hCUVVGTlFTeHJRa0ZCYTBJc2FVSkRWSEJETEVGRVUxazdOa05CVkdZN08yRkJVM0ZDUVN4clFrRkJhMEk3YVVSQlZIWkRPMUZCVjBrc1NVRkJUVU1zV1VGQldTeEhRVUZIUXl4VlFVRlpMR0ZCUVVFc1JVRkRNMEpETEdGQlFXRXNSMEZCUjBNc1ZVRkJZU3hqUVVGQkxFVkJRemRDUXl4blFrRkJaMElzUjBGQlJ5eEpRVUZKUXl4VFFVRlpMRk5CUVVOTUxGbEJRVmtzUTBGQlF5eEZRVU5xUkUwc2FVSkJRV2xDTEVkQlFVY3NTVUZCU1VRc1UwRkJXU3hUUVVGRFNDeGhRVUZoTEVOQlFVTXNSVUZEYmtSTExHbERRVUZwUXl4SFFVRkhPMWxCUTJ4RFNDeG5Ra0ZCWjBJN1dVRkRhRUpGTEdsQ1FVRnBRanRUUVVOc1FpeEZRVU5FUlN3MlEwRkJOa01zUjBGQlJ5eEpRVUZKUXl4alFVRnBRaXhUUVVGRFJpeHBRMEZCYVVNc1EwRkJReXhGUVVONFIwY3NNa1JCUVRKRUxFZEJRVWNzU1VGQlNVTXNaVUZCYTBJc1UwRkJRMGdzTmtOQlFUWkRMRU5CUVVNc1JVRkRia2xKTEV0QlFVc3NSMEZCUnp0WlFVTk9SaXd5UkVGQk1rUTdVMEZETlVRc1FVRkJRenRwUTBGRlJrVXNTMEZCU3pzN08wTkJSV1FzUTBGc1FpdERReXhYUVVGVkxGTkJhMEo2UkR0clFrRnNRbTlDWkN4clFrRkJhMElzUVVGVWRrTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ydWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZVwiKSk7XG52YXIgX2RvY3VtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9kZS9ibmYvZG9jdW1lbnRcIikpO1xudmFyIF9kb2N1bWVudDEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL2RvY3VtZW50XCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBEb2N1bWVudFJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoRG9jdW1lbnRSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERvY3VtZW50UnVsZSk7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnRSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jdW1lbnRSdWxlKTtcbiAgICAgICAgdmFyIGRvY3VtZW50RGVmaW5pdGlvbiA9IG5ldyBfZG9jdW1lbnQxLmRlZmF1bHQoKSwgbmFtZSA9IF9ydWxlTmFtZXMuRG9jdW1lbnRSdWxlTmFtZSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZG9jdW1lbnREZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfZG9jdW1lbnQuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gRG9jdW1lbnRSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IERvY3VtZW50UnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMMlJ2WTNWdFpXNTBMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1VuVnNaU0JtY205dElGd2lMaTR2Y25Wc1pWd2lPMXh1YVcxd2IzSjBJRVJ2WTNWdFpXNTBRazVHVG05a1pTQm1jbTl0SUZ3aUxpNHZibTlrWlM5aWJtWXZaRzlqZFcxbGJuUmNJanRjYm1sdGNHOXlkQ0JFYjJOMWJXVnVkRVJsWm1sdWFYUnBiMjRnWm5KdmJTQmNJaTR1TDJSbFptbHVhWFJwYjI0dlpHOWpkVzFsYm5SY0lqdGNibHh1YVcxd2IzSjBJSHNnUkc5amRXMWxiblJTZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1JHOWpkVzFsYm5SU2RXeGxJR1Y0ZEdWdVpITWdVblZzWlNCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0NrZ2UxeHVJQ0FnSUdOdmJuTjBJR1J2WTNWdFpXNTBSR1ZtYVc1cGRHbHZiaUE5SUc1bGR5QkViMk4xYldWdWRFUmxabWx1YVhScGIyNG9LU3hjYmlBZ0lDQWdJQ0FnSUNCdVlXMWxJRDBnUkc5amRXMWxiblJTZFd4bFRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNCaGJXSnBaM1Z2ZFhNZ1BTQm1ZV3h6WlN4Y2JpQWdJQ0FnSUNBZ0lDQmtaV1pwYm1sMGFXOXVjeUE5SUZ0Y2JpQWdJQ0FnSUNBZ0lDQWdJR1J2WTNWdFpXNTBSR1ZtYVc1cGRHbHZibHh1SUNBZ0lDQWdJQ0FnSUYwc1hHNGdJQ0FnSUNBZ0lDQWdUbTlrWlNBOUlFUnZZM1Z0Wlc1MFFrNUdUbTlrWlR0Y2JpQWdJQ0JjYmlBZ0lDQnpkWEJsY2lodVlXMWxMQ0JoYldKcFozVnZkWE1zSUdSbFptbHVhWFJwYjI1ekxDQk9iMlJsS1Z4dUlDQjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lSRzlqZFcxbGJuUlNkV3hsSWl3aVpHOWpkVzFsYm5SRVpXWnBibWwwYVc5dUlpd2lSRzlqZFcxbGJuUkVaV1pwYm1sMGFXOXVJaXdpYm1GdFpTSXNJa1J2WTNWdFpXNTBVblZzWlU1aGJXVWlMQ0poYldKcFozVnZkWE1pTENKa1pXWnBibWwwYVc5dWN5SXNJazV2WkdVaUxDSkViMk4xYldWdWRFSk9SazV2WkdVaUxDSlNkV3hsSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUldsQ0xFbEJRVUVzUzBGQlV5eHJRMEZCVkN4VFFVRlRMRVZCUVVFN1FVRkRSU3hKUVVGQkxGTkJRWE5DTEd0RFFVRjBRaXh6UWtGQmMwSXNSVUZCUVR0QlFVTnVRaXhKUVVGQkxGVkJRWGRDTEd0RFFVRjRRaXgzUWtGQmQwSXNSVUZCUVR0QlFVVjBRaXhKUVVGQkxGVkJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdPenM3T3pzN096czdPenM3T3p0TFFVNHZRenM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVZGbExFbEJRVUVzUVVGQlRVRXNXVUZCV1N4cFFrTlNPVUlzUVVSUldUdHBRMEZTWmpzN1lVRlJjVUpCTEZsQlFWazdNa05CVW1wRE8xRkJWVWtzU1VGQlRVTXNhMEpCUVd0Q0xFZEJRVWNzU1VGQlNVTXNWVUZCYTBJc1ZVRkJSU3hGUVVNM1EwTXNTVUZCU1N4SFFVRkhReXhWUVVGblFpeHBRa0ZCUVN4RlFVTjJRa01zVTBGQlV5eEhRVUZITEV0QlFVc3NSVUZEYWtKRExGZEJRVmNzUjBGQlJ6dFpRVU5hVEN4clFrRkJhMEk3VTBGRGJrSXNSVUZEUkUwc1NVRkJTU3hIUVVGSFF5eFRRVUZsTEZGQlFVRXNRVUZCUXp0cFEwRkZka0pNTEVsQlFVa3NSVUZCUlVVc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFWcDVRMFVzUzBGQlNTeFRRVmszUXp0clFrRmFiMEpVTEZsQlFWa3NRVUZTYWtNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGVOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiKSk7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxpdGllcy9hcnJheVwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFJ1bGVOYW1lQk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKFJ1bGVOYW1lQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJ1bGVOYW1lQk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gUnVsZU5hbWVCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZU5hbWVCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUnVsZU5hbWVCTkZOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZW5lcmF0ZVBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVBhcnQobG9va0FoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVOYW1lID0gdGhpcy5nZXRSdWxlTmFtZSgpLCBydWxlTmFtZVBhcnQgPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQocnVsZU5hbWUsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lUGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFJ1bGVOYW1lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZU5hbWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgZmlyc3RDaGlsZE5vZGUgPSAoMCwgX2FycmF5KS5maXJzdChjaGlsZE5vZGVzKSwgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLCBydWxlTmFtZSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQ7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25UZXJtaW5hbC5kZWZhdWx0LmZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMoUnVsZU5hbWVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUnVsZU5hbWVCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSdWxlTmFtZUJORk5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl1YjJSbEwySnVaaTl5ZFd4bFRtRnRaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElGSjFiR1ZPWVcxbFVHRnlkQ0JtY205dElGd2lMaTR2TGk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5eWRXeGxUbUZ0WlZ3aU8xeHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNUbTlrWlNCbWNtOXRJRndpTGk0dkxpNHZibTlrWlM5dWIyNVVaWEp0YVc1aGJGd2lPMXh1WEc1cGJYQnZjblFnZXlCbWFYSnpkQ0I5SUdaeWIyMGdYQ0l1TGk4dUxpOTFkR2xzYVhScFpYTXZZWEp5WVhsY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1VuVnNaVTVoYldWQ1RrWk9iMlJsSUdWNGRHVnVaSE1nVG05dVZHVnliV2x1WVd4T2IyUmxJSHRjYmlBZ1oyVnVaWEpoZEdWUVlYSjBLR3h2YjJ0QmFHVmhaQ2tnZTF4dUlDQWdJR052Ym5OMElISjFiR1ZPWVcxbElEMGdkR2hwY3k1blpYUlNkV3hsVG1GdFpTZ3BMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVk9ZVzFsVUdGeWRDQTlJRzVsZHlCU2RXeGxUbUZ0WlZCaGNuUW9jblZzWlU1aGJXVXNJR3h2YjJ0QmFHVmhaQ2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjblZzWlU1aGJXVlFZWEowTzF4dUlDQjlYRzVjYmlBZ1oyVjBVblZzWlU1aGJXVW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ1kyaHBiR1JPYjJSbGN5QTlJSFJvYVhNdVoyVjBRMmhwYkdST2IyUmxjeWdwTEZ4dUlDQWdJQ0FnSUNBZ0lHWnBjbk4wUTJocGJHUk9iMlJsSUQwZ1ptbHljM1FvWTJocGJHUk9iMlJsY3lrc1hHNGdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeE9iMlJsSUQwZ1ptbHljM1JEYUdsc1pFNXZaR1VzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRTV2WkdWRGIyNTBaVzUwSUQwZ2RHVnliV2x1WVd4T2IyUmxMbWRsZEVOdmJuUmxiblFvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnlkV3hsVG1GdFpTQTlJSFJsY20xcGJtRnNUbTlrWlVOdmJuUmxiblE3SUM4dkwxeHVJQ0FnSUZ4dUlDQWdJSEpsZEhWeWJpQnlkV3hsVG1GdFpUdGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0VW5Wc1pVNWhiV1ZCYm1SRGFHbHNaRTV2WkdWektISjFiR1ZPWVcxbExDQmphR2xzWkU1dlpHVnpLU0I3SUhKbGRIVnliaUJPYjI1VVpYSnRhVzVoYkU1dlpHVXVabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aFNkV3hsVG1GdFpVSk9SazV2WkdVc0lISjFiR1ZPWVcxbExDQmphR2xzWkU1dlpHVnpLVHNnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxKMWJHVk9ZVzFsUWs1R1RtOWtaU0lzSW1kbGJtVnlZWFJsVUdGeWRDSXNJbXh2YjJ0QmFHVmhaQ0lzSW5KMWJHVk9ZVzFsSWl3aVoyVjBVblZzWlU1aGJXVWlMQ0p5ZFd4bFRtRnRaVkJoY25RaUxDSlNkV3hsVG1GdFpWQmhjblFpTENKamFHbHNaRTV2WkdWeklpd2laMlYwUTJocGJHUk9iMlJsY3lJc0ltWnBjbk4wUTJocGJHUk9iMlJsSWl3aVptbHljM1FpTENKMFpYSnRhVzVoYkU1dlpHVWlMQ0owWlhKdGFXNWhiRTV2WkdWRGIyNTBaVzUwSWl3aVoyVjBRMjl1ZEdWdWRDSXNJbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTWlMQ0pPYjI1VVpYSnRhVzVoYkU1dlpHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZlVUlzU1VGQlFTeFRRVUZwUXl4clEwRkJha01zYVVOQlFXbERMRVZCUVVFN1FVRkRPVUlzU1VGQlFTeFpRVUYzUWl4clEwRkJlRUlzZDBKQlFYZENMRVZCUVVFN1FVRkZPVUlzU1VGQlFTeE5RVUYxUWl4WFFVRjJRaXgxUWtGQmRVSXNRMEZCUVRzN096czdPenM3T3pzN096czdPemhFUVV3M1F6dHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlBaU3hKUVVGQkxFRkJRVTFCTEdWQlFXVXNhVUpEVUdwRExFRkVUMWs3SzBOQlVHWTdPMkZCVDNGQ1FTeGxRVUZsT3poRFFWQndRenM3T3pzN1dVRlJSVU1zUjBGQldTeEZRVUZhUVN4alFVRlpPMWxGVW1Rc1QwWlJSVUVzVTBGQlFVRXNXVUZCV1N4RFFVRkRReXhUUVVGVExFVkJRVVU3WjBKQlEzUkNMRWxCUVUxRExGRkJRVkVzUjBGQlJ5eEpRVUZKTEVOQlFVTkRMRmRCUVZjc1JVRkJSU3hGUVVNM1FrTXNXVUZCV1N4SFFVRkhMRWxCUVVsRExGTkJRVmtzVTBGQlEwZ3NVVUZCVVN4RlFVRkZSQ3hUUVVGVExFTkJRVU1zUVVGQlF6dG5Ra0ZGTTBRc1QwRkJUMGNzV1VGQldTeERRVUZETzJGQlEzSkNPenM3V1VGRlJFUXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZabUlzVDBabFJVRXNVMEZCUVVFc1YwRkJWeXhIUVVGSE8yZENRVU5hTEVsQlFVMUhMRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU5ETEdGQlFXRXNSVUZCUlN4RlFVTnFRME1zWTBGQll5eEhRVUZIUXl4RFFVRkJRU3hIUVVGQlFTeE5RVUZMTEVGQlFWa3NRMEZCUVN4UFFVRllTQ3hWUVVGVkxFTkJRVU1zUlVGRGJFTkpMRmxCUVZrc1IwRkJSMFlzWTBGQll5eEZRVU0zUWtjc2JVSkJRVzFDTEVkQlFVZEVMRmxCUVZrc1EwRkJRMFVzVlVGQlZTeEZRVUZGTEVWQlF5OURWaXhSUVVGUkxFZEJRVWRUTEcxQ1FVRnRRaXhCUVVGRExFVkJRVU1zUjBGQlJ6dG5Ra0ZGZWtNc1QwRkJUMVFzVVVGQlVTeERRVUZETzJGQlEycENPenM3TzFsQlJVMVhMRWRCUVhsQ0xFVkJRWHBDUVN3eVFrRkJlVUk3V1VWNlFteERMRTlHZVVKRkxGTkJRVTlCTEhsQ1FVRjVRaXhEUVVGRFdDeFJRVUZSTEVWQlFVVkpMRlZCUVZVc1JVRkJSVHRuUWtGQlJTeFBRVUZQVVN4WlFVRmxMRk5CUVVORUxIbENRVUY1UWl4RFFVRkRaQ3hsUVVGbExFVkJRVVZITEZGQlFWRXNSVUZCUlVrc1ZVRkJWU3hEUVVGRExFTkJRVU03WVVGQlJUczdUVUY2UW5KS096dERRVEJDUXl4RFFXNUNORU5STEZsQlFXVXNVMEZ0UWpORU8ydENRVzVDYjBKbUxHVkJRV1VzUVVGUWNFTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ydWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZVwiKSk7XG52YXIgX25hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL25hbWVcIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3J1bGVOYW1lXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBSdWxlTmFtZVJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoUnVsZU5hbWVSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJ1bGVOYW1lUnVsZSk7XG4gICAgZnVuY3Rpb24gUnVsZU5hbWVSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZU5hbWVSdWxlKTtcbiAgICAgICAgdmFyIG5hbWVEZWZpbml0aW9uID0gbmV3IF9uYW1lLmRlZmF1bHQoKSwgbmFtZSA9IF9ydWxlTmFtZXMuUnVsZU5hbWVSdWxlTmFtZSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb24gLy8vXG4gICAgICAgIF0sIE5vZGUgPSBfcnVsZU5hbWUuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gUnVsZU5hbWVSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJ1bGVOYW1lUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMM0oxYkdWT1lXMWxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1VuVnNaU0JtY205dElGd2lMaTR2Y25Wc1pWd2lPMXh1YVcxd2IzSjBJRTVoYldWRVpXWnBibWwwYVc5dUlHWnliMjBnWENJdUxpOWtaV1pwYm1sMGFXOXVMMjVoYldWY0lqdGNibWx0Y0c5eWRDQlNkV3hsVG1GdFpVSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwzSjFiR1ZPWVcxbFhDSTdYRzVjYm1sdGNHOXlkQ0I3SUZKMWJHVk9ZVzFsVW5Wc1pVNWhiV1VnZlNCbWNtOXRJRndpTGk0dmNuVnNaVTVoYldWelhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGSjFiR1ZPWVcxbFVuVnNaU0JsZUhSbGJtUnpJRkoxYkdVZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lncElIdGNiaUFnSUNCamIyNXpkQ0J1WVcxbFJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCT1lXMWxSR1ZtYVc1cGRHbHZiaWdwTEZ4dUlDQWdJQ0FnSUNBZ0lHNWhiV1VnUFNCU2RXeGxUbUZ0WlZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYm1GdFpVUmxabWx1YVhScGIyNGdJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lGMHNYRzRnSUNBZ0lDQWdJQ0FnVG05a1pTQTlJRkoxYkdWT1lXMWxRazVHVG05a1pUdGNiaUFnSUNCY2JpQWdJQ0J6ZFhCbGNpaHVZVzFsTENCaGJXSnBaM1Z2ZFhNc0lHUmxabWx1YVhScGIyNXpMQ0JPYjJSbEtWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVW5Wc1pVNWhiV1ZTZFd4bElpd2libUZ0WlVSbFptbHVhWFJwYjI0aUxDSk9ZVzFsUkdWbWFXNXBkR2x2YmlJc0ltNWhiV1VpTENKU2RXeGxUbUZ0WlZKMWJHVk9ZVzFsSWl3aVlXMWlhV2QxYjNWeklpd2laR1ZtYVc1cGRHbHZibk1pTENKT2IyUmxJaXdpVW5Wc1pVNWhiV1ZDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBNc1NVRkJRU3hMUVVGdlFpeHJRMEZCY0VJc2IwSkJRVzlDTEVWQlFVRTdRVUZEYmtJc1NVRkJRU3hUUVVGelFpeHJRMEZCZEVJc2MwSkJRWE5DTEVWQlFVRTdRVUZGYWtJc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCT3pzN096czdPenM3T3pzN096czdTMEZPTDBNN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlJaU3hKUVVGQkxFRkJRVTFCTEZsQlFWa3NhVUpEVWpsQ0xFRkVVVms3YVVOQlVtWTdPMkZCVVhGQ1FTeFpRVUZaT3pKRFFWSnFRenRSUVZWSkxFbEJRVTFETEdOQlFXTXNSMEZCUnl4SlFVRkpReXhMUVVGakxGVkJRVVVzUlVGRGNrTkRMRWxCUVVrc1IwRkJSME1zVlVGQlowSXNhVUpCUVVFc1JVRkRka0pETEZOQlFWTXNSMEZCUnl4TFFVRkxMRVZCUTJwQ1F5eFhRVUZYTEVkQlFVYzdXVUZEV2t3c1kwRkJZeXhEUVVGRkxFZEJRVWM3VTBGRGNFSXNSVUZEUkUwc1NVRkJTU3hIUVVGSFF5eFRRVUZsTEZGQlFVRXNRVUZCUXp0cFEwRkZka0pNTEVsQlFVa3NSVUZCUlVVc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFWcDVRMFVzUzBGQlNTeFRRVmszUXp0clFrRmFiMEpVTEZsQlFWa3NRVUZTYWtNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3dpbGRjYXJkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC90ZXJtaW5hbC93aWxkY2FyZFwiKSk7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBXaWxkY2FyZEJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhXaWxkY2FyZEJORk5vZGUsIE5vblRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXaWxkY2FyZEJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIFdpbGRjYXJkQk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpbGRjYXJkQk5GTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFdpbGRjYXJkQk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuZXJhdGVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWxkY2FyZFBhcnQgPSBuZXcgX3dpbGRjYXJkLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lsZGNhcmRQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhXaWxkY2FyZEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBXaWxkY2FyZEJORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFdpbGRjYXJkQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOTNhV3hrWTJGeVpDNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZkcGJHUmpZWEprVUdGeWRDQm1jbTl0SUZ3aUxpNHZMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOTNhV3hrWTJGeVpGd2lPMXh1YVcxd2IzSjBJRTV2YmxSbGNtMXBibUZzVG05a1pTQm1jbTl0SUZ3aUxpNHZMaTR2Ym05a1pTOXViMjVVWlhKdGFXNWhiRndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJYYVd4a1kyRnlaRUpPUms1dlpHVWdaWGgwWlc1a2N5Qk9iMjVVWlhKdGFXNWhiRTV2WkdVZ2UxeHVJQ0JuWlc1bGNtRjBaVkJoY25Rb2JHOXZhMEZvWldGa0tTQjdYRzRnSUNBZ1kyOXVjM1FnZDJsc1pHTmhjbVJRWVhKMElEMGdibVYzSUZkcGJHUmpZWEprVUdGeWRDZ3BPMXh1WEc0Z0lDQWdjbVYwZFhKdUlIZHBiR1JqWVhKa1VHRnlkRHRjYmlBZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFVuVnNaVTVoYldWQmJtUkRhR2xzWkU1dlpHVnpLSEoxYkdWT1lXMWxMQ0JqYUdsc1pFNXZaR1Z6S1NCN0lISmxkSFZ5YmlCT2IyNVVaWEp0YVc1aGJFNXZaR1V1Wm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeWhYYVd4a1kyRnlaRUpPUms1dlpHVXNJSEoxYkdWT1lXMWxMQ0JqYUdsc1pFNXZaR1Z6S1RzZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklsZHBiR1JqWVhKa1FrNUdUbTlrWlNJc0ltZGxibVZ5WVhSbFVHRnlkQ0lzSW14dmIydEJhR1ZoWkNJc0luZHBiR1JqWVhKa1VHRnlkQ0lzSWxkcGJHUmpZWEprVUdGeWRDSXNJbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTWlMQ0p5ZFd4bFRtRnRaU0lzSW1Ob2FXeGtUbTlrWlhNaUxDSk9iMjVVWlhKdGFXNWhiRTV2WkdVaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRmVVSXNTVUZCUVN4VFFVRTRRaXhyUTBGQk9VSXNPRUpCUVRoQ0xFVkJRVUU3UVVGRE0wSXNTVUZCUVN4WlFVRjNRaXhyUTBGQmVFSXNkMEpCUVhkQ0xFVkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZJY0VRN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlMyVXNTVUZCUVN4QlFVRk5RU3hsUVVGbExHbENRMHhxUXl4QlJFdFpPeXREUVV4bU96dGhRVXR4UWtFc1pVRkJaVHM0UTBGTWNFTTdPenM3TzFsQlRVVkRMRWRCUVZrc1JVRkJXa0VzWTBGQldUdFpSVTVrTEU5R1RVVkJMRk5CUVVGQkxGbEJRVmtzUTBGQlEwTXNVMEZCVXl4RlFVRkZPMmRDUVVOMFFpeEpRVUZOUXl4WlFVRlpMRWRCUVVjc1NVRkJTVU1zVTBGQldTeFZRVUZGTEVGQlFVTTdaMEpCUlhoRExFOUJRVTlFTEZsQlFWa3NRMEZCUXp0aFFVTnlRanM3T3p0WlFVVk5SU3hIUVVGNVFpeEZRVUY2UWtFc01rSkJRWGxDTzFsRldteERMRTlHV1VVc1UwRkJUMEVzZVVKQlFYbENMRU5CUVVORExGRkJRVkVzUlVGQlJVTXNWVUZCVlN4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZsQlFXVXNVMEZCUTBnc2VVSkJRWGxDTEVOQlFVTk1MR1ZCUVdVc1JVRkJSVTBzVVVGQlVTeEZRVUZGUXl4VlFVRlZMRU5CUVVNc1EwRkJRenRoUVVGRk96dE5RVnB5U2pzN1EwRmhReXhEUVZJMFEwTXNXVUZCWlN4VFFWRXpSRHRyUWtGU2IwSlNMR1ZCUVdVc1FVRk1jRU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb25cIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvdGVybWluYWwvdGVybWluYWxTeW1ib2xcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFRlcm1pbmFsU3ltYm9sRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhUZXJtaW5hbFN5bWJvbERlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGVybWluYWxTeW1ib2xEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBUZXJtaW5hbFN5bWJvbERlZmluaXRpb24oY29udGVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVybWluYWxTeW1ib2xEZWZpbml0aW9uKTtcbiAgICAgICAgdmFyIHRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChjb250ZW50KSwgcGFydHMgPSBbXG4gICAgICAgICAgICB0ZXJtaW5hbFN5bWJvbFBhcnRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFRlcm1pbmFsU3ltYm9sRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZXJtaW5hbFN5bWJvbERlZmluaXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMM1JsY20xcGJtRnNVM2x0WW05c0xtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dlpHVm1hVzVwZEdsdmJsd2lPMXh1YVcxd2IzSjBJRlJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOTBaWEp0YVc1aGJGTjViV0p2YkZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCVVpYSnRhVzVoYkZONWJXSnZiRVJsWm1sdWFYUnBiMjRnWlhoMFpXNWtjeUJFWldacGJtbDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvWTI5dWRHVnVkQ2tnZTF4dUlDQWdJR052Ym5OMElIUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDQTlJRzVsZHlCVVpYSnRhVzVoYkZONWJXSnZiRkJoY25Rb1kyOXVkR1Z1ZENrc1hHNGdJQ0FnSUNBZ0lDQWdjR0Z5ZEhNZ1BTQmJYRzRnSUNBZ0lDQWdJQ0FnSUNCMFpYSnRhVzVoYkZONWJXSnZiRkJoY25SY2JpQWdJQ0FnSUNBZ0lDQmRPMXh1SUNBZ0lGeHVJQ0FnSUhOMWNHVnlLSEJoY25SektWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVkdWeWJXbHVZV3hUZVcxaWIyeEVaV1pwYm1sMGFXOXVJaXdpWTI5dWRHVnVkQ0lzSW5SbGNtMXBibUZzVTNsdFltOXNVR0Z5ZENJc0lsUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDSXNJbkJoY25Seklpd2lSR1ZtYVc1cGRHbHZiaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVYxUWl4SlFVRkJMRmRCUVdVc2EwTkJRV1lzWlVGQlpTeEZRVUZCTzBGQlExQXNTVUZCUVN4bFFVRnBReXhyUTBGQmFrTXNhVU5CUVdsRExFVkJRVUU3T3pzN096czdPenM3T3pzN096dExRVWhvUlRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFVdGxMRWxCUVVFc1FVRkJUVUVzZDBKQlFYZENMR2xDUTB3eFF5eEJSRXRaTzIxRVFVeG1PenRoUVV0eFFrRXNkMEpCUVhkQ0xFTkJReTlDUXl4UFFVRlBPM1ZFUVU1eVFqdFJRVTlKTEVsQlFVMURMR3RDUVVGclFpeEhRVUZITEVsQlFVbERMR1ZCUVd0Q0xGTkJRVU5HTEU5QlFVOHNRMEZCUXl4RlFVTndSRWNzUzBGQlN5eEhRVUZITzFsQlEwNUdMR3RDUVVGclFqdFRRVU51UWl4QlFVRkRPMmxEUVVWR1JTeExRVUZMT3pzN1EwRkZaQ3hEUVZSeFJFTXNWMEZCVlN4VFFWTXZSRHRyUWtGVWIwSk1MSGRDUVVGM1FpeEJRVXczUXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfb2NjYW1MZXhlcnMgPSByZXF1aXJlKFwib2NjYW0tbGV4ZXJzXCIpO1xudmFyIF9ydWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZVwiKSk7XG52YXIgX3dpbGRjYXJkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9kZS9ibmYvd2lsZGNhcmRcIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vdGVybWluYWxTeW1ib2xcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIHdpbGRjYXJkID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLndpbGRjYXJkO1xudmFyIFdpbGRjYXJkUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhXaWxkY2FyZFJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoV2lsZGNhcmRSdWxlKTtcbiAgICBmdW5jdGlvbiBXaWxkY2FyZFJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXaWxkY2FyZFJ1bGUpO1xuICAgICAgICB2YXIgd2lsZGNhcmRUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSB3aWxkY2FyZCwgd2lsZGNhcmRUZXJtaW5hbFN5bWJvbERlZmluaXRpb24gPSBuZXcgX3Rlcm1pbmFsU3ltYm9sLmRlZmF1bHQod2lsZGNhcmRUZXJtaW5hbFN5bWJvbENvbnRlbnQpLCBuYW1lID0gX3J1bGVOYW1lcy5XaWxkY2FyZFJ1bGVOYW1lLCBhbWJpZ3VvdXMgPSBmYWxzZSwgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICB3aWxkY2FyZFRlcm1pbmFsU3ltYm9sRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX3dpbGRjYXJkLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIFdpbGRjYXJkUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBXaWxkY2FyZFJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDNkcGJHUmpZWEprTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdleUJ6Y0dWamFXRnNVM2x0WW05c2N5QjlJR1p5YjIwZ1hDSnZZMk5oYlMxc1pYaGxjbk5jSWp0Y2JseHVhVzF3YjNKMElGSjFiR1VnWm5KdmJTQmNJaTR1TDNKMWJHVmNJanRjYm1sdGNHOXlkQ0JYYVd4a1kyRnlaRUpPUms1dlpHVWdabkp2YlNCY0lpNHVMMjV2WkdVdlltNW1MM2RwYkdSallYSmtYQ0k3WEc1cGJYQnZjblFnVkdWeWJXbHVZV3hUZVcxaWIyeEVaV1pwYm1sMGFXOXVJR1p5YjIwZ1hDSXVMaTlrWldacGJtbDBhVzl1TDNSbGNtMXBibUZzVTNsdFltOXNYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGZHBiR1JqWVhKa1VuVnNaVTVoYldVZ2ZTQm1jbTl0SUZ3aUxpNHZjblZzWlU1aGJXVnpYQ0k3WEc1Y2JtTnZibk4wSUhzZ2QybHNaR05oY21RZ2ZTQTlJSE53WldOcFlXeFRlVzFpYjJ4ek8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCWGFXeGtZMkZ5WkZKMWJHVWdaWGgwWlc1a2N5QlNkV3hsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdkMmxzWkdOaGNtUlVaWEp0YVc1aGJGTjViV0p2YkVOdmJuUmxiblFnUFNCM2FXeGtZMkZ5WkN4Y2JpQWdJQ0FnSUNBZ0lDQjNhV3hrWTJGeVpGUmxjbTFwYm1Gc1UzbHRZbTlzUkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJVWlhKdGFXNWhiRk41YldKdmJFUmxabWx1YVhScGIyNG9kMmxzWkdOaGNtUlVaWEp0YVc1aGJGTjViV0p2YkVOdmJuUmxiblFwTEZ4dUlDQWdJQ0FnSUNBZ0lHNWhiV1VnUFNCWGFXeGtZMkZ5WkZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnZDJsc1pHTmhjbVJVWlhKdGFXNWhiRk41YldKdmJFUmxabWx1YVhScGIyNWNiaUFnSUNBZ0lDQWdJQ0JkTEZ4dUlDQWdJQ0FnSUNBZ0lFNXZaR1VnUFNCWGFXeGtZMkZ5WkVKT1JrNXZaR1U3WEc1Y2JpQWdJQ0J6ZFhCbGNpaHVZVzFsTENCaGJXSnBaM1Z2ZFhNc0lHUmxabWx1YVhScGIyNXpMQ0JPYjJSbEtWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpZDJsc1pHTmhjbVFpTENKemNHVmphV0ZzVTNsdFltOXNjeUlzSWxkcGJHUmpZWEprVW5Wc1pTSXNJbmRwYkdSallYSmtWR1Z5YldsdVlXeFRlVzFpYjJ4RGIyNTBaVzUwSWl3aWQybHNaR05oY21SVVpYSnRhVzVoYkZONWJXSnZiRVJsWm1sdWFYUnBiMjRpTENKVVpYSnRhVzVoYkZONWJXSnZiRVJsWm1sdWFYUnBiMjRpTENKdVlXMWxJaXdpVjJsc1pHTmhjbVJTZFd4bFRtRnRaU0lzSW1GdFltbG5kVzkxY3lJc0ltUmxabWx1YVhScGIyNXpJaXdpVG05a1pTSXNJbGRwYkdSallYSmtRazVHVG05a1pTSXNJbEoxYkdVaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRkswSXNTVUZCUVN4WlFVRmpMRmRCUVdRc1kwRkJZeXhEUVVGQk8wRkJSVFZDTEVsQlFVRXNTMEZCVXl4clEwRkJWQ3hUUVVGVExFVkJRVUU3UVVGRFJTeEpRVUZCTEZOQlFYTkNMR3REUVVGMFFpeHpRa0ZCYzBJc1JVRkJRVHRCUVVOaUxFbEJRVUVzWlVGQk9FSXNhME5CUVRsQ0xEaENRVUU0UWl4RlFVRkJPMEZCUld4RExFbEJRVUVzVlVGQll5eFhRVUZrTEdOQlFXTXNRMEZCUVRzN096czdPenM3T3pzN096czdPMHRCVWk5RE96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJWVUVzU1VGQlRTeEJRVUZGUVN4UlFVRlJMRWRCUVV0RExGbEJRV01zWjBKQlFUTkNSQ3hSUVVGUkxFRkJRVzFDTEVGQlFVTTdRVUZGY2tJc1NVRkJRU3hCUVVGTlJTeFpRVUZaTEdsQ1ExbzVRaXhCUkZsWk8ybERRVnBtT3p0aFFWbHhRa0VzV1VGQldUc3lRMEZhYWtNN1VVRmpTU3hKUVVGTlF5dzJRa0ZCTmtJc1IwRkJSMGdzVVVGQlVTeEZRVU40UTBrc1owTkJRV2RETEVkQlFVY3NTVUZCU1VNc1pVRkJkMElzVTBGQlEwWXNOa0pCUVRaQ0xFTkJRVU1zUlVGRE9VWkhMRWxCUVVrc1IwRkJSME1zVlVGQlowSXNhVUpCUVVFc1JVRkRka0pETEZOQlFWTXNSMEZCUnl4TFFVRkxMRVZCUTJwQ1F5eFhRVUZYTEVkQlFVYzdXVUZEV2t3c1owTkJRV2RETzFOQlEycERMRVZCUTBSTkxFbEJRVWtzUjBGQlIwTXNVMEZCWlN4UlFVRkJMRUZCUVVNN2FVTkJSWFpDVEN4SlFVRkpMRVZCUVVWRkxGTkJRVk1zUlVGQlJVTXNWMEZCVnl4RlFVRkZReXhKUVVGSk96czdRMEZGTTBNc1EwRmllVU5GTEV0QlFVa3NVMEZoTjBNN2EwSkJZbTlDVml4WlFVRlpMRUZCV21wREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfdmVydGljYWxCcmFuY2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZlcnRpY2FsQnJhbmNoXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEVORF9PRl9MSU5FID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLkVORF9PRl9MSU5FO1xudmFyIEVuZE9mTGluZU5vZGVQYXJzZVRyZWUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKSB7XG4gICAgX2luaGVyaXRzKEVuZE9mTGluZU5vZGVQYXJzZVRyZWUsIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVuZE9mTGluZU5vZGVQYXJzZVRyZWUpO1xuICAgIGZ1bmN0aW9uIEVuZE9mTGluZU5vZGVQYXJzZVRyZWUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRPZkxpbmVOb2RlUGFyc2VUcmVlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoRW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSwgbnVsbCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbU5vdGhpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTm90aGluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gRU5EX09GX0xJTkUsIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGggPSBzdHJpbmdMZW5ndGgsIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gX3ZlcnRpY2FsQnJhbmNoLmRlZmF1bHQuZnJvbVdpZHRoKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGgpLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLCB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBfdmVydGljYWxCcmFuY2guZGVmYXVsdC5mcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihFbmRPZkxpbmVOb2RlUGFyc2VUcmVlLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mTGluZU5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRPZkxpbmVOb2RlUGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEVuZE9mTGluZU5vZGVQYXJzZVRyZWU7XG59KF92ZXJ0aWNhbEJyYW5jaC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVuZE9mTGluZU5vZGVQYXJzZVRyZWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWEp6WlZSeVpXVXZaVzVrVDJaTWFXNWxUbTlrWlM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJSHNnYzNCbFkybGhiRk41YldKdmJITWdmU0JtY205dElGd2liMk5qWVcwdGJHVjRaWEp6WENJN1hHNWNibWx0Y0c5eWRDQldaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlNCbWNtOXRJRndpTGk5MlpYSjBhV05oYkVKeVlXNWphRndpTzF4dVhHNWpiMjV6ZENCN0lFVk9SRjlQUmw5TVNVNUZJSDBnUFNCemNHVmphV0ZzVTNsdFltOXNjenRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdSVzVrVDJaTWFXNWxUbTlrWlZCaGNuTmxWSEpsWlNCbGVIUmxibVJ6SUZabGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxJSHRjYmlBZ2MzUmhkR2xqSUdaeWIyMU9iM1JvYVc1bktDa2dlMXh1SUNBZ0lHTnZibk4wSUhOMGNtbHVaeUE5SUVWT1JGOVBSbDlNU1U1RkxDQXZMeTljYmlBZ0lDQWdJQ0FnSUNCemRISnBibWRNWlc1bmRHZ2dQU0J6ZEhKcGJtY3ViR1Z1WjNSb0xGeHVJQ0FnSUNBZ0lDQWdJSFpsY25ScFkyRnNRbkpoYm1Ob1VHRnljMlZVY21WbFYybGtkR2dnUFNCemRISnBibWRNWlc1bmRHZ3NJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lIWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsSUQwZ1ZtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1V1Wm5KdmJWZHBaSFJvS0habGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxWMmxrZEdncExGeHVJQ0FnSUNBZ0lDQWdJSFpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0Z1BTQjJaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlM1blpYUldaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1S0Nrc1hHNGdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeE9iMlJsVUdGeWMyVlVjbVZsSUQwZ1ZtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1V1Wm5KdmJWTjBjbWx1WjBGdVpGWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRvUlc1a1QyWk1hVzVsVG05a1pWQmhjbk5sVkhKbFpTd2djM1J5YVc1bkxDQjJaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1S1R0Y2JseHVJQ0FnSUhSbGNtMXBibUZzVG05a1pWQmhjbk5sVkhKbFpTNWhjSEJsYm1SVWIxUnZjQ2gyWlhKMGFXTmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTazdYRzVjYmlBZ0lDQmpiMjV6ZENCbGJtUlBaa3hwYm1WT2IyUmxVR0Z5YzJWVWNtVmxJRDBnZEdWeWJXbHVZV3hPYjJSbFVHRnljMlZVY21WbE95QXZMeTljYmx4dUlDQWdJSEpsZEhWeWJpQmxibVJQWmt4cGJtVk9iMlJsVUdGeWMyVlVjbVZsTzF4dUlDQjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lSVTVFWDA5R1gweEpUa1VpTENKemNHVmphV0ZzVTNsdFltOXNjeUlzSWtWdVpFOW1UR2x1WlU1dlpHVlFZWEp6WlZSeVpXVWlMQ0ptY205dFRtOTBhR2x1WnlJc0luTjBjbWx1WnlJc0luTjBjbWx1WjB4bGJtZDBhQ0lzSW14bGJtZDBhQ0lzSW5abGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxWMmxrZEdnaUxDSjJaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlNJc0lsWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsSWl3aVpuSnZiVmRwWkhSb0lpd2lkbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlJc0ltZGxkRlpsY25ScFkyRnNRbkpoYm1Ob1VHOXphWFJwYjI0aUxDSjBaWEp0YVc1aGJFNXZaR1ZRWVhKelpWUnlaV1VpTENKbWNtOXRVM1J5YVc1blFXNWtWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlJc0ltRndjR1Z1WkZSdlZHOXdJaXdpWlc1a1QyWk1hVzVsVG05a1pWQmhjbk5sVkhKbFpTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXJRaXhKUVVGQkxGbEJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdRVUZGVkN4SlFVRkJMR1ZCUVd0Q0xHdERRVUZzUWl4clFrRkJhMElzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVcDBSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZOUVN4SlFVRk5MRUZCUVVWQkxGZEJRVmNzUjBGQlMwTXNXVUZCWXl4blFrRkJPVUpFTEZkQlFWY3NRVUZCYlVJc1FVRkJRenRCUVVWNFFpeEpRVUZCTEVGQlFVMUZMSE5DUVVGelFpeHBRa05TZUVNc1FVUlJXVHM0UkVGU1pqczdZVUZSY1VKQkxITkNRVUZ6UWp0eFJFRlNNME03T3pzN08xbEJVMU5ETEVkQlFWY3NSVUZCV0VFc1lVRkJWenRaUlZSd1FpeFBSbE5GTEZOQlFVOUJMRmRCUVZjc1IwRkJSenRuUWtGRGJrSXNTVUZCVFVNc1RVRkJUU3hIUVVGSFNpeFhRVUZYTEVWQlEzQkNTeXhaUVVGWkxFZEJRVWRFTEUxQlFVMHNRMEZCUTBVc1RVRkJUU3hGUVVNMVFrTXNORUpCUVRSQ0xFZEJRVWRHTEZsQlFWa3NSVUZETTBOSExIVkNRVUYxUWl4SFFVRkhReXhsUVVGMVFpeFRRVUZEUXl4VFFVRlRMRU5CUVVOSUxEUkNRVUUwUWl4RFFVRkRMRVZCUTNwR1NTeHpRa0ZCYzBJc1IwRkJSMGdzZFVKQlFYVkNMRU5CUVVOSkxIbENRVUY1UWl4RlFVRkZMRVZCUXpWRlF5eHhRa0ZCY1VJc1IwRkJSMG9zWlVGQmRVSXNVMEZCUTBzc2JVTkJRVzFETEVOQlFVTmFMSE5DUVVGelFpeEZRVUZGUlN4TlFVRk5MRVZCUVVWUExITkNRVUZ6UWl4RFFVRkRMRUZCUVVNN1owSkJSV3hLUlN4eFFrRkJjVUlzUTBGQlEwVXNWMEZCVnl4RFFVRkRVQ3gxUWtGQmRVSXNRMEZCUXl4RFFVRkRPMmRDUVVVelJDeEpRVUZOVVN4elFrRkJjMElzUjBGQlIwZ3NjVUpCUVhGQ0xFRkJRVU1zUlVGQlF5eEhRVUZITzJkQ1FVVjZSQ3hQUVVGUFJ5eHpRa0ZCYzBJc1EwRkJRenRoUVVNdlFqczdUVUYwUWtnN08wTkJkVUpETEVOQlptMUVVQ3hsUVVGMVFpeFRRV1V4UlR0clFrRm1iMEpRTEhOQ1FVRnpRaXhCUVZJelF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3Rlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdGVybWluYWxcIikpO1xudmFyIF9lbmRPZkxpbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFyc2VUcmVlL2VuZE9mTGluZU5vZGVcIikpO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgRW5kT2ZMaW5lQk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKEVuZE9mTGluZUJORk5vZGUsIFRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFbmRPZkxpbmVCTkZOb2RlKTtcbiAgICBmdW5jdGlvbiBFbmRPZkxpbmVCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kT2ZMaW5lQk5GTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEVuZE9mTGluZUJORk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldENvbnRlbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZW50KCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gX2NvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1BhcnNlVHJlZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZkxpbmVOb2RlUGFyc2VUcmVlID0gX2VuZE9mTGluZU5vZGUuZGVmYXVsdC5mcm9tTm90aGluZygpLCBwYXJzZVRyZWUgPSBlbmRPZkxpbmVOb2RlUGFyc2VUcmVlOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVNpZ25pZmljYW50VG9rZW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90ZXJtaW5hbC5kZWZhdWx0LmZyb21TaWduaWZpY2FudFRva2VuKEVuZE9mTGluZUJORk5vZGUsIHNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEVuZE9mTGluZUJORk5vZGU7XG59KF90ZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVuZE9mTGluZUJORk5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl1YjJSbEwzUmxjbTFwYm1Gc0wyVnVaRTltVEdsdVpTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZSbGNtMXBibUZzVG05a1pTQm1jbTl0SUZ3aUxpNHZkR1Z5YldsdVlXeGNJanRjYm1sdGNHOXlkQ0JGYm1SUFpreHBibVZPYjJSbFVHRnljMlZVY21WbElHWnliMjBnWENJdUxpOHVMaTl3WVhKelpWUnlaV1V2Wlc1a1QyWk1hVzVsVG05a1pWd2lPMXh1WEc1cGJYQnZjblFnZXlCRlRWQlVXVjlUVkZKSlRrY2dmU0JtY205dElGd2lMaTR2TGk0dlkyOXVjM1JoYm5SelhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklFVnVaRTltVEdsdVpVSk9SazV2WkdVZ1pYaDBaVzVrY3lCVVpYSnRhVzVoYkU1dlpHVWdlMXh1SUNCblpYUkRiMjUwWlc1MEtDa2dlMXh1SUNBZ0lHTnZibk4wSUdOdmJuUmxiblFnUFNCRlRWQlVXVjlUVkZKSlRrYzdYRzVjYmlBZ0lDQnlaWFIxY200Z1kyOXVkR1Z1ZER0Y2JpQWdmVnh1WEc0Z0lHRnpVR0Z5YzJWVWNtVmxLSFJ2YTJWdWN5a2dlMXh1SUNBZ0lHTnZibk4wSUdWdVpFOW1UR2x1WlU1dlpHVlFZWEp6WlZSeVpXVWdQU0JGYm1SUFpreHBibVZPYjJSbFVHRnljMlZVY21WbExtWnliMjFPYjNSb2FXNW5LQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2NHRnljMlZVY21WbElEMGdaVzVrVDJaTWFXNWxUbTlrWlZCaGNuTmxWSEpsWlRzZ0lDOHZMMXh1WEc0Z0lDQWdjbVYwZFhKdUlIQmhjbk5sVkhKbFpUdGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0VTJsbmJtbG1hV05oYm5SVWIydGxiaWh6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVLU0I3SUhKbGRIVnliaUJVWlhKdGFXNWhiRTV2WkdVdVpuSnZiVk5wWjI1cFptbGpZVzUwVkc5clpXNG9SVzVrVDJaTWFXNWxRazVHVG05a1pTd2djMmxuYm1sbWFXTmhiblJVYjJ0bGJpazdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpGYm1SUFpreHBibVZDVGtaT2IyUmxJaXdpWjJWMFEyOXVkR1Z1ZENJc0ltTnZiblJsYm5RaUxDSkZUVkJVV1Y5VFZGSkpUa2NpTENKaGMxQmhjbk5sVkhKbFpTSXNJblJ2YTJWdWN5SXNJbVZ1WkU5bVRHbHVaVTV2WkdWUVlYSnpaVlJ5WldVaUxDSkZibVJQWmt4cGJtVk9iMlJsVUdGeWMyVlVjbVZsSWl3aVpuSnZiVTV2ZEdocGJtY2lMQ0p3WVhKelpWUnlaV1VpTENKbWNtOXRVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbk5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0pVWlhKdGFXNWhiRTV2WkdVaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRmVVSXNTVUZCUVN4VFFVRmhMR3REUVVGaUxHRkJRV0VzUlVGQlFUdEJRVU5JTEVsQlFVRXNZMEZCSzBJc2EwTkJRUzlDTEN0Q1FVRXJRaXhGUVVGQk8wRkJSWEpETEVsQlFVRXNWVUZCYVVJc1YwRkJha0lzYVVKQlFXbENMRU5CUVVFN096czdPenM3T3pzN096czdPenM0UkVGTU9VTTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJUMlVzU1VGQlFTeEJRVUZOUVN4blFrRkJaMElzYVVKRFVHeERMRUZFVDFrN05rTkJVR1k3TzJGQlQzRkNRU3huUWtGQlowSTdLME5CVUhKRE96czdPenRaUVZGRlF5eEhRVUZWTEVWQlFWWkJMRmxCUVZVN1dVVlNXaXhQUmxGRlFTeFRRVUZCUVN4VlFVRlZMRWRCUVVjN1owSkJRMWdzU1VGQlRVTXNUMEZCVHl4SFFVRkhReXhWUVVGWkxHRkJRVUVzUVVGQlF6dG5Ra0ZGTjBJc1QwRkJUMFFzVDBGQlR5eERRVUZETzJGQlEyaENPenM3V1VGRlJFVXNSMEZCVnl4RlFVRllRU3hoUVVGWE8xbEZaR0lzVDBaalJVRXNVMEZCUVVFc1YwRkJWeXhEUVVGRFF5eE5RVUZOTEVWQlFVVTdaMEpCUTJ4Q0xFbEJRVTFETEhOQ1FVRnpRaXhIUVVGSFF5eGpRVUZ6UWl4VFFVRkRReXhYUVVGWExFVkJRVVVzUlVGRE4wUkRMRk5CUVZNc1IwRkJSMGdzYzBKQlFYTkNMRUZCUVVNc1JVRkJSU3hIUVVGSE8yZENRVVU1UXl4UFFVRlBSeXhUUVVGVExFTkJRVU03WVVGRGJFSTdPenM3V1VGRlRVTXNSMEZCYjBJc1JVRkJjRUpCTEhOQ1FVRnZRanRaUlhKQ04wSXNUMFp4UWtVc1UwRkJUMEVzYjBKQlFXOUNMRU5CUVVORExHZENRVUZuUWl4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZOQlFWa3NVMEZCUTBZc2IwSkJRVzlDTEVOQlFVTldMR2RDUVVGblFpeEZRVUZGVnl4blFrRkJaMElzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCY2tKcVNUczdRMEZ6UWtNc1EwRm1Oa05ETEZOQlFWa3NVMEZsZWtRN2EwSkJabTlDV2l4blFrRkJaMElzUVVGUWNrTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX3Rlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiKSk7XG52YXIgX2VuZE9mTGluZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvdGVybWluYWwvZW5kT2ZMaW5lXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEVORF9PRl9MSU5FID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLkVORF9PRl9MSU5FO1xudmFyIEVuZE9mTGluZVBhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFRlcm1pbmFsUGFydCkge1xuICAgIF9pbmhlcml0cyhFbmRPZkxpbmVQYXJ0LCBUZXJtaW5hbFBhcnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRW5kT2ZMaW5lUGFydCk7XG4gICAgZnVuY3Rpb24gRW5kT2ZMaW5lUGFydCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZE9mTGluZVBhcnQpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhFbmRPZkxpbmVQYXJ0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwYXJzZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkO1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZkxpbmVCTkZOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSwgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLCBzaWduaWZpY2FudFRva2VuID0gbmV4dFNpZ25pZmljYW50VG9rZW47IC8vL1xuICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuRW5kT2ZMaW5lVG9rZW4gPSBzaWduaWZpY2FudFRva2VuLmlzRW5kT2ZMaW5lVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50VG9rZW5FbmRPZkxpbmVUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZMaW5lQk5GTm9kZSA9IF9lbmRPZkxpbmUuZGVmYXVsdC5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBlbmRPZkxpbmVCTkZOb2RlICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChlbmRPZkxpbmVCTkZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhc1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBFTkRfT0ZfTElORTsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEVuZE9mTGluZVBhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIEVuZE9mTGluZVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEVuZE9mTGluZVBhcnQ7XG59KF90ZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVuZE9mTGluZVBhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl3WVhKMEwzUmxjbTFwYm1Gc0wyVnVaRTltVEdsdVpTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUhzZ2MzQmxZMmxoYkZONWJXSnZiSE1nZlNCbWNtOXRJRndpYjJOallXMHRiR1Y0WlhKelhDSTdYRzVjYm1sdGNHOXlkQ0JVWlhKdGFXNWhiRkJoY25RZ1puSnZiU0JjSWk0dUx5NHVMM0JoY25RdmRHVnliV2x1WVd4Y0lqdGNibWx0Y0c5eWRDQkZibVJQWmt4cGJtVkNUa1pPYjJSbElHWnliMjBnWENJdUxpOHVMaTl1YjJSbEwzUmxjbTFwYm1Gc0wyVnVaRTltVEdsdVpWd2lPMXh1WEc1amIyNXpkQ0I3SUVWT1JGOVBSbDlNU1U1RklIMGdQU0J6Y0dWamFXRnNVM2x0WW05c2N6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1JXNWtUMlpNYVc1bFVHRnlkQ0JsZUhSbGJtUnpJRlJsY20xcGJtRnNVR0Z5ZENCN1hHNGdJSEJoY25ObEtHNXZaR1Z6TENCemRHRjBaU3dnWTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0JzWlhRZ2NHRnljMlZrTzF4dVhHNGdJQ0FnYkdWMElHVnVaRTltVEdsdVpVSk9SazV2WkdVZ1BTQnVkV3hzTzF4dUlDQWdJRnh1SUNBZ0lHTnZibk4wSUhOaGRtVmtTVzVrWlhnZ1BTQnpkR0YwWlM1blpYUlRZWFpsWkVsdVpHVjRLQ2tzWEc1Y2RGeDBJQ0FnSUNBZ2JtVjRkRk5wWjI1cFptbGpZVzUwVkc5clpXNGdQU0J6ZEdGMFpTNW5aWFJPWlhoMFUybG5ibWxtYVdOaGJuUlViMnRsYmlncExGeHVJQ0FnSUNBZ0lDQWdJSE5wWjI1cFptbGpZVzUwVkc5clpXNGdQU0J1WlhoMFUybG5ibWxtYVdOaGJuUlViMnRsYmpzZ0x5OHZYRzVjYmlBZ0lDQnBaaUFvYzJsbmJtbG1hV05oYm5SVWIydGxiaUFoUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnWTI5dWMzUWdjMmxuYm1sbWFXTmhiblJVYjJ0bGJrVnVaRTltVEdsdVpWUnZhMlZ1SUQwZ2MybG5ibWxtYVdOaGJuUlViMnRsYmk1cGMwVnVaRTltVEdsdVpWUnZhMlZ1S0NrN1hHNWNiaUFnSUNBZ0lHbG1JQ2h6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVSVzVrVDJaTWFXNWxWRzlyWlc0cElIdGNiaUFnSUNBZ0lDQWdaVzVrVDJaTWFXNWxRazVHVG05a1pTQTlJRVZ1WkU5bVRHbHVaVUpPUms1dlpHVXVabkp2YlZOcFoyNXBabWxqWVc1MFZHOXJaVzRvYzJsbmJtbG1hV05oYm5SVWIydGxiaWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjR0Z5YzJWa0lEMGdLR1Z1WkU5bVRHbHVaVUpPUms1dlpHVWdJVDA5SUc1MWJHd3BPMXh1WEc0Z0lDQWdhV1lnS0hCaGNuTmxaQ2tnZTF4dUlDQWdJQ0FnYm05a1pYTXVjSFZ6YUNobGJtUlBaa3hwYm1WQ1RrWk9iMlJsS1R0Y2JseHVJQ0FnSUNBZ2FXWWdLR05oYkd4aVlXTnJJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUhCaGNuTmxaQ0E5SUdOaGJHeGlZV05yS0NrN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0NGd1lYSnpaV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnViMlJsY3k1d2IzQW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNnaGNHRnljMlZrS1NCN1hHNGdJQ0FnSUNCemRHRjBaUzVpWVdOcmRISmhZMnNvYzJGMlpXUkpibVJsZUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJSEJoY25ObFpEdGNiaUFnZlZ4dVhHNGdJR0Z6VTNSeWFXNW5LQ2tnZTF4dUlDQWdJR052Ym5OMElITjBjbWx1WnlBOUlFVk9SRjlQUmw5TVNVNUZPeUF2THk5Y2JseHVJQ0FnSUhKbGRIVnliaUJ6ZEhKcGJtYzdYRzRnSUgxY2JseHVJQ0JqYkc5dVpTZ3BJSHNnY21WMGRYSnVJSE4xY0dWeUxtTnNiMjVsS0VWdVpFOW1UR2x1WlZCaGNuUXBPeUI5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpUlU1RVgwOUdYMHhKVGtVaUxDSnpjR1ZqYVdGc1UzbHRZbTlzY3lJc0lrVnVaRTltVEdsdVpWQmhjblFpTENKd1lYSnpaU0lzSW01dlpHVnpJaXdpYzNSaGRHVWlMQ0pqWVd4c1ltRmpheUlzSW5CaGNuTmxaQ0lzSW1WdVpFOW1UR2x1WlVKT1JrNXZaR1VpTENKellYWmxaRWx1WkdWNElpd2laMlYwVTJGMlpXUkpibVJsZUNJc0ltNWxlSFJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpWjJWMFRtVjRkRk5wWjI1cFptbGpZVzUwVkc5clpXNGlMQ0p6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVJaXdpYzJsbmJtbG1hV05oYm5SVWIydGxia1Z1WkU5bVRHbHVaVlJ2YTJWdUlpd2lhWE5GYm1SUFpreHBibVZVYjJ0bGJpSXNJa1Z1WkU5bVRHbHVaVUpPUms1dlpHVWlMQ0ptY205dFUybG5ibWxtYVdOaGJuUlViMnRsYmlJc0luQjFjMmdpTENKd2IzQWlMQ0ppWVdOcmRISmhZMnNpTENKaGMxTjBjbWx1WnlJc0luTjBjbWx1WnlJc0ltTnNiMjVsSWl3aVZHVnliV2x1WVd4UVlYSjBJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSU3RDTEVsQlFVRXNXVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHRCUVVWd1FpeEpRVUZCTEZOQlFYRkNMR3REUVVGeVFpeHhRa0ZCY1VJc1JVRkJRVHRCUVVOcVFpeEpRVUZCTEZWQlFTdENMR3REUVVFdlFpd3JRa0ZCSzBJc1JVRkJRVHM3T3pzN096czdPenM3T3pzN096aEVRVXcxUkR0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN01FSkJRVUU3T3pzN096czdPenM3VTBGQlFUczdPenM3T3p0TFFVRkJPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096czdkME5CUVVFN096czdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlQwRXNTVUZCVFN4QlFVRkZRU3hYUVVGWExFZEJRVXRETEZsQlFXTXNaMEpCUVRsQ1JDeFhRVUZYTEVGQlFXMUNMRUZCUVVNN1FVRkZlRUlzU1VGQlFTeEJRVUZOUlN4aFFVRmhMR2xDUTFRdlFpeEJSRk5aT3pCRFFWUm1PenRoUVZOeFFrRXNZVUZCWVRzMFEwRlViRU03T3pzN08xbEJWVVZETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlZaUUxFOUdWVVZCTEZOQlFVRkJMRXRCUVVzc1EwRkJRME1zUzBGQlN5eEZRVUZGUXl4TFFVRkxMRVZCUVVWRExGRkJRVkVzUlVGQlJUdG5Ra0ZETlVJc1NVRkJTVU1zVFVGQlRTeEJRVUZETzJkQ1FVVllMRWxCUVVsRExHZENRVUZuUWl4SFFVRkhMRWxCUVVrc1FVRkJRenRuUWtGRk5VSXNTVUZCVFVNc1ZVRkJWU3hIUVVGSFNpeExRVUZMTEVOQlFVTkxMR0ZCUVdFc1JVRkJSU3hGUVVOd1EwTXNiMEpCUVc5Q0xFZEJRVWRPTEV0QlFVc3NRMEZCUTA4c2RVSkJRWFZDTEVWQlFVVXNSVUZEY0VSRExHZENRVUZuUWl4SFFVRkhSaXh2UWtGQmIwSXNRVUZCUXl4RlFVRkRMRWRCUVVjN1owSkJSV3hFTEVsQlFVbEZMR2RDUVVGblFpeExRVUZMTEVsQlFVa3NSVUZCUlR0dlFrRkROMElzU1VGQlRVTXNPRUpCUVRoQ0xFZEJRVWRFTEdkQ1FVRm5RaXhEUVVGRFJTeG5Ra0ZCWjBJc1JVRkJSU3hCUVVGRE8yOUNRVVV6UlN4SlFVRkpSQ3c0UWtGQk9FSXNSVUZCUlR0M1FrRkRiRU5PTEdkQ1FVRm5RaXhIUVVGSFVTeFZRVUZuUWl4VFFVRkRReXh2UWtGQmIwSXNRMEZCUTBvc1owSkJRV2RDTEVOQlFVTXNRMEZCUXp0eFFrRkROVVU3YVVKQlEwWTdaMEpCUlVST0xFMUJRVTBzUjBGQlNVTXNaMEpCUVdkQ0xFdEJRVXNzU1VGQlNTeEJRVUZETEVOQlFVTTdaMEpCUlhKRExFbEJRVWxFTEUxQlFVMHNSVUZCUlR0dlFrRkRWa2dzUzBGQlN5eERRVUZEWXl4SlFVRkpMRU5CUVVOV0xHZENRVUZuUWl4RFFVRkRMRU5CUVVNN2IwSkJSVGRDTEVsQlFVbEdMRkZCUVZFc1MwRkJTeXhKUVVGSkxFVkJRVVU3ZDBKQlEzSkNReXhOUVVGTkxFZEJRVWRFTEZGQlFWRXNSVUZCUlN4RFFVRkRPM2RDUVVWd1FpeEpRVUZKTEVOQlFVTkRMRTFCUVUwc1JVRkJSVHMwUWtGRFdFZ3NTMEZCU3l4RFFVRkRaU3hIUVVGSExFVkJRVVVzUTBGQlF6dDVRa0ZEWWp0eFFrRkRSanRwUWtGRFJqdG5Ra0ZGUkN4SlFVRkpMRU5CUVVOYUxFMUJRVTBzUlVGQlJUdHZRa0ZEV0VZc1MwRkJTeXhEUVVGRFpTeFRRVUZUTEVOQlFVTllMRlZCUVZVc1EwRkJReXhEUVVGRE8ybENRVU0zUWp0blFrRkZSQ3hQUVVGUFJpeE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJqTEVkQlFWRXNSVUZCVWtFc1ZVRkJVVHRaUldoRVZpeFBSbWRFUlVFc1UwRkJRVUVzVVVGQlVTeEhRVUZITzJkQ1FVTlVMRWxCUVUxRExFMUJRVTBzUjBGQlIzUkNMRmRCUVZjc1FVRkJReXhGUVVGRExFZEJRVWM3WjBKQlJTOUNMRTlCUVU5elFpeE5RVUZOTEVOQlFVTTdZVUZEWmpzN08xbEJSVVJETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUlhSRVVDeFBSbk5FUlVFc1UwRkJRVUVzUzBGQlN5eEhRVUZITzJkQ1FVRkZMRTlCUVU4c2NVSkJOME5GY2tJc1lVRkJZU3hoUVRaRFZIRkNMRTlCUVVzc1JVRkJXQ3hKUVVGTExFTkJRVUVzV1VGQlQzSkNMR0ZCUVdFc1JVRkJSVHRoUVVGRk96dE5RWFJFYUVRN08wTkJkVVJETEVOQk9VTXdRM05DTEZOQlFWa3NVMEU0UTNSRU8ydENRVGxEYjBKMFFpeGhRVUZoTEVGQlZHeERJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9lbmRPZkxpbmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZVwiKSk7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBFbmRPZkxpbmVCTkZOb2RlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoRW5kT2ZMaW5lQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVuZE9mTGluZUJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIEVuZE9mTGluZUJORk5vZGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRPZkxpbmVCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoRW5kT2ZMaW5lQk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuZXJhdGVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZkxpbmVQYXJ0ID0gbmV3IF9lbmRPZkxpbmUuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRPZkxpbmVQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhFbmRPZkxpbmVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gRW5kT2ZMaW5lQk5GTm9kZTtcbn0oX25vblRlcm1pbmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW5kT2ZMaW5lQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOWxibVJQWmt4cGJtVXVhbk1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2JtbHRjRzl5ZENCRmJtUlBaa3hwYm1WUVlYSjBJR1p5YjIwZ1hDSXVMaTh1TGk5d1lYSjBMM1JsY20xcGJtRnNMMlZ1WkU5bVRHbHVaVndpTzF4dWFXMXdiM0owSUU1dmJsUmxjbTFwYm1Gc1RtOWtaU0JtY205dElGd2lMaTR2TGk0dmJtOWtaUzl1YjI1VVpYSnRhVzVoYkZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCRmJtUlBaa3hwYm1WQ1RrWk9iMlJsSUdWNGRHVnVaSE1nVG05dVZHVnliV2x1WVd4T2IyUmxJSHRjYmlBZ1oyVnVaWEpoZEdWUVlYSjBLR3h2YjJ0QmFHVmhaQ2tnZTF4dUlDQWdJR052Ym5OMElHVnVaRTltVEdsdVpWQmhjblFnUFNCdVpYY2dSVzVrVDJaTWFXNWxVR0Z5ZENncE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUdWdVpFOW1UR2x1WlZCaGNuUTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aHlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWtnZXlCeVpYUjFjbTRnVG05dVZHVnliV2x1WVd4T2IyUmxMbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9SVzVrVDJaTWFXNWxRazVHVG05a1pTd2djblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wT3lCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVJXNWtUMlpNYVc1bFFrNUdUbTlrWlNJc0ltZGxibVZ5WVhSbFVHRnlkQ0lzSW14dmIydEJhR1ZoWkNJc0ltVnVaRTltVEdsdVpWQmhjblFpTENKRmJtUlBaa3hwYm1WUVlYSjBJaXdpWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeUlzSW5KMWJHVk9ZVzFsSWl3aVkyaHBiR1JPYjJSbGN5SXNJazV2YmxSbGNtMXBibUZzVG05a1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXdRaXhKUVVGQkxGVkJRU3RDTEd0RFFVRXZRaXdyUWtGQkswSXNSVUZCUVR0QlFVTTNRaXhKUVVGQkxGbEJRWGRDTEd0RFFVRjRRaXgzUWtGQmQwSXNSVUZCUVRzN096czdPenM3T3pzN096czdPemhFUVVod1JEdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRkxaU3hKUVVGQkxFRkJRVTFCTEdkQ1FVRm5RaXhwUWtOTWJFTXNRVVJMV1R0blJFRk1aanM3WVVGTGNVSkJMR2RDUVVGblFqc3JRMEZNY2tNN096czdPMWxCVFVWRExFZEJRVmtzUlVGQldrRXNZMEZCV1R0WlJVNWtMRTlHVFVWQkxGTkJRVUZCTEZsQlFWa3NRMEZCUTBNc1UwRkJVeXhGUVVGRk8yZENRVU4wUWl4SlFVRk5ReXhoUVVGaExFZEJRVWNzU1VGQlNVTXNWVUZCWVN4VlFVRkZMRUZCUVVNN1owSkJSVEZETEU5QlFVOUVMR0ZCUVdFc1EwRkJRenRoUVVOMFFqczdPenRaUVVWTlJTeEhRVUY1UWl4RlFVRjZRa0VzTWtKQlFYbENPMWxGV214RExFOUdXVVVzVTBGQlQwRXNlVUpCUVhsQ0xFTkJRVU5ETEZGQlFWRXNSVUZCUlVNc1ZVRkJWU3hGUVVGRk8yZENRVUZGTEU5QlFVOURMRmxCUVdVc1UwRkJRMGdzZVVKQlFYbENMRU5CUVVOTUxHZENRVUZuUWl4RlFVRkZUU3hSUVVGUkxFVkJRVVZETEZWQlFWVXNRMEZCUXl4RFFVRkRPMkZCUVVVN08wMUJXblJLT3p0RFFXRkRMRU5CVWpaRFF5eFpRVUZsTEZOQlVUVkVPMnRDUVZKdlFsSXNaMEpCUVdkQ0xFRkJUSEpESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfb2NjYW1MZXhlcnMgPSByZXF1aXJlKFwib2NjYW0tbGV4ZXJzXCIpO1xudmFyIF9ydWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZVwiKSk7XG52YXIgX2VuZE9mTGluZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL2VuZE9mTGluZVwiKSk7XG52YXIgX3Rlcm1pbmFsU3ltYm9sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi90ZXJtaW5hbFN5bWJvbFwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgRU5EX09GX0xJTkUgPSBfb2NjYW1MZXhlcnMuc3BlY2lhbFN5bWJvbHMuRU5EX09GX0xJTkU7XG52YXIgRW5kT2ZMaW5lUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhFbmRPZkxpbmVSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVuZE9mTGluZVJ1bGUpO1xuICAgIGZ1bmN0aW9uIEVuZE9mTGluZVJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRPZkxpbmVSdWxlKTtcbiAgICAgICAgdmFyIGVuZE9mTGluZVRlcm1pbmFsU3ltYm9sQ29udGVudCA9IEVORF9PRl9MSU5FLCBlbmRPZkxpbmVUZXJtaW5hbFN5bWJvbERlZmluaXRpb24gPSBuZXcgX3Rlcm1pbmFsU3ltYm9sLmRlZmF1bHQoZW5kT2ZMaW5lVGVybWluYWxTeW1ib2xDb250ZW50KSwgbmFtZSA9IF9ydWxlTmFtZXMuRW5kT2ZMaW5lUnVsZU5hbWUsIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVuZE9mTGluZVRlcm1pbmFsU3ltYm9sRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX2VuZE9mTGluZS5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBFbmRPZkxpbmVSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVuZE9mTGluZVJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDJWdVpFOW1UR2x1WlM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJSHNnYzNCbFkybGhiRk41YldKdmJITWdmU0JtY205dElGd2liMk5qWVcwdGJHVjRaWEp6WENJN1hHNWNibWx0Y0c5eWRDQlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxYQ0k3WEc1cGJYQnZjblFnUlc1a1QyWk1hVzVsUWs1R1RtOWtaU0JtY205dElGd2lMaTR2Ym05a1pTOWlibVl2Wlc1a1QyWk1hVzVsWENJN1hHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4VGVXMWliMnhFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dUwzUmxjbTFwYm1Gc1UzbHRZbTlzWENJN1hHNWNibWx0Y0c5eWRDQjdJRVZ1WkU5bVRHbHVaVkoxYkdWT1lXMWxJSDBnWm5KdmJTQmNJaTR1TDNKMWJHVk9ZVzFsYzF3aU8xeHVYRzVqYjI1emRDQjdJRVZPUkY5UFJsOU1TVTVGSUgwZ1BTQnpjR1ZqYVdGc1UzbHRZbTlzY3p0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nUlc1a1QyWk1hVzVsVW5Wc1pTQmxlSFJsYm1SeklGSjFiR1VnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWdwSUh0Y2JpQWdJQ0JqYjI1emRDQmxibVJQWmt4cGJtVlVaWEp0YVc1aGJGTjViV0p2YkVOdmJuUmxiblFnUFNCRlRrUmZUMFpmVEVsT1JTeGNiaUFnSUNBZ0lDQWdJQ0JsYm1SUFpreHBibVZVWlhKdGFXNWhiRk41YldKdmJFUmxabWx1YVhScGIyNGdQU0J1WlhjZ1ZHVnliV2x1WVd4VGVXMWliMnhFWldacGJtbDBhVzl1S0dWdVpFOW1UR2x1WlZSbGNtMXBibUZzVTNsdFltOXNRMjl1ZEdWdWRDa3NYRzRnSUNBZ0lDQWdJQ0FnYm1GdFpTQTlJRVZ1WkU5bVRHbHVaVkoxYkdWT1lXMWxMRnh1SUNBZ0lDQWdJQ0FnSUdGdFltbG5kVzkxY3lBOUlHWmhiSE5sTEZ4dUlDQWdJQ0FnSUNBZ0lHUmxabWx1YVhScGIyNXpJRDBnVzF4dUlDQWdJQ0FnSUNBZ0lDQWdaVzVrVDJaTWFXNWxWR1Z5YldsdVlXeFRlVzFpYjJ4RVpXWnBibWwwYVc5dVhHNGdJQ0FnSUNBZ0lDQWdYU3hjYmlBZ0lDQWdJQ0FnSUNCT2IyUmxJRDBnUlc1a1QyWk1hVzVsUWs1R1RtOWtaVHRjYmx4dUlDQWdJSE4xY0dWeUtHNWhiV1VzSUdGdFltbG5kVzkxY3l3Z1pHVm1hVzVwZEdsdmJuTXNJRTV2WkdVcFhHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpGVGtSZlQwWmZURWxPUlNJc0luTndaV05wWVd4VGVXMWliMnh6SWl3aVJXNWtUMlpNYVc1bFVuVnNaU0lzSW1WdVpFOW1UR2x1WlZSbGNtMXBibUZzVTNsdFltOXNRMjl1ZEdWdWRDSXNJbVZ1WkU5bVRHbHVaVlJsY20xcGJtRnNVM2x0WW05c1JHVm1hVzVwZEdsdmJpSXNJbFJsY20xcGJtRnNVM2x0WW05c1JHVm1hVzVwZEdsdmJpSXNJbTVoYldVaUxDSkZibVJQWmt4cGJtVlNkV3hsVG1GdFpTSXNJbUZ0WW1sbmRXOTFjeUlzSW1SbFptbHVhWFJwYjI1eklpd2lUbTlrWlNJc0lrVnVaRTltVEdsdVpVSk9SazV2WkdVaUxDSlNkV3hsSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUlN0Q0xFbEJRVUVzV1VGQll5eFhRVUZrTEdOQlFXTXNRMEZCUVR0QlFVVTFRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBjc1NVRkJRU3hWUVVGMVFpeHJRMEZCZGtJc2RVSkJRWFZDTEVWQlFVRTdRVUZEWml4SlFVRkJMR1ZCUVRoQ0xHdERRVUU1UWl3NFFrRkJPRUlzUlVGQlFUdEJRVVZxUXl4SlFVRkJMRlZCUVdNc1YwRkJaQ3hqUVVGakxFTkJRVUU3T3pzN096czdPenM3T3pzN096dExRVkpvUkRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFWVkJMRWxCUVUwc1FVRkJSVUVzVjBGQlZ5eEhRVUZMUXl4WlFVRmpMR2RDUVVFNVFrUXNWMEZCVnl4QlFVRnRRaXhCUVVGRE8wRkJSWGhDTEVsQlFVRXNRVUZCVFVVc1lVRkJZU3hwUWtOYUwwSXNRVVJaV1R0clEwRmFaanM3WVVGWmNVSkJMR0ZCUVdFN05FTkJXbXhETzFGQlkwa3NTVUZCVFVNc09FSkJRVGhDTEVkQlFVZElMRmRCUVZjc1JVRkROVU5KTEdsRFFVRnBReXhIUVVGSExFbEJRVWxETEdWQlFYZENMRk5CUVVOR0xEaENRVUU0UWl4RFFVRkRMRVZCUTJoSFJ5eEpRVUZKTEVkQlFVZERMRlZCUVdsQ0xHdENRVUZCTEVWQlEzaENReXhUUVVGVExFZEJRVWNzUzBGQlN5eEZRVU5xUWtNc1YwRkJWeXhIUVVGSE8xbEJRMXBNTEdsRFFVRnBRenRUUVVOc1F5eEZRVU5FVFN4SlFVRkpMRWRCUVVkRExGVkJRV2RDTEZGQlFVRXNRVUZCUXp0cFEwRkZlRUpNTEVsQlFVa3NSVUZCUlVVc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFXSXdRMFVzUzBGQlNTeFRRV0U1UXp0clFrRmliMEpXTEdGQlFXRXNRVUZhYkVNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfcGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3BhcnRcIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcnVsZU5hbWVcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFF1YW50aWZpZXJSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSdWxlKSB7XG4gICAgX2luaGVyaXRzKFF1YW50aWZpZXJSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFF1YW50aWZpZXJSdWxlKTtcbiAgICBmdW5jdGlvbiBRdWFudGlmaWVyUnVsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1YW50aWZpZXJSdWxlKTtcbiAgICAgICAgdmFyIG5hbWUgPSBfcnVsZU5hbWVzLlF1YW50aWZpZXJSdWxlTmFtZSwgb3B0aW9uYWxRdWFudGlmaWVyUnVsZU5hbWUgPSBfcnVsZU5hbWVzLk9wdGlvbmFsUXVhbnRpZmllclJ1bGVOYW1lLCBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWUgPSBfcnVsZU5hbWVzLk9uZU9yTW9yZVF1YW50aWZpZXJSdWxlTmFtZSwgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZSA9IF9ydWxlTmFtZXMuWmVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZSwgb3B0aW9uYWxRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KG9wdGlvbmFsUXVhbnRpZmllclJ1bGVOYW1lKSwgb25lT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWUpLCB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdCh6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lKSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgb25lT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfcGFydC5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBRdWFudGlmaWVyUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBRdWFudGlmaWVyUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMM0YxWVc1MGFXWnBaWEl1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxYQ0k3WEc1cGJYQnZjblFnVUdGeWRFSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwzQmhjblJjSWp0Y2JtbHRjRzl5ZENCU2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI0Z1puSnZiU0JjSWk0dUwyUmxabWx1YVhScGIyNHZjblZzWlU1aGJXVmNJanRjYmx4dWFXMXdiM0owSUhzZ1VYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbExDQlBjSFJwYjI1aGJGRjFZVzUwYVdacFpYSlNkV3hsVG1GdFpTd2dUMjVsVDNKTmIzSmxVWFZoYm5ScFptbGxjbEoxYkdWT1lXMWxMQ0JhWlhKdlQzSk5iM0psVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsSUgwZ1puSnZiU0JjSWk0dUwzSjFiR1ZPWVcxbGMxd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlJkV0Z1ZEdsbWFXVnlVblZzWlNCbGVIUmxibVJ6SUZKMWJHVWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCdVlXMWxJRDBnVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHOXdkR2x2Ym1Gc1VYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbElEMGdUM0IwYVc5dVlXeFJkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnYjI1bFQzSk5iM0psVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsSUQwZ1QyNWxUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJSHBsY205UGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1VnUFNCYVpYSnZUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbExGeHVJQ0FnSUNBZ0lDQWdJRzl3ZEdsdmJtRnNVWFZoYm5ScFptbGxjbEoxYkdWT1lXMWxSR1ZtYVc1cGRHbHZiaUE5SUc1bGR5QlNkV3hsVG1GdFpVUmxabWx1YVhScGIyNG9iM0IwYVc5dVlXeFJkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVXBMRnh1SUNBZ0lDQWdJQ0FnSUc5dVpVOXlUVzl5WlZGMVlXNTBhV1pwWlhKU2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI0Z1BTQnVaWGNnVW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1S0c5dVpVOXlUVzl5WlZGMVlXNTBhV1pwWlhKU2RXeGxUbUZ0WlNrc1hHNGdJQ0FnSUNBZ0lDQWdlbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRnUFNCdVpYY2dVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVLSHBsY205UGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1VwTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYjNCMGFXOXVZV3hSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiMjVsVDNKTmIzSmxVWFZoYm5ScFptbGxjbEoxYkdWT1lXMWxSR1ZtYVc1cGRHbHZiaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lIcGxjbTlQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVYRzRnSUNBZ0lDQWdJQ0FnWFN4Y2JpQWdJQ0FnSUNBZ0lDQk9iMlJsSUQwZ1VHRnlkRUpPUms1dlpHVTdYRzRnSUNBZ1hHNGdJQ0FnYzNWd1pYSW9ibUZ0WlN3Z1lXMWlhV2QxYjNWekxDQmtaV1pwYm1sMGFXOXVjeXdnVG05a1pTbGNiaUFnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWxGMVlXNTBhV1pwWlhKU2RXeGxJaXdpYm1GdFpTSXNJbEYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU0lzSW05d2RHbHZibUZzVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsSWl3aVQzQjBhVzl1WVd4UmRXRnVkR2xtYVdWeVVuVnNaVTVoYldVaUxDSnZibVZQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVWlMQ0pQYm1WUGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1VpTENKNlpYSnZUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbElpd2lXbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU0lzSW05d2RHbHZibUZzVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsUkdWbWFXNXBkR2x2YmlJc0lsSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpSXNJbTl1WlU5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRpTENKNlpYSnZUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpSXNJbUZ0WW1sbmRXOTFjeUlzSW1SbFptbHVhWFJwYjI1eklpd2lUbTlrWlNJc0lsQmhjblJDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBZc1NVRkJRU3hMUVVGclFpeHJRMEZCYkVJc2EwSkJRV3RDTEVWQlFVRTdRVUZEV0N4SlFVRkJMRk5CUVhkQ0xHdERRVUY0UWl4M1FrRkJkMElzUlVGQlFUdEJRVVZ0UlN4SlFVRkJMRlZCUVdNc1YwRkJaQ3hqUVVGakxFTkJRVUU3T3pzN096czdPenM3T3pzN096dExRVTU0U1RzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFWRmxMRWxCUVVFc1FVRkJUVUVzWTBGQll5eHBRa05TYUVNc1FVUlJXVHR0UTBGU1pqczdZVUZSY1VKQkxHTkJRV003TmtOQlVtNURPMUZCVlVrc1NVRkJUVU1zU1VGQlNTeEhRVUZIUXl4VlFVRnJRaXh0UWtGQlFTeEZRVU42UWtNc01FSkJRVEJDTEVkQlFVZERMRlZCUVRCQ0xESkNRVUZCTEVWQlEzWkVReXd5UWtGQk1rSXNSMEZCUjBNc1ZVRkJNa0lzTkVKQlFVRXNSVUZEZWtSRExEUkNRVUUwUWl4SFFVRkhReXhWUVVFMFFpdzJRa0ZCUVN4RlFVTXpSRU1zYjBOQlFXOURMRWRCUVVjc1NVRkJTVU1zVTBGQmEwSXNVMEZCUTFBc01FSkJRVEJDTEVOQlFVTXNSVUZEZWtaUkxIRkRRVUZ4UXl4SFFVRkhMRWxCUVVsRUxGTkJRV3RDTEZOQlFVTk1MREpDUVVFeVFpeERRVUZETEVWQlF6TkdUeXh6UTBGQmMwTXNSMEZCUnl4SlFVRkpSaXhUUVVGclFpeFRRVUZEU0N3MFFrRkJORUlzUTBGQlF5eEZRVU0zUmswc1UwRkJVeXhIUVVGSExFdEJRVXNzUlVGRGFrSkRMRmRCUVZjc1IwRkJSenRaUVVOYVRDeHZRMEZCYjBNN1dVRkRjRU5GTEhGRFFVRnhRenRaUVVOeVEwTXNjME5CUVhORE8xTkJRM1pETEVWQlEwUkhMRWxCUVVrc1IwRkJSME1zUzBGQlZ5eFJRVUZCTEVGQlFVTTdhVU5CUlc1Q1ppeEpRVUZKTEVWQlFVVlpMRk5CUVZNc1JVRkJSVU1zVjBGQlZ5eEZRVUZGUXl4SlFVRkpPenM3UTBGRk0wTXNRMEZ1UWpKRFJTeExRVUZKTEZOQmJVSXZRenRyUWtGdVFtOUNha0lzWTBGQll5eEJRVkp1UXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2RlZmluaXRpb25cIikpO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgRGVmaW5pdGlvbkJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhEZWZpbml0aW9uQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERlZmluaXRpb25CTkZOb2RlKTtcbiAgICBmdW5jdGlvbiBEZWZpbml0aW9uQk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmluaXRpb25CTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoRGVmaW5pdGlvbkJORk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdlbmVyYXRlRGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLCBwYXJ0Tm9kZXMgPSBjaGlsZE5vZGVzLCBsb29rQWhlYWQgPSBmYWxzZSwgcGFydHMgPSBwYXJ0Tm9kZXMubWFwKGZ1bmN0aW9uKHBhcnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydE5vZGUuZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgIH0pLCBkZWZpbml0aW9uID0gbmV3IF9kZWZpbml0aW9uLmRlZmF1bHQocGFydHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhEZWZpbml0aW9uQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIERlZmluaXRpb25CTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZpbml0aW9uQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOWtaV1pwYm1sMGFXOXVMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZMaTR2WkdWbWFXNXBkR2x2Ymx3aU8xeHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNUbTlrWlNCbWNtOXRJRndpTGk0dkxpNHZibTlrWlM5dWIyNVVaWEp0YVc1aGJGd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QkVaV1pwYm1sMGFXOXVRazVHVG05a1pTQmxlSFJsYm1SeklFNXZibFJsY20xcGJtRnNUbTlrWlNCN1hHNGdJR2RsYm1WeVlYUmxSR1ZtYVc1cGRHbHZiaWdwSUh0Y2JpQWdJQ0JqYjI1emRDQmphR2xzWkU1dlpHVnpJRDBnZEdocGN5NW5aWFJEYUdsc1pFNXZaR1Z6S0Nrc1hHNGdJQ0FnSUNBZ0lDQWdjR0Z5ZEU1dlpHVnpJRDBnWTJocGJHUk9iMlJsY3l3Z0x5OHZYRzRnSUNBZ0lDQWdJQ0FnYkc5dmEwRm9aV0ZrSUQwZ1ptRnNjMlVzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0J3WVhKMGN5QTlJSEJoY25ST2IyUmxjeTV0WVhBb0tIQmhjblJPYjJSbEtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCd1lYSjBJRDBnY0dGeWRFNXZaR1V1WjJWdVpYSmhkR1ZRWVhKMEtHeHZiMnRCYUdWaFpDazdYRzRnSUZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIQmhjblE3WEc0Z0lDQWdJQ0FnSUNBZ2ZTa3NYRzRnSUNBZ0lDQWdJQ0FnWkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJFWldacGJtbDBhVzl1S0hCaGNuUnpLVHRjYmx4dUlDQWdJSEpsZEhWeWJpQmtaV1pwYm1sMGFXOXVPMXh1SUNCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9jblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wSUhzZ2NtVjBkWEp1SUU1dmJsUmxjbTFwYm1Gc1RtOWtaUzVtY205dFVuVnNaVTVoYldWQmJtUkRhR2xzWkU1dlpHVnpLRVJsWm1sdWFYUnBiMjVDVGtaT2IyUmxMQ0J5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrN0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SkVaV1pwYm1sMGFXOXVRazVHVG05a1pTSXNJbWRsYm1WeVlYUmxSR1ZtYVc1cGRHbHZiaUlzSW1Ob2FXeGtUbTlrWlhNaUxDSm5aWFJEYUdsc1pFNXZaR1Z6SWl3aWNHRnlkRTV2WkdWeklpd2liRzl2YTBGb1pXRmtJaXdpY0dGeWRITWlMQ0p0WVhBaUxDSndZWEowVG05a1pTSXNJbkJoY25RaUxDSm5aVzVsY21GMFpWQmhjblFpTENKa1pXWnBibWwwYVc5dUlpd2lSR1ZtYVc1cGRHbHZiaUlzSW1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1pTENKeWRXeGxUbUZ0WlNJc0lrNXZibFJsY20xcGJtRnNUbTlrWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWMVFpeEpRVUZCTEZkQlFXdENMR3REUVVGc1FpeHJRa0ZCYTBJc1JVRkJRVHRCUVVOaUxFbEJRVUVzV1VGQmQwSXNhME5CUVhoQ0xIZENRVUYzUWl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJTSEJFTzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVV0bExFbEJRVUVzUVVGQlRVRXNhVUpCUVdsQ0xHbENRMHh1UXl4QlJFdFpPMmxFUVV4bU96dGhRVXR4UWtFc2FVSkJRV2xDTzJkRVFVeDBRenM3T3pzN1dVRk5SVU1zUjBGQmEwSXNSVUZCYkVKQkxHOUNRVUZyUWp0WlJVNXdRaXhQUmsxRlFTeFRRVUZCUVN4clFrRkJhMElzUjBGQlJ6dG5Ra0ZEYmtJc1NVRkJUVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEUXl4VFFVRlRMRWRCUVVkR0xGVkJRVlVzUlVGRGRFSkhMRk5CUVZNc1IwRkJSeXhMUVVGTExFVkJRMnBDUXl4TFFVRkxMRWRCUVVkR0xGTkJRVk1zUTBGQlEwY3NSMEZCUnl4RFFVRkRMRk5CUVVORExGRkJRVkVzUlVGQlN6dHZRa0ZEYkVNc1NVRkJUVU1zU1VGQlNTeEhRVUZIUkN4UlFVRlJMRU5CUVVORkxGbEJRVmtzUTBGQlEwd3NVMEZCVXl4RFFVRkRMRUZCUVVNN2IwSkJSVGxETEU5QlFVOUpMRWxCUVVrc1EwRkJRenRwUWtGRFlpeERRVUZETEVWQlEwWkZMRlZCUVZVc1IwRkJSeXhKUVVGSlF5eFhRVUZWTEZOQlFVTk9MRXRCUVVzc1EwRkJReXhCUVVGRE8yZENRVVY2UXl4UFFVRlBTeXhWUVVGVkxFTkJRVU03WVVGRGJrSTdPenM3V1VGRlRVVXNSMEZCZVVJc1JVRkJla0pCTERKQ1FVRjVRanRaUlhCQ2JFTXNUMFp2UWtVc1UwRkJUMEVzZVVKQlFYbENMRU5CUVVORExGRkJRVkVzUlVGQlJWb3NWVUZCVlN4RlFVRkZPMmRDUVVGRkxFOUJRVTloTEZsQlFXVXNVMEZCUTBZc2VVSkJRWGxDTEVOQlFVTmlMR2xDUVVGcFFpeEZRVUZGWXl4UlFVRlJMRVZCUVVWYUxGVkJRVlVzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCY0VKMlNqczdRMEZ4UWtNc1EwRm9RamhEWVN4WlFVRmxMRk5CWjBJM1JEdHJRa0ZvUW05Q1ppeHBRa0ZCYVVJc1FVRk1kRU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb25cIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIikpO1xudmFyIF9vbmVPck1vcmVQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIERlZmluaXRpb25EZWZpbml0aW9uID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihEZWZpbml0aW9uKSB7XG4gICAgX2luaGVyaXRzKERlZmluaXRpb25EZWZpbml0aW9uLCBEZWZpbml0aW9uKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERlZmluaXRpb25EZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBEZWZpbml0aW9uRGVmaW5pdGlvbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmluaXRpb25EZWZpbml0aW9uKTtcbiAgICAgICAgdmFyIHBhcnRSdWxlTmFtZSA9IF9ydWxlTmFtZXMuUGFydFJ1bGVOYW1lLCBwYXJ0UnVsZU5hbWVQYXJ0ID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KHBhcnRSdWxlTmFtZSksIG9uZU9yTW9yZVJ1bGVOYW1lUGFydHNQYXJ0ID0gbmV3IF9vbmVPck1vcmVQYXJ0cy5kZWZhdWx0KHBhcnRSdWxlTmFtZVBhcnQpLCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9uZU9yTW9yZVJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBEZWZpbml0aW9uRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZpbml0aW9uRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwyUmxabWx1YVhScGIyNHVhbk1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2JtbHRjRzl5ZENCRVpXWnBibWwwYVc5dUlHWnliMjBnWENJdUxpOWtaV1pwYm1sMGFXOXVYQ0k3WEc1cGJYQnZjblFnVW5Wc1pVNWhiV1ZRWVhKMElHWnliMjBnWENJdUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wzSjFiR1ZPWVcxbFhDSTdYRzVwYlhCdmNuUWdUMjVsVDNKTmIzSmxVR0Z5ZEhOUVlYSjBJR1p5YjIwZ1hDSXVMaTl3WVhKMEwyNXZibFJsY20xcGJtRnNMMjl1WlU5eVRXOXlaVkJoY25SelhDSTdYRzVjYm1sdGNHOXlkQ0I3SUZCaGNuUlNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTl5ZFd4bFRtRnRaWE5jSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nUkdWbWFXNXBkR2x2YmtSbFptbHVhWFJwYjI0Z1pYaDBaVzVrY3lCRVpXWnBibWwwYVc5dUlIdGNiaUFnWTI5dWMzUnlkV04wYjNJb0tTQjdYRzRnSUNBZ1kyOXVjM1FnY0dGeWRGSjFiR1ZPWVcxbElEMGdVR0Z5ZEZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJTZFd4bFRtRnRaVkJoY25RZ1BTQnVaWGNnVW5Wc1pVNWhiV1ZRWVhKMEtIQmhjblJTZFd4bFRtRnRaU2tzWEc0Z0lDQWdJQ0FnSUNBZ2IyNWxUM0pOYjNKbFVuVnNaVTVoYldWUVlYSjBjMUJoY25RZ1BTQnVaWGNnVDI1bFQzSk5iM0psVUdGeWRITlFZWEowS0hCaGNuUlNkV3hsVG1GdFpWQmhjblFwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYjI1bFQzSk5iM0psVW5Wc1pVNWhiV1ZRWVhKMGMxQmhjblJjYmlBZ0lDQWdJQ0FnSUNCZE8xeHVYRzRnSUNBZ2MzVndaWElvY0dGeWRITXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKRVpXWnBibWwwYVc5dVJHVm1hVzVwZEdsdmJpSXNJbkJoY25SU2RXeGxUbUZ0WlNJc0lsQmhjblJTZFd4bFRtRnRaU0lzSW5CaGNuUlNkV3hsVG1GdFpWQmhjblFpTENKU2RXeGxUbUZ0WlZCaGNuUWlMQ0p2Ym1WUGNrMXZjbVZTZFd4bFRtRnRaVkJoY25SelVHRnlkQ0lzSWs5dVpVOXlUVzl5WlZCaGNuUnpVR0Z5ZENJc0luQmhjblJ6SWl3aVJHVm1hVzVwZEdsdmJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVjFRaXhKUVVGQkxGZEJRV1VzYTBOQlFXWXNaVUZCWlN4RlFVRkJPMEZCUTJJc1NVRkJRU3hUUVVFNFFpeHJRMEZCT1VJc09FSkJRVGhDTEVWQlFVRTdRVUZEZUVJc1NVRkJRU3hsUVVGdlF5eHJRMEZCY0VNc2IwTkJRVzlETEVWQlFVRTdRVUZGZEVNc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCT3pzN096czdPenM3T3pzN096czdTMEZPTTBNN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlJaU3hKUVVGQkxFRkJRVTFCTEc5Q1FVRnZRaXhwUWtOU2RFTXNRVVJSV1RzclEwRlNaanM3WVVGUmNVSkJMRzlDUVVGdlFqdHRSRUZTZWtNN1VVRlZTU3hKUVVGTlF5eFpRVUZaTEVkQlFVZERMRlZCUVZrc1lVRkJRU3hGUVVNelFrTXNaMEpCUVdkQ0xFZEJRVWNzU1VGQlNVTXNVMEZCV1N4VFFVRkRTQ3haUVVGWkxFTkJRVU1zUlVGRGFrUkpMREJDUVVFd1FpeEhRVUZITEVsQlFVbERMR1ZCUVd0Q0xGTkJRVU5JTEdkQ1FVRm5RaXhEUVVGRExFVkJRM0pGU1N4TFFVRkxMRWRCUVVjN1dVRkRUa1lzTUVKQlFUQkNPMU5CUXpOQ0xFRkJRVU03YVVOQlJVWkZMRXRCUVVzN096dERRVVZrTEVOQldHbEVReXhYUVVGVkxGTkJWek5FTzJ0Q1FWaHZRbElzYjBKQlFXOUNMRUZCVW5wREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL2RlZmluaXRpb25cIikpO1xudmFyIF9kZWZpbml0aW9uMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vZGVmaW5pdGlvblwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgRGVmaW5pdGlvblJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoRGVmaW5pdGlvblJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVmaW5pdGlvblJ1bGUpO1xuICAgIGZ1bmN0aW9uIERlZmluaXRpb25SdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmaW5pdGlvblJ1bGUpO1xuICAgICAgICB2YXIgbmFtZSA9IF9ydWxlTmFtZXMuRGVmaW5pdGlvblJ1bGVOYW1lLCBkZWZpbml0aW9uRGVmaW5pdGlvbiA9IG5ldyBfZGVmaW5pdGlvbjEuZGVmYXVsdCgpLCBhbWJpZ3VvdXMgPSBmYWxzZSwgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBkZWZpbml0aW9uRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX2RlZmluaXRpb24uZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gRGVmaW5pdGlvblJ1bGU7XG59KF9ydWxlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmaW5pdGlvblJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDJSbFptbHVhWFJwYjI0dWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JTZFd4bElHWnliMjBnWENJdUxpOXlkV3hsWENJN1hHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJrSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwyUmxabWx1YVhScGIyNWNJanRjYm1sdGNHOXlkQ0JFWldacGJtbDBhVzl1UkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dlpHVm1hVzVwZEdsdmJpOWtaV1pwYm1sMGFXOXVYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lFUmxabWx1YVhScGIyNVNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTl5ZFd4bFRtRnRaWE5jSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nUkdWbWFXNXBkR2x2YmxKMWJHVWdaWGgwWlc1a2N5QlNkV3hsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdibUZ0WlNBOUlFUmxabWx1YVhScGIyNVNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1UkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJFWldacGJtbDBhVzl1UkdWbWFXNXBkR2x2YmlncExGeHVJQ0FnSUNBZ0lDQWdJR0Z0WW1sbmRXOTFjeUE5SUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0FnSUdSbFptbHVhWFJwYjI1eklEMGdXMXh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVm1hVzVwZEdsdmJrUmxabWx1YVhScGIyNWNiaUFnSUNBZ0lDQWdJQ0JkTEZ4dUlDQWdJQ0FnSUNBZ0lFNXZaR1VnUFNCRVpXWnBibWwwYVc5dVFrNUdUbTlrWlR0Y2JpQWdJQ0JjYmlBZ0lDQnpkWEJsY2lodVlXMWxMQ0JoYldKcFozVnZkWE1zSUdSbFptbHVhWFJwYjI1ekxDQk9iMlJsS1Z4dUlDQjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lSR1ZtYVc1cGRHbHZibEoxYkdVaUxDSnVZVzFsSWl3aVJHVm1hVzVwZEdsdmJsSjFiR1ZPWVcxbElpd2laR1ZtYVc1cGRHbHZia1JsWm1sdWFYUnBiMjRpTENKRVpXWnBibWwwYVc5dVJHVm1hVzVwZEdsdmJpSXNJbUZ0WW1sbmRXOTFjeUlzSW1SbFptbHVhWFJwYjI1eklpd2lUbTlrWlNJc0lrUmxabWx1YVhScGIyNUNUa1pPYjJSbElpd2lVblZzWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWcFFpeEpRVUZCTEV0QlFWTXNhME5CUVZRc1UwRkJVeXhGUVVGQk8wRkJRMGtzU1VGQlFTeFhRVUYzUWl4clEwRkJlRUlzZDBKQlFYZENMRVZCUVVFN1FVRkRja0lzU1VGQlFTeFpRVUV3UWl4clEwRkJNVUlzTUVKQlFUQkNMRVZCUVVFN1FVRkZlRUlzU1VGQlFTeFZRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRk9ha1E3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUlpTeEpRVUZCTEVGQlFVMUJMR05CUVdNc2FVSkRVbWhETEVGRVVWazdiVU5CVW1ZN08yRkJVWEZDUVN4alFVRmpPelpEUVZKdVF6dFJRVlZKTEVsQlFVMURMRWxCUVVrc1IwRkJSME1zVlVGQmEwSXNiVUpCUVVFc1JVRkRla0pETEc5Q1FVRnZRaXhIUVVGSExFbEJRVWxETEZsQlFXOUNMRlZCUVVVc1JVRkRha1JETEZOQlFWTXNSMEZCUnl4TFFVRkxMRVZCUTJwQ1F5eFhRVUZYTEVkQlFVYzdXVUZEV2tnc2IwSkJRVzlDTzFOQlEzSkNMRVZCUTBSSkxFbEJRVWtzUjBGQlIwTXNWMEZCYVVJc1VVRkJRU3hCUVVGRE8ybERRVVY2UWxBc1NVRkJTU3hGUVVGRlNTeFRRVUZUTEVWQlFVVkRMRmRCUVZjc1JVRkJSVU1zU1VGQlNUczdPME5CUlRORExFTkJXakpEUlN4TFFVRkpMRk5CV1M5RE8ydENRVnB2UWxRc1kwRkJZeXhCUVZKdVF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxpdGllcy9hcnJheVwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIERlZmluaXRpb25zQk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKERlZmluaXRpb25zQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERlZmluaXRpb25zQk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gRGVmaW5pdGlvbnNCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmaW5pdGlvbnNCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoRGVmaW5pdGlvbnNCTkZOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZW5lcmF0ZURlZmluaXRpb25zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbml0aW9ucygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLCBldmVuQ2hpbGROb2RlcyA9ICgwLCBfYXJyYXkpLmV2ZW4oY2hpbGROb2RlcyksIGRlZmluaXRpb25CTkZOb2RlcyA9IGV2ZW5DaGlsZE5vZGVzLCBkZWZpbml0aW9ucyA9IGRlZmluaXRpb25CTkZOb2Rlcy5tYXAoZnVuY3Rpb24oZGVmaW5pdGlvbkJORk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBkZWZpbml0aW9uQk5GTm9kZS5nZW5lcmF0ZURlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhEZWZpbml0aW9uc0JORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBEZWZpbml0aW9uc0JORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmluaXRpb25zQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOWtaV1pwYm1sMGFXOXVjeTVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNUbTlrWlNCbWNtOXRJRndpTGk0dkxpNHZibTlrWlM5dWIyNVVaWEp0YVc1aGJGd2lPMXh1WEc1cGJYQnZjblFnZXlCbGRtVnVJSDBnWm5KdmJTQmNJaTR1THk0dUwzVjBhV3hwZEdsbGN5OWhjbkpoZVZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCRVpXWnBibWwwYVc5dWMwSk9SazV2WkdVZ1pYaDBaVzVrY3lCT2IyNVVaWEp0YVc1aGJFNXZaR1VnZTF4dUlDQm5aVzVsY21GMFpVUmxabWx1YVhScGIyNXpLQ2tnZTF4dUlDQWdJR052Ym5OMElHTm9hV3hrVG05a1pYTWdQU0IwYUdsekxtZGxkRU5vYVd4a1RtOWtaWE1vS1N4Y2JpQWdJQ0FnSUNBZ0lDQmxkbVZ1UTJocGJHUk9iMlJsY3lBOUlHVjJaVzRvWTJocGJHUk9iMlJsY3lrc0lDQXZMeTljYmlBZ0lDQWdJQ0FnSUNCa1pXWnBibWwwYVc5dVFrNUdUbTlrWlhNZ1BTQmxkbVZ1UTJocGJHUk9iMlJsY3l3Z0x5OHZYRzRnSUNBZ0lDQWdJQ0FnWkdWbWFXNXBkR2x2Ym5NZ1BTQmtaV1pwYm1sMGFXOXVRazVHVG05a1pYTXViV0Z3S0Noa1pXWnBibWwwYVc5dVFrNUdUbTlrWlNrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWkdWbWFXNXBkR2x2YmlBOUlHUmxabWx1YVhScGIyNUNUa1pPYjJSbExtZGxibVZ5WVhSbFJHVm1hVzVwZEdsdmJpZ3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdaR1ZtYVc1cGRHbHZianRjYmlBZ0lDQWdJQ0FnSUNCOUtUdGNiaUFnSUNCY2JpQWdJQ0J5WlhSMWNtNGdaR1ZtYVc1cGRHbHZibk03WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeWh5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrZ2V5QnlaWFIxY200Z1RtOXVWR1Z5YldsdVlXeE9iMlJsTG1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1vUkdWbWFXNXBkR2x2Ym5OQ1RrWk9iMlJsTENCeWRXeGxUbUZ0WlN3Z1kyaHBiR1JPYjJSbGN5azdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpFWldacGJtbDBhVzl1YzBKT1JrNXZaR1VpTENKblpXNWxjbUYwWlVSbFptbHVhWFJwYjI1eklpd2lZMmhwYkdST2IyUmxjeUlzSW1kbGRFTm9hV3hrVG05a1pYTWlMQ0psZG1WdVEyaHBiR1JPYjJSbGN5SXNJbVYyWlc0aUxDSmtaV1pwYm1sMGFXOXVRazVHVG05a1pYTWlMQ0prWldacGJtbDBhVzl1Y3lJc0ltMWhjQ0lzSW1SbFptbHVhWFJwYjI1Q1RrWk9iMlJsSWl3aVpHVm1hVzVwZEdsdmJpSXNJbWRsYm1WeVlYUmxSR1ZtYVc1cGRHbHZiaUlzSW1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1pTENKeWRXeGxUbUZ0WlNJc0lrNXZibFJsY20xcGJtRnNUbTlrWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVMFFpeEpRVUZCTEZsQlFYZENMR3REUVVGNFFpeDNRa0ZCZDBJc1JVRkJRVHRCUVVVdlFpeEpRVUZCTEUxQlFYVkNMRmRCUVhaQ0xIVkNRVUYxUWl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJTalZETzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVUxbExFbEJRVUVzUVVGQlRVRXNhMEpCUVd0Q0xHbENRMDV3UXl4QlJFMVpPMnRFUVU1bU96dGhRVTF4UWtFc2EwSkJRV3RDTzJsRVFVNTJRenM3T3pzN1dVRlBSVU1zUjBGQmJVSXNSVUZCYmtKQkxIRkNRVUZ0UWp0WlJWQnlRaXhQUms5RlFTeFRRVUZCUVN4dFFrRkJiVUlzUjBGQlJ6dG5Ra0ZEY0VJc1NVRkJUVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEUXl4alFVRmpMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTFCUVVrc1FVRkJXU3hEUVVGQkxFMUJRVmhJTEZWQlFWVXNRMEZCUXl4RlFVTnFRMGtzYTBKQlFXdENMRWRCUVVkR0xHTkJRV01zUlVGRGJrTkhMRmRCUVZjc1IwRkJSMFFzYTBKQlFXdENMRU5CUVVORkxFZEJRVWNzUTBGQlF5eFRRVUZEUXl4cFFrRkJhVUlzUlVGQlN6dHZRa0ZETVVRc1NVRkJUVU1zVlVGQlZTeEhRVUZIUkN4cFFrRkJhVUlzUTBGQlEwVXNhMEpCUVd0Q0xFVkJRVVVzUVVGQlF6dHZRa0ZGTVVRc1QwRkJUMFFzVlVGQlZTeERRVUZETzJsQ1FVTnVRaXhEUVVGRExFRkJRVU03WjBKQlJWUXNUMEZCVDBnc1YwRkJWeXhEUVVGRE8yRkJRM0JDT3pzN08xbEJSVTFMTEVkQlFYbENMRVZCUVhwQ1FTd3lRa0ZCZVVJN1dVVndRbXhETEU5R2IwSkZMRk5CUVU5QkxIbENRVUY1UWl4RFFVRkRReXhSUVVGUkxFVkJRVVZZTEZWQlFWVXNSVUZCUlR0blFrRkJSU3hQUVVGUFdTeFpRVUZsTEZOQlFVTkdMSGxDUVVGNVFpeERRVUZEV2l4clFrRkJhMElzUlVGQlJXRXNVVUZCVVN4RlFVRkZXQ3hWUVVGVkxFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFYQkNlRW83TzBOQmNVSkRMRU5CWml0RFdTeFpRVUZsTEZOQlpUbEVPMnRDUVdadlFtUXNhMEpCUVd0Q0xFRkJUblpESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCIpKTtcbnZhciBfYXJyYXkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbGl0aWVzL2FycmF5XCIpO1xudmFyIF9sb29rQWhlYWQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbGl0aWVzL2xvb2tBaGVhZFwiKTtcbnZhciBfcGFydFR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3BhcnRUeXBlc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsUGFydCkge1xuICAgIF9pbmhlcml0cyhTZXF1ZW5jZU9mUGFydHNQYXJ0LCBOb25UZXJtaW5hbFBhcnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2VxdWVuY2VPZlBhcnRzUGFydCk7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2VPZlBhcnRzUGFydChwYXJ0cykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VxdWVuY2VPZlBhcnRzUGFydCk7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgdmFyIHR5cGUgPSBfcGFydFR5cGVzLlNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlOyAvLy9cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgX3RoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoU2VxdWVuY2VPZlBhcnRzUGFydCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0UGFydHNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJ0cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksIHBhcnRzTm9kZXMgPSBbXSwgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9ICgwLCBfbG9va0FoZWFkKS5wYXJzZVBhcnRzKHRoaXMucGFydHMsIHBhcnRzTm9kZXMsIGluZGV4LCBzdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9hcnJheSkucHVzaChub2RlcywgcGFydHNOb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzU3RyaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNTdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzU3RyaW5nMSA9IHRoaXMucGFydHMucmVkdWNlKGZ1bmN0aW9uKHBhcnRzU3RyaW5nLCBwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0U3RyaW5nID0gcGFydC5hc1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gcGFydFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gXCJcIi5jb25jYXQocGFydHNTdHJpbmcsIFwiIFwiKS5jb25jYXQocGFydFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzU3RyaW5nO1xuICAgICAgICAgICAgICAgIH0sIG51bGwpLCBzdHJpbmcgPSBcIiggXCIuY29uY2F0KHBhcnRzU3RyaW5nMSwgXCIgKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoU2VxdWVuY2VPZlBhcnRzUGFydC5wcm90b3R5cGUpLCBcImNsb25lXCIsIHRoaXMpLmNhbGwodGhpcywgU2VxdWVuY2VPZlBhcnRzUGFydCwgdGhpcy5wYXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTm9kZXMobm9kZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsQnV0Rmlyc3RBbmRMYXN0Tm9kZXMgPSAoMCwgX2FycmF5KS5hbGxCdXRGaXJzdEFuZExhc3Qobm9kZXMpO1xuICAgICAgICAgICAgICAgIG5vZGVzID0gYWxsQnV0Rmlyc3RBbmRMYXN0Tm9kZXM7IC8vL1xuICAgICAgICAgICAgICAgIHZhciBsb29rQWhlYWQgPSBmYWxzZSwgcGFydHMgPSBub2Rlcy5tYXAoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgIH0pLCBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c1BhcnQocGFydHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXF1ZW5jZU9mUGFydHNQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFNlcXVlbmNlT2ZQYXJ0c1BhcnQ7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl3WVhKMEwyNXZibFJsY20xcGJtRnNMM05sY1hWbGJtTmxUMlpRWVhKMGN5NXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUU1dmJsUmxjbTFwYm1Gc1VHRnlkQ0JtY205dElGd2lMaTR2TGk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkZ3aU8xeHVYRzVwYlhCdmNuUWdleUJ3ZFhOb0lIMGdabkp2YlNCY0lpNHVMeTR1TDNWMGFXeHBkR2xsY3k5aGNuSmhlVndpTzF4dWFXMXdiM0owSUhzZ2NHRnljMlZRWVhKMGN5QjlJR1p5YjIwZ1hDSXVMaTh1TGk5MWRHbHNhWFJwWlhNdmJHOXZhMEZvWldGa1hDSTdYRzVwYlhCdmNuUWdleUJoYkd4Q2RYUkdhWEp6ZEVGdVpFeGhjM1FnZlNCbWNtOXRJRndpTGk0dkxpNHZkWFJwYkdsMGFXVnpMMkZ5Y21GNVhDSTdYRzVwYlhCdmNuUWdleUJUWlhGMVpXNWpaVTltVUdGeWRITlFZWEowVkhsd1pTQjlJR1p5YjIwZ1hDSXVMaTh1TGk5d1lYSjBWSGx3WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1UyVnhkV1Z1WTJWUFpsQmhjblJ6VUdGeWRDQmxlSFJsYm1SeklFNXZibFJsY20xcGJtRnNVR0Z5ZENCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0hCaGNuUnpLU0I3WEc0Z0lDQWdZMjl1YzNRZ2RIbHdaU0E5SUZObGNYVmxibU5sVDJaUVlYSjBjMUJoY25SVWVYQmxPeUF2THk5Y2JseHVJQ0FnSUhOMWNHVnlLSFI1Y0dVcE8xeHVYRzRnSUNBZ2RHaHBjeTV3WVhKMGN5QTlJSEJoY25Sek8xeHVJQ0I5WEc1Y2JpQWdaMlYwVUdGeWRITW9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11Y0dGeWRITTdYRzRnSUgxY2JseHVJQ0J3WVhKelpTaHViMlJsY3l3Z2MzUmhkR1VzSUdOaGJHeGlZV05yS1NCN1hHNGdJQ0FnYkdWMElIQmhjbk5sWkR0Y2JseHVJQ0FnSUdOdmJuTjBJSE5oZG1Wa1NXNWtaWGdnUFNCemRHRjBaUzVuWlhSVFlYWmxaRWx1WkdWNEtDa3NYRzRnSUNBZ0lDQWdJQ0FnY0dGeWRITk9iMlJsY3lBOUlGdGRMRnh1SUNBZ0lDQWdJQ0FnSUdsdVpHVjRJRDBnTUR0Y2JseHVJQ0FnSUhCaGNuTmxaQ0E5SUhCaGNuTmxVR0Z5ZEhNb2RHaHBjeTV3WVhKMGN5d2djR0Z5ZEhOT2IyUmxjeXdnYVc1a1pYZ3NJSE4wWVhSbExDQmpZV3hzWW1GamF5azdYRzVjYmlBZ0lDQnBaaUFvY0dGeWMyVmtLU0I3WEc0Z0lDQWdJQ0J3ZFhOb0tHNXZaR1Z6TENCd1lYSjBjMDV2WkdWektUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9JWEJoY25ObFpDa2dlMXh1SUNBZ0lDQWdjM1JoZEdVdVltRmphM1J5WVdOcktITmhkbVZrU1c1a1pYZ3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCd1lYSnpaV1E3WEc0Z0lIMWNibHh1SUNCaGMxTjBjbWx1WnlncElIdGNiaUFnSUNCamIyNXpkQ0J3WVhKMGMxTjBjbWx1WnlBOUlIUm9hWE11Y0dGeWRITXVjbVZrZFdObEtDaHdZWEowYzFOMGNtbHVaeXdnY0dGeWRDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NHRnlkRk4wY21sdVp5QTlJSEJoY25RdVlYTlRkSEpwYm1jb0tUdGNibHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSEJoY25SelUzUnlhVzVuSUQwOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaGNuUnpVM1J5YVc1bklEMGdjR0Z5ZEZOMGNtbHVaenRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaGNuUnpVM1J5YVc1bklEMGdZQ1I3Y0dGeWRITlRkSEpwYm1kOUlDUjdjR0Z5ZEZOMGNtbHVaMzFnTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2NHRnlkSE5UZEhKcGJtYzdYRzRnSUNBZ0lDQWdJQ0FnZlN3Z2JuVnNiQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2MzUnlhVzVuSUQwZ1lDZ2dKSHR3WVhKMGMxTjBjbWx1WjMwZ0tXQTdYRzVjYmlBZ0lDQnlaWFIxY200Z2MzUnlhVzVuTzF4dUlDQjlYRzVjYmlBZ1kyeHZibVVvS1NCN0lISmxkSFZ5YmlCemRYQmxjaTVqYkc5dVpTaFRaWEYxWlc1alpVOW1VR0Z5ZEhOUVlYSjBMQ0IwYUdsekxuQmhjblJ6S1RzZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFRtOWtaWE1vYm05a1pYTXBJSHRjYmlBZ0lDQmpiMjV6ZENCaGJHeENkWFJHYVhKemRFRnVaRXhoYzNST2IyUmxjeUE5SUdGc2JFSjFkRVpwY25OMFFXNWtUR0Z6ZENodWIyUmxjeWs3WEc1Y2JpQWdJQ0J1YjJSbGN5QTlJR0ZzYkVKMWRFWnBjbk4wUVc1a1RHRnpkRTV2WkdWek95QWdMeTh2WEc1Y2JpQWdJQ0JqYjI1emRDQnNiMjlyUVdobFlXUWdQU0JtWVd4elpTeGNiaUFnSUNBZ0lDQWdJQ0J3WVhKMGN5QTlJRzV2WkdWekxtMWhjQ2dvYm05a1pTa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NHRnlkQ0E5SUc1dlpHVXVaMlZ1WlhKaGRHVlFZWEowS0d4dmIydEJhR1ZoWkNrN1hHNWNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJ3WVhKME8xeHVJQ0FnSUNBZ0lDQWdJSDBwTEZ4dUlDQWdJQ0FnSUNBZ0lITmxjWFZsYm1ObFQyWlFZWEowYzFCaGNuUWdQU0J1WlhjZ1UyVnhkV1Z1WTJWUFpsQmhjblJ6VUdGeWRDaHdZWEowY3lrN1hHNWNiaUFnSUNCeVpYUjFjbTRnYzJWeGRXVnVZMlZQWmxCaGNuUnpVR0Z5ZER0Y2JpQWdmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJbE5sY1hWbGJtTmxUMlpRWVhKMGMxQmhjblFpTENKd1lYSjBjeUlzSW5SNWNHVWlMQ0pUWlhGMVpXNWpaVTltVUdGeWRITlFZWEowVkhsd1pTSXNJbWRsZEZCaGNuUnpJaXdpY0dGeWMyVWlMQ0p1YjJSbGN5SXNJbk4wWVhSbElpd2lZMkZzYkdKaFkyc2lMQ0p3WVhKelpXUWlMQ0p6WVhabFpFbHVaR1Y0SWl3aVoyVjBVMkYyWldSSmJtUmxlQ0lzSW5CaGNuUnpUbTlrWlhNaUxDSnBibVJsZUNJc0luQmhjbk5sVUdGeWRITWlMQ0p3ZFhOb0lpd2lZbUZqYTNSeVlXTnJJaXdpWVhOVGRISnBibWNpTENKd1lYSjBjMU4wY21sdVp5SXNJbkpsWkhWalpTSXNJbkJoY25RaUxDSndZWEowVTNSeWFXNW5JaXdpYzNSeWFXNW5JaXdpWTJ4dmJtVWlMQ0ptY205dFRtOWtaWE1pTENKaGJHeENkWFJHYVhKemRFRnVaRXhoYzNST2IyUmxjeUlzSW1Gc2JFSjFkRVpwY25OMFFXNWtUR0Z6ZENJc0lteHZiMnRCYUdWaFpDSXNJbTFoY0NJc0ltNXZaR1VpTENKblpXNWxjbUYwWlZCaGNuUWlMQ0p6WlhGMVpXNWpaVTltVUdGeWRITlFZWEowSWl3aVRtOXVWR1Z5YldsdVlXeFFZWEowSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUlRSQ0xFbEJRVUVzV1VGQmQwSXNhME5CUVhoQ0xIZENRVUYzUWl4RlFVRkJPMEZCUlM5Q0xFbEJRVUVzVFVGQmRVSXNWMEZCZGtJc2RVSkJRWFZDTEVOQlFVRTdRVUZEYWtJc1NVRkJRU3hWUVVFeVFpeFhRVUV6UWl3eVFrRkJNa0lzUTBGQlFUdEJRVVZrTEVsQlFVRXNWVUZCYVVJc1YwRkJha0lzYVVKQlFXbENMRU5CUVVFN096czdPenM3T3pzN096czdPenM0UkVGUWVrUTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPekJDUVVGQk96czdPenM3T3pzN08xTkJRVUU3T3pzN096czdTMEZCUVRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TzNkRFFVRkJPenM3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVk5sTEVsQlFVRXNRVUZCVFVFc2JVSkJRVzFDTEdsQ1ExUnlReXhCUkZOWk8yMUVRVlJtT3p0aFFWTnhRa0VzYlVKQlFXMUNMRU5CUXpGQ1F5eExRVUZMTzJ0RVFWWnVRanM3VVVGWFNTeEpRVUZOUXl4SlFVRkpMRWRCUVVkRExGVkJRWFZDTEhkQ1FVRkJMRUZCUVVNc1JVRkJReXhIUVVGSE8ydERRVVZ1UTBRc1NVRkJTU3hEUldKa0xFTkdZV2RDTzFGQlJWb3NUVUZCUzBRc1MwRkJTeXhIUVVGSFFTeExRVUZMTEVOQlFVTTdPenM3TzFsQlIzSkNSeXhIUVVGUkxFVkJRVkpCTEZWQlFWRTdXVVZzUWxZc1QwWnJRa1ZCTEZOQlFVRkJMRkZCUVZFc1IwRkJSenRuUWtGRFZDeFBRVUZQTEVsQlFVa3NRMEZCUTBnc1MwRkJTeXhEUVVGRE8yRkJRMjVDT3pzN1dVRkZSRWtzUjBGQlN5eEZRVUZNUVN4UFFVRkxPMWxGZEVKUUxFOUdjMEpGUVN4VFFVRkJRU3hMUVVGTExFTkJRVU5ETEV0QlFVc3NSVUZCUlVNc1MwRkJTeXhGUVVGRlF5eFJRVUZSTEVWQlFVVTdaMEpCUXpWQ0xFbEJRVWxETEUxQlFVMHNRVUZCUXp0blFrRkZXQ3hKUVVGTlF5eFZRVUZWTEVkQlFVZElMRXRCUVVzc1EwRkJRMGtzWVVGQllTeEZRVUZGTEVWQlEyeERReXhWUVVGVkxFZEJRVWNzUlVGQlJTeEZRVU5tUXl4TFFVRkxMRWRCUVVjc1EwRkJReXhCUVVGRE8yZENRVVZvUWtvc1RVRkJUU3hIUVVGSFN5eERRVUZCUVN4SFFVRkJRU3hWUVVGVkxFRkJRV2RFTEVOQlFVRXNXVUZCTDBNc1NVRkJTU3hEUVVGRFlpeExRVUZMTEVWQlFVVlhMRlZCUVZVc1JVRkJSVU1zUzBGQlN5eEZRVUZGVGl4TFFVRkxMRVZCUVVWRExGRkJRVkVzUTBGQlF5eERRVUZETzJkQ1FVVndSU3hKUVVGSlF5eE5RVUZOTEVWQlFVVTdiMEpCUTFaTkxFTkJRVUZCTEVkQlFVRkJMRTFCUVVrc1FVRkJiVUlzUTBGQlFTeE5RVUZzUWxRc1MwRkJTeXhGUVVGRlRTeFZRVUZWTEVOQlFVTXNRMEZCUXp0cFFrRkRla0k3WjBKQlJVUXNTVUZCU1N4RFFVRkRTQ3hOUVVGTkxFVkJRVVU3YjBKQlExaEdMRXRCUVVzc1EwRkJRMU1zVTBGQlV5eERRVUZEVGl4VlFVRlZMRU5CUVVNc1EwRkJRenRwUWtGRE4wSTdaMEpCUlVRc1QwRkJUMFFzVFVGQlRTeERRVUZETzJGQlEyWTdPenRaUVVWRVVTeEhRVUZSTEVWQlFWSkJMRlZCUVZFN1dVVXhRMVlzVDBZd1EwVkJMRk5CUVVGQkxGRkJRVkVzUjBGQlJ6dG5Ra0ZEVkN4SlFVRk5ReXhaUVVGWExFZEJRVWNzU1VGQlNTeERRVUZEYWtJc1MwRkJTeXhEUVVGRGEwSXNUVUZCVFN4RFFVRkRMRk5CUVVORUxGZEJRVmNzUlVGQlJVVXNTVUZCU1N4RlFVRkxPMjlDUVVOeVJDeEpRVUZOUXl4VlFVRlZMRWRCUVVkRUxFbEJRVWtzUTBGQlEwZ3NVVUZCVVN4RlFVRkZMRUZCUVVNN2IwSkJSVzVETEVsQlFVbERMRmRCUVZjc1MwRkJTeXhKUVVGSkxFVkJRVVU3ZDBKQlEzaENRU3hYUVVGWExFZEJRVWRITEZWQlFWVXNRMEZCUXp0eFFrRkRNVUlzVFVGQlRUdDNRa0ZEVEVnc1YwRkJWeXhIUVVGSExFRkJRVU1zUlVGQlFTeERRVUZwUWtjc1RVRkJWU3hEUVVGNlFrZ3NWMEZCVnl4RlFVRkRMRWRCUVVNc1EwRkJZU3hEUVVGQkxFMUJRVUVzUTBGQldFY3NWVUZCVlN4RFFVRkZMRU5CUVVNN2NVSkJRemxETzI5Q1FVVkVMRTlCUVU5SUxGZEJRVmNzUTBGQlF6dHBRa0ZEY0VJc1JVRkJSU3hKUVVGSkxFTkJRVU1zUlVGRFVra3NUVUZCVFN4SFFVRkhMRUZCUVVNc1NVRkJSU3hEUVVGakxFMUJRVVVzUTBGQlpFb3NXVUZCVnl4RlFVRkRMRWxCUVVVc1EwRkJReXhCUVVGRE8yZENRVVZ3UXl4UFFVRlBTU3hOUVVGTkxFTkJRVU03WVVGRFpqczdPMWxCUlVSRExFZEJRVXNzUlVGQlRFRXNUMEZCU3p0WlJUTkVVQ3hQUmpKRVJVRXNVMEZCUVVFc1MwRkJTeXhIUVVGSE8yZENRVUZGTEU5QlFVOHNjVUpCYkVSRmRrSXNiVUpCUVcxQ0xHRkJhMFJtZFVJc1QwRkJTeXhGUVVGWUxFbEJRVXNzUTBGQlFTeFpRVUZQZGtJc2JVSkJRVzFDTEVWQlFVVXNTVUZCU1N4RFFVRkRReXhMUVVGTExFVkJRVVU3WVVGQlJUczdPenRaUVVWNlJIVkNMRWRCUVZNc1JVRkJWRUVzVjBGQlV6dFpSVGRFYkVJc1QwWTJSRVVzVTBGQlQwRXNVMEZCVXl4RFFVRkRiRUlzUzBGQlN5eEZRVUZGTzJkQ1FVTjBRaXhKUVVGTmJVSXNkVUpCUVhWQ0xFZEJRVWRETEVOQlFVRkJMRWRCUVVGQkxFMUJRV3RDTEVGQlFVOHNRMEZCUVN4dlFrRkJUbkJDTEV0QlFVc3NRMEZCUXl4QlFVRkRPMmRDUVVVeFJFRXNTMEZCU3l4SFFVRkhiVUlzZFVKQlFYVkNMRU5CUVVNc1EwRkJSU3hIUVVGSE8yZENRVVZ5UXl4SlFVRk5SU3hUUVVGVExFZEJRVWNzUzBGQlN5eEZRVU5xUWpGQ0xFdEJRVXNzUjBGQlIwc3NTMEZCU3l4RFFVRkRjMElzUjBGQlJ5eERRVUZETEZOQlFVTkRMRWxCUVVrc1JVRkJTenR2UWtGRE1VSXNTVUZCVFZRc1NVRkJTU3hIUVVGSFV5eEpRVUZKTEVOQlFVTkRMRmxCUVZrc1EwRkJRMGdzVTBGQlV5eERRVUZETEVGQlFVTTdiMEpCUlRGRExFOUJRVTlRTEVsQlFVa3NRMEZCUXp0cFFrRkRZaXhEUVVGRExFVkJRMFpYTEcxQ1FVRnRRaXhIUVVGSExFbEJRVWt2UWl4dFFrRkJiVUlzUTBGQlEwTXNTMEZCU3l4RFFVRkRMRUZCUVVNN1owSkJSVE5FTEU5QlFVODRRaXh0UWtGQmJVSXNRMEZCUXp0aFFVTTFRanM3VFVFelJVZzdPME5CTkVWRExFTkJia1ZuUkVNc1dVRkJaU3hUUVcxRkwwUTdhMEpCYmtWdlFtaERMRzFDUVVGdFFpeEJRVlI0UXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfb2NjYW1MZXhlcnMgPSByZXF1aXJlKFwib2NjYW0tbGV4ZXJzXCIpO1xudmFyIF9kZWZpbml0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvblwiKSk7XG52YXIgX3J1bGVOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiKSk7XG52YXIgX3Rlcm1pbmFsU3ltYm9sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC90ZXJtaW5hbC90ZXJtaW5hbFN5bWJvbFwiKSk7XG52YXIgX3plcm9Pck1vcmVQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCIpKTtcbnZhciBfc2VxdWVuY2VPZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIHZlcnRpY2FsQmFyID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLnZlcnRpY2FsQmFyO1xudmFyIERlZmluaXRpb25zRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhEZWZpbml0aW9uc0RlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVmaW5pdGlvbnNEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBEZWZpbml0aW9uc0RlZmluaXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWZpbml0aW9uc0RlZmluaXRpb24pO1xuICAgICAgICB2YXIgZGVmaW5pdGlvblJ1bGVOYW1lID0gX3J1bGVOYW1lcy5EZWZpbml0aW9uUnVsZU5hbWUsIHZlcnRpY2FsQmFyVGVybWluYWxTeW1ib2xDb250ZW50ID0gdmVydGljYWxCYXIsIGRlZmluaXRpb25SdWxlTmFtZVBhcnQgPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQoZGVmaW5pdGlvblJ1bGVOYW1lKSwgdmVydGljYWxCYXJUZXJtaW5hbFN5bWJvbFBhcnQgPSBuZXcgX3Rlcm1pbmFsU3ltYm9sLmRlZmF1bHQodmVydGljYWxCYXJUZXJtaW5hbFN5bWJvbENvbnRlbnQpLCB2ZXJ0aWNhbEJhclRlcm1pbmFsU3ltYm9sVGhlbkRlZmluaXRpb25SdWxlTmFtZVBhcnRzID0gW1xuICAgICAgICAgICAgdmVydGljYWxCYXJUZXJtaW5hbFN5bWJvbFBhcnQsXG4gICAgICAgICAgICBkZWZpbml0aW9uUnVsZU5hbWVQYXJ0XG4gICAgICAgIF0sIHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBuZXcgX3NlcXVlbmNlT2ZQYXJ0cy5kZWZhdWx0KHZlcnRpY2FsQmFyVGVybWluYWxTeW1ib2xUaGVuRGVmaW5pdGlvblJ1bGVOYW1lUGFydHMpLCB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IG5ldyBfemVyb09yTW9yZVBhcnRzLmRlZmF1bHQoc2VxdWVuY2VPZlBhcnRzUGFydCksIHBhcnRzID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvblJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIHplcm9Pck1vcmVTZXF1ZW5jZU9mUGFydHNQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBEZWZpbml0aW9uc0RlZmluaXRpb247XG59KF9kZWZpbml0aW9uLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmaW5pdGlvbnNEZWZpbml0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrWldacGJtbDBhVzl1TDJSbFptbHVhWFJwYjI1ekxtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnZXlCemNHVmphV0ZzVTNsdFltOXNjeUI5SUdaeWIyMGdYQ0p2WTJOaGJTMXNaWGhsY25OY0lqdGNibHh1YVcxd2IzSjBJRVJsWm1sdWFYUnBiMjRnWm5KdmJTQmNJaTR1TDJSbFptbHVhWFJwYjI1Y0lqdGNibWx0Y0c5eWRDQlNkV3hsVG1GdFpWQmhjblFnWm5KdmJTQmNJaTR1TDNCaGNuUXZibTl1VkdWeWJXbHVZV3d2Y25Wc1pVNWhiV1ZjSWp0Y2JtbHRjRzl5ZENCVVpYSnRhVzVoYkZONWJXSnZiRkJoY25RZ1puSnZiU0JjSWk0dUwzQmhjblF2ZEdWeWJXbHVZV3d2ZEdWeWJXbHVZV3hUZVcxaWIyeGNJanRjYm1sdGNHOXlkQ0JhWlhKdlQzSk5iM0psVUdGeWRITlFZWEowSUdaeWIyMGdYQ0l1TGk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDNwbGNtOVBjazF2Y21WUVlYSjBjMXdpTzF4dWFXMXdiM0owSUZObGNYVmxibU5sVDJaUVlYSjBjMUJoY25RZ1puSnZiU0JjSWk0dUwzQmhjblF2Ym05dVZHVnliV2x1WVd3dmMyVnhkV1Z1WTJWUFpsQmhjblJ6WENJN1hHNWNibWx0Y0c5eWRDQjdJRVJsWm1sdWFYUnBiMjVTZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1WTI5dWMzUWdleUIyWlhKMGFXTmhiRUpoY2lCOUlEMGdjM0JsWTJsaGJGTjViV0p2YkhNN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUVSbFptbHVhWFJwYjI1elJHVm1hVzVwZEdsdmJpQmxlSFJsYm1SeklFUmxabWx1YVhScGIyNGdlMXh1SUNCamIyNXpkSEoxWTNSdmNpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCa1pXWnBibWwwYVc5dVVuVnNaVTVoYldVZ1BTQkVaV1pwYm1sMGFXOXVVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnZG1WeWRHbGpZV3hDWVhKVVpYSnRhVzVoYkZONWJXSnZiRU52Ym5SbGJuUWdQU0IyWlhKMGFXTmhiRUpoY2l4Y2JpQWdJQ0FnSUNBZ0lDQmtaV1pwYm1sMGFXOXVVblZzWlU1aGJXVlFZWEowSUQwZ2JtVjNJRkoxYkdWT1lXMWxVR0Z5ZENoa1pXWnBibWwwYVc5dVVuVnNaVTVoYldVcExGeHVJQ0FnSUNBZ0lDQWdJSFpsY25ScFkyRnNRbUZ5VkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSUQwZ2JtVjNJRlJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ2gyWlhKMGFXTmhiRUpoY2xSbGNtMXBibUZzVTNsdFltOXNRMjl1ZEdWdWRDa3NYRzRnSUNBZ0lDQWdJQ0FnZG1WeWRHbGpZV3hDWVhKVVpYSnRhVzVoYkZONWJXSnZiRlJvWlc1RVpXWnBibWwwYVc5dVVuVnNaVTVoYldWUVlYSjBjeUE5SUZ0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpsY25ScFkyRnNRbUZ5VkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdaR1ZtYVc1cGRHbHZibEoxYkdWT1lXMWxVR0Z5ZEZ4dUlDQWdJQ0FnSUNBZ0lGMHNYRzRnSUNBZ0lDQWdJQ0FnYzJWeGRXVnVZMlZQWmxCaGNuUnpVR0Z5ZENBOUlHNWxkeUJUWlhGMVpXNWpaVTltVUdGeWRITlFZWEowS0habGNuUnBZMkZzUW1GeVZHVnliV2x1WVd4VGVXMWliMnhVYUdWdVJHVm1hVzVwZEdsdmJsSjFiR1ZPWVcxbFVHRnlkSE1wTEZ4dUlDQWdJQ0FnSUNBZ0lIcGxjbTlQY2sxdmNtVlRaWEYxWlc1alpVOW1VR0Z5ZEhOUVlYSjBJRDBnYm1WM0lGcGxjbTlQY2sxdmNtVlFZWEowYzFCaGNuUW9jMlZ4ZFdWdVkyVlBabEJoY25SelVHRnlkQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2NHRnlkSE1nUFNCYlhHNGdJQ0FnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1VW5Wc1pVNWhiV1ZRWVhKMExGeHVJQ0FnSUNBZ0lDQWdJQ0FnZW1WeWIwOXlUVzl5WlZObGNYVmxibU5sVDJaUVlYSjBjMUJoY25SY2JpQWdJQ0FnSUNBZ0lDQmRPMXh1SUNBZ0lGeHVJQ0FnSUhOMWNHVnlLSEJoY25SektWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpZG1WeWRHbGpZV3hDWVhJaUxDSnpjR1ZqYVdGc1UzbHRZbTlzY3lJc0lrUmxabWx1YVhScGIyNXpSR1ZtYVc1cGRHbHZiaUlzSW1SbFptbHVhWFJwYjI1U2RXeGxUbUZ0WlNJc0lrUmxabWx1YVhScGIyNVNkV3hsVG1GdFpTSXNJblpsY25ScFkyRnNRbUZ5VkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MElpd2laR1ZtYVc1cGRHbHZibEoxYkdWT1lXMWxVR0Z5ZENJc0lsSjFiR1ZPWVcxbFVHRnlkQ0lzSW5abGNuUnBZMkZzUW1GeVZHVnliV2x1WVd4VGVXMWliMnhRWVhKMElpd2lWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJaXdpZG1WeWRHbGpZV3hDWVhKVVpYSnRhVzVoYkZONWJXSnZiRlJvWlc1RVpXWnBibWwwYVc5dVVuVnNaVTVoYldWUVlYSjBjeUlzSW5ObGNYVmxibU5sVDJaUVlYSjBjMUJoY25RaUxDSlRaWEYxWlc1alpVOW1VR0Z5ZEhOUVlYSjBJaXdpZW1WeWIwOXlUVzl5WlZObGNYVmxibU5sVDJaUVlYSjBjMUJoY25RaUxDSmFaWEp2VDNKTmIzSmxVR0Z5ZEhOUVlYSjBJaXdpY0dGeWRITWlMQ0pFWldacGJtbDBhVzl1SWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUlN0Q0xFbEJRVUVzV1VGQll5eFhRVUZrTEdOQlFXTXNRMEZCUVR0QlFVVjBRaXhKUVVGQkxGZEJRV1VzYTBOQlFXWXNaVUZCWlN4RlFVRkJPMEZCUTJJc1NVRkJRU3hUUVVFNFFpeHJRMEZCT1VJc09FSkJRVGhDTEVWQlFVRTdRVUZEZUVJc1NVRkJRU3hsUVVGcFF5eHJRMEZCYWtNc2FVTkJRV2xETEVWQlFVRTdRVUZEYUVNc1NVRkJRU3huUWtGQmNVTXNhME5CUVhKRExIRkRRVUZ4UXl4RlFVRkJPMEZCUTNKRExFbEJRVUVzWjBKQlFYRkRMR3REUVVGeVF5eHhRMEZCY1VNc1JVRkJRVHRCUVVWc1F5eEpRVUZCTEZWQlFXTXNWMEZCWkN4alFVRmpMRU5CUVVFN096czdPenM3T3pzN096czdPenRMUVZacVJEczdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVmxCTEVsQlFVMHNRVUZCUlVFc1YwRkJWeXhIUVVGTFF5eFpRVUZqTEdkQ1FVRTVRa1FzVjBGQlZ5eEJRVUZ0UWl4QlFVRkRPMEZCUlhoQ0xFbEJRVUVzUVVGQlRVVXNjVUpCUVhGQ0xHbENRMlIyUXl4QlJHTlpPMmRFUVdSbU96dGhRV054UWtFc2NVSkJRWEZDTzI5RVFXUXhRenRSUVdkQ1NTeEpRVUZOUXl4clFrRkJhMElzUjBGQlIwTXNWVUZCYTBJc2JVSkJRVUVzUlVGRGRrTkRMR2REUVVGblF5eEhRVUZIVEN4WFFVRlhMRVZCUXpsRFRTeHpRa0ZCYzBJc1IwRkJSeXhKUVVGSlF5eFRRVUZaTEZOQlFVTktMR3RDUVVGclFpeERRVUZETEVWQlF6ZEVTeXcyUWtGQk5rSXNSMEZCUnl4SlFVRkpReXhsUVVGclFpeFRRVUZEU2l4blEwRkJaME1zUTBGQlF5eEZRVU40Umtzc2IwUkJRVzlFTEVkQlFVYzdXVUZEY2tSR0xEWkNRVUUyUWp0WlFVTTNRa1lzYzBKQlFYTkNPMU5CUTNaQ0xFVkJRMFJMTEcxQ1FVRnRRaXhIUVVGSExFbEJRVWxETEdkQ1FVRnRRaXhUUVVGRFJpeHZSRUZCYjBRc1EwRkJReXhGUVVOdVIwY3NOa0pCUVRaQ0xFZEJRVWNzU1VGQlNVTXNaMEpCUVcxQ0xGTkJRVU5JTEcxQ1FVRnRRaXhEUVVGRExFVkJRelZGU1N4TFFVRkxMRWRCUVVjN1dVRkRUbFFzYzBKQlFYTkNPMWxCUTNSQ1R5dzJRa0ZCTmtJN1UwRkRPVUlzUVVGQlF6dHBRMEZGUmtVc1MwRkJTenM3TzBOQlJXUXNRMEZ1UW10RVF5eFhRVUZWTEZOQmJVSTFSRHRyUWtGdVFtOUNaQ3h4UWtGQmNVSXNRVUZrTVVNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfZGVmaW5pdGlvbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ub2RlL2JuZi9kZWZpbml0aW9uc1wiKSk7XG52YXIgX2RlZmluaXRpb25zMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vZGVmaW5pdGlvbnNcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIERlZmluaXRpb25zUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhEZWZpbml0aW9uc1J1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVmaW5pdGlvbnNSdWxlKTtcbiAgICBmdW5jdGlvbiBEZWZpbml0aW9uc1J1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWZpbml0aW9uc1J1bGUpO1xuICAgICAgICB2YXIgZGVmaW5pdGlvbnNEZWZpbml0aW9uID0gbmV3IF9kZWZpbml0aW9uczEuZGVmYXVsdCgpLCBuYW1lID0gX3J1bGVOYW1lcy5EZWZpbml0aW9uc1J1bGVOYW1lLCBhbWJpZ3VvdXMgPSBmYWxzZSwgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBkZWZpbml0aW9uc0RlZmluaXRpb25cbiAgICAgICAgXSwgTm9kZSA9IF9kZWZpbml0aW9ucy5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBEZWZpbml0aW9uc1J1bGU7XG59KF9ydWxlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmaW5pdGlvbnNSdWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl5ZFd4bEwyUmxabWx1YVhScGIyNXpMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1VuVnNaU0JtY205dElGd2lMaTR2Y25Wc1pWd2lPMXh1YVcxd2IzSjBJRVJsWm1sdWFYUnBiMjV6UWs1R1RtOWtaU0JtY205dElGd2lMaTR2Ym05a1pTOWlibVl2WkdWbWFXNXBkR2x2Ym5OY0lqdGNibWx0Y0c5eWRDQkVaV1pwYm1sMGFXOXVjMFJsWm1sdWFYUnBiMjRnWm5KdmJTQmNJaTR1TDJSbFptbHVhWFJwYjI0dlpHVm1hVzVwZEdsdmJuTmNJanRjYmx4dWFXMXdiM0owSUhzZ1JHVm1hVzVwZEdsdmJuTlNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTl5ZFd4bFRtRnRaWE5jSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nUkdWbWFXNXBkR2x2Ym5OU2RXeGxJR1Y0ZEdWdVpITWdVblZzWlNCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0NrZ2UxeHVJQ0FnSUdOdmJuTjBJR1JsWm1sdWFYUnBiMjV6UkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJFWldacGJtbDBhVzl1YzBSbFptbHVhWFJwYjI0b0tTeGNiaUFnSUNBZ0lDQWdJQ0J1WVcxbElEMGdSR1ZtYVc1cGRHbHZibk5TZFd4bFRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNCaGJXSnBaM1Z2ZFhNZ1BTQm1ZV3h6WlN4Y2JpQWdJQ0FnSUNBZ0lDQmtaV1pwYm1sMGFXOXVjeUE5SUZ0Y2JpQWdJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6UkdWbWFXNXBkR2x2Ymx4dUlDQWdJQ0FnSUNBZ0lGMHNYRzRnSUNBZ0lDQWdJQ0FnVG05a1pTQTlJRVJsWm1sdWFYUnBiMjV6UWs1R1RtOWtaVHRjYmlBZ0lDQmNiaUFnSUNCemRYQmxjaWh1WVcxbExDQmhiV0pwWjNWdmRYTXNJR1JsWm1sdWFYUnBiMjV6TENCT2IyUmxLVnh1SUNCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVJHVm1hVzVwZEdsdmJuTlNkV3hsSWl3aVpHVm1hVzVwZEdsdmJuTkVaV1pwYm1sMGFXOXVJaXdpUkdWbWFXNXBkR2x2Ym5ORVpXWnBibWwwYVc5dUlpd2libUZ0WlNJc0lrUmxabWx1YVhScGIyNXpVblZzWlU1aGJXVWlMQ0poYldKcFozVnZkWE1pTENKa1pXWnBibWwwYVc5dWN5SXNJazV2WkdVaUxDSkVaV1pwYm1sMGFXOXVjMEpPUms1dlpHVWlMQ0pTZFd4bElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJXbENMRWxCUVVFc1MwRkJVeXhyUTBGQlZDeFRRVUZUTEVWQlFVRTdRVUZEU3l4SlFVRkJMRmxCUVhsQ0xHdERRVUY2UWl4NVFrRkJlVUlzUlVGQlFUdEJRVU4wUWl4SlFVRkJMR0ZCUVRKQ0xHdERRVUV6UWl3eVFrRkJNa0lzUlVGQlFUdEJRVVY2UWl4SlFVRkJMRlZCUVdNc1YwRkJaQ3hqUVVGakxFTkJRVUU3T3pzN096czdPenM3T3pzN096dExRVTVzUkRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TWtKQlFVRTdPenM3T3pzN08zRkdRVUZCT3pzN096czdPenM3T3pzN2JVVkJRVUU3TzJsRVFVRkJPenM3T3p0QlFWRmxMRWxCUVVFc1FVRkJUVUVzWlVGQlpTeHBRa05TYWtNc1FVUlJXVHR2UTBGU1pqczdZVUZSY1VKQkxHVkJRV1U3T0VOQlVuQkRPMUZCVlVrc1NVRkJUVU1zY1VKQlFYRkNMRWRCUVVjc1NVRkJTVU1zWVVGQmNVSXNWVUZCUlN4RlFVTnVSRU1zU1VGQlNTeEhRVUZIUXl4VlFVRnRRaXh2UWtGQlFTeEZRVU14UWtNc1UwRkJVeXhIUVVGSExFdEJRVXNzUlVGRGFrSkRMRmRCUVZjc1IwRkJSenRaUVVOYVRDeHhRa0ZCY1VJN1UwRkRkRUlzUlVGRFJFMHNTVUZCU1N4SFFVRkhReXhaUVVGclFpeFJRVUZCTEVGQlFVTTdhVU5CUlRGQ1RDeEpRVUZKTEVWQlFVVkZMRk5CUVZNc1JVRkJSVU1zVjBGQlZ5eEZRVUZGUXl4SlFVRkpPenM3UTBGRk0wTXNRMEZhTkVORkxFdEJRVWtzVTBGWmFFUTdhMEpCV205Q1ZDeGxRVUZsTEVGQlVuQkRJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uL25vZGUvbm9uVGVybWluYWxcIikpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsaXRpZXMvYXJyYXlcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBUZXJtaW5hbFBhcnRCTkZOb2RlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoVGVybWluYWxQYXJ0Qk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRlcm1pbmFsUGFydEJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsUGFydEJORk5vZGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXJtaW5hbFBhcnRCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoVGVybWluYWxQYXJ0Qk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuZXJhdGVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksIGZpcnN0Q2hpbGROb2RlID0gKDAsIF9hcnJheSkuZmlyc3QoY2hpbGROb2RlcyksIG5vZGUgPSBmaXJzdENoaWxkTm9kZSwgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhydWxlTmFtZSwgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uVGVybWluYWwuZGVmYXVsdC5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKFRlcm1pbmFsUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBUZXJtaW5hbFBhcnRCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZXJtaW5hbFBhcnRCTkZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOXdZWEowTDNSbGNtMXBibUZzTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdUbTl1VkdWeWJXbHVZV3hPYjJSbElHWnliMjBnWENJdUxpOHVMaTh1TGk5dWIyUmxMMjV2YmxSbGNtMXBibUZzWENJN1hHNWNibWx0Y0c5eWRDQjdJR1pwY25OMElIMGdabkp2YlNCY0lpNHVMeTR1THk0dUwzVjBhV3hwZEdsbGN5OWhjbkpoZVZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCVVpYSnRhVzVoYkZCaGNuUkNUa1pPYjJSbElHVjRkR1Z1WkhNZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUh0Y2JpQWdaMlZ1WlhKaGRHVlFZWEowS0d4dmIydEJhR1ZoWkNrZ2UxeHVJQ0FnSUdOdmJuTjBJR05vYVd4a1RtOWtaWE1nUFNCMGFHbHpMbWRsZEVOb2FXeGtUbTlrWlhNb0tTeGNiaUFnSUNBZ0lDQWdJQ0JtYVhKemRFTm9hV3hrVG05a1pTQTlJR1pwY25OMEtHTm9hV3hrVG05a1pYTXBMRnh1SUNBZ0lDQWdJQ0FnSUc1dlpHVWdQU0JtYVhKemRFTm9hV3hrVG05a1pTd2dJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lIQmhjblFnUFNCdWIyUmxMbWRsYm1WeVlYUmxVR0Z5ZENoc2IyOXJRV2hsWVdRcE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhCaGNuUTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aHlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWtnZXlCeVpYUjFjbTRnVG05dVZHVnliV2x1WVd4T2IyUmxMbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9WR1Z5YldsdVlXeFFZWEowUWs1R1RtOWtaU3dnY25Wc1pVNWhiV1VzSUdOb2FXeGtUbTlrWlhNcE95QjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lWR1Z5YldsdVlXeFFZWEowUWs1R1RtOWtaU0lzSW1kbGJtVnlZWFJsVUdGeWRDSXNJbXh2YjJ0QmFHVmhaQ0lzSW1Ob2FXeGtUbTlrWlhNaUxDSm5aWFJEYUdsc1pFNXZaR1Z6SWl3aVptbHljM1JEYUdsc1pFNXZaR1VpTENKbWFYSnpkQ0lzSW01dlpHVWlMQ0p3WVhKMElpd2labkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5SXNJbkoxYkdWT1lXMWxJaXdpVG05dVZHVnliV2x1WVd4T2IyUmxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSVFJDTEVsQlFVRXNXVUZCTWtJc2EwTkJRVE5DTERKQ1FVRXlRaXhGUVVGQk8wRkJSV3BETEVsQlFVRXNUVUZCTUVJc1YwRkJNVUlzTUVKQlFUQkNMRU5CUVVFN096czdPenM3T3pzN096czdPenM0UkVGS2FFUTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJUV1VzU1VGQlFTeEJRVUZOUVN4dFFrRkJiVUlzYVVKRFRuSkRMRUZFVFZrN2JVUkJUbVk3TzJGQlRYRkNRU3h0UWtGQmJVSTdhMFJCVG5oRE96czdPenRaUVU5RlF5eEhRVUZaTEVWQlFWcEJMR05CUVZrN1dVVlFaQ3hQUms5RlFTeFRRVUZCUVN4WlFVRlpMRU5CUVVORExGTkJRVk1zUlVGQlJUdG5Ra0ZEZEVJc1NVRkJUVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEUXl4alFVRmpMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTFCUVVzc1FVRkJXU3hEUVVGQkxFOUJRVmhJTEZWQlFWVXNRMEZCUXl4RlFVTnNRMGtzU1VGQlNTeEhRVUZIUml4alFVRmpMRVZCUTNKQ1J5eEpRVUZKTEVkQlFVZEVMRWxCUVVrc1EwRkJRMDRzV1VGQldTeERRVUZEUXl4VFFVRlRMRU5CUVVNc1FVRkJRenRuUWtGRk1VTXNUMEZCVDAwc1NVRkJTU3hEUVVGRE8yRkJRMkk3T3pzN1dVRkZUVU1zUjBGQmVVSXNSVUZCZWtKQkxESkNRVUY1UWp0WlJXaENiRU1zVDBablFrVXNVMEZCVDBFc2VVSkJRWGxDTEVOQlFVTkRMRkZCUVZFc1JVRkJSVkFzVlVGQlZTeEZRVUZGTzJkQ1FVRkZMRTlCUVU5UkxGbEJRV1VzVTBGQlEwWXNlVUpCUVhsQ0xFTkJRVU5VTEcxQ1FVRnRRaXhGUVVGRlZTeFJRVUZSTEVWQlFVVlFMRlZCUVZVc1EwRkJReXhEUVVGRE8yRkJRVVU3TzAxQmFFSjZTanM3UTBGcFFrTXNRMEZZWjBSUkxGbEJRV1VzVTBGWEwwUTdhMEpCV0c5Q1dDeHRRa0ZCYlVJc1FVRk9lRU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF90ZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3BhcnQvdGVybWluYWxcIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcnVsZU5hbWVcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFRlcm1pbmFsUGFydFJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoVGVybWluYWxQYXJ0UnVsZSwgUnVsZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUZXJtaW5hbFBhcnRSdWxlKTtcbiAgICBmdW5jdGlvbiBUZXJtaW5hbFBhcnRSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVybWluYWxQYXJ0UnVsZSk7XG4gICAgICAgIHZhciBuYW1lID0gX3J1bGVOYW1lcy5UZXJtaW5hbFBhcnRSdWxlTmFtZSwgd2lsZGNhcmRSdWxlTmFtZSA9IF9ydWxlTmFtZXMuV2lsZGNhcmRSdWxlTmFtZSwgZW5kT2ZMaW5lUnVsZU5hbWUgPSBfcnVsZU5hbWVzLkVuZE9mTGluZVJ1bGVOYW1lLCB0ZXJtaW5hbFN5bWJvbFJ1bGVOYW1lID0gX3J1bGVOYW1lcy5UZXJtaW5hbFN5bWJvbFJ1bGVOYW1lLCByZWd1bGFyRXhwcmVzc2lvblJ1bGVOYW1lID0gX3J1bGVOYW1lcy5SZWd1bGFyRXhwcmVzc2lvblJ1bGVOYW1lLCBzaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lID0gX3J1bGVOYW1lcy5TaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lLCB3aWxkY2FyZFJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdCh3aWxkY2FyZFJ1bGVOYW1lKSwgZW5kT2ZMaW5lUnVsZU5hbWVEZWZpbml0aW9uID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KGVuZE9mTGluZVJ1bGVOYW1lKSwgdGVybWluYWxTeW1ib2xSdWxlTmFtZURlZmluaXRpb24gPSBuZXcgX3J1bGVOYW1lLmRlZmF1bHQodGVybWluYWxTeW1ib2xSdWxlTmFtZSksIHJlZ3VsYXJFeHByZXNzaW9uUnVsZU5hbWVEZWZpbml0aW9uID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KHJlZ3VsYXJFeHByZXNzaW9uUnVsZU5hbWUpLCBzaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChzaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lKSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvblJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHRlcm1pbmFsU3ltYm9sUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgZW5kT2ZMaW5lUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgd2lsZGNhcmRSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgXSwgTm9kZSA9IF90ZXJtaW5hbC5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXJtaW5hbFBhcnRSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlcm1pbmFsUGFydFJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDNSbGNtMXBibUZzVUdGeWRDNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdWY0lqdGNibWx0Y0c5eWRDQlVaWEp0YVc1aGJGQmhjblJDVGtaT2IyUmxJR1p5YjIwZ1hDSXVMaTl1YjJSbEwySnVaaTl3WVhKMEwzUmxjbTFwYm1Gc1hDSTdYRzVwYlhCdmNuUWdVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVJR1p5YjIwZ1hDSXVMaTlrWldacGJtbDBhVzl1TDNKMWJHVk9ZVzFsWENJN1hHNWNibWx0Y0c5eWRDQjdJRlJsY20xcGJtRnNVR0Z5ZEZKMWJHVk9ZVzFsTENCU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxKMWJHVk9ZVzFsTENCVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pWSjFiR1ZPWVcxbExDQlVaWEp0YVc1aGJGTjViV0p2YkZKMWJHVk9ZVzFsTENCRmJtUlBaa3hwYm1WU2RXeGxUbUZ0WlN3Z1YybHNaR05oY21SU2RXeGxUbUZ0WlNCOUlHWnliMjBnWENJdUxpOXlkV3hsVG1GdFpYTmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdWR1Z5YldsdVlXeFFZWEowVW5Wc1pTQmxlSFJsYm1SeklGSjFiR1VnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWdwSUh0Y2JpQWdJQ0JqYjI1emRDQnVZVzFsSUQwZ1ZHVnliV2x1WVd4UVlYSjBVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnZDJsc1pHTmhjbVJTZFd4bFRtRnRaU0E5SUZkcGJHUmpZWEprVW5Wc1pVNWhiV1VzWEc0Z0lDQWdJQ0FnSUNBZ1pXNWtUMlpNYVc1bFVuVnNaVTVoYldVZ1BTQkZibVJQWmt4cGJtVlNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRk41YldKdmJGSjFiR1ZPWVcxbElEMGdWR1Z5YldsdVlXeFRlVzFpYjJ4U2RXeGxUbUZ0WlN4Y2JpQWdJQ0FnSUNBZ0lDQnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsSjFiR1ZPWVcxbElEMGdVbVZuZFd4aGNrVjRjSEpsYzNOcGIyNVNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0J6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZKMWJHVk9ZVzFsSUQwZ1UybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVlNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0IzYVd4a1kyRnlaRkoxYkdWT1lXMWxSR1ZtYVc1cGRHbHZiaUE5SUc1bGR5QlNkV3hsVG1GdFpVUmxabWx1YVhScGIyNG9kMmxzWkdOaGNtUlNkV3hsVG1GdFpTa3NYRzRnSUNBZ0lDQWdJQ0FnWlc1a1QyWk1hVzVsVW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1SUQwZ2JtVjNJRkoxYkdWT1lXMWxSR1ZtYVc1cGRHbHZiaWhsYm1SUFpreHBibVZTZFd4bFRtRnRaU2tzWEc0Z0lDQWdJQ0FnSUNBZ2RHVnliV2x1WVd4VGVXMWliMnhTZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRnUFNCdVpYY2dVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVLSFJsY20xcGJtRnNVM2x0WW05c1VuVnNaVTVoYldVcExGeHVJQ0FnSUNBZ0lDQWdJSEpsWjNWc1lYSkZlSEJ5WlhOemFXOXVVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVJRDBnYm1WM0lGSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpaHlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsSjFiR1ZPWVcxbEtTeGNiaUFnSUNBZ0lDQWdJQ0J6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZKMWJHVk9ZVzFsUkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJTZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRvYzJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dWU2RXeGxUbUZ0WlNrc1hHNGdJQ0FnSUNBZ0lDQWdZVzFpYVdkMWIzVnpJRDBnWm1Gc2MyVXNYRzRnSUNBZ0lDQWdJQ0FnWkdWbWFXNXBkR2x2Ym5NZ1BTQmJYRzRnSUNBZ0lDQWdJQ0FnSUNCemFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pWSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpeGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1VW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeFRlVzFpYjJ4U2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI0c1hHNGdJQ0FnSUNBZ0lDQWdJQ0JsYm1SUFpreHBibVZTZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjNhV3hrWTJGeVpGSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJseHVJQ0FnSUNBZ0lDQWdJRjBzWEc0Z0lDQWdJQ0FnSUNBZ1RtOWtaU0E5SUZSbGNtMXBibUZzVUdGeWRFSk9SazV2WkdVN1hHNGdJQ0FnWEc0Z0lDQWdjM1Z3WlhJb2JtRnRaU3dnWVcxaWFXZDFiM1Z6TENCa1pXWnBibWwwYVc5dWN5d2dUbTlrWlNsY2JpQWdmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJbFJsY20xcGJtRnNVR0Z5ZEZKMWJHVWlMQ0p1WVcxbElpd2lWR1Z5YldsdVlXeFFZWEowVW5Wc1pVNWhiV1VpTENKM2FXeGtZMkZ5WkZKMWJHVk9ZVzFsSWl3aVYybHNaR05oY21SU2RXeGxUbUZ0WlNJc0ltVnVaRTltVEdsdVpWSjFiR1ZPWVcxbElpd2lSVzVrVDJaTWFXNWxVblZzWlU1aGJXVWlMQ0owWlhKdGFXNWhiRk41YldKdmJGSjFiR1ZPWVcxbElpd2lWR1Z5YldsdVlXeFRlVzFpYjJ4U2RXeGxUbUZ0WlNJc0luSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVVuVnNaVTVoYldVaUxDSlNaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsSjFiR1ZPWVcxbElpd2ljMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZTZFd4bFRtRnRaU0lzSWxOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFVuVnNaVTVoYldVaUxDSjNhV3hrWTJGeVpGSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpSXNJbEoxYkdWT1lXMWxSR1ZtYVc1cGRHbHZiaUlzSW1WdVpFOW1UR2x1WlZKMWJHVk9ZVzFsUkdWbWFXNXBkR2x2YmlJc0luUmxjbTFwYm1Gc1UzbHRZbTlzVW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1SWl3aWNtVm5kV3hoY2tWNGNISmxjM05wYjI1U2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI0aUxDSnphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVkoxYkdWT1lXMWxSR1ZtYVc1cGRHbHZiaUlzSW1GdFltbG5kVzkxY3lJc0ltUmxabWx1YVhScGIyNXpJaXdpVG05a1pTSXNJbFJsY20xcGJtRnNVR0Z5ZEVKT1JrNXZaR1VpTENKU2RXeGxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSV2xDTEVsQlFVRXNTMEZCVXl4clEwRkJWQ3hUUVVGVExFVkJRVUU3UVVGRFRTeEpRVUZCTEZOQlFUSkNMR3REUVVFelFpd3lRa0ZCTWtJc1JVRkJRVHRCUVVNMVFpeEpRVUZCTEZOQlFYZENMR3REUVVGNFFpeDNRa0ZCZDBJc1JVRkJRVHRCUVVWdlJ5eEpRVUZCTEZWQlFXTXNWMEZCWkN4alFVRmpMRU5CUVVFN096czdPenM3T3pzN096czdPenRMUVU1NlN6czdPenM3T3pzN096czdPenROUVVGQk8zbEVRVUZCT3pzN096czdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVkZsTEVsQlFVRXNRVUZCVFVFc1owSkJRV2RDTEdsQ1ExSnNReXhCUkZGWk8zRkRRVkptT3p0aFFWRnhRa0VzWjBKQlFXZENPeXREUVZKeVF6dFJRVlZKTEVsQlFVMURMRWxCUVVrc1IwRkJSME1zVlVGQmIwSXNjVUpCUVVFc1JVRkRNMEpETEdkQ1FVRm5RaXhIUVVGSFF5eFZRVUZuUWl4cFFrRkJRU3hGUVVOdVEwTXNhVUpCUVdsQ0xFZEJRVWRETEZWQlFXbENMR3RDUVVGQkxFVkJRM0pEUXl4elFrRkJjMElzUjBGQlIwTXNWVUZCYzBJc2RVSkJRVUVzUlVGREwwTkRMSGxDUVVGNVFpeEhRVUZIUXl4VlFVRjVRaXd3UWtGQlFTeEZRVU55UkVNc05FSkJRVFJDTEVkQlFVZERMRlZCUVRSQ0xEWkNRVUZCTEVWQlF6TkVReXd3UWtGQk1FSXNSMEZCUnl4SlFVRkpReXhUUVVGclFpeFRRVUZEV0N4blFrRkJaMElzUTBGQlF5eEZRVU55UlZrc01rSkJRVEpDTEVkQlFVY3NTVUZCU1VRc1UwRkJhMElzVTBGQlExUXNhVUpCUVdsQ0xFTkJRVU1zUlVGRGRrVlhMR2REUVVGblF5eEhRVUZITEVsQlFVbEdMRk5CUVd0Q0xGTkJRVU5RTEhOQ1FVRnpRaXhEUVVGRExFVkJRMnBHVlN4dFEwRkJiVU1zUjBGQlJ5eEpRVUZKU0N4VFFVRnJRaXhUUVVGRFRDeDVRa0ZCZVVJc1EwRkJReXhGUVVOMlJsTXNjME5CUVhORExFZEJRVWNzU1VGQlNVb3NVMEZCYTBJc1UwRkJRMGdzTkVKQlFUUkNMRU5CUVVNc1JVRkROMFpSTEZOQlFWTXNSMEZCUnl4TFFVRkxMRVZCUTJwQ1F5eFhRVUZYTEVkQlFVYzdXVUZEV2tZc2MwTkJRWE5ETzFsQlEzUkRSQ3h0UTBGQmJVTTdXVUZEYmtORUxHZERRVUZuUXp0WlFVTm9RMFFzTWtKQlFUSkNPMWxCUXpOQ1Jpd3dRa0ZCTUVJN1UwRkRNMElzUlVGRFJGRXNTVUZCU1N4SFFVRkhReXhUUVVGdFFpeFJRVUZCTEVGQlFVTTdhVU5CUlROQ2NrSXNTVUZCU1N4RlFVRkZhMElzVTBGQlV5eEZRVUZGUXl4WFFVRlhMRVZCUVVWRExFbEJRVWs3T3p0RFFVVXpReXhEUVhwQ05rTkZMRXRCUVVrc1UwRjVRbXBFTzJ0Q1FYcENiMEoyUWl4blFrRkJaMElzUVVGU2NrTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIikpO1xudmFyIF9jaG9pY2VPZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9jaG9pY2VPZlBhcnRzXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIENob2ljZU9mUGFydHNCTkZOb2RlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoQ2hvaWNlT2ZQYXJ0c0JORk5vZGUsIE5vblRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDaG9pY2VPZlBhcnRzQk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gQ2hvaWNlT2ZQYXJ0c0JORk5vZGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaG9pY2VPZlBhcnRzQk5GTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKENob2ljZU9mUGFydHNCTkZOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZW5lcmF0ZVBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVBhcnQobG9va0FoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgbm9kZXMgPSBjaGlsZE5vZGVzLnNsaWNlKCksIHBhcnQgPSBfY2hvaWNlT2ZQYXJ0cy5kZWZhdWx0LmZyb21Ob2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhydWxlTmFtZSwgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uVGVybWluYWwuZGVmYXVsdC5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKENob2ljZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ2hvaWNlT2ZQYXJ0c0JORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENob2ljZU9mUGFydHNCTkZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5amFHOXBZMlZQWmxCaGNuUnpMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUdaeWIyMGdYQ0l1TGk4dUxpOXViMlJsTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVwYlhCdmNuUWdRMmh2YVdObFQyWlFZWEowYzFCaGNuUWdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUXZibTl1VkdWeWJXbHVZV3d2WTJodmFXTmxUMlpRWVhKMGMxd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QkRhRzlwWTJWUFpsQmhjblJ6UWs1R1RtOWtaU0JsZUhSbGJtUnpJRTV2YmxSbGNtMXBibUZzVG05a1pTQjdYRzRnSUdkbGJtVnlZWFJsVUdGeWRDaHNiMjlyUVdobFlXUXBJSHRjYmlBZ0lDQmpiMjV6ZENCamFHbHNaRTV2WkdWeklEMGdkR2hwY3k1blpYUkRhR2xzWkU1dlpHVnpLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2JtOWtaWE1nUFNCamFHbHNaRTV2WkdWekxuTnNhV05sS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdjR0Z5ZENBOUlFTm9iMmxqWlU5bVVHRnlkSE5RWVhKMExtWnliMjFPYjJSbGN5aHViMlJsY3lrN1hHNWNiaUFnSUNCeVpYUjFjbTRnY0dGeWREdGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0VW5Wc1pVNWhiV1ZCYm1SRGFHbHNaRTV2WkdWektISjFiR1ZPWVcxbExDQmphR2xzWkU1dlpHVnpLU0I3SUhKbGRIVnliaUJPYjI1VVpYSnRhVzVoYkU1dlpHVXVabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aERhRzlwWTJWUFpsQmhjblJ6UWs1R1RtOWtaU3dnY25Wc1pVNWhiV1VzSUdOb2FXeGtUbTlrWlhNcE95QjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lRMmh2YVdObFQyWlFZWEowYzBKT1JrNXZaR1VpTENKblpXNWxjbUYwWlZCaGNuUWlMQ0pzYjI5clFXaGxZV1FpTENKamFHbHNaRTV2WkdWeklpd2laMlYwUTJocGJHUk9iMlJsY3lJc0ltNXZaR1Z6SWl3aWMyeHBZMlVpTENKd1lYSjBJaXdpUTJodmFXTmxUMlpRWVhKMGMxQmhjblFpTENKbWNtOXRUbTlrWlhNaUxDSm1jbTl0VW5Wc1pVNWhiV1ZCYm1SRGFHbHNaRTV2WkdWeklpd2ljblZzWlU1aGJXVWlMQ0pPYjI1VVpYSnRhVzVoYkU1dlpHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZORUlzU1VGQlFTeFpRVUYzUWl4clEwRkJlRUlzZDBKQlFYZENMRVZCUVVFN1FVRkRkRUlzU1VGQlFTeGpRVUZ6UXl4clEwRkJkRU1zYzBOQlFYTkRMRVZCUVVFN096czdPenM3T3pzN096czdPenM0UkVGSWNFVTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJTMlVzU1VGQlFTeEJRVUZOUVN4dlFrRkJiMElzYVVKRFRIUkRMRUZFUzFrN2IwUkJUR1k3TzJGQlMzRkNRU3h2UWtGQmIwSTdiVVJCVEhwRE96czdPenRaUVUxRlF5eEhRVUZaTEVWQlFWcEJMR05CUVZrN1dVVk9aQ3hQUmsxRlFTeFRRVUZCUVN4WlFVRlpMRU5CUVVORExGTkJRVk1zUlVGQlJUdG5Ra0ZEZEVJc1NVRkJUVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEUXl4TFFVRkxMRWRCUVVkR0xGVkJRVlVzUTBGQlEwY3NTMEZCU3l4RlFVRkZMRVZCUXpGQ1F5eEpRVUZKTEVkQlFVZERMR05CUVdsQ0xGTkJRVU5ETEZOQlFWTXNRMEZCUTBvc1MwRkJTeXhEUVVGRExFRkJRVU03WjBKQlJXaEVMRTlCUVU5RkxFbEJRVWtzUTBGQlF6dGhRVU5pT3pzN08xbEJSVTFITEVkQlFYbENMRVZCUVhwQ1FTd3lRa0ZCZVVJN1dVVmtiRU1zVDBaalJTeFRRVUZQUVN4NVFrRkJlVUlzUTBGQlEwTXNVVUZCVVN4RlFVRkZVaXhWUVVGVkxFVkJRVVU3WjBKQlFVVXNUMEZCVDFNc1dVRkJaU3hUUVVGRFJpeDVRa0ZCZVVJc1EwRkJRMVlzYjBKQlFXOUNMRVZCUVVWWExGRkJRVkVzUlVGQlJWSXNWVUZCVlN4RFFVRkRMRU5CUVVNN1lVRkJSVHM3VFVGa01VbzdPME5CWlVNc1EwRldhVVJUTEZsQlFXVXNVMEZWYUVVN2EwSkJWbTlDV2l4dlFrRkJiMElzUVVGTWVrTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfcnVsZU5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCIpKTtcbnZhciBfb25lT3JNb3JlUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCIpKTtcbnZhciBfdGVybWluYWxTeW1ib2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L3Rlcm1pbmFsL3Rlcm1pbmFsU3ltYm9sXCIpKTtcbnZhciBfc2VxdWVuY2VPZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIHZlcnRpY2FsQmFyID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLnZlcnRpY2FsQmFyLCBvcGVuQnJhY2tldCA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy5vcGVuQnJhY2tldCwgY2xvc2VCcmFja2V0ID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmNsb3NlQnJhY2tldDtcbnZhciBDaG9pY2VPZlBhcnRzRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhDaG9pY2VPZlBhcnRzRGVmaW5pdGlvbiwgRGVmaW5pdGlvbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDaG9pY2VPZlBhcnRzRGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaG9pY2VPZlBhcnRzRGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBwYXJ0UnVsZU5hbWUgPSBfcnVsZU5hbWVzLlBhcnRSdWxlTmFtZSwgdmVydGljYWxCYXJUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgb3BlbkJyYWNrZXRUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSBvcGVuQnJhY2tldCwgY2xvc2VCcmFja2V0VGVybWluYWxTeW1ib2xDb250ZW50ID0gY2xvc2VCcmFja2V0LCBwYXJ0UnVsZU5hbWVQYXJ0ID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KHBhcnRSdWxlTmFtZSksIHZlcnRpY2FsQmFyVGVybWluYWxTeW1ib2xQYXJ0ID0gbmV3IF90ZXJtaW5hbFN5bWJvbC5kZWZhdWx0KHZlcnRpY2FsQmFyVGVybWluYWxTeW1ib2xDb250ZW50KSwgb3BlbkJyYWNrZXRUZXJtaW5hbFN5bWJvbFBhcnQgPSBuZXcgX3Rlcm1pbmFsU3ltYm9sLmRlZmF1bHQob3BlbkJyYWNrZXRUZXJtaW5hbFN5bWJvbENvbnRlbnQpLCBjbG9zZUJyYWNrZXRUZXJtaW5hbFN5bWJvbFBhcnQgPSBuZXcgX3Rlcm1pbmFsU3ltYm9sLmRlZmF1bHQoY2xvc2VCcmFja2V0VGVybWluYWxTeW1ib2xDb250ZW50KSwgdmVydGljYWxCYXJUZXJtaW5hbFN5bWJvbFRoZW5QYXJ0UnVsZU5hbWVQYXJ0cyA9IFtcbiAgICAgICAgICAgIHZlcnRpY2FsQmFyVGVybWluYWxTeW1ib2xQYXJ0LFxuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydFxuICAgICAgICBdLCBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gbmV3IF9zZXF1ZW5jZU9mUGFydHMuZGVmYXVsdCh2ZXJ0aWNhbEJhclRlcm1pbmFsU3ltYm9sVGhlblBhcnRSdWxlTmFtZVBhcnRzKSwgb25lT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IG5ldyBfb25lT3JNb3JlUGFydHMuZGVmYXVsdChzZXF1ZW5jZU9mUGFydHNQYXJ0KSwgcGFydHMgPSBbXG4gICAgICAgICAgICBvcGVuQnJhY2tldFRlcm1pbmFsU3ltYm9sUGFydCxcbiAgICAgICAgICAgIHBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvbmVPck1vcmVTZXF1ZW5jZU9mUGFydHNQYXJ0LFxuICAgICAgICAgICAgY2xvc2VCcmFja2V0VGVybWluYWxTeW1ib2xQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBDaG9pY2VPZlBhcnRzRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaG9pY2VPZlBhcnRzRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwyTm9iMmxqWlU5bVVHRnlkSE11YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJSE53WldOcFlXeFRlVzFpYjJ4eklIMGdabkp2YlNCY0ltOWpZMkZ0TFd4bGVHVnljMXdpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZibHdpTzF4dWFXMXdiM0owSUZKMWJHVk9ZVzFsVUdGeWRDQm1jbTl0SUZ3aUxpNHZjR0Z5ZEM5dWIyNVVaWEp0YVc1aGJDOXlkV3hsVG1GdFpWd2lPMXh1YVcxd2IzSjBJRTl1WlU5eVRXOXlaVkJoY25SelVHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOXViMjVVWlhKdGFXNWhiQzl2Ym1WUGNrMXZjbVZRWVhKMGMxd2lPMXh1YVcxd2IzSjBJRlJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOTBaWEp0YVc1aGJGTjViV0p2YkZ3aU8xeHVhVzF3YjNKMElGTmxjWFZsYm1ObFQyWlFZWEowYzFCaGNuUWdabkp2YlNCY0lpNHVMM0JoY25RdmJtOXVWR1Z5YldsdVlXd3ZjMlZ4ZFdWdVkyVlBabEJoY25SelhDSTdYRzVjYm1sdGNHOXlkQ0I3SUZCaGNuUlNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTl5ZFd4bFRtRnRaWE5jSWp0Y2JseHVZMjl1YzNRZ2V5QjJaWEowYVdOaGJFSmhjaXdnYjNCbGJrSnlZV05yWlhRc0lHTnNiM05sUW5KaFkydGxkQ0I5SUQwZ2MzQmxZMmxoYkZONWJXSnZiSE03WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRU5vYjJsalpVOW1VR0Z5ZEhORVpXWnBibWwwYVc5dUlHVjRkR1Z1WkhNZ1JHVm1hVzVwZEdsdmJpQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtDa2dlMXh1SUNBZ0lHTnZibk4wSUhCaGNuUlNkV3hsVG1GdFpTQTlJRkJoY25SU2RXeGxUbUZ0WlN4Y2JpQWdJQ0FnSUNBZ0lDQjJaWEowYVdOaGJFSmhjbFJsY20xcGJtRnNVM2x0WW05c1EyOXVkR1Z1ZENBOUlIWmxjblJwWTJGc1FtRnlMQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnZjR1Z1UW5KaFkydGxkRlJsY20xcGJtRnNVM2x0WW05c1EyOXVkR1Z1ZENBOUlHOXdaVzVDY21GamEyVjBMQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQmpiRzl6WlVKeVlXTnJaWFJVWlhKdGFXNWhiRk41YldKdmJFTnZiblJsYm5RZ1BTQmpiRzl6WlVKeVlXTnJaWFFzSUM4dkwxeHVJQ0FnSUNBZ0lDQWdJSEJoY25SU2RXeGxUbUZ0WlZCaGNuUWdQU0J1WlhjZ1VuVnNaVTVoYldWUVlYSjBLSEJoY25SU2RXeGxUbUZ0WlNrc1hHNGdJQ0FnSUNBZ0lDQWdkbVZ5ZEdsallXeENZWEpVWlhKdGFXNWhiRk41YldKdmJGQmhjblFnUFNCdVpYY2dWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBLSFpsY25ScFkyRnNRbUZ5VkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MEtTeGNiaUFnSUNBZ0lDQWdJQ0J2Y0dWdVFuSmhZMnRsZEZSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZENBOUlHNWxkeUJVWlhKdGFXNWhiRk41YldKdmJGQmhjblFvYjNCbGJrSnlZV05yWlhSVVpYSnRhVzVoYkZONWJXSnZiRU52Ym5SbGJuUXBMRnh1SUNBZ0lDQWdJQ0FnSUdOc2IzTmxRbkpoWTJ0bGRGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDQTlJRzVsZHlCVVpYSnRhVzVoYkZONWJXSnZiRkJoY25Rb1kyeHZjMlZDY21GamEyVjBWR1Z5YldsdVlXeFRlVzFpYjJ4RGIyNTBaVzUwS1N4Y2JpQWdJQ0FnSUNBZ0lDQjJaWEowYVdOaGJFSmhjbFJsY20xcGJtRnNVM2x0WW05c1ZHaGxibEJoY25SU2RXeGxUbUZ0WlZCaGNuUnpJRDBnVzF4dUlDQWdJQ0FnSUNBZ0lDQWdkbVZ5ZEdsallXeENZWEpVWlhKdGFXNWhiRk41YldKdmJGQmhjblFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQndZWEowVW5Wc1pVNWhiV1ZRWVhKMFhHNGdJQ0FnSUNBZ0lDQWdYU3hjYmlBZ0lDQWdJQ0FnSUNCelpYRjFaVzVqWlU5bVVHRnlkSE5RWVhKMElEMGdibVYzSUZObGNYVmxibU5sVDJaUVlYSjBjMUJoY25Rb2RtVnlkR2xqWVd4Q1lYSlVaWEp0YVc1aGJGTjViV0p2YkZSb1pXNVFZWEowVW5Wc1pVNWhiV1ZRWVhKMGN5a3NYRzRnSUNBZ0lDQWdJQ0FnYjI1bFQzSk5iM0psVTJWeGRXVnVZMlZQWmxCaGNuUnpVR0Z5ZENBOUlHNWxkeUJQYm1WUGNrMXZjbVZRWVhKMGMxQmhjblFvYzJWeGRXVnVZMlZQWmxCaGNuUnpVR0Z5ZENrc1hHNGdJQ0FnSUNBZ0lDQWdjR0Z5ZEhNZ1BTQmJYRzRnSUNBZ0lDQWdJQ0FnSUNCdmNHVnVRbkpoWTJ0bGRGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUhCaGNuUlNkV3hsVG1GdFpWQmhjblFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnZibVZQY2sxdmNtVlRaWEYxWlc1alpVOW1VR0Z5ZEhOUVlYSjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1kyeHZjMlZDY21GamEyVjBWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBYRzRnSUNBZ0lDQWdJQ0FnWFR0Y2JseHVJQ0FnSUhOMWNHVnlLSEJoY25SektWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpZG1WeWRHbGpZV3hDWVhJaUxDSnpjR1ZqYVdGc1UzbHRZbTlzY3lJc0ltOXdaVzVDY21GamEyVjBJaXdpWTJ4dmMyVkNjbUZqYTJWMElpd2lRMmh2YVdObFQyWlFZWEowYzBSbFptbHVhWFJwYjI0aUxDSndZWEowVW5Wc1pVNWhiV1VpTENKUVlYSjBVblZzWlU1aGJXVWlMQ0oyWlhKMGFXTmhiRUpoY2xSbGNtMXBibUZzVTNsdFltOXNRMjl1ZEdWdWRDSXNJbTl3Wlc1Q2NtRmphMlYwVkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MElpd2lZMnh2YzJWQ2NtRmphMlYwVkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MElpd2ljR0Z5ZEZKMWJHVk9ZVzFsVUdGeWRDSXNJbEoxYkdWT1lXMWxVR0Z5ZENJc0luWmxjblJwWTJGc1FtRnlWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJaXdpVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSWl3aWIzQmxia0p5WVdOclpYUlVaWEp0YVc1aGJGTjViV0p2YkZCaGNuUWlMQ0pqYkc5elpVSnlZV05yWlhSVVpYSnRhVzVoYkZONWJXSnZiRkJoY25RaUxDSjJaWEowYVdOaGJFSmhjbFJsY20xcGJtRnNVM2x0WW05c1ZHaGxibEJoY25SU2RXeGxUbUZ0WlZCaGNuUnpJaXdpYzJWeGRXVnVZMlZQWmxCaGNuUnpVR0Z5ZENJc0lsTmxjWFZsYm1ObFQyWlFZWEowYzFCaGNuUWlMQ0p2Ym1WUGNrMXZjbVZUWlhGMVpXNWpaVTltVUdGeWRITlFZWEowSWl3aVQyNWxUM0pOYjNKbFVHRnlkSE5RWVhKMElpd2ljR0Z5ZEhNaUxDSkVaV1pwYm1sMGFXOXVJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSU3RDTEVsQlFVRXNXVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHRCUVVWMFFpeEpRVUZCTEZkQlFXVXNhME5CUVdZc1pVRkJaU3hGUVVGQk8wRkJRMklzU1VGQlFTeFRRVUU0UWl4clEwRkJPVUlzT0VKQlFUaENMRVZCUVVFN1FVRkRlRUlzU1VGQlFTeGxRVUZ2UXl4clEwRkJjRU1zYjBOQlFXOURMRVZCUVVFN1FVRkRjRU1zU1VGQlFTeGxRVUZwUXl4clEwRkJha01zYVVOQlFXbERMRVZCUVVFN1FVRkRhRU1zU1VGQlFTeG5Ra0ZCY1VNc2EwTkJRWEpETEhGRFFVRnhReXhGUVVGQk8wRkJSWGhETEVsQlFVRXNWVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJWak5ET3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQldVRXNTVUZCVVVFc1YwRkJWeXhIUVVGblEwTXNXVUZCWXl4blFrRkJla1JFTEZkQlFWY3NSVUZCUlVVc1YwRkJWeXhIUVVGdFFrUXNXVUZCWXl4blFrRkJOVU5ETEZkQlFWY3NSVUZCUlVNc1dVRkJXU3hIUVVGTFJpeFpRVUZqTEdkQ1FVRXZRa1VzV1VGQldTeEJRVUZ2UWp0QlFVVnVSQ3hKUVVGQkxFRkJRVTFETEhWQ1FVRjFRaXhwUWtOa2VrTXNRVVJqV1R0clJFRmtaanM3WVVGamNVSkJMSFZDUVVGMVFqdHpSRUZrTlVNN1VVRm5Ra2tzU1VGQlRVTXNXVUZCV1N4SFFVRkhReXhWUVVGWkxHRkJRVUVzUlVGRE0wSkRMR2REUVVGblF5eEhRVUZIVUN4WFFVRlhMRVZCUXpsRFVTeG5RMEZCWjBNc1IwRkJSMDRzVjBGQlZ5eEZRVU01UTA4c2FVTkJRV2xETEVkQlFVZE9MRmxCUVZrc1JVRkRhRVJQTEdkQ1FVRm5RaXhIUVVGSExFbEJRVWxETEZOQlFWa3NVMEZCUTA0c1dVRkJXU3hEUVVGRExFVkJRMnBFVHl3MlFrRkJOa0lzUjBGQlJ5eEpRVUZKUXl4bFFVRnJRaXhUUVVGRFRpeG5RMEZCWjBNc1EwRkJReXhGUVVONFJrOHNOa0pCUVRaQ0xFZEJRVWNzU1VGQlNVUXNaVUZCYTBJc1UwRkJRMHdzWjBOQlFXZERMRU5CUVVNc1JVRkRlRVpQTERoQ1FVRTRRaXhIUVVGSExFbEJRVWxHTEdWQlFXdENMRk5CUVVOS0xHbERRVUZwUXl4RFFVRkRMRVZCUXpGR1R5dzRRMEZCT0VNc1IwRkJSenRaUVVNdlEwb3NOa0pCUVRaQ08xbEJRemRDUml4blFrRkJaMEk3VTBGRGFrSXNSVUZEUkU4c2JVSkJRVzFDTEVkQlFVY3NTVUZCU1VNc1owSkJRVzFDTEZOQlFVTkdMRGhEUVVFNFF5eERRVUZETEVWQlF6ZEdSeXcwUWtGQk5FSXNSMEZCUnl4SlFVRkpReXhsUVVGclFpeFRRVUZEU0N4dFFrRkJiVUlzUTBGQlF5eEZRVU14UlVrc1MwRkJTeXhIUVVGSE8xbEJRMDVRTERaQ1FVRTJRanRaUVVNM1Frb3NaMEpCUVdkQ08xbEJRMmhDVXl3MFFrRkJORUk3V1VGRE5VSktMRGhDUVVFNFFqdFRRVU12UWl4QlFVRkRPMmxEUVVWR1RTeExRVUZMT3pzN1EwRkZaQ3hEUVhwQ2IwUkRMRmRCUVZVc1UwRjVRamxFTzJ0Q1FYcENiMEpzUWl4MVFrRkJkVUlzUVVGa05VTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ydWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZVwiKSk7XG52YXIgX2Nob2ljZU9mUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ub2RlL2JuZi9jaG9pY2VPZlBhcnRzXCIpKTtcbnZhciBfY2hvaWNlT2ZQYXJ0czEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL2Nob2ljZU9mUGFydHNcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIENob2ljZU9mUGFydHNSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSdWxlKSB7XG4gICAgX2luaGVyaXRzKENob2ljZU9mUGFydHNSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENob2ljZU9mUGFydHNSdWxlKTtcbiAgICBmdW5jdGlvbiBDaG9pY2VPZlBhcnRzUnVsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENob2ljZU9mUGFydHNSdWxlKTtcbiAgICAgICAgdmFyIG5hbWUgPSBfcnVsZU5hbWVzLkNob2ljZU9mUGFydHNSdWxlTmFtZSwgY2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gPSBuZXcgX2Nob2ljZU9mUGFydHMxLmRlZmF1bHQoKSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c0RlZmluaXRpb25cbiAgICAgICAgXSwgTm9kZSA9IF9jaG9pY2VPZlBhcnRzLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIENob2ljZU9mUGFydHNSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENob2ljZU9mUGFydHNSdWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl5ZFd4bEwyTm9iMmxqWlU5bVVHRnlkSE11YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxYQ0k3WEc1cGJYQnZjblFnUTJodmFXTmxUMlpRWVhKMGMwSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwyTm9iMmxqWlU5bVVHRnlkSE5jSWp0Y2JtbHRjRzl5ZENCRGFHOXBZMlZQWmxCaGNuUnpSR1ZtYVc1cGRHbHZiaUJtY205dElGd2lMaTR2WkdWbWFXNXBkR2x2Ymk5amFHOXBZMlZQWmxCaGNuUnpYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lFTm9iMmxqWlU5bVVHRnlkSE5TZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1EyaHZhV05sVDJaUVlYSjBjMUoxYkdVZ1pYaDBaVzVrY3lCU2RXeGxJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2JtRnRaU0E5SUVOb2IybGpaVTltVUdGeWRITlNkV3hsVG1GdFpTeGNiaUFnSUNBZ0lDQWdJQ0JqYUc5cFkyVlBabEJoY25SelJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCRGFHOXBZMlZQWmxCaGNuUnpSR1ZtYVc1cGRHbHZiaWdwTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTJodmFXTmxUMlpRWVhKMGMwUmxabWx1YVhScGIyNWNiaUFnSUNBZ0lDQWdJQ0JkTEZ4dUlDQWdJQ0FnSUNBZ0lFNXZaR1VnUFNCRGFHOXBZMlZQWmxCaGNuUnpRazVHVG05a1pUdGNiaUFnSUNCY2JpQWdJQ0J6ZFhCbGNpaHVZVzFsTENCaGJXSnBaM1Z2ZFhNc0lHUmxabWx1YVhScGIyNXpMQ0JPYjJSbEtWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpUTJodmFXTmxUMlpRWVhKMGMxSjFiR1VpTENKdVlXMWxJaXdpUTJodmFXTmxUMlpRWVhKMGMxSjFiR1ZPWVcxbElpd2lZMmh2YVdObFQyWlFZWEowYzBSbFptbHVhWFJwYjI0aUxDSkRhRzlwWTJWUFpsQmhjblJ6UkdWbWFXNXBkR2x2YmlJc0ltRnRZbWxuZFc5MWN5SXNJbVJsWm1sdWFYUnBiMjV6SWl3aVRtOWtaU0lzSWtOb2IybGpaVTltVUdGeWRITkNUa1pPYjJSbElpd2lVblZzWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWcFFpeEpRVUZCTEV0QlFWTXNhME5CUVZRc1UwRkJVeXhGUVVGQk8wRkJRMDhzU1VGQlFTeGpRVUV5UWl4clEwRkJNMElzTWtKQlFUSkNMRVZCUVVFN1FVRkRlRUlzU1VGQlFTeGxRVUUyUWl4clEwRkJOMElzTmtKQlFUWkNMRVZCUVVFN1FVRkZNMElzU1VGQlFTeFZRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRk9jRVE3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUlpTeEpRVUZCTEVGQlFVMUJMR2xDUVVGcFFpeHBRa05TYmtNc1FVUlJXVHR6UTBGU1pqczdZVUZSY1VKQkxHbENRVUZwUWp0blJFRlNkRU03VVVGVlNTeEpRVUZOUXl4SlFVRkpMRWRCUVVkRExGVkJRWEZDTEhOQ1FVRkJMRVZCUXpWQ1F5eDFRa0ZCZFVJc1IwRkJSeXhKUVVGSlF5eGxRVUYxUWl4VlFVRkZMRVZCUTNaRVF5eFRRVUZUTEVkQlFVY3NTMEZCU3l4RlFVTnFRa01zVjBGQlZ5eEhRVUZITzFsQlExcElMSFZDUVVGMVFqdFRRVU40UWl4RlFVTkVTU3hKUVVGSkxFZEJRVWRETEdOQlFXOUNMRkZCUVVFc1FVRkJRenRwUTBGRk5VSlFMRWxCUVVrc1JVRkJSVWtzVTBGQlV5eEZRVUZGUXl4WFFVRlhMRVZCUVVWRExFbEJRVWs3T3p0RFFVVXpReXhEUVZvNFEwVXNTMEZCU1N4VFFWbHNSRHRyUWtGYWIwSlVMR2xDUVVGcFFpeEJRVkowUXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCIpKTtcbnZhciBfdGVybWluYWxTeW1ib2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3Rlcm1pbmFsU3ltYm9sXCIpKTtcbnZhciBfYXJyYXkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbGl0aWVzL2FycmF5XCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBUZXJtaW5hbFN5bWJvbEJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhUZXJtaW5hbFN5bWJvbEJORk5vZGUsIE5vblRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUZXJtaW5hbFN5bWJvbEJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsU3ltYm9sQk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlcm1pbmFsU3ltYm9sQk5GTm9kZSk7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlZ3VsYXJFeHByZXNzaW9uXCIsIC9eXCIoKD86XFxcXC58W15cIlxcXFxdKSopXCIkLyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFRlcm1pbmFsU3ltYm9sQk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuZXJhdGVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksIHRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChjb250ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYWxTeW1ib2xQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0Q29udGVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRlbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgZmlyc3RDaGlsZE5vZGUgPSAoMCwgX2FycmF5KS5maXJzdChjaGlsZE5vZGVzKSwgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLCBtYXRjaGVzID0gdGVybWluYWxOb2RlQ29udGVudC5tYXRjaCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKSwgc2Vjb25kTWF0Y2ggPSAoMCwgX2FycmF5KS5zZWNvbmQobWF0Y2hlcyksIGNvbnRlbnQgPSBzZWNvbmRNYXRjaC5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIikucmVwbGFjZSgvXFxcXFwiL2csIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25UZXJtaW5hbC5kZWZhdWx0LmZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMoVGVybWluYWxTeW1ib2xCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gVGVybWluYWxTeW1ib2xCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZXJtaW5hbFN5bWJvbEJORk5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl1YjJSbEwySnVaaTkwWlhKdGFXNWhiRk41YldKdmJDNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUU1dmJsUmxjbTFwYm1Gc1RtOWtaU0JtY205dElGd2lMaTR2TGk0dmJtOWtaUzl1YjI1VVpYSnRhVzVoYkZ3aU8xeHVhVzF3YjNKMElGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDQm1jbTl0SUZ3aUxpNHZMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOTBaWEp0YVc1aGJGTjViV0p2YkZ3aU8xeHVYRzVwYlhCdmNuUWdleUJtYVhKemRDd2djMlZqYjI1a0lIMGdabkp2YlNCY0lpNHVMeTR1TDNWMGFXeHBkR2xsY3k5aGNuSmhlVndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJVWlhKdGFXNWhiRk41YldKdmJFSk9SazV2WkdVZ1pYaDBaVzVrY3lCT2IyNVVaWEp0YVc1aGJFNXZaR1VnZTF4dUlDQnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJpQTlJQzllWENJb0tEODZYRnhjWEM1OFcxNWNJbHhjWEZ4ZEtTb3BYQ0lrTHp0Y2JseHVJQ0JuWlc1bGNtRjBaVkJoY25Rb2JHOXZhMEZvWldGa0tTQjdYRzRnSUNBZ1kyOXVjM1FnWTI5dWRHVnVkQ0E5SUhSb2FYTXVaMlYwUTI5dWRHVnVkQ2dwTEZ4dUlDQWdJQ0FnSUNBZ0lIUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDQTlJRzVsZHlCVVpYSnRhVzVoYkZONWJXSnZiRkJoY25Rb1kyOXVkR1Z1ZENrN1hHNWNiaUFnSUNCeVpYUjFjbTRnZEdWeWJXbHVZV3hUZVcxaWIyeFFZWEowTzF4dUlDQjlYRzVjYmlBZ1oyVjBRMjl1ZEdWdWRDZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCamFHbHNaRTV2WkdWeklEMGdkR2hwY3k1blpYUkRhR2xzWkU1dlpHVnpLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ1ptbHljM1JEYUdsc1pFNXZaR1VnUFNCbWFYSnpkQ2hqYUdsc1pFNXZaR1Z6S1N4Y2JpQWdJQ0FnSUNBZ0lDQjBaWEp0YVc1aGJFNXZaR1VnUFNCbWFYSnpkRU5vYVd4a1RtOWtaU3dnSUM4dkwxeHVJQ0FnSUNBZ0lDQWdJSFJsY20xcGJtRnNUbTlrWlVOdmJuUmxiblFnUFNCMFpYSnRhVzVoYkU1dlpHVXVaMlYwUTI5dWRHVnVkQ2dwTEZ4dUlDQWdJQ0FnSUNBZ0lHMWhkR05vWlhNZ1BTQjBaWEp0YVc1aGJFNXZaR1ZEYjI1MFpXNTBMbTFoZEdOb0tIUm9hWE11Y21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRwTEZ4dUlDQWdJQ0FnSUNBZ0lITmxZMjl1WkUxaGRHTm9JRDBnYzJWamIyNWtLRzFoZEdOb1pYTXBMRnh1SUNBZ0lDQWdJQ0FnSUdOdmJuUmxiblFnUFNCelpXTnZibVJOWVhSamFDNXlaWEJzWVdObEtDOWNYRnhjWEZ4Y1hDOW5MQ0JjSWx4Y1hGeGNJaWt1Y21Wd2JHRmpaU2d2WEZ4Y1hGd2lMMmNzSUZ3aVhGeGNJbHdpS1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJqYjI1MFpXNTBPMXh1SUNCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9jblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wSUhzZ2NtVjBkWEp1SUU1dmJsUmxjbTFwYm1Gc1RtOWtaUzVtY205dFVuVnNaVTVoYldWQmJtUkRhR2xzWkU1dlpHVnpLRlJsY20xcGJtRnNVM2x0WW05c1FrNUdUbTlrWlN3Z2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBPeUI5WEc1OVhHNWNiaUpkTENKdVlXMWxjeUk2V3lKVVpYSnRhVzVoYkZONWJXSnZiRUpPUms1dlpHVWlMQ0p5WldkMWJHRnlSWGh3Y21WemMybHZiaUlzSW1kbGJtVnlZWFJsVUdGeWRDSXNJbXh2YjJ0QmFHVmhaQ0lzSW1OdmJuUmxiblFpTENKblpYUkRiMjUwWlc1MElpd2lkR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJaXdpVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSWl3aVkyaHBiR1JPYjJSbGN5SXNJbWRsZEVOb2FXeGtUbTlrWlhNaUxDSm1hWEp6ZEVOb2FXeGtUbTlrWlNJc0ltWnBjbk4wSWl3aWRHVnliV2x1WVd4T2IyUmxJaXdpZEdWeWJXbHVZV3hPYjJSbFEyOXVkR1Z1ZENJc0ltMWhkR05vWlhNaUxDSnRZWFJqYUNJc0luTmxZMjl1WkUxaGRHTm9JaXdpYzJWamIyNWtJaXdpY21Wd2JHRmpaU0lzSW1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1pTENKeWRXeGxUbUZ0WlNJc0lrNXZibFJsY20xcGJtRnNUbTlrWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVMFFpeEpRVUZCTEZsQlFYZENMR3REUVVGNFFpeDNRa0ZCZDBJc1JVRkJRVHRCUVVOeVFpeEpRVUZCTEdWQlFXOURMR3REUVVGd1F5eHZRMEZCYjBNc1JVRkJRVHRCUVVWeVF5eEpRVUZCTEUxQlFYVkNMRmRCUVhaQ0xIVkNRVUYxUWl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJUSEpFTzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN096czdPMVZCUVVFN08zZENRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlBaU3hKUVVGQkxFRkJRVTFCTEhGQ1FVRnhRaXhwUWtOUWVFTXNRVVJQWVR0eFJFRlFaanM3WVVGUGNVSkJMSEZDUVVGeFFqdHZSRUZRTVVNN096WkRRVUZCTzFGQlVVVkRMQ3REUVVGQlFTeHRRa0ZCYVVJc01FSkJRVEpDTEVGRlVqbERMRU5HVVRoRE96czdPenRaUVVVMVEwTXNSMEZCV1N4RlFVRmFRU3hqUVVGWk8xbEZWbVFzVDBaVlJVRXNVMEZCUVVFc1dVRkJXU3hEUVVGRFF5eFRRVUZUTEVWQlFVVTdaMEpCUTNSQ0xFbEJRVTFETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVORExGVkJRVlVzUlVGQlJTeEZRVU16UWtNc2EwSkJRV3RDTEVkQlFVY3NTVUZCU1VNc1pVRkJhMElzVTBGQlEwZ3NUMEZCVHl4RFFVRkRMRUZCUVVNN1owSkJSVE5FTEU5QlFVOUZMR3RDUVVGclFpeERRVUZETzJGQlF6TkNPenM3V1VGRlJFUXNSMEZCVlN4RlFVRldRU3haUVVGVk8xbEZha0phTEU5R2FVSkZRU3hUUVVGQlFTeFZRVUZWTEVkQlFVYzdaMEpCUTFnc1NVRkJUVWNzVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hGUVVGRkxFVkJRMnBEUXl4alFVRmpMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTFCUVVzc1FVRkJXU3hEUVVGQkxFOUJRVmhJTEZWQlFWVXNRMEZCUXl4RlFVTnNRMGtzV1VGQldTeEhRVUZIUml4alFVRmpMRVZCUXpkQ1J5eHRRa0ZCYlVJc1IwRkJSMFFzV1VGQldTeERRVUZEVUN4VlFVRlZMRVZCUVVVc1JVRkRMME5UTEU5QlFVOHNSMEZCUjBRc2JVSkJRVzFDTEVOQlFVTkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU5rTEdsQ1FVRnBRaXhEUVVGRExFVkJRek5FWlN4WFFVRlhMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTFCUVUwc1FVRkJVeXhEUVVGQkxGRkJRVkpJTEU5QlFVOHNRMEZCUXl4RlFVTTNRbFlzVDBGQlR5eEhRVUZIV1N4WFFVRlhMRU5CUVVORkxFOUJRVThzVlVGQlZTeEpRVUZKTEVOQlFVTXNRMEZCUTBFc1QwRkJUeXhUUVVGVExFbEJRVWtzUTBGQlF5eEJRVUZETzJkQ1FVVjZSU3hQUVVGUFpDeFBRVUZQTEVOQlFVTTdZVUZEYUVJN096czdXVUZGVFdVc1IwRkJlVUlzUlVGQmVrSkJMREpDUVVGNVFqdFpSVGRDYkVNc1QwWTJRa1VzVTBGQlQwRXNlVUpCUVhsQ0xFTkJRVU5ETEZGQlFWRXNSVUZCUlZvc1ZVRkJWU3hGUVVGRk8yZENRVUZGTEU5QlFVOWhMRmxCUVdVc1UwRkJRMFlzZVVKQlFYbENMRU5CUVVOdVFpeHhRa0ZCY1VJc1JVRkJSVzlDTEZGQlFWRXNSVUZCUlZvc1ZVRkJWU3hEUVVGRExFTkJRVU03WVVGQlJUczdUVUUzUWpOS096dERRVGhDUXl4RFFYWkNhMFJoTEZsQlFXVXNVMEYxUW1wRk8ydENRWFpDYjBKeVFpeHhRa0ZCY1VJc1FVRlFNVU1pZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb25cIikpO1xudmFyIF9zaWduaWZpY2FudFRva2VuVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24oc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBuZXcgX3NpZ25pZmljYW50VG9rZW5UeXBlLmRlZmF1bHQoc2lnbmlmaWNhbnRUb2tlblR5cGUpLCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUGFydFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcGFydHMpO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uO1xufShfZGVmaW5pdGlvbi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwzTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZibHdpTzF4dWFXMXdiM0owSUZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFVHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOXphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlVSbFptbHVhWFJwYjI0Z1pYaDBaVzVrY3lCRVpXWnBibWwwYVc5dUlIdGNiaUFnWTI5dWMzUnlkV04wYjNJb2MybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVXBJSHRjYmlBZ0lDQmpiMjV6ZENCemFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pWQmhjblFnUFNCdVpYY2dVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZRWVhKMEtITnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxLU3hjYmlBZ0lDQWdJQ0FnSUNCd1lYSjBjeUE5SUZ0Y2JpQWdJQ0FnSUNBZ0lDQWdJSE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsVUdGeWRGeHVJQ0FnSUNBZ0lDQWdJRjA3WEc0Z0lDQWdYRzRnSUNBZ2MzVndaWElvY0dGeWRITXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pVUmxabWx1YVhScGIyNGlMQ0p6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlNJc0luTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxVR0Z5ZENJc0lsTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxVR0Z5ZENJc0luQmhjblJ6SWl3aVJHVm1hVzVwZEdsdmJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVjFRaXhKUVVGQkxGZEJRV1VzYTBOQlFXWXNaVUZCWlN4RlFVRkJPMEZCUTBRc1NVRkJRU3h4UWtGQmRVTXNhME5CUVhaRExIVkRRVUYxUXl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRklOVVU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGTFpTeEpRVUZCTEVGQlFVMUJMRGhDUVVFNFFpeHBRa05NYUVRc1FVUkxXVHQ1UkVGTVpqczdZVUZMY1VKQkxEaENRVUU0UWl4RFFVTnlRME1zYjBKQlFXOUNPelpFUVU1c1F6dFJRVTlKTEVsQlFVMURMSGRDUVVGM1FpeEhRVUZITEVsQlFVbERMSEZDUVVGM1FpeFRRVUZEUml4dlFrRkJiMElzUTBGQlF5eEZRVU0zUlVjc1MwRkJTeXhIUVVGSE8xbEJRMDVHTEhkQ1FVRjNRanRUUVVONlFpeEJRVUZETzJsRFFVVkdSU3hMUVVGTE96czdRMEZGWkN4RFFWUXlSRU1zVjBGQlZTeFRRVk55UlR0clFrRlViMEpNTERoQ1FVRTRRaXhCUVV4dVJDSjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3Rlcm1pbmFsU3ltYm9sXCIpKTtcbnZhciBfc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL3NpZ25pZmljYW50VG9rZW5UeXBlXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBzdHJpbmdMaXRlcmFsVHlwZSA9IF9vY2NhbUxleGVycy50eXBlcy5zdHJpbmdMaXRlcmFsVHlwZTtcbnZhciBUZXJtaW5hbFN5bWJvbFJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoVGVybWluYWxTeW1ib2xSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRlcm1pbmFsU3ltYm9sUnVsZSk7XG4gICAgZnVuY3Rpb24gVGVybWluYWxTeW1ib2xSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVybWluYWxTeW1ib2xSdWxlKTtcbiAgICAgICAgdmFyIHN0cmluZ0xpdGVyYWxTaWduaWZpY2FudFRva2VuVHlwZSA9IHN0cmluZ0xpdGVyYWxUeXBlLCBzdHJpbmdMaXRlcmFsU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uID0gbmV3IF9zaWduaWZpY2FudFRva2VuVHlwZS5kZWZhdWx0KHN0cmluZ0xpdGVyYWxTaWduaWZpY2FudFRva2VuVHlwZSksIG5hbWUgPSBfcnVsZU5hbWVzLlRlcm1pbmFsU3ltYm9sUnVsZU5hbWUsIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb25cbiAgICAgICAgXSwgTm9kZSA9IF90ZXJtaW5hbFN5bWJvbC5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXJtaW5hbFN5bWJvbFJ1bGU7XG59KF9ydWxlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVybWluYWxTeW1ib2xSdWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl5ZFd4bEwzUmxjbTFwYm1Gc1UzbHRZbTlzTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdleUIwZVhCbGN5QjlJR1p5YjIwZ1hDSnZZMk5oYlMxc1pYaGxjbk5jSWp0Y2JseHVhVzF3YjNKMElGSjFiR1VnWm5KdmJTQmNJaTR1TDNKMWJHVmNJanRjYm1sdGNHOXlkQ0JVWlhKdGFXNWhiRk41YldKdmJFSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwzUmxjbTFwYm1Gc1UzbHRZbTlzWENJN1hHNXBiWEJ2Y25RZ1UybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVkVaV1pwYm1sMGFXOXVJR1p5YjIwZ1hDSXVMaTlrWldacGJtbDBhVzl1TDNOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFhDSTdYRzVjYm1sdGNHOXlkQ0I3SUZSbGNtMXBibUZzVTNsdFltOXNVblZzWlU1aGJXVWdmU0JtY205dElGd2lMaTR2Y25Wc1pVNWhiV1Z6WENJN1hHNWNibU52Ym5OMElIc2djM1J5YVc1blRHbDBaWEpoYkZSNWNHVWdmU0E5SUhSNWNHVnpPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlVaWEp0YVc1aGJGTjViV0p2YkZKMWJHVWdaWGgwWlc1a2N5QlNkV3hsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdjM1J5YVc1blRHbDBaWEpoYkZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbElEMGdjM1J5YVc1blRHbDBaWEpoYkZSNWNHVXNJQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnpkSEpwYm1kTWFYUmxjbUZzVTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dWRVpXWnBibWwwYVc5dUlEMGdibVYzSUZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFJHVm1hVzVwZEdsdmJpaHpkSEpwYm1kTWFYUmxjbUZzVTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dVcExGeHVJQ0FnSUNBZ0lDQWdJRzVoYldVZ1BTQlVaWEp0YVc1aGJGTjViV0p2YkZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYzNSeWFXNW5UR2wwWlhKaGJGTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxSR1ZtYVc1cGRHbHZibHh1SUNBZ0lDQWdJQ0FnSUYwc1hHNGdJQ0FnSUNBZ0lDQWdUbTlrWlNBOUlGUmxjbTFwYm1Gc1UzbHRZbTlzUWs1R1RtOWtaVHRjYmx4dUlDQWdJSE4xY0dWeUtHNWhiV1VzSUdGdFltbG5kVzkxY3l3Z1pHVm1hVzVwZEdsdmJuTXNJRTV2WkdVcFhHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUp6ZEhKcGJtZE1hWFJsY21Gc1ZIbHdaU0lzSW5SNWNHVnpJaXdpVkdWeWJXbHVZV3hUZVcxaWIyeFNkV3hsSWl3aWMzUnlhVzVuVEdsMFpYSmhiRk5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsSWl3aWMzUnlhVzVuVEdsMFpYSmhiRk5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsUkdWbWFXNXBkR2x2YmlJc0lsTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxSR1ZtYVc1cGRHbHZiaUlzSW01aGJXVWlMQ0pVWlhKdGFXNWhiRk41YldKdmJGSjFiR1ZPWVcxbElpd2lZVzFpYVdkMWIzVnpJaXdpWkdWbWFXNXBkR2x2Ym5NaUxDSk9iMlJsSWl3aVZHVnliV2x1WVd4VGVXMWliMnhDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnpRaXhKUVVGQkxGbEJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdRVUZGYmtJc1NVRkJRU3hMUVVGVExHdERRVUZVTEZOQlFWTXNSVUZCUVR0QlFVTlJMRWxCUVVFc1pVRkJORUlzYTBOQlFUVkNMRFJDUVVFMFFpeEZRVUZCTzBGQlEyNUNMRWxCUVVFc2NVSkJRVzlETEd0RFFVRndReXh2UTBGQmIwTXNSVUZCUVR0QlFVVjRReXhKUVVGQkxGVkJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdPenM3T3pzN096czdPenM3T3p0TFFWSnlSRHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVZWQkxFbEJRVTBzUVVGQlJVRXNhVUpCUVdsQ0xFZEJRVXRETEZsQlFVc3NUMEZCTTBKRUxHbENRVUZwUWl4QlFVRlZMRUZCUVVNN1FVRkZja0lzU1VGQlFTeEJRVUZOUlN4clFrRkJhMElzYVVKRFduQkRMRUZFV1ZrN2RVTkJXbVk3TzJGQldYRkNRU3hyUWtGQmEwSTdhVVJCV25aRE8xRkJZMGtzU1VGQlRVTXNhVU5CUVdsRExFZEJRVWRJTEdsQ1FVRnBRaXhGUVVOeVJFa3NNa05CUVRKRExFZEJRVWNzU1VGQlNVTXNjVUpCUVRoQ0xGTkJRVU5HTEdsRFFVRnBReXhEUVVGRExFVkJRMjVJUnl4SlFVRkpMRWRCUVVkRExGVkJRWE5DTEhWQ1FVRkJMRVZCUXpkQ1F5eFRRVUZUTEVkQlFVY3NTMEZCU3l4RlFVTnFRa01zVjBGQlZ5eEhRVUZITzFsQlExcE1MREpEUVVFeVF6dFRRVU0xUXl4RlFVTkVUU3hKUVVGSkxFZEJRVWRETEdWQlFYRkNMRkZCUVVFc1FVRkJRenRwUTBGRk4wSk1MRWxCUVVrc1JVRkJSVVVzVTBGQlV5eEZRVUZGUXl4WFFVRlhMRVZCUVVWRExFbEJRVWs3T3p0RFFVVXpReXhEUVdJclEwVXNTMEZCU1N4VFFXRnVSRHRyUWtGaWIwSldMR3RDUVVGclFpeEJRVnAyUXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlL25vblRlcm1pbmFsXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIE5vblRlcm1pbmFsUGFydEJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhOb25UZXJtaW5hbFBhcnRCTkZOb2RlLCBOb25UZXJtaW5hbE5vZGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTm9uVGVybWluYWxQYXJ0Qk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gTm9uVGVybWluYWxQYXJ0Qk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vblRlcm1pbmFsUGFydEJORk5vZGUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhOb25UZXJtaW5hbFBhcnRCTkZOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZW5lcmF0ZVBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVBhcnQobG9va0FoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgbm9kZXMgPSBjaGlsZE5vZGVzLnNsaWNlKCksIHBhcnQgPSBwYXJ0RnJvbU5vZGVzKG5vZGVzLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhOb25UZXJtaW5hbFBhcnRCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9uVGVybWluYWxQYXJ0Qk5GTm9kZTtcbn0oX25vblRlcm1pbmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9uVGVybWluYWxQYXJ0Qk5GTm9kZTtcbmZ1bmN0aW9uIHBhcnRGcm9tTm9kZXMobm9kZXMsIGxvb2tBaGVhZCkge1xuICAgIHZhciBwYXJ0ID0gbnVsbDtcbiAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgaWYgKG5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXMucG9wKCk7XG4gICAgICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChsb29rQWhlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnBvcCgpO1xuICAgICAgICBsb29rQWhlYWQgPSB0cnVlO1xuICAgICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2RlcywgbG9va0FoZWFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdUbTl1VkdWeWJXbHVZV3hPYjJSbElHWnliMjBnWENJdUxpOHVMaTh1TGk5dWIyUmxMMjV2YmxSbGNtMXBibUZzWENJN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUU1dmJsUmxjbTFwYm1Gc1VHRnlkRUpPUms1dlpHVWdaWGgwWlc1a2N5Qk9iMjVVWlhKdGFXNWhiRTV2WkdVZ2UxeHVJQ0JuWlc1bGNtRjBaVkJoY25Rb2JHOXZhMEZvWldGa0tTQjdYRzRnSUNBZ1kyOXVjM1FnWTJocGJHUk9iMlJsY3lBOUlIUm9hWE11WjJWMFEyaHBiR1JPYjJSbGN5Z3BMRnh1SUNBZ0lDQWdJQ0FnSUc1dlpHVnpJRDBnWTJocGJHUk9iMlJsY3k1emJHbGpaU2dwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblFnUFNCd1lYSjBSbkp2YlU1dlpHVnpLRzV2WkdWekxDQnNiMjlyUVdobFlXUXBPMXh1WEc0Z0lDQWdjbVYwZFhKdUlIQmhjblE3WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeWh5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrZ2V5QnlaWFIxY200Z1RtOXVWR1Z5YldsdVlXeE9iMlJsTG1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1vVG05dVZHVnliV2x1WVd4UVlYSjBRazVHVG05a1pTd2djblZzWlU1aGJXVXNJR05vYVd4a1RtOWtaWE1wT3lCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUhCaGNuUkdjbTl0VG05a1pYTW9ibTlrWlhNc0lHeHZiMnRCYUdWaFpDa2dlMXh1SUNCc1pYUWdjR0Z5ZENBOUlHNTFiR3c3WEc1Y2JpQWdZMjl1YzNRZ2JtOWtaWE5NWlc1bmRHZ2dQU0J1YjJSbGN5NXNaVzVuZEdnN1hHNWNiaUFnYVdZZ0tHNXZaR1Z6VEdWdVozUm9JRDA5UFNBeEtTQjdYRzRnSUNBZ1kyOXVjM1FnYm05a1pTQTlJRzV2WkdWekxuQnZjQ2dwTzF4dVhHNGdJQ0FnY0dGeWRDQTlJRzV2WkdVdVoyVnVaWEpoZEdWUVlYSjBLR3h2YjJ0QmFHVmhaQ2s3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnYm05a1pYTXVjRzl3S0NrN1hHNWNiaUFnSUNCc2IyOXJRV2hsWVdRZ1BTQjBjblZsTzF4dVhHNGdJQ0FnY0dGeWRDQTlJSEJoY25SR2NtOXRUbTlrWlhNb2JtOWtaWE1zSUd4dmIydEJhR1ZoWkNrN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2NHRnlkRHRjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUpPYjI1VVpYSnRhVzVoYkZCaGNuUkNUa1pPYjJSbElpd2laMlZ1WlhKaGRHVlFZWEowSWl3aWJHOXZhMEZvWldGa0lpd2lZMmhwYkdST2IyUmxjeUlzSW1kbGRFTm9hV3hrVG05a1pYTWlMQ0p1YjJSbGN5SXNJbk5zYVdObElpd2ljR0Z5ZENJc0luQmhjblJHY205dFRtOWtaWE1pTENKbWNtOXRVblZzWlU1aGJXVkJibVJEYUdsc1pFNXZaR1Z6SWl3aWNuVnNaVTVoYldVaUxDSk9iMjVVWlhKdGFXNWhiRTV2WkdVaUxDSnViMlJsYzB4bGJtZDBhQ0lzSW14bGJtZDBhQ0lzSW01dlpHVWlMQ0p3YjNBaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRk5FSXNTVUZCUVN4WlFVRXlRaXhyUTBGQk0wSXNNa0pCUVRKQ0xFVkJRVUU3T3pzN096czdPenM3T3pzN096czRSRUZHZGtRN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlNXVXNTVUZCUVN4QlFVRk5RU3h6UWtGQmMwSXNhVUpCV1hoRExFRkJXbGs3YzBSQlNtWTdPMkZCU1hGQ1FTeHpRa0ZCYzBJN2NVUkJTak5ET3pzN096dFpRVXRGUXl4SFFVRlpMRVZCUVZwQkxHTkJRVms3V1VOTVpDeFBSRXRGUVN4VFFVRkJRU3haUVVGWkxFTkJRVU5ETEZOQlFWTXNSVUZCUlR0blFrRkRkRUlzU1VGQlRVTXNWVUZCVlN4SFFVRkhMRWxCUVVrc1EwRkJRME1zWVVGQllTeEZRVUZGTEVWQlEycERReXhMUVVGTExFZEJRVWRHTEZWQlFWVXNRMEZCUTBjc1MwRkJTeXhGUVVGRkxFVkJRekZDUXl4SlFVRkpMRWRCUVVkRExHRkJRV0VzUTBGQlEwZ3NTMEZCU3l4RlFVRkZTQ3hUUVVGVExFTkJRVU1zUVVGQlF6dG5Ra0ZGTjBNc1QwRkJUMHNzU1VGQlNTeERRVUZETzJGQlEySTdPenM3V1VGRlRVVXNSMEZCZVVJc1JVRkJla0pCTERKQ1FVRjVRanRaUTJKc1F5eFBSR0ZGTEZOQlFVOUJMSGxDUVVGNVFpeERRVUZEUXl4UlFVRlJMRVZCUVVWUUxGVkJRVlVzUlVGQlJUdG5Ra0ZCUlN4UFFVRlBVU3haUVVGbExGTkJRVU5HTEhsQ1FVRjVRaXhEUVVGRFZDeHpRa0ZCYzBJc1JVRkJSVlVzVVVGQlVTeEZRVUZGVUN4VlFVRlZMRU5CUVVNc1EwRkJRenRoUVVGRk96dE5RV0kxU2pzN1EwRmpReXhEUVZadFJGRXNXVUZCWlN4VFFWVnNSVHRyUWtGV2IwSllMSE5DUVVGelFpeEJRVW96UXp0QlFXZENRU3hUUVVGVFVTeGhRVUZoTEVOQlFVTklMRXRCUVVzc1JVRkJSVWdzVTBGQlV5eEZRVUZGTzBsQlEzWkRMRWxCUVVsTExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVGQlFVTTdTVUZGYUVJc1NVRkJUVXNzVjBGQlZ5eEhRVUZIVUN4TFFVRkxMRU5CUVVOUkxFMUJRVTBzUVVGQlF6dEpRVVZxUXl4SlFVRkpSQ3hYUVVGWExFdEJRVXNzUTBGQlF5eEZRVUZGTzFGQlEzSkNMRWxCUVUxRkxFbEJRVWtzUjBGQlIxUXNTMEZCU3l4RFFVRkRWU3hIUVVGSExFVkJRVVVzUVVGQlF6dFJRVVY2UWxJc1NVRkJTU3hIUVVGSFR5eEpRVUZKTEVOQlFVTmlMRmxCUVZrc1EwRkJRME1zVTBGQlV5eERRVUZETEVOQlFVTTdTMEZEY2tNc1RVRkJUVHRSUVVOTVJ5eExRVUZMTEVOQlFVTlZMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJSVnBpTEZOQlFWTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkZha0pMTEVsQlFVa3NSMEZCUjBNc1lVRkJZU3hEUVVGRFNDeExRVUZMTEVWQlFVVklMRk5CUVZNc1EwRkJReXhEUVVGRE8wdEJRM2hETzBsQlJVUXNUMEZCVDBzc1NVRkJTU3hEUVVGRE8wTkJRMklpZlE9PSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uL2RlZmluaXRpb25cIikpO1xudmFyIF9ydWxlTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIikpO1xudmFyIF9vcHRpb25hbFBhcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhSdWxlTmFtZU5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uLCBEZWZpbml0aW9uKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24pO1xuICAgIGZ1bmN0aW9uIFJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdWxlTmFtZU5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uKTtcbiAgICAgICAgdmFyIHJ1bGVOYW1lUnVsZU5hbWUgPSBfcnVsZU5hbWVzLlJ1bGVOYW1lUnVsZU5hbWUsIGxvb2tBaGVhZE1vZGlmaWVyUnVsZU5hbWUgPSBfcnVsZU5hbWVzLkxvb2tBaGVhZE1vZGlmaWVyUnVsZU5hbWUsIHJ1bGVOYW1lUnVsZU5hbWVQYXJ0ID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KHJ1bGVOYW1lUnVsZU5hbWUpLCBsb29rQWhlYWRNb2RpZmllclJ1bGVOYW1lUGFydCA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChsb29rQWhlYWRNb2RpZmllclJ1bGVOYW1lKSwgb3B0aW9uYWxMb29rQWhlYWRSdWxlTmFtZVBhcnRQYXJ0ID0gbmV3IF9vcHRpb25hbFBhcnQuZGVmYXVsdChsb29rQWhlYWRNb2RpZmllclJ1bGVOYW1lUGFydCksIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbExvb2tBaGVhZFJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb247XG59KF9kZWZpbml0aW9uLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlrWldacGJtbDBhVzl1TDNCaGNuUlNkV3hsTDI1dmJsUmxjbTFwYm1Gc0wzSjFiR1ZPWVcxbExtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dkxpNHZMaTR2WkdWbWFXNXBkR2x2Ymx3aU8xeHVhVzF3YjNKMElGSjFiR1ZPWVcxbFVHRnlkQ0JtY205dElGd2lMaTR2TGk0dkxpNHZjR0Z5ZEM5dWIyNVVaWEp0YVc1aGJDOXlkV3hsVG1GdFpWd2lPMXh1YVcxd2IzSjBJRTl3ZEdsdmJtRnNVR0Z5ZEZCaGNuUWdabkp2YlNCY0lpNHVMeTR1THk0dUwzQmhjblF2Ym05dVZHVnliV2x1WVd3dmIzQjBhVzl1WVd4UVlYSjBYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGSjFiR1ZPWVcxbFVuVnNaVTVoYldVc0lFeHZiMnRCYUdWaFpFMXZaR2xtYVdWeVVuVnNaVTVoYldVZ2ZTQm1jbTl0SUZ3aUxpNHZMaTR2TGk0dmNuVnNaVTVoYldWelhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGSjFiR1ZPWVcxbFRtOXVWR1Z5YldsdVlXeFFZWEowVW5Wc1pVUmxabWx1YVhScGIyNGdaWGgwWlc1a2N5QkVaV1pwYm1sMGFXOXVJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2NuVnNaVTVoYldWU2RXeGxUbUZ0WlNBOUlGSjFiR1ZPWVcxbFVuVnNaVTVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdiRzl2YTBGb1pXRmtUVzlrYVdacFpYSlNkV3hsVG1GdFpTQTlJRXh2YjJ0QmFHVmhaRTF2WkdsbWFXVnlVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnY25Wc1pVNWhiV1ZTZFd4bFRtRnRaVkJoY25RZ1BTQnVaWGNnVW5Wc1pVNWhiV1ZRWVhKMEtISjFiR1ZPWVcxbFVuVnNaVTVoYldVcExGeHVJQ0FnSUNBZ0lDQWdJR3h2YjJ0QmFHVmhaRTF2WkdsbWFXVnlVblZzWlU1aGJXVlFZWEowSUQwZ2JtVjNJRkoxYkdWT1lXMWxVR0Z5ZENoc2IyOXJRV2hsWVdSTmIyUnBabWxsY2xKMWJHVk9ZVzFsS1N4Y2JpQWdJQ0FnSUNBZ0lDQnZjSFJwYjI1aGJFeHZiMnRCYUdWaFpGSjFiR1ZPWVcxbFVHRnlkRkJoY25RZ1BTQnVaWGNnVDNCMGFXOXVZV3hRWVhKMFVHRnlkQ2hzYjI5clFXaGxZV1JOYjJScFptbGxjbEoxYkdWT1lXMWxVR0Z5ZENrc1hHNGdJQ0FnSUNBZ0lDQWdjR0Z5ZEhNZ1BTQmJYRzRnSUNBZ0lDQWdJQ0FnSUNCeWRXeGxUbUZ0WlZKMWJHVk9ZVzFsVUdGeWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUc5d2RHbHZibUZzVEc5dmEwRm9aV0ZrVW5Wc1pVNWhiV1ZRWVhKMFVHRnlkRnh1SUNBZ0lDQWdJQ0FnSUYwN1hHNGdJQ0FnWEc0Z0lDQWdjM1Z3WlhJb2NHRnlkSE1wWEc0Z0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SlNkV3hsVG1GdFpVNXZibFJsY20xcGJtRnNVR0Z5ZEZKMWJHVkVaV1pwYm1sMGFXOXVJaXdpY25Wc1pVNWhiV1ZTZFd4bFRtRnRaU0lzSWxKMWJHVk9ZVzFsVW5Wc1pVNWhiV1VpTENKc2IyOXJRV2hsWVdSTmIyUnBabWxsY2xKMWJHVk9ZVzFsSWl3aVRHOXZhMEZvWldGa1RXOWthV1pwWlhKU2RXeGxUbUZ0WlNJc0luSjFiR1ZPWVcxbFVuVnNaVTVoYldWUVlYSjBJaXdpVW5Wc1pVNWhiV1ZRWVhKMElpd2liRzl2YTBGb1pXRmtUVzlrYVdacFpYSlNkV3hsVG1GdFpWQmhjblFpTENKdmNIUnBiMjVoYkV4dmIydEJhR1ZoWkZKMWJHVk9ZVzFsVUdGeWRGQmhjblFpTENKUGNIUnBiMjVoYkZCaGNuUlFZWEowSWl3aWNHRnlkSE1pTENKRVpXWnBibWwwYVc5dUlsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJYVkNMRWxCUVVFc1YwRkJjVUlzYTBOQlFYSkNMSEZDUVVGeFFpeEZRVUZCTzBGQlEyNUNMRWxCUVVFc1UwRkJiME1zYTBOQlFYQkRMRzlEUVVGdlF5eEZRVUZCTzBGQlEyaERMRWxCUVVFc1lVRkJkME1zYTBOQlFYaERMSGREUVVGM1F5eEZRVUZCTzBGQlJWUXNTVUZCUVN4VlFVRnZRaXhYUVVGd1FpeHZRa0ZCYjBJc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJUbWhHT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlVXVXNTVUZCUVN4QlFVRk5RU3h4UTBGQmNVTXNhVUpEVW5aRUxFRkVVVms3WjBWQlVtWTdPMkZCVVhGQ1FTeHhRMEZCY1VNN2IwVkJVakZFTzFGQlZVa3NTVUZCVFVNc1owSkJRV2RDTEVkQlFVZERMRlZCUVdkQ0xHbENRVUZCTEVWQlEyNURReXg1UWtGQmVVSXNSMEZCUjBNc1ZVRkJlVUlzTUVKQlFVRXNSVUZEY2tSRExHOUNRVUZ2UWl4SFFVRkhMRWxCUVVsRExGTkJRVmtzVTBGQlEwd3NaMEpCUVdkQ0xFTkJRVU1zUlVGRGVrUk5MRFpDUVVFMlFpeEhRVUZITEVsQlFVbEVMRk5CUVZrc1UwRkJRMGdzZVVKQlFYbENMRU5CUVVNc1JVRkRNMFZMTEdsRFFVRnBReXhIUVVGSExFbEJRVWxETEdGQlFXZENMRk5CUVVOR0xEWkNRVUUyUWl4RFFVRkRMRVZCUTNaR1J5eExRVUZMTEVkQlFVYzdXVUZEVGt3c2IwSkJRVzlDTzFsQlEzQkNSeXhwUTBGQmFVTTdVMEZEYkVNc1FVRkJRenRwUTBGRlJrVXNTMEZCU3pzN08wTkJSV1FzUTBGa2EwVkRMRmRCUVZVc1UwRmpOVVU3YTBKQlpHOUNXQ3h4UTBGQmNVTXNRVUZTTVVRaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfcnVsZU5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL3J1bGVOYW1lXCIpKTtcbnZhciBfbm9uVGVybWluYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ub2RlL2JuZi9wYXJ0L25vblRlcm1pbmFsXCIpKTtcbnZhciBfcnVsZU5hbWUxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9wYXJ0UnVsZS9ub25UZXJtaW5hbC9ydWxlTmFtZVwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgTm9uVGVybWluYWxQYXJ0UnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhOb25UZXJtaW5hbFBhcnRSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vblRlcm1pbmFsUGFydFJ1bGUpO1xuICAgIGZ1bmN0aW9uIE5vblRlcm1pbmFsUGFydFJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25UZXJtaW5hbFBhcnRSdWxlKTtcbiAgICAgICAgdmFyIG5hbWUgPSBfcnVsZU5hbWVzLk5vblRlcm1pbmFsUGFydFJ1bGVOYW1lLCBjaG9pY2VPZlBhcnRzUnVsZU5hbWUgPSBfcnVsZU5hbWVzLkNob2ljZU9mUGFydHNSdWxlTmFtZSwgc2VxdWVuY2VPZlBhcnRzUnVsZU5hbWUgPSBfcnVsZU5hbWVzLlNlcXVlbmNlT2ZQYXJ0c1J1bGVOYW1lLCBjaG9pY2VPZlBhcnRzUnVsZU5hbWVEZWZpbml0aW9uID0gbmV3IF9ydWxlTmFtZS5kZWZhdWx0KGNob2ljZU9mUGFydHNSdWxlTmFtZSksIHNlcXVlbmNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChzZXF1ZW5jZU9mUGFydHNSdWxlTmFtZSksIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSBuZXcgX3J1bGVOYW1lMS5kZWZhdWx0KCksIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNob2ljZU9mUGFydHNSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBydWxlTmFtZU5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfbm9uVGVybWluYWwuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gTm9uVGVybWluYWxQYXJ0UnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBOb25UZXJtaW5hbFBhcnRSdWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl5ZFd4bEwyNXZibFJsY20xcGJtRnNVR0Z5ZEM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJRkoxYkdVZ1puSnZiU0JjSWk0dUwzSjFiR1ZjSWp0Y2JtbHRjRzl5ZENCU2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI0Z1puSnZiU0JjSWk0dUwyUmxabWx1YVhScGIyNHZjblZzWlU1aGJXVmNJanRjYm1sdGNHOXlkQ0JPYjI1VVpYSnRhVzVoYkZCaGNuUkNUa1pPYjJSbElHWnliMjBnWENJdUxpOXViMlJsTDJKdVppOXdZWEowTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVwYlhCdmNuUWdVblZzWlU1aGJXVk9iMjVVWlhKdGFXNWhiRkJoY25SU2RXeGxSR1ZtYVc1cGRHbHZiaUJtY205dElGd2lMaTR2WkdWbWFXNXBkR2x2Ymk5d1lYSjBVblZzWlM5dWIyNVVaWEp0YVc1aGJDOXlkV3hsVG1GdFpWd2lPMXh1WEc1cGJYQnZjblFnZXlCT2IyNVVaWEp0YVc1aGJGQmhjblJTZFd4bFRtRnRaU3dnUTJodmFXTmxUMlpRWVhKMGMxSjFiR1ZPWVcxbExDQlRaWEYxWlc1alpVOW1VR0Z5ZEhOU2RXeGxUbUZ0WlNCOUlHWnliMjBnWENJdUxpOXlkV3hsVG1GdFpYTmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaU0JsZUhSbGJtUnpJRkoxYkdVZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lncElIdGNiaUFnSUNCamIyNXpkQ0J1WVcxbElEMGdUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaVTVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdZMmh2YVdObFQyWlFZWEowYzFKMWJHVk9ZVzFsSUQwZ1EyaHZhV05sVDJaUVlYSjBjMUoxYkdWT1lXMWxMRnh1SUNBZ0lDQWdJQ0FnSUhObGNYVmxibU5sVDJaUVlYSjBjMUoxYkdWT1lXMWxJRDBnVTJWeGRXVnVZMlZQWmxCaGNuUnpVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnWTJodmFXTmxUMlpRWVhKMGMxSjFiR1ZPWVcxbFJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCU2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI0b1kyaHZhV05sVDJaUVlYSjBjMUoxYkdWT1lXMWxLU3hjYmlBZ0lDQWdJQ0FnSUNCelpYRjFaVzVqWlU5bVVHRnlkSE5TZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRnUFNCdVpYY2dVblZzWlU1aGJXVkVaV1pwYm1sMGFXOXVLSE5sY1hWbGJtTmxUMlpRWVhKMGMxSjFiR1ZPWVcxbEtTeGNiaUFnSUNBZ0lDQWdJQ0J5ZFd4bFRtRnRaVTV2YmxSbGNtMXBibUZzVUdGeWRGSjFiR1ZFWldacGJtbDBhVzl1SUQwZ2JtVjNJRkoxYkdWT1lXMWxUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaVVJsWm1sdWFYUnBiMjRvS1N4Y2JpQWdJQ0FnSUNBZ0lDQmhiV0pwWjNWdmRYTWdQU0JtWVd4elpTeGNiaUFnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1Y3lBOUlGdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOb2IybGpaVTltVUdGeWRITlNkV3hsVG1GdFpVUmxabWx1YVhScGIyNHNYRzRnSUNBZ0lDQWdJQ0FnSUNCelpYRjFaVzVqWlU5bVVHRnlkSE5TZFd4bFRtRnRaVVJsWm1sdWFYUnBiMjRzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnlkV3hsVG1GdFpVNXZibFJsY20xcGJtRnNVR0Z5ZEZKMWJHVkVaV1pwYm1sMGFXOXVYRzRnSUNBZ0lDQWdJQ0FnWFN4Y2JpQWdJQ0FnSUNBZ0lDQk9iMlJsSUQwZ1RtOXVWR1Z5YldsdVlXeFFZWEowUWs1R1RtOWtaVHRjYmlBZ0lDQmNiaUFnSUNCemRYQmxjaWh1WVcxbExDQmhiV0pwWjNWdmRYTXNJR1JsWm1sdWFYUnBiMjV6TENCT2IyUmxLVnh1SUNCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVRtOXVWR1Z5YldsdVlXeFFZWEowVW5Wc1pTSXNJbTVoYldVaUxDSk9iMjVVWlhKdGFXNWhiRkJoY25SU2RXeGxUbUZ0WlNJc0ltTm9iMmxqWlU5bVVHRnlkSE5TZFd4bFRtRnRaU0lzSWtOb2IybGpaVTltVUdGeWRITlNkV3hsVG1GdFpTSXNJbk5sY1hWbGJtTmxUMlpRWVhKMGMxSjFiR1ZPWVcxbElpd2lVMlZ4ZFdWdVkyVlBabEJoY25SelVuVnNaVTVoYldVaUxDSmphRzlwWTJWUFpsQmhjblJ6VW5Wc1pVNWhiV1ZFWldacGJtbDBhVzl1SWl3aVVuVnNaVTVoYldWRVpXWnBibWwwYVc5dUlpd2ljMlZ4ZFdWdVkyVlBabEJoY25SelVuVnNaVTVoYldWRVpXWnBibWwwYVc5dUlpd2ljblZzWlU1aGJXVk9iMjVVWlhKdGFXNWhiRkJoY25SU2RXeGxSR1ZtYVc1cGRHbHZiaUlzSWxKMWJHVk9ZVzFsVG05dVZHVnliV2x1WVd4UVlYSjBVblZzWlVSbFptbHVhWFJwYjI0aUxDSmhiV0pwWjNWdmRYTWlMQ0prWldacGJtbDBhVzl1Y3lJc0lrNXZaR1VpTENKT2IyNVVaWEp0YVc1aGJGQmhjblJDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBzc1NVRkJRU3hUUVVGM1FpeHJRMEZCZUVJc2QwSkJRWGRDTEVWQlFVRTdRVUZEY0VJc1NVRkJRU3haUVVFNFFpeHJRMEZCT1VJc09FSkJRVGhDTEVWQlFVRTdRVUZEWml4SlFVRkJMRlZCUVRaRExHdERRVUUzUXl3MlEwRkJOa01zUlVGQlFUdEJRVVZRTEVsQlFVRXNWVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJVSFJIT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlUyVXNTVUZCUVN4QlFVRk5RU3h0UWtGQmJVSXNhVUpEVkhKRExFRkVVMWs3ZDBOQlZHWTdPMkZCVTNGQ1FTeHRRa0ZCYlVJN2EwUkJWSGhETzFGQlYwa3NTVUZCVFVNc1NVRkJTU3hIUVVGSFF5eFZRVUYxUWl4M1FrRkJRU3hGUVVNNVFrTXNjVUpCUVhGQ0xFZEJRVWRETEZWQlFYRkNMSE5DUVVGQkxFVkJRemREUXl4MVFrRkJkVUlzUjBGQlIwTXNWVUZCZFVJc2QwSkJRVUVzUlVGRGFrUkRMQ3RDUVVFclFpeEhRVUZITEVsQlFVbERMRk5CUVd0Q0xGTkJRVU5NTEhGQ1FVRnhRaXhEUVVGRExFVkJReTlGVFN4cFEwRkJhVU1zUjBGQlJ5eEpRVUZKUkN4VFFVRnJRaXhUUVVGRFNDeDFRa0ZCZFVJc1EwRkJReXhGUVVOdVJrc3NjVU5CUVhGRExFZEJRVWNzU1VGQlNVTXNWVUZCY1VNc1ZVRkJSU3hGUVVOdVJrTXNVMEZCVXl4SFFVRkhMRXRCUVVzc1JVRkRha0pETEZkQlFWY3NSMEZCUnp0WlFVTmFUaXdyUWtGQkswSTdXVUZETDBKRkxHbERRVUZwUXp0WlFVTnFRME1zY1VOQlFYRkRPMU5CUTNSRExFVkJRMFJKTEVsQlFVa3NSMEZCUjBNc1dVRkJjMElzVVVGQlFTeEJRVUZETzJsRFFVVTVRbVFzU1VGQlNTeEZRVUZGVnl4VFFVRlRMRVZCUVVWRExGZEJRVmNzUlVGQlJVTXNTVUZCU1RzN08wTkJSVE5ETEVOQmJFSm5SRVVzUzBGQlNTeFRRV3RDY0VRN2EwSkJiRUp2UW1oQ0xHMUNRVUZ0UWl4QlFWUjRReUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIikpO1xudmFyIF9zZXF1ZW5jZU9mUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoU2VxdWVuY2VPZlBhcnRzQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoU2VxdWVuY2VPZlBhcnRzQk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuZXJhdGVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksIG5vZGVzID0gY2hpbGROb2Rlcy5zbGljZSgpLCBwYXJ0ID0gX3NlcXVlbmNlT2ZQYXJ0cy5kZWZhdWx0LmZyb21Ob2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhydWxlTmFtZSwgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uVGVybWluYWwuZGVmYXVsdC5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5elpYRjFaVzVqWlU5bVVHRnlkSE11YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQk9iMjVVWlhKdGFXNWhiRTV2WkdVZ1puSnZiU0JjSWk0dUx5NHVMMjV2WkdVdmJtOXVWR1Z5YldsdVlXeGNJanRjYm1sdGNHOXlkQ0JUWlhGMVpXNWpaVTltVUdGeWRITlFZWEowSUdaeWIyMGdYQ0l1TGk4dUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wzTmxjWFZsYm1ObFQyWlFZWEowYzF3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCVFpYRjFaVzVqWlU5bVVHRnlkSE5DVGtaT2IyUmxJR1Y0ZEdWdVpITWdUbTl1VkdWeWJXbHVZV3hPYjJSbElIdGNiaUFnWjJWdVpYSmhkR1ZRWVhKMEtHeHZiMnRCYUdWaFpDa2dlMXh1SUNBZ0lHTnZibk4wSUdOb2FXeGtUbTlrWlhNZ1BTQjBhR2x6TG1kbGRFTm9hV3hrVG05a1pYTW9LU3hjYmlBZ0lDQWdJQ0FnSUNCdWIyUmxjeUE5SUdOb2FXeGtUbTlrWlhNdWMyeHBZMlVvS1N4Y2JpQWdJQ0FnSUNBZ0lDQndZWEowSUQwZ1UyVnhkV1Z1WTJWUFpsQmhjblJ6VUdGeWRDNW1jbTl0VG05a1pYTW9ibTlrWlhNcE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhCaGNuUTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aHlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWtnZXlCeVpYUjFjbTRnVG05dVZHVnliV2x1WVd4T2IyUmxMbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9VMlZ4ZFdWdVkyVlBabEJoY25SelFrNUdUbTlrWlN3Z2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBPeUI5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVTJWeGRXVnVZMlZQWmxCaGNuUnpRazVHVG05a1pTSXNJbWRsYm1WeVlYUmxVR0Z5ZENJc0lteHZiMnRCYUdWaFpDSXNJbU5vYVd4a1RtOWtaWE1pTENKblpYUkRhR2xzWkU1dlpHVnpJaXdpYm05a1pYTWlMQ0p6YkdsalpTSXNJbkJoY25RaUxDSlRaWEYxWlc1alpVOW1VR0Z5ZEhOUVlYSjBJaXdpWm5KdmJVNXZaR1Z6SWl3aVpuSnZiVkoxYkdWT1lXMWxRVzVrUTJocGJHUk9iMlJsY3lJc0luSjFiR1ZPWVcxbElpd2lUbTl1VkdWeWJXbHVZV3hPYjJSbElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJUUkNMRWxCUVVFc1dVRkJkMElzYTBOQlFYaENMSGRDUVVGM1FpeEZRVUZCTzBGQlEzQkNMRWxCUVVFc1owSkJRWGRETEd0RFFVRjRReXgzUTBGQmQwTXNSVUZCUVRzN096czdPenM3T3pzN096czdPemhFUVVoNFJUdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRkxaU3hKUVVGQkxFRkJRVTFCTEhOQ1FVRnpRaXhwUWtOTWVFTXNRVVJMV1R0elJFRk1aanM3WVVGTGNVSkJMSE5DUVVGelFqdHhSRUZNTTBNN096czdPMWxCVFVWRExFZEJRVmtzUlVGQldrRXNZMEZCV1R0WlJVNWtMRTlHVFVWQkxGTkJRVUZCTEZsQlFWa3NRMEZCUTBNc1UwRkJVeXhGUVVGRk8yZENRVU4wUWl4SlFVRk5ReXhWUVVGVkxFZEJRVWNzU1VGQlNTeERRVUZEUXl4aFFVRmhMRVZCUVVVc1JVRkRha05ETEV0QlFVc3NSMEZCUjBZc1ZVRkJWU3hEUVVGRFJ5eExRVUZMTEVWQlFVVXNSVUZETVVKRExFbEJRVWtzUjBGQlIwTXNaMEpCUVcxQ0xGTkJRVU5ETEZOQlFWTXNRMEZCUTBvc1MwRkJTeXhEUVVGRExFRkJRVU03WjBKQlJXeEVMRTlCUVU5RkxFbEJRVWtzUTBGQlF6dGhRVU5pT3pzN08xbEJSVTFITEVkQlFYbENMRVZCUVhwQ1FTd3lRa0ZCZVVJN1dVVmtiRU1zVDBaalJTeFRRVUZQUVN4NVFrRkJlVUlzUTBGQlEwTXNVVUZCVVN4RlFVRkZVaXhWUVVGVkxFVkJRVVU3WjBKQlFVVXNUMEZCVDFNc1dVRkJaU3hUUVVGRFJpeDVRa0ZCZVVJc1EwRkJRMVlzYzBKQlFYTkNMRVZCUVVWWExGRkJRVkVzUlVGQlJWSXNWVUZCVlN4RFFVRkRMRU5CUVVNN1lVRkJSVHM3VFVGa05VbzdPME5CWlVNc1EwRldiVVJUTEZsQlFXVXNVMEZWYkVVN2EwSkJWbTlDV2l4elFrRkJjMElzUVVGTU0wTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfcnVsZU5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCIpKTtcbnZhciBfdGVybWluYWxTeW1ib2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L3Rlcm1pbmFsL3Rlcm1pbmFsU3ltYm9sXCIpKTtcbnZhciBfb25lT3JNb3JlUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBvcGVuQnJhY2tldCA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy5vcGVuQnJhY2tldCwgY2xvc2VCcmFja2V0ID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmNsb3NlQnJhY2tldDtcbnZhciBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihEZWZpbml0aW9uKSB7XG4gICAgX2luaGVyaXRzKFNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2VxdWVuY2VPZlBhcnRzRGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2VPZlBhcnRzRGVmaW5pdGlvbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24pO1xuICAgICAgICB2YXIgcGFydFJ1bGVOYW1lID0gX3J1bGVOYW1lcy5QYXJ0UnVsZU5hbWUsIG9wZW5CcmFja2V0VGVybWluYWxTeW1ib2xDb250ZW50ID0gb3BlbkJyYWNrZXQsIGNsb3NlQnJhY2tldFRlcm1pbmFsU3ltYm9sQ29udGVudCA9IGNsb3NlQnJhY2tldCwgcGFydFJ1bGVOYW1lUGFydCA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdChwYXJ0UnVsZU5hbWUpLCBvcGVuQnJhY2tldFRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChvcGVuQnJhY2tldFRlcm1pbmFsU3ltYm9sQ29udGVudCksIGNsb3NlQnJhY2tldFRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChjbG9zZUJyYWNrZXRUZXJtaW5hbFN5bWJvbENvbnRlbnQpLCBvbmVPck1vcmVQYXJ0UnVsZU5hbWVQYXJ0c1BhcnQgPSBuZXcgX29uZU9yTW9yZVBhcnRzLmRlZmF1bHQocGFydFJ1bGVOYW1lUGFydCksIHBhcnRzID0gW1xuICAgICAgICAgICAgb3BlbkJyYWNrZXRUZXJtaW5hbFN5bWJvbFBhcnQsXG4gICAgICAgICAgICBwYXJ0UnVsZU5hbWVQYXJ0LFxuICAgICAgICAgICAgb25lT3JNb3JlUGFydFJ1bGVOYW1lUGFydHNQYXJ0LFxuICAgICAgICAgICAgY2xvc2VCcmFja2V0VGVybWluYWxTeW1ib2xQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uO1xufShfZGVmaW5pdGlvbi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMM05sY1hWbGJtTmxUMlpRWVhKMGN5NXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUhzZ2MzQmxZMmxoYkZONWJXSnZiSE1nZlNCbWNtOXRJRndpYjJOallXMHRiR1Y0WlhKelhDSTdYRzVjYm1sdGNHOXlkQ0JFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dVhDSTdYRzVwYlhCdmNuUWdVblZzWlU1aGJXVlFZWEowSUdaeWIyMGdYQ0l1TGk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDNKMWJHVk9ZVzFsWENJN1hHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4VGVXMWliMnhRWVhKMElHWnliMjBnWENJdUxpOXdZWEowTDNSbGNtMXBibUZzTDNSbGNtMXBibUZzVTNsdFltOXNYQ0k3WEc1cGJYQnZjblFnVDI1bFQzSk5iM0psVUdGeWRITlFZWEowSUdaeWIyMGdYQ0l1TGk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDI5dVpVOXlUVzl5WlZCaGNuUnpYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGQmhjblJTZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1WTI5dWMzUWdleUJ2Y0dWdVFuSmhZMnRsZEN3Z1kyeHZjMlZDY21GamEyVjBJSDBnUFNCemNHVmphV0ZzVTNsdFltOXNjenRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdVMlZ4ZFdWdVkyVlBabEJoY25SelJHVm1hVzVwZEdsdmJpQmxlSFJsYm1SeklFUmxabWx1YVhScGIyNGdlMXh1SUNCamIyNXpkSEoxWTNSdmNpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCd1lYSjBVblZzWlU1aGJXVWdQU0JRWVhKMFVuVnNaVTVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdiM0JsYmtKeVlXTnJaWFJVWlhKdGFXNWhiRk41YldKdmJFTnZiblJsYm5RZ1BTQnZjR1Z1UW5KaFkydGxkQ3dnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdZMnh2YzJWQ2NtRmphMlYwVkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MElEMGdZMnh2YzJWQ2NtRmphMlYwTENBdkx5OWNiaUFnSUNBZ0lDQWdJQ0J3WVhKMFVuVnNaVTVoYldWUVlYSjBJRDBnYm1WM0lGSjFiR1ZPWVcxbFVHRnlkQ2h3WVhKMFVuVnNaVTVoYldVcExGeHVJQ0FnSUNBZ0lDQWdJRzl3Wlc1Q2NtRmphMlYwVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSUQwZ2JtVjNJRlJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ2h2Y0dWdVFuSmhZMnRsZEZSbGNtMXBibUZzVTNsdFltOXNRMjl1ZEdWdWRDa3NYRzRnSUNBZ0lDQWdJQ0FnWTJ4dmMyVkNjbUZqYTJWMFZHVnliV2x1WVd4VGVXMWliMnhRWVhKMElEMGdibVYzSUZSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZENoamJHOXpaVUp5WVdOclpYUlVaWEp0YVc1aGJGTjViV0p2YkVOdmJuUmxiblFwTEZ4dUlDQWdJQ0FnSUNBZ0lHOXVaVTl5VFc5eVpWQmhjblJTZFd4bFRtRnRaVkJoY25SelVHRnlkQ0E5SUc1bGR5QlBibVZQY2sxdmNtVlFZWEowYzFCaGNuUW9jR0Z5ZEZKMWJHVk9ZVzFsVUdGeWRDa3NYRzRnSUNBZ0lDQWdJQ0FnY0dGeWRITWdQU0JiWEc0Z0lDQWdJQ0FnSUNBZ0lDQnZjR1Z1UW5KaFkydGxkRlJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIQmhjblJTZFd4bFRtRnRaVkJoY25Rc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J2Ym1WUGNrMXZjbVZRWVhKMFVuVnNaVTVoYldWUVlYSjBjMUJoY25Rc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYkc5elpVSnlZV05yWlhSVVpYSnRhVzVoYkZONWJXSnZiRkJoY25SY2JpQWdJQ0FnSUNBZ0lDQmRPMXh1WEc0Z0lDQWdjM1Z3WlhJb2NHRnlkSE1wWEc0Z0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SnZjR1Z1UW5KaFkydGxkQ0lzSW5Od1pXTnBZV3hUZVcxaWIyeHpJaXdpWTJ4dmMyVkNjbUZqYTJWMElpd2lVMlZ4ZFdWdVkyVlBabEJoY25SelJHVm1hVzVwZEdsdmJpSXNJbkJoY25SU2RXeGxUbUZ0WlNJc0lsQmhjblJTZFd4bFRtRnRaU0lzSW05d1pXNUNjbUZqYTJWMFZHVnliV2x1WVd4VGVXMWliMnhEYjI1MFpXNTBJaXdpWTJ4dmMyVkNjbUZqYTJWMFZHVnliV2x1WVd4VGVXMWliMnhEYjI1MFpXNTBJaXdpY0dGeWRGSjFiR1ZPWVcxbFVHRnlkQ0lzSWxKMWJHVk9ZVzFsVUdGeWRDSXNJbTl3Wlc1Q2NtRmphMlYwVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSWl3aVZHVnliV2x1WVd4VGVXMWliMnhRWVhKMElpd2lZMnh2YzJWQ2NtRmphMlYwVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSWl3aWIyNWxUM0pOYjNKbFVHRnlkRkoxYkdWT1lXMWxVR0Z5ZEhOUVlYSjBJaXdpVDI1bFQzSk5iM0psVUdGeWRITlFZWEowSWl3aWNHRnlkSE1pTENKRVpXWnBibWwwYVc5dUlsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJTdENMRWxCUVVFc1dVRkJZeXhYUVVGa0xHTkJRV01zUTBGQlFUdEJRVVYwUWl4SlFVRkJMRmRCUVdVc2EwTkJRV1lzWlVGQlpTeEZRVUZCTzBGQlEySXNTVUZCUVN4VFFVRTRRaXhyUTBGQk9VSXNPRUpCUVRoQ0xFVkJRVUU3UVVGRGVFSXNTVUZCUVN4bFFVRnBReXhyUTBGQmFrTXNhVU5CUVdsRExFVkJRVUU3UVVGRGFrTXNTVUZCUVN4bFFVRnZReXhyUTBGQmNFTXNiME5CUVc5RExFVkJRVUU3UVVGRmRFTXNTVUZCUVN4VlFVRmpMRmRCUVdRc1kwRkJZeXhEUVVGQk96czdPenM3T3pzN096czdPenM3UzBGVU0wTTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZYUVN4SlFVRlJRU3hYUVVGWExFZEJRVzFDUXl4WlFVRmpMR2RDUVVFMVEwUXNWMEZCVnl4RlFVRkZSU3haUVVGWkxFZEJRVXRFTEZsQlFXTXNaMEpCUVM5Q1F5eFpRVUZaTEVGQlFXOUNPMEZCUlhSRExFbEJRVUVzUVVGQlRVTXNlVUpCUVhsQ0xHbENRMkl6UXl4QlJHRlpPMjlFUVdKbU96dGhRV0Z4UWtFc2VVSkJRWGxDTzNkRVFXSTVRenRSUVdWSkxFbEJRVTFETEZsQlFWa3NSMEZCUjBNc1ZVRkJXU3hoUVVGQkxFVkJRek5DUXl4blEwRkJaME1zUjBGQlIwNHNWMEZCVnl4RlFVTTVRMDhzYVVOQlFXbERMRWRCUVVkTUxGbEJRVmtzUlVGRGFFUk5MR2RDUVVGblFpeEhRVUZITEVsQlFVbERMRk5CUVZrc1UwRkJRMHdzV1VGQldTeERRVUZETEVWQlEycEVUU3cyUWtGQk5rSXNSMEZCUnl4SlFVRkpReXhsUVVGclFpeFRRVUZEVEN4blEwRkJaME1zUTBGQlF5eEZRVU40Umswc09FSkJRVGhDTEVkQlFVY3NTVUZCU1VRc1pVRkJhMElzVTBGQlEwb3NhVU5CUVdsRExFTkJRVU1zUlVGRE1VWk5MRGhDUVVFNFFpeEhRVUZITEVsQlFVbERMR1ZCUVd0Q0xGTkJRVU5PTEdkQ1FVRm5RaXhEUVVGRExFVkJRM3BGVHl4TFFVRkxMRWRCUVVjN1dVRkRUa3dzTmtKQlFUWkNPMWxCUXpkQ1JpeG5Ra0ZCWjBJN1dVRkRhRUpMTERoQ1FVRTRRanRaUVVNNVFrUXNPRUpCUVRoQ08xTkJReTlDTEVGQlFVTTdhVU5CUlVaSExFdEJRVXM3T3p0RFFVVmtMRU5CYkVKelJFTXNWMEZCVlN4VFFXdENhRVU3YTBKQmJFSnZRbUlzZVVKQlFYbENMRUZCWWpsREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfc2VxdWVuY2VPZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9kZS9ibmYvc2VxdWVuY2VPZlBhcnRzXCIpKTtcbnZhciBfc2VxdWVuY2VPZlBhcnRzMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vc2VxdWVuY2VPZlBhcnRzXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBTZXF1ZW5jZU9mUGFydHNSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSdWxlKSB7XG4gICAgX2luaGVyaXRzKFNlcXVlbmNlT2ZQYXJ0c1J1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2VxdWVuY2VPZlBhcnRzUnVsZSk7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2VPZlBhcnRzUnVsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcXVlbmNlT2ZQYXJ0c1J1bGUpO1xuICAgICAgICB2YXIgbmFtZSA9IF9ydWxlTmFtZXMuU2VxdWVuY2VPZlBhcnRzUnVsZU5hbWUsIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24gPSBuZXcgX3NlcXVlbmNlT2ZQYXJ0czEuZGVmYXVsdCgpLCBhbWJpZ3VvdXMgPSBmYWxzZSwgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfc2VxdWVuY2VPZlBhcnRzLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIFNlcXVlbmNlT2ZQYXJ0c1J1bGU7XG59KF9ydWxlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2VxdWVuY2VPZlBhcnRzUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMM05sY1hWbGJtTmxUMlpRWVhKMGN5NXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdWY0lqdGNibWx0Y0c5eWRDQlRaWEYxWlc1alpVOW1VR0Z5ZEhOQ1RrWk9iMlJsSUdaeWIyMGdYQ0l1TGk5dWIyUmxMMkp1Wmk5elpYRjFaVzVqWlU5bVVHRnlkSE5jSWp0Y2JtbHRjRzl5ZENCVFpYRjFaVzVqWlU5bVVHRnlkSE5FWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dUwzTmxjWFZsYm1ObFQyWlFZWEowYzF3aU8xeHVYRzVwYlhCdmNuUWdleUJUWlhGMVpXNWpaVTltVUdGeWRITlNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTl5ZFd4bFRtRnRaWE5jSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVTJWeGRXVnVZMlZQWmxCaGNuUnpVblZzWlNCbGVIUmxibVJ6SUZKMWJHVWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCdVlXMWxJRDBnVTJWeGRXVnVZMlZQWmxCaGNuUnpVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnYzJWeGRXVnVZMlZQWmxCaGNuUnpSR1ZtYVc1cGRHbHZiaUE5SUc1bGR5QlRaWEYxWlc1alpVOW1VR0Z5ZEhORVpXWnBibWwwYVc5dUtDa3NYRzRnSUNBZ0lDQWdJQ0FnWVcxaWFXZDFiM1Z6SUQwZ1ptRnNjMlVzWEc0Z0lDQWdJQ0FnSUNBZ1pHVm1hVzVwZEdsdmJuTWdQU0JiWEc0Z0lDQWdJQ0FnSUNBZ0lDQnpaWEYxWlc1alpVOW1VR0Z5ZEhORVpXWnBibWwwYVc5dVhHNGdJQ0FnSUNBZ0lDQWdYU3hjYmlBZ0lDQWdJQ0FnSUNCT2IyUmxJRDBnVTJWeGRXVnVZMlZQWmxCaGNuUnpRazVHVG05a1pUdGNibHh1SUNBZ0lITjFjR1Z5S0c1aGJXVXNJR0Z0WW1sbmRXOTFjeXdnWkdWbWFXNXBkR2x2Ym5Nc0lFNXZaR1VwWEc0Z0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5SlRaWEYxWlc1alpVOW1VR0Z5ZEhOU2RXeGxJaXdpYm1GdFpTSXNJbE5sY1hWbGJtTmxUMlpRWVhKMGMxSjFiR1ZPWVcxbElpd2ljMlZ4ZFdWdVkyVlBabEJoY25SelJHVm1hVzVwZEdsdmJpSXNJbE5sY1hWbGJtTmxUMlpRWVhKMGMwUmxabWx1YVhScGIyNGlMQ0poYldKcFozVnZkWE1pTENKa1pXWnBibWwwYVc5dWN5SXNJazV2WkdVaUxDSlRaWEYxWlc1alpVOW1VR0Z5ZEhOQ1RrWk9iMlJsSWl3aVVuVnNaU0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVZwUWl4SlFVRkJMRXRCUVZNc2EwTkJRVlFzVTBGQlV5eEZRVUZCTzBGQlExTXNTVUZCUVN4blFrRkJOa0lzYTBOQlFUZENMRFpDUVVFMlFpeEZRVUZCTzBGQlF6RkNMRWxCUVVFc2FVSkJRU3RDTEd0RFFVRXZRaXdyUWtGQkswSXNSVUZCUVR0QlFVVTNRaXhKUVVGQkxGVkJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdPenM3T3pzN096czdPenM3T3p0TFFVNTBSRHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVZGbExFbEJRVUVzUVVGQlRVRXNiVUpCUVcxQ0xHbENRMUp5UXl4QlJGRlpPM2REUVZKbU96dGhRVkZ4UWtFc2JVSkJRVzFDTzJ0RVFWSjRRenRSUVZWSkxFbEJRVTFETEVsQlFVa3NSMEZCUjBNc1ZVRkJkVUlzZDBKQlFVRXNSVUZET1VKRExIbENRVUY1UWl4SFFVRkhMRWxCUVVsRExHbENRVUY1UWl4VlFVRkZMRVZCUXpORVF5eFRRVUZUTEVkQlFVY3NTMEZCU3l4RlFVTnFRa01zVjBGQlZ5eEhRVUZITzFsQlExcElMSGxDUVVGNVFqdFRRVU14UWl4RlFVTkVTU3hKUVVGSkxFZEJRVWRETEdkQ1FVRnpRaXhSUVVGQkxFRkJRVU03YVVOQlJUbENVQ3hKUVVGSkxFVkJRVVZKTEZOQlFWTXNSVUZCUlVNc1YwRkJWeXhGUVVGRlF5eEpRVUZKT3pzN1EwRkZNME1zUTBGYVowUkZMRXRCUVVrc1UwRlpjRVE3YTBKQldtOUNWQ3h0UWtGQmJVSXNRVUZTZUVNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfdmVydGljYWxCcmFuY2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZlcnRpY2FsQnJhbmNoXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIE5PX1dISVRFU1BBQ0UgPSBfb2NjYW1MZXhlcnMuc3BlY2lhbFN5bWJvbHMuTk9fV0hJVEVTUEFDRTtcbnZhciBOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSkge1xuICAgIF9pbmhlcml0cyhOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlLCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlKTtcbiAgICBmdW5jdGlvbiBOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9XaGl0ZXNwYWNlTm9kZVBhcnNlVHJlZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUsIG51bGwsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Ob3RoaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vdGhpbmcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IE5PX1dISVRFU1BBQ0UsIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGggPSBzdHJpbmdMZW5ndGgsIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gX3ZlcnRpY2FsQnJhbmNoLmRlZmF1bHQuZnJvbVdpZHRoKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGgpLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLCB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBfdmVydGljYWxCcmFuY2guZGVmYXVsdC5mcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBub1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7XG59KF92ZXJ0aWNhbEJyYW5jaC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWEp6WlZSeVpXVXZibTlYYUdsMFpYTndZV05sVG05a1pTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUhzZ2MzQmxZMmxoYkZONWJXSnZiSE1nZlNCbWNtOXRJRndpYjJOallXMHRiR1Y0WlhKelhDSTdYRzVjYm1sdGNHOXlkQ0JXWlhKMGFXTmhiRUp5WVc1amFGQmhjbk5sVkhKbFpTQm1jbTl0SUZ3aUxpOTJaWEowYVdOaGJFSnlZVzVqYUZ3aU8xeHVYRzVqYjI1emRDQjdJRTVQWDFkSVNWUkZVMUJCUTBVZ2ZTQTlJSE53WldOcFlXeFRlVzFpYjJ4ek8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCT2IxZG9hWFJsYzNCaFkyVk9iMlJsVUdGeWMyVlVjbVZsSUdWNGRHVnVaSE1nVm1WeWRHbGpZV3hDY21GdVkyaFFZWEp6WlZSeVpXVWdlMXh1SUNCemRHRjBhV01nWm5KdmJVNXZkR2hwYm1jb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYzNSeWFXNW5JRDBnVGs5ZlYwaEpWRVZUVUVGRFJTd2dMeTh2WEc0Z0lDQWdJQ0FnSUNBZ2MzUnlhVzVuVEdWdVozUm9JRDBnYzNSeWFXNW5MbXhsYm1kMGFDeGNiaUFnSUNBZ0lDQWdJQ0IyWlhKMGFXTmhiRUp5WVc1amFGQmhjbk5sVkhKbFpWZHBaSFJvSUQwZ2MzUnlhVzVuVEdWdVozUm9MQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQjJaWEowYVdOaGJFSnlZVzVqYUZCaGNuTmxWSEpsWlNBOUlGWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsTG1aeWIyMVhhV1IwYUNoMlpYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaVmRwWkhSb0tTeGNiaUFnSUNBZ0lDQWdJQ0IyWlhKMGFXTmhiRUp5WVc1amFGQnZjMmwwYVc5dUlEMGdkbVZ5ZEdsallXeENjbUZ1WTJoUVlYSnpaVlJ5WldVdVoyVjBWbVZ5ZEdsallXeENjbUZ1WTJoUWIzTnBkR2x2YmlncExGeHVJQ0FnSUNBZ0lDQWdJSFJsY20xcGJtRnNUbTlrWlZCaGNuTmxWSEpsWlNBOUlGWmxjblJwWTJGc1FuSmhibU5vVUdGeWMyVlVjbVZsTG1aeWIyMVRkSEpwYm1kQmJtUldaWEowYVdOaGJFSnlZVzVqYUZCdmMybDBhVzl1S0U1dlYyaHBkR1Z6Y0dGalpVNXZaR1ZRWVhKelpWUnlaV1VzSUhOMGNtbHVaeXdnZG1WeWRHbGpZV3hDY21GdVkyaFFiM05wZEdsdmJpazdYRzVjYmlBZ0lDQjBaWEp0YVc1aGJFNXZaR1ZRWVhKelpWUnlaV1V1WVhCd1pXNWtWRzlVYjNBb2RtVnlkR2xqWVd4Q2NtRnVZMmhRWVhKelpWUnlaV1VwTzF4dVhHNGdJQ0FnWTI5dWMzUWdibTlYYUdsMFpYTndZV05sVG05a1pWQmhjbk5sVkhKbFpTQTlJSFJsY20xcGJtRnNUbTlrWlZCaGNuTmxWSEpsWlRzZ0x5OHZYRzVjYmlBZ0lDQnlaWFIxY200Z2JtOVhhR2wwWlhOd1lXTmxUbTlrWlZCaGNuTmxWSEpsWlR0Y2JpQWdmVnh1ZlZ4dUlsMHNJbTVoYldWeklqcGJJazVQWDFkSVNWUkZVMUJCUTBVaUxDSnpjR1ZqYVdGc1UzbHRZbTlzY3lJc0lrNXZWMmhwZEdWemNHRmpaVTV2WkdWUVlYSnpaVlJ5WldVaUxDSm1jbTl0VG05MGFHbHVaeUlzSW5OMGNtbHVaeUlzSW5OMGNtbHVaMHhsYm1kMGFDSXNJbXhsYm1kMGFDSXNJblpsY25ScFkyRnNRbkpoYm1Ob1VHRnljMlZVY21WbFYybGtkR2dpTENKMlpYSjBhV05oYkVKeVlXNWphRkJoY25ObFZISmxaU0lzSWxabGNuUnBZMkZzUW5KaGJtTm9VR0Z5YzJWVWNtVmxJaXdpWm5KdmJWZHBaSFJvSWl3aWRtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaUlzSW1kbGRGWmxjblJwWTJGc1FuSmhibU5vVUc5emFYUnBiMjRpTENKMFpYSnRhVzVoYkU1dlpHVlFZWEp6WlZSeVpXVWlMQ0ptY205dFUzUnlhVzVuUVc1a1ZtVnlkR2xqWVd4Q2NtRnVZMmhRYjNOcGRHbHZiaUlzSW1Gd2NHVnVaRlJ2Vkc5d0lpd2libTlYYUdsMFpYTndZV05sVG05a1pWQmhjbk5sVkhKbFpTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXJRaXhKUVVGQkxGbEJRV01zVjBGQlpDeGpRVUZqTEVOQlFVRTdRVUZGVkN4SlFVRkJMR1ZCUVd0Q0xHdERRVUZzUWl4clFrRkJhMElzUlVGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVcDBSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZOUVN4SlFVRk5MRUZCUVVWQkxHRkJRV0VzUjBGQlMwTXNXVUZCWXl4blFrRkJhRU5FTEdGQlFXRXNRVUZCYlVJc1FVRkJRenRCUVVVeFFpeEpRVUZCTEVGQlFVMUZMSGxDUVVGNVFpeHBRa05TTTBNc1FVUlJXVHRwUlVGU1pqczdZVUZSY1VKQkxIbENRVUY1UWp0M1JFRlNPVU03T3pzN08xbEJVMU5ETEVkQlFWY3NSVUZCV0VFc1lVRkJWenRaUlZSd1FpeFBSbE5GTEZOQlFVOUJMRmRCUVZjc1IwRkJSenRuUWtGRGJrSXNTVUZCVFVNc1RVRkJUU3hIUVVGSFNpeGhRVUZoTEVWQlEzUkNTeXhaUVVGWkxFZEJRVWRFTEUxQlFVMHNRMEZCUTBVc1RVRkJUU3hGUVVNMVFrTXNORUpCUVRSQ0xFZEJRVWRHTEZsQlFWa3NSVUZETTBOSExIVkNRVUYxUWl4SFFVRkhReXhsUVVGMVFpeFRRVUZEUXl4VFFVRlRMRU5CUVVOSUxEUkNRVUUwUWl4RFFVRkRMRVZCUTNwR1NTeHpRa0ZCYzBJc1IwRkJSMGdzZFVKQlFYVkNMRU5CUVVOSkxIbENRVUY1UWl4RlFVRkZMRVZCUXpWRlF5eHhRa0ZCY1VJc1IwRkJSMG9zWlVGQmRVSXNVMEZCUTBzc2JVTkJRVzFETEVOQlFVTmFMSGxDUVVGNVFpeEZRVUZGUlN4TlFVRk5MRVZCUVVWUExITkNRVUZ6UWl4RFFVRkRMRUZCUVVNN1owSkJSWEpLUlN4eFFrRkJjVUlzUTBGQlEwVXNWMEZCVnl4RFFVRkRVQ3gxUWtGQmRVSXNRMEZCUXl4RFFVRkRPMmRDUVVVelJDeEpRVUZOVVN4NVFrRkJlVUlzUjBGQlIwZ3NjVUpCUVhGQ0xFRkJRVU1zUlVGQlF5eEhRVUZITzJkQ1FVVTFSQ3hQUVVGUFJ5eDVRa0ZCZVVJc1EwRkJRenRoUVVOc1F6czdUVUYwUWtnN08wTkJkVUpETEVOQlpuTkVVQ3hsUVVGMVFpeFRRV1UzUlR0clFrRm1iMEpRTEhsQ1FVRjVRaXhCUVZJNVF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3Rlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdGVybWluYWxcIikpO1xudmFyIF9ub1doaXRlc3BhY2VOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFyc2VUcmVlL25vV2hpdGVzcGFjZU5vZGVcIikpO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgTm9XaGl0ZXNwYWNlTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKE5vV2hpdGVzcGFjZU5vZGUsIFRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb1doaXRlc3BhY2VOb2RlKTtcbiAgICBmdW5jdGlvbiBOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9XaGl0ZXNwYWNlTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE5vV2hpdGVzcGFjZU5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFR5cGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbnVsbDsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRDb250ZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IF9jb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNOb1doaXRlc3BhY2VOb2RlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgICAgICAgICAgICAgIHZhciBub1doaXRlc3BhY2VOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9XaGl0ZXNwYWNlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFzUGFyc2VUcmVlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgPSBfbm9XaGl0ZXNwYWNlTm9kZS5kZWZhdWx0LmZyb21Ob3RoaW5nKCksIHBhcnNlVHJlZSA9IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tTm90aGluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Ob3RoaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FudFRva2VuID0gbnVsbCwgbm9XaGl0ZXNwYWNlTm9kZSA9IF90ZXJtaW5hbC5kZWZhdWx0LmZyb21TaWduaWZpY2FudFRva2VuKE5vV2hpdGVzcGFjZU5vZGUsIHNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub1doaXRlc3BhY2VOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vV2hpdGVzcGFjZU5vZGU7XG59KF90ZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vV2hpdGVzcGFjZU5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl1YjJSbEwzUmxjbTFwYm1Gc0wyNXZWMmhwZEdWemNHRmpaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElGUmxjbTFwYm1Gc1RtOWtaU0JtY205dElGd2lMaTR2ZEdWeWJXbHVZV3hjSWp0Y2JtbHRjRzl5ZENCT2IxZG9hWFJsYzNCaFkyVk9iMlJsVUdGeWMyVlVjbVZsSUdaeWIyMGdYQ0l1TGk4dUxpOXdZWEp6WlZSeVpXVXZibTlYYUdsMFpYTndZV05sVG05a1pWd2lPMXh1WEc1cGJYQnZjblFnZXlCRlRWQlVXVjlUVkZKSlRrY2dmU0JtY205dElGd2lMaTR2TGk0dlkyOXVjM1JoYm5SelhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklFNXZWMmhwZEdWemNHRmpaVTV2WkdVZ1pYaDBaVzVrY3lCVVpYSnRhVzVoYkU1dlpHVWdlMXh1SUNCblpYUlVlWEJsS0NrZ2UxeHVJQ0FnSUdOdmJuTjBJSFI1Y0dVZ1BTQnVkV3hzT3lBZ0x5OHZYRzVjYmlBZ0lDQnlaWFIxY200Z2RIbHdaVHRjYmlBZ2ZWeHVYRzRnSUdkbGRFTnZiblJsYm5Rb0tTQjdYRzRnSUNBZ1kyOXVjM1FnWTI5dWRHVnVkQ0E5SUVWTlVGUlpYMU5VVWtsT1J6dGNibHh1SUNBZ0lISmxkSFZ5YmlCamIyNTBaVzUwTzF4dUlDQjlYRzVjYmlBZ2FYTk9iMWRvYVhSbGMzQmhZMlZPYjJSbEtDa2dlMXh1SUNBZ0lHTnZibk4wSUc1dlYyaHBkR1Z6Y0dGalpVNXZaR1VnUFNCMGNuVmxPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHNXZWMmhwZEdWemNHRmpaVTV2WkdVN1hHNGdJSDFjYmx4dUlDQmhjMUJoY25ObFZISmxaU2gwYjJ0bGJuTXBJSHRjYmlBZ0lDQmpiMjV6ZENCdWIxZG9hWFJsYzNCaFkyVk9iMlJsVUdGeWMyVlVjbVZsSUQwZ1RtOVhhR2wwWlhOd1lXTmxUbTlrWlZCaGNuTmxWSEpsWlM1bWNtOXRUbTkwYUdsdVp5Z3BMRnh1SUNBZ0lDQWdJQ0FnSUhCaGNuTmxWSEpsWlNBOUlHNXZWMmhwZEdWemNHRmpaVTV2WkdWUVlYSnpaVlJ5WldVN0lDQXZMeTljYmx4dUlDQWdJSEpsZEhWeWJpQndZWEp6WlZSeVpXVTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlU1dmRHaHBibWNvS1NCN1hHNGdJQ0FnWTI5dWMzUWdjMmxuYm1sbWFXTmhiblJVYjJ0bGJpQTlJRzUxYkd3c1hHNGdJQ0FnSUNBZ0lDQWdibTlYYUdsMFpYTndZV05sVG05a1pTQTlJRlJsY20xcGJtRnNUbTlrWlM1bWNtOXRVMmxuYm1sbWFXTmhiblJVYjJ0bGJpaE9iMWRvYVhSbGMzQmhZMlZPYjJSbExDQnphV2R1YVdacFkyRnVkRlJ2YTJWdUtUdGNibHh1SUNBZ0lISmxkSFZ5YmlCdWIxZG9hWFJsYzNCaFkyVk9iMlJsTzF4dUlDQjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lUbTlYYUdsMFpYTndZV05sVG05a1pTSXNJbWRsZEZSNWNHVWlMQ0owZVhCbElpd2laMlYwUTI5dWRHVnVkQ0lzSW1OdmJuUmxiblFpTENKRlRWQlVXVjlUVkZKSlRrY2lMQ0pwYzA1dlYyaHBkR1Z6Y0dGalpVNXZaR1VpTENKdWIxZG9hWFJsYzNCaFkyVk9iMlJsSWl3aVlYTlFZWEp6WlZSeVpXVWlMQ0owYjJ0bGJuTWlMQ0p1YjFkb2FYUmxjM0JoWTJWT2IyUmxVR0Z5YzJWVWNtVmxJaXdpVG05WGFHbDBaWE53WVdObFRtOWtaVkJoY25ObFZISmxaU0lzSW1aeWIyMU9iM1JvYVc1bklpd2ljR0Z5YzJWVWNtVmxJaXdpYzJsbmJtbG1hV05oYm5SVWIydGxiaUlzSWxSbGNtMXBibUZzVG05a1pTSXNJbVp5YjIxVGFXZHVhV1pwWTJGdWRGUnZhMlZ1SWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUlhsQ0xFbEJRVUVzVTBGQllTeHJRMEZCWWl4aFFVRmhMRVZCUVVFN1FVRkRRU3hKUVVGQkxHbENRVUZyUXl4clEwRkJiRU1zYTBOQlFXdERMRVZCUVVFN1FVRkZNME1zU1VGQlFTeFZRVUZwUWl4WFFVRnFRaXhwUWtGQmFVSXNRMEZCUVRzN096czdPenM3T3pzN096czdPemhFUVV3NVF6dHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlBaU3hKUVVGQkxFRkJRVTFCTEdkQ1FVRm5RaXhwUWtOUWJFTXNRVVJQV1RzMlEwRlFaanM3WVVGUGNVSkJMR2RDUVVGblFqc3JRMEZRY2tNN096czdPMWxCVVVWRExFZEJRVThzUlVGQlVFRXNVMEZCVHp0WlJWSlVMRTlHVVVWQkxGTkJRVUZCTEU5QlFVOHNSMEZCUnp0blFrRkRVaXhKUVVGTlF5eEpRVUZKTEVkQlFVY3NTVUZCU1N4QlFVRkRMRVZCUVVVc1IwRkJSenRuUWtGRmRrSXNUMEZCVDBFc1NVRkJTU3hEUVVGRE8yRkJRMkk3T3p0WlFVVkVReXhIUVVGVkxFVkJRVlpCTEZsQlFWVTdXVVZrV2l4UFJtTkZRU3hUUVVGQlFTeFZRVUZWTEVkQlFVYzdaMEpCUTFnc1NVRkJUVU1zVDBGQlR5eEhRVUZIUXl4VlFVRlpMR0ZCUVVFc1FVRkJRenRuUWtGRk4wSXNUMEZCVDBRc1QwRkJUeXhEUVVGRE8yRkJRMmhDT3pzN1dVRkZSRVVzUjBGQmEwSXNSVUZCYkVKQkxHOUNRVUZyUWp0WlJYQkNjRUlzVDBadlFrVkJMRk5CUVVGQkxHdENRVUZyUWl4SFFVRkhPMmRDUVVOdVFpeEpRVUZOUXl4blFrRkJaMElzUjBGQlJ5eEpRVUZKTEVGQlFVTTdaMEpCUlRsQ0xFOUJRVTlCTEdkQ1FVRm5RaXhEUVVGRE8yRkJRM3BDT3pzN1dVRkZSRU1zUjBGQlZ5eEZRVUZZUVN4aFFVRlhPMWxGTVVKaUxFOUdNRUpGUVN4VFFVRkJRU3hYUVVGWExFTkJRVU5ETEUxQlFVMHNSVUZCUlR0blFrRkRiRUlzU1VGQlRVTXNlVUpCUVhsQ0xFZEJRVWRETEdsQ1FVRjVRaXhUUVVGRFF5eFhRVUZYTEVWQlFVVXNSVUZEYmtWRExGTkJRVk1zUjBGQlIwZ3NlVUpCUVhsQ0xFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVnFSQ3hQUVVGUFJ5eFRRVUZUTEVOQlFVTTdZVUZEYkVJN096czdXVUZGVFVRc1IwRkJWeXhGUVVGWVFTeGhRVUZYTzFsRmFrTndRaXhQUm1sRFJTeFRRVUZQUVN4WFFVRlhMRWRCUVVjN1owSkJRMjVDTEVsQlFVMUZMR2RDUVVGblFpeEhRVUZITEVsQlFVa3NSVUZEZGtKUUxHZENRVUZuUWl4SFFVRkhVU3hUUVVGWkxGTkJRVU5ETEc5Q1FVRnZRaXhEUVVGRGFFSXNaMEpCUVdkQ0xFVkJRVVZqTEdkQ1FVRm5RaXhEUVVGRExFRkJRVU03WjBKQlJTOUdMRTlCUVU5UUxHZENRVUZuUWl4RFFVRkRPMkZCUTNwQ096dE5RWFJEU0RzN1EwRjFRME1zUTBGb1F6WkRVU3hUUVVGWkxGTkJaME42UkR0clFrRm9RMjlDWml4blFrRkJaMElzUVVGUWNrTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX3Rlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiKSk7XG52YXIgX25vV2hpdGVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSl7XG4gICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIE5PX1dISVRFU1BBQ0UgPSBfb2NjYW1MZXhlcnMuc3BlY2lhbFN5bWJvbHMuTk9fV0hJVEVTUEFDRTtcbnZhciBOb1doaXRlc3BhY2VQYXJ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihUZXJtaW5hbFBhcnQpIHtcbiAgICBfaW5oZXJpdHMoTm9XaGl0ZXNwYWNlUGFydCwgVGVybWluYWxQYXJ0KTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vV2hpdGVzcGFjZVBhcnQpO1xuICAgIGZ1bmN0aW9uIE5vV2hpdGVzcGFjZVBhcnQoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb1doaXRlc3BhY2VQYXJ0KTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoTm9XaGl0ZXNwYWNlUGFydCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNOb1doaXRlc3BhY2VQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNOb1doaXRlc3BhY2VQYXJ0KCkge1xuICAgICAgICAgICAgICAgIHZhciBub1doaXRlc3BhY2VQYXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgdmFyIG5vV2hpdGVzcGFjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLCBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBzdGF0ZS5pc05leHRUb2tlbldoaXRlc3BhY2VUb2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFRva2VuV2hpdGVzcGFjZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vV2hpdGVzcGFjZU5vZGUgPSBfbm9XaGl0ZXNwYWNlLmRlZmF1bHQuZnJvbU5vdGhpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gbm9XaGl0ZXNwYWNlTm9kZSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9XaGl0ZXNwYWNlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gTk9fV0hJVEVTUEFDRTsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE5vV2hpdGVzcGFjZVBhcnQucHJvdG90eXBlKSwgXCJjbG9uZVwiLCB0aGlzKS5jYWxsKHRoaXMsIE5vV2hpdGVzcGFjZVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vV2hpdGVzcGFjZVBhcnQ7XG59KF90ZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vV2hpdGVzcGFjZVBhcnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl3WVhKMEwzUmxjbTFwYm1Gc0wyNXZWMmhwZEdWemNHRmpaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElIc2djM0JsWTJsaGJGTjViV0p2YkhNZ2ZTQm1jbTl0SUZ3aWIyTmpZVzB0YkdWNFpYSnpYQ0k3WEc1Y2JtbHRjRzl5ZENCVVpYSnRhVzVoYkZCaGNuUWdabkp2YlNCY0lpNHVMeTR1TDNCaGNuUXZkR1Z5YldsdVlXeGNJanRjYm1sdGNHOXlkQ0JPYjFkb2FYUmxjM0JoWTJWT2IyUmxJR1p5YjIwZ1hDSXVMaTh1TGk5dWIyUmxMM1JsY20xcGJtRnNMMjV2VjJocGRHVnpjR0ZqWlZ3aU8xeHVYRzVqYjI1emRDQjdJRTVQWDFkSVNWUkZVMUJCUTBVZ2ZTQTlJSE53WldOcFlXeFRlVzFpYjJ4ek8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCT2IxZG9hWFJsYzNCaFkyVlFZWEowSUdWNGRHVnVaSE1nVkdWeWJXbHVZV3hRWVhKMElIdGNiaUFnYVhOT2IxZG9hWFJsYzNCaFkyVlFZWEowS0NrZ2UxeHVJQ0FnSUdOdmJuTjBJRzV2VjJocGRHVnpjR0ZqWlZCaGNuUWdQU0IwY25WbE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUc1dlYyaHBkR1Z6Y0dGalpWQmhjblE3WEc0Z0lIMWNibHh1SUNCd1lYSnpaU2h1YjJSbGN5d2djM1JoZEdVc0lHTmhiR3hpWVdOcktTQjdYRzRnSUNBZ2JHVjBJSEJoY25ObFpEdGNibHh1SUNBZ0lHeGxkQ0J1YjFkb2FYUmxjM0JoWTJWT2IyUmxJRDBnYm5Wc2JEdGNibHh1SUNBZ0lHTnZibk4wSUhOaGRtVmtTVzVrWlhnZ1BTQnpkR0YwWlM1blpYUlRZWFpsWkVsdVpHVjRLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2JtVjRkRlJ2YTJWdVYyaHBkR1Z6Y0dGalpWUnZhMlZ1SUQwZ2MzUmhkR1V1YVhOT1pYaDBWRzlyWlc1WGFHbDBaWE53WVdObFZHOXJaVzRvS1R0Y2JseHVJQ0FnSUdsbUlDZ2hibVY0ZEZSdmEyVnVWMmhwZEdWemNHRmpaVlJ2YTJWdUtTQjdYRzRnSUNBZ0lDQnViMWRvYVhSbGMzQmhZMlZPYjJSbElEMGdUbTlYYUdsMFpYTndZV05sVG05a1pTNW1jbTl0VG05MGFHbHVaeWdwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEJoY25ObFpDQTlJQ2h1YjFkb2FYUmxjM0JoWTJWT2IyUmxJQ0U5UFNCdWRXeHNLVnh1WEc0Z0lDQWdhV1lnS0hCaGNuTmxaQ2tnZTF4dUlDQWdJQ0FnYm05a1pYTXVjSFZ6YUNodWIxZG9hWFJsYzNCaFkyVk9iMlJsS1R0Y2JseHVJQ0FnSUNBZ2FXWWdLR05oYkd4aVlXTnJJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUhCaGNuTmxaQ0E5SUdOaGJHeGlZV05yS0NrN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0NGd1lYSnpaV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnViMlJsY3k1d2IzQW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNnaGNHRnljMlZrS1NCN1hHNGdJQ0FnSUNCemRHRjBaUzVpWVdOcmRISmhZMnNvYzJGMlpXUkpibVJsZUNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJSEJoY25ObFpEdGNiaUFnZlZ4dVhHNGdJR0Z6VTNSeWFXNW5LQ2tnZTF4dUlDQWdJR052Ym5OMElITjBjbWx1WnlBOUlFNVBYMWRJU1ZSRlUxQkJRMFU3SUM4dkwxeHVYRzRnSUNBZ2NtVjBkWEp1SUhOMGNtbHVaenRjYmlBZ2ZWeHVYRzRnSUdOc2IyNWxLQ2tnZXlCeVpYUjFjbTRnYzNWd1pYSXVZMnh2Ym1Vb1RtOVhhR2wwWlhOd1lXTmxVR0Z5ZENrN0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5Sk9UMTlYU0VsVVJWTlFRVU5GSWl3aWMzQmxZMmxoYkZONWJXSnZiSE1pTENKT2IxZG9hWFJsYzNCaFkyVlFZWEowSWl3aWFYTk9iMWRvYVhSbGMzQmhZMlZRWVhKMElpd2libTlYYUdsMFpYTndZV05sVUdGeWRDSXNJbkJoY25ObElpd2libTlrWlhNaUxDSnpkR0YwWlNJc0ltTmhiR3hpWVdOcklpd2ljR0Z5YzJWa0lpd2libTlYYUdsMFpYTndZV05sVG05a1pTSXNJbk5oZG1Wa1NXNWtaWGdpTENKblpYUlRZWFpsWkVsdVpHVjRJaXdpYm1WNGRGUnZhMlZ1VjJocGRHVnpjR0ZqWlZSdmEyVnVJaXdpYVhOT1pYaDBWRzlyWlc1WGFHbDBaWE53WVdObFZHOXJaVzRpTENKT2IxZG9hWFJsYzNCaFkyVk9iMlJsSWl3aVpuSnZiVTV2ZEdocGJtY2lMQ0p3ZFhOb0lpd2ljRzl3SWl3aVltRmphM1J5WVdOcklpd2lZWE5UZEhKcGJtY2lMQ0p6ZEhKcGJtY2lMQ0pqYkc5dVpTSXNJbFJsY20xcGJtRnNVR0Z5ZENKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVclFpeEpRVUZCTEZsQlFXTXNWMEZCWkN4alFVRmpMRU5CUVVFN1FVRkZjRUlzU1VGQlFTeFRRVUZ4UWl4clEwRkJja0lzY1VKQlFYRkNMRVZCUVVFN1FVRkRha0lzU1VGQlFTeGhRVUZyUXl4clEwRkJiRU1zYTBOQlFXdERMRVZCUVVFN096czdPenM3T3pzN096czdPenM0UkVGTUwwUTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPekJDUVVGQk96czdPenM3T3pzN08xTkJRVUU3T3pzN096czdTMEZCUVRzN096czdPenM3T3pzN096dE5RVUZCTzNsRVFVRkJPenM3T3pzN096czdPenM3T3pzN2RVSkJRVUU3TzB0QlFVRTdPenM3TzNkRFFVRkJPenM3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVTlCTEVsQlFVMHNRVUZCUlVFc1lVRkJZU3hIUVVGTFF5eFpRVUZqTEdkQ1FVRm9RMFFzWVVGQllTeEJRVUZ0UWl4QlFVRkRPMEZCUlRGQ0xFbEJRVUVzUVVGQlRVVXNaMEpCUVdkQ0xHbENRMVJzUXl4QlJGTlpPelpEUVZSbU96dGhRVk54UWtFc1owSkJRV2RDT3l0RFFWUnlRenM3T3pzN1dVRlZSVU1zUjBGQmEwSXNSVUZCYkVKQkxHOUNRVUZyUWp0WlJWWndRaXhQUmxWRlFTeFRRVUZCUVN4clFrRkJhMElzUjBGQlJ6dG5Ra0ZEYmtJc1NVRkJUVU1zWjBKQlFXZENMRWRCUVVjc1NVRkJTU3hCUVVGRE8yZENRVVU1UWl4UFFVRlBRU3huUWtGQlowSXNRMEZCUXp0aFFVTjZRanM3TzFsQlJVUkRMRWRCUVVzc1JVRkJURUVzVDBGQlN6dFpSV2hDVUN4UFJtZENSVUVzVTBGQlFVRXNTMEZCU3l4RFFVRkRReXhMUVVGTExFVkJRVVZETEV0QlFVc3NSVUZCUlVNc1VVRkJVU3hGUVVGRk8yZENRVU0xUWl4SlFVRkpReXhOUVVGTkxFRkJRVU03WjBKQlJWZ3NTVUZCU1VNc1owSkJRV2RDTEVkQlFVY3NTVUZCU1N4QlFVRkRPMmRDUVVVMVFpeEpRVUZOUXl4VlFVRlZMRWRCUVVkS0xFdEJRVXNzUTBGQlEwc3NZVUZCWVN4RlFVRkZMRVZCUTJ4RFF5eDNRa0ZCZDBJc1IwRkJSMDRzUzBGQlN5eERRVUZEVHl3d1FrRkJNRUlzUlVGQlJTeEJRVUZETzJkQ1FVVndSU3hKUVVGSkxFTkJRVU5FTEhkQ1FVRjNRaXhGUVVGRk8yOUNRVU0zUWtnc1owSkJRV2RDTEVkQlFVZExMR0ZCUVdkQ0xGTkJRVU5ETEZkQlFWY3NSVUZCUlN4RFFVRkRPMmxDUVVOdVJEdG5Ra0ZGUkZBc1RVRkJUU3hIUVVGSlF5eG5Ra0ZCWjBJc1MwRkJTeXhKUVVGSkxFRkJRVU1zUVVFMVFuaERPMmRDUVRoQ1NTeEpRVUZKUkN4TlFVRk5MRVZCUVVVN2IwSkJRMVpJTEV0QlFVc3NRMEZCUTFjc1NVRkJTU3hEUVVGRFVDeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRE8yOUNRVVUzUWl4SlFVRkpSaXhSUVVGUkxFdEJRVXNzU1VGQlNTeEZRVUZGTzNkQ1FVTnlRa01zVFVGQlRTeEhRVUZIUkN4UlFVRlJMRVZCUVVVc1EwRkJRenQzUWtGRmNFSXNTVUZCU1N4RFFVRkRReXhOUVVGTkxFVkJRVVU3TkVKQlExaElMRXRCUVVzc1EwRkJRMWtzUjBGQlJ5eEZRVUZGTEVOQlFVTTdlVUpCUTJJN2NVSkJRMFk3YVVKQlEwWTdaMEpCUlVRc1NVRkJTU3hEUVVGRFZDeE5RVUZOTEVWQlFVVTdiMEpCUTFoR0xFdEJRVXNzUTBGQlExa3NVMEZCVXl4RFFVRkRVaXhWUVVGVkxFTkJRVU1zUTBGQlF6dHBRa0ZETjBJN1owSkJSVVFzVDBGQlQwWXNUVUZCVFN4RFFVRkRPMkZCUTJZN096dFpRVVZFVnl4SFFVRlJMRVZCUVZKQkxGVkJRVkU3V1VWcVJGWXNUMFpwUkVWQkxGTkJRVUZCTEZGQlFWRXNSMEZCUnp0blFrRkRWQ3hKUVVGTlF5eE5RVUZOTEVkQlFVZHlRaXhoUVVGaExFRkJRVU1zUlVGQlF5eEhRVUZITzJkQ1FVVnFReXhQUVVGUGNVSXNUVUZCVFN4RFFVRkRPMkZCUTJZN096dFpRVVZFUXl4SFFVRkxMRVZCUVV4QkxFOUJRVXM3V1VWMlJGQXNUMFoxUkVWQkxGTkJRVUZCTEV0QlFVc3NSMEZCUnp0blFrRkJSU3hQUVVGUExIRkNRVGxEUlhCQ0xHZENRVUZuUWl4aFFUaERXbTlDTEU5QlFVc3NSVUZCV0N4SlFVRkxMRU5CUVVFc1dVRkJUM0JDTEdkQ1FVRm5RaXhGUVVGRk8yRkJRVVU3TzAxQmRrUnVSRHM3UTBGM1JFTXNRMEV2UXpaRGNVSXNVMEZCV1N4VFFTdERla1E3YTBKQkwwTnZRbkpDTEdkQ1FVRm5RaXhCUVZSeVF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG52YXIgX25vV2hpdGVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsIE5vblRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb1doaXRlc3BhY2VQYXJ0Qk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb1doaXRlc3BhY2VQYXJ0Qk5GTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZW5lcmF0ZVBhcnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVBhcnQobG9va0FoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vV2hpdGVzcGFjZVBhcnQgPSBuZXcgX25vV2hpdGVzcGFjZS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhydWxlTmFtZSwgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbm9uVGVybWluYWwuZGVmYXVsdC5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9XaGl0ZXNwYWNlUGFydEJORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5dWIyUmxMMkp1Wmk5dWIxZG9hWFJsYzNCaFkyVlFZWEowTG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdUbTl1VkdWeWJXbHVZV3hPYjJSbElHWnliMjBnWENJdUxpOHVMaTl1YjJSbEwyNXZibFJsY20xcGJtRnNYQ0k3WEc1cGJYQnZjblFnVG05WGFHbDBaWE53WVdObFVHRnlkQ0JtY205dElGd2lMaTR2TGk0dmNHRnlkQzkwWlhKdGFXNWhiQzl1YjFkb2FYUmxjM0JoWTJWY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1RtOVhhR2wwWlhOd1lXTmxVR0Z5ZEVKT1JrNXZaR1VnWlhoMFpXNWtjeUJPYjI1VVpYSnRhVzVoYkU1dlpHVWdlMXh1SUNCblpXNWxjbUYwWlZCaGNuUW9iRzl2YTBGb1pXRmtLU0I3WEc0Z0lDQWdZMjl1YzNRZ2JtOVhhR2wwWlhOd1lXTmxVR0Z5ZENBOUlHNWxkeUJPYjFkb2FYUmxjM0JoWTJWUVlYSjBLQ2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdibTlYYUdsMFpYTndZV05sVUdGeWREdGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0VW5Wc1pVNWhiV1ZCYm1SRGFHbHNaRTV2WkdWektISjFiR1ZPWVcxbExDQmphR2xzWkU1dlpHVnpLU0I3SUhKbGRIVnliaUJPYjI1VVpYSnRhVzVoYkU1dlpHVXVabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aE9iMWRvYVhSbGMzQmhZMlZRWVhKMFFrNUdUbTlrWlN3Z2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBPeUI5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpVG05WGFHbDBaWE53WVdObFVHRnlkRUpPUms1dlpHVWlMQ0puWlc1bGNtRjBaVkJoY25RaUxDSnNiMjlyUVdobFlXUWlMQ0p1YjFkb2FYUmxjM0JoWTJWUVlYSjBJaXdpVG05WGFHbDBaWE53WVdObFVHRnlkQ0lzSW1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1pTENKeWRXeGxUbUZ0WlNJc0ltTm9hV3hrVG05a1pYTWlMQ0pPYjI1VVpYSnRhVzVoYkU1dlpHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZORUlzU1VGQlFTeFpRVUYzUWl4clEwRkJlRUlzZDBKQlFYZENMRVZCUVVFN1FVRkRka0lzU1VGQlFTeGhRVUZyUXl4clEwRkJiRU1zYTBOQlFXdERMRVZCUVVFN096czdPenM3T3pzN096czdPenM0UkVGSUwwUTdjME5CUVVFN05rUkJRVUU3YVVWQlFVRTdPenM3ZDBWQlFVRTdaMFZCUVVFN096czdPenRMUVVGQk96czdPenM3T3pzN096czdPMDFCUVVFN2VVUkJRVUU3T3pzN096czdPenM3T3pzN096dDFRa0ZCUVRzN1MwRkJRVHM3T3pzeVFrRkJRVHM3T3pzN096czdjVVpCUVVFN096czdPenM3T3pzN096dHRSVUZCUVRzN2FVUkJRVUU3T3pzN08wRkJTMlVzU1VGQlFTeEJRVUZOUVN4MVFrRkJkVUlzYVVKRFRIcERMRUZFUzFrN2RVUkJUR1k3TzJGQlMzRkNRU3gxUWtGQmRVSTdjMFJCVERWRE96czdPenRaUVUxRlF5eEhRVUZaTEVWQlFWcEJMR05CUVZrN1dVVk9aQ3hQUmsxRlFTeFRRVUZCUVN4WlFVRlpMRU5CUVVORExGTkJRVk1zUlVGQlJUdG5Ra0ZEZEVJc1NVRkJUVU1zWjBKQlFXZENMRWRCUVVjc1NVRkJTVU1zWVVGQlowSXNWVUZCUlN4QlFVRkRPMmRDUVVWb1JDeFBRVUZQUkN4blFrRkJaMElzUTBGQlF6dGhRVU42UWpzN096dFpRVVZOUlN4SFFVRjVRaXhGUVVGNlFrRXNNa0pCUVhsQ08xbEZXbXhETEU5R1dVVXNVMEZCVDBFc2VVSkJRWGxDTEVOQlFVTkRMRkZCUVZFc1JVRkJSVU1zVlVGQlZTeEZRVUZGTzJkQ1FVRkZMRTlCUVU5RExGbEJRV1VzVTBGQlEwZ3NlVUpCUVhsQ0xFTkJRVU5NTEhWQ1FVRjFRaXhGUVVGRlRTeFJRVUZSTEVWQlFVVkRMRlZCUVZVc1EwRkJReXhEUVVGRE8yRkJRVVU3TzAxQldqZEtPenREUVdGRExFTkJVbTlFUXl4WlFVRmxMRk5CVVc1Rk8ydENRVkp2UWxJc2RVSkJRWFZDTEVGQlREVkRJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfdGVybWluYWxTeW1ib2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L3Rlcm1pbmFsL3Rlcm1pbmFsU3ltYm9sXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBOT19XSElURVNQQUNFID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLk5PX1dISVRFU1BBQ0U7XG52YXIgTm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoTm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb24pO1xuICAgIGZ1bmN0aW9uIE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb24pO1xuICAgICAgICB2YXIgY29udGVudCA9IE5PX1dISVRFU1BBQ0UsIHRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChjb250ZW50KSwgcGFydHMgPSBbXG4gICAgICAgICAgICB0ZXJtaW5hbFN5bWJvbFBhcnRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uO1xufShfZGVmaW5pdGlvbi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrWldacGJtbDBhVzl1TDI1dlYyaHBkR1Z6Y0dGalpWQmhjblF1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJSE53WldOcFlXeFRlVzFpYjJ4eklIMGdabkp2YlNCY0ltOWpZMkZ0TFd4bGVHVnljMXdpTzF4dVhHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZibHdpTzF4dWFXMXdiM0owSUZSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZENCbWNtOXRJRndpTGk0dmNHRnlkQzkwWlhKdGFXNWhiQzkwWlhKdGFXNWhiRk41YldKdmJGd2lPMXh1WEc1amIyNXpkQ0I3SUU1UFgxZElTVlJGVTFCQlEwVWdmU0E5SUhOd1pXTnBZV3hUZVcxaWIyeHpPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5Qk9iMWRvYVhSbGMzQmhZMlZRWVhKMFJHVm1hVzVwZEdsdmJpQmxlSFJsYm1SeklFUmxabWx1YVhScGIyNGdlMXh1SUNCamIyNXpkSEoxWTNSdmNpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCamIyNTBaVzUwSUQwZ1RrOWZWMGhKVkVWVFVFRkRSU3hjYmlBZ0lDQWdJQ0FnSUNCMFpYSnRhVzVoYkZONWJXSnZiRkJoY25RZ1BTQnVaWGNnVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowS0dOdmJuUmxiblFwTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdWeWJXbHVZV3hUZVcxaWIyeFFZWEowWEc0Z0lDQWdJQ0FnSUNBZ1hUdGNibHh1SUNBZ0lITjFjR1Z5S0hCaGNuUnpLVnh1SUNCOVhHNTlYRzRpWFN3aWJtRnRaWE1pT2xzaVRrOWZWMGhKVkVWVFVFRkRSU0lzSW5Od1pXTnBZV3hUZVcxaWIyeHpJaXdpVG05WGFHbDBaWE53WVdObFVHRnlkRVJsWm1sdWFYUnBiMjRpTENKamIyNTBaVzUwSWl3aWRHVnliV2x1WVd4VGVXMWliMnhRWVhKMElpd2lWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJaXdpY0dGeWRITWlMQ0pFWldacGJtbDBhVzl1SWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUlN0Q0xFbEJRVUVzV1VGQll5eFhRVUZrTEdOQlFXTXNRMEZCUVR0QlFVVjBRaXhKUVVGQkxGZEJRV1VzYTBOQlFXWXNaVUZCWlN4RlFVRkJPMEZCUTFBc1NVRkJRU3hsUVVGcFF5eHJRMEZCYWtNc2FVTkJRV2xETEVWQlFVRTdPenM3T3pzN096czdPenM3T3p0TFFVeG9SVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVU5QkxFbEJRVTBzUVVGQlJVRXNZVUZCWVN4SFFVRkxReXhaUVVGakxHZENRVUZvUTBRc1lVRkJZU3hCUVVGdFFpeEJRVUZETzBGQlJURkNMRWxCUVVFc1FVRkJUVVVzTUVKQlFUQkNMR2xDUTFRMVF5eEJSRk5aTzNGRVFWUm1PenRoUVZOeFFrRXNNRUpCUVRCQ08zbEVRVlF2UXp0UlFWZEpMRWxCUVUxRExFOUJRVThzUjBGQlIwZ3NZVUZCWVN4RlFVTjJRa2tzYTBKQlFXdENMRWRCUVVjc1NVRkJTVU1zWlVGQmEwSXNVMEZCUTBZc1QwRkJUeXhEUVVGRExFVkJRM0JFUnl4TFFVRkxMRWRCUVVjN1dVRkRUa1lzYTBKQlFXdENPMU5CUTI1Q0xFRkJRVU03YVVOQlJVWkZMRXRCUVVzN096dERRVVZrTEVOQlZuVkVReXhYUVVGVkxGTkJWV3BGTzJ0Q1FWWnZRa3dzTUVKQlFUQkNMRUZCVkM5REluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfbm9XaGl0ZXNwYWNlUGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL25vV2hpdGVzcGFjZVBhcnRcIikpO1xudmFyIF9ub1doaXRlc3BhY2VQYXJ0MSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vbm9XaGl0ZXNwYWNlUGFydFwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgTm9XaGl0ZXNwYWNlUGFydFJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJ1bGUpIHtcbiAgICBfaW5oZXJpdHMoTm9XaGl0ZXNwYWNlUGFydFJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTm9XaGl0ZXNwYWNlUGFydFJ1bGUpO1xuICAgIGZ1bmN0aW9uIE5vV2hpdGVzcGFjZVBhcnRSdWxlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9XaGl0ZXNwYWNlUGFydFJ1bGUpO1xuICAgICAgICB2YXIgbm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb24gPSBuZXcgX25vV2hpdGVzcGFjZVBhcnQxLmRlZmF1bHQoKSwgbmFtZSA9IF9ydWxlTmFtZXMuTm9XaGl0ZXNwYWNlUGFydFJ1bGVOYW1lLCBhbWJpZ3VvdXMgPSBmYWxzZSwgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX25vV2hpdGVzcGFjZVBhcnQuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gTm9XaGl0ZXNwYWNlUGFydFJ1bGU7XG59KF9ydWxlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9XaGl0ZXNwYWNlUGFydFJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDI1dlYyaHBkR1Z6Y0dGalpWQmhjblF1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxYQ0k3WEc1cGJYQnZjblFnVG05WGFHbDBaWE53WVdObFVHRnlkRUpPUms1dlpHVWdabkp2YlNCY0lpNHVMMjV2WkdVdlltNW1MMjV2VjJocGRHVnpjR0ZqWlZCaGNuUmNJanRjYm1sdGNHOXlkQ0JPYjFkb2FYUmxjM0JoWTJWUVlYSjBSR1ZtYVc1cGRHbHZiaUJtY205dElGd2lMaTR2WkdWbWFXNXBkR2x2Ymk5dWIxZG9hWFJsYzNCaFkyVlFZWEowWENJN1hHNWNibWx0Y0c5eWRDQjdJRTV2VjJocGRHVnpjR0ZqWlZCaGNuUlNkV3hsVG1GdFpTQjlJR1p5YjIwZ1hDSXVMaTl5ZFd4bFRtRnRaWE5jSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVG05WGFHbDBaWE53WVdObFVHRnlkRkoxYkdVZ1pYaDBaVzVrY3lCU2RXeGxJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2JtOVhhR2wwWlhOd1lXTmxVR0Z5ZEVSbFptbHVhWFJwYjI0Z1BTQnVaWGNnVG05WGFHbDBaWE53WVdObFVHRnlkRVJsWm1sdWFYUnBiMjRvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnVZVzFsSUQwZ1RtOVhhR2wwWlhOd1lXTmxVR0Z5ZEZKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lHRnRZbWxuZFc5MWN5QTlJR1poYkhObExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6SUQwZ1cxeHVJQ0FnSUNBZ0lDQWdJQ0FnYm05WGFHbDBaWE53WVdObFVHRnlkRVJsWm1sdWFYUnBiMjVjYmlBZ0lDQWdJQ0FnSUNCZExGeHVJQ0FnSUNBZ0lDQWdJRTV2WkdVZ1BTQk9iMWRvYVhSbGMzQmhZMlZRWVhKMFFrNUdUbTlrWlR0Y2JseHVJQ0FnSUhOMWNHVnlLRzVoYldVc0lHRnRZbWxuZFc5MWN5d2daR1ZtYVc1cGRHbHZibk1zSUU1dlpHVXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKT2IxZG9hWFJsYzNCaFkyVlFZWEowVW5Wc1pTSXNJbTV2VjJocGRHVnpjR0ZqWlZCaGNuUkVaV1pwYm1sMGFXOXVJaXdpVG05WGFHbDBaWE53WVdObFVHRnlkRVJsWm1sdWFYUnBiMjRpTENKdVlXMWxJaXdpVG05WGFHbDBaWE53WVdObFVHRnlkRkoxYkdWT1lXMWxJaXdpWVcxaWFXZDFiM1Z6SWl3aVpHVm1hVzVwZEdsdmJuTWlMQ0pPYjJSbElpd2lUbTlYYUdsMFpYTndZV05sVUdGeWRFSk9SazV2WkdVaUxDSlNkV3hsSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUldsQ0xFbEJRVUVzUzBGQlV5eHJRMEZCVkN4VFFVRlRMRVZCUVVFN1FVRkRWU3hKUVVGQkxHbENRVUU0UWl4clEwRkJPVUlzT0VKQlFUaENMRVZCUVVFN1FVRkRNMElzU1VGQlFTeHJRa0ZCWjBNc2EwTkJRV2hETEdkRFFVRm5ReXhGUVVGQk8wRkJSVGxDTEVsQlFVRXNWVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJUblpFT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlVXVXNTVUZCUVN4QlFVRk5RU3h2UWtGQmIwSXNhVUpEVW5SRExFRkVVVms3ZVVOQlVtWTdPMkZCVVhGQ1FTeHZRa0ZCYjBJN2JVUkJVbnBETzFGQlZVa3NTVUZCVFVNc01FSkJRVEJDTEVkQlFVY3NTVUZCU1VNc2EwSkJRVEJDTEZWQlFVVXNSVUZETjBSRExFbEJRVWtzUjBGQlIwTXNWVUZCZDBJc2VVSkJRVUVzUlVGREwwSkRMRk5CUVZNc1IwRkJSeXhMUVVGTExFVkJRMnBDUXl4WFFVRlhMRWRCUVVjN1dVRkRXa3dzTUVKQlFUQkNPMU5CUXpOQ0xFVkJRMFJOTEVsQlFVa3NSMEZCUjBNc2FVSkJRWFZDTEZGQlFVRXNRVUZCUXp0cFEwRkZMMEpNTEVsQlFVa3NSVUZCUlVVc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFWcHBSRVVzUzBGQlNTeFRRVmx5UkR0clFrRmFiMEpVTEc5Q1FVRnZRaXhCUVZKNlF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBNb2RpZmllckJORk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vblRlcm1pbmFsTm9kZSkge1xuICAgIF9pbmhlcml0cyhNb2RpZmllckJORk5vZGUsIE5vblRlcm1pbmFsTm9kZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNb2RpZmllckJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIE1vZGlmaWVyQk5GTm9kZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGlmaWVyQk5GTm9kZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE1vZGlmaWVyQk5GTm9kZSwgbnVsbCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhNb2RpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBNb2RpZmllckJORk5vZGU7XG59KF9ub25UZXJtaW5hbC5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGlmaWVyQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOXRiMlJwWm1sbGNpNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUU1dmJsUmxjbTFwYm1Gc1RtOWtaU0JtY205dElGd2lMaTR2TGk0dmJtOWtaUzl1YjI1VVpYSnRhVzVoYkZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCTmIyUnBabWxsY2tKT1JrNXZaR1VnWlhoMFpXNWtjeUJPYjI1VVpYSnRhVzVoYkU1dlpHVWdlMXh1SUNCemRHRjBhV01nWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeWh5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrZ2V5QnlaWFIxY200Z1RtOXVWR1Z5YldsdVlXeE9iMlJsTG1aeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1vVFc5a2FXWnBaWEpDVGtaT2IyUmxMQ0J5ZFd4bFRtRnRaU3dnWTJocGJHUk9iMlJsY3lrN0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5Sk5iMlJwWm1sbGNrSk9SazV2WkdVaUxDSm1jbTl0VW5Wc1pVNWhiV1ZCYm1SRGFHbHNaRTV2WkdWeklpd2ljblZzWlU1aGJXVWlMQ0pqYUdsc1pFNXZaR1Z6SWl3aVRtOXVWR1Z5YldsdVlXeE9iMlJsSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4WlFVRlpMRU5CUVVNN096dEZRVUZpTzNkQ1FVRkJPMEZCUlRSQ0xFbEJRVUVzV1VGQmQwSXNhME5CUVhoQ0xIZENRVUYzUWl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJSbkJFTzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN1MwRkJRVHM3T3pzN096czdPenM3T3p0TlFVRkJPM2xFUVVGQk96czdPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdNa0pCUVVFN096czdPenM3TzNGR1FVRkJPenM3T3pzN096czdPenM3YlVWQlFVRTdPMmxFUVVGQk96czdPenRCUVVsbExFbEJRVUVzUVVGQlRVRXNaVUZCWlN4cFFrTktha01zUVVSSldUc3JRMEZLWmpzN1lVRkpjVUpCTEdWQlFXVTdPRU5CU25CRE96czdPenRaUVV0VFF5eEhRVUY1UWl4RlFVRjZRa0VzTWtKQlFYbENPMWxGVEd4RExFOUdTMFVzVTBGQlQwRXNlVUpCUVhsQ0xFTkJRVU5ETEZGQlFWRXNSVUZCUlVNc1ZVRkJWU3hGUVVGRk8yZENRVUZGTEU5QlFVOURMRmxCUVdVc1UwRkJRMGdzZVVKQlFYbENMRU5CUVVORUxHVkJRV1VzUlVGQlJVVXNVVUZCVVN4RlFVRkZReXhWUVVGVkxFTkJRVU1zUTBGQlF6dGhRVUZGT3p0TlFVeHlTanM3UTBGTlF5eERRVVkwUTBNc1dVRkJaU3hUUVVVelJEdHJRa0ZHYjBKS0xHVkJRV1VzUVVGS2NFTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfbm9XaGl0ZXNwYWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvdGVybWluYWwvdGVybWluYWxTeW1ib2xcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIGVsbGlwc2lzID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmVsbGlwc2lzO1xudmFyIExvb2tBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoTG9va0FoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbiwgRGVmaW5pdGlvbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMb29rQWhlYWRNb2RpZmllclJ1bGVEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBMb29rQWhlYWRNb2RpZmllclJ1bGVEZWZpbml0aW9uKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9va0FoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBjb250ZW50ID0gZWxsaXBzaXMsIG5vV2hpdGVzcGFjZVBhcnQgPSBuZXcgX25vV2hpdGVzcGFjZS5kZWZhdWx0KCksIHRlcm1pbmFsU3ltYm9sUGFydCA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdChjb250ZW50KSwgcGFydHMgPSBbXG4gICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0LFxuICAgICAgICAgICAgdGVybWluYWxTeW1ib2xQYXJ0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0cyk7XG4gICAgfVxuICAgIHJldHVybiBMb29rQWhlYWRNb2RpZmllclJ1bGVEZWZpbml0aW9uO1xufShfZGVmaW5pdGlvbi5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IExvb2tBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMMnh2YjJ0QmFHVmhaRTF2WkdsbWFXVnlVblZzWlM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJSHNnYzNCbFkybGhiRk41YldKdmJITWdmU0JtY205dElGd2liMk5qWVcwdGJHVjRaWEp6WENJN1hHNWNibWx0Y0c5eWRDQkVaV1pwYm1sMGFXOXVJR1p5YjIwZ1hDSXVMaTlrWldacGJtbDBhVzl1WENJN1hHNXBiWEJ2Y25RZ1RtOVhhR2wwWlhOd1lXTmxVR0Z5ZENCbWNtOXRJRndpTGk0dmNHRnlkQzkwWlhKdGFXNWhiQzl1YjFkb2FYUmxjM0JoWTJWY0lqdGNibWx0Y0c5eWRDQlVaWEp0YVc1aGJGTjViV0p2YkZCaGNuUWdabkp2YlNCY0lpNHVMM0JoY25RdmRHVnliV2x1WVd3dmRHVnliV2x1WVd4VGVXMWliMnhjSWp0Y2JseHVZMjl1YzNRZ2V5QmxiR3hwY0hOcGN5QjlJRDBnYzNCbFkybGhiRk41YldKdmJITTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklFeHZiMnRCYUdWaFpFMXZaR2xtYVdWeVVuVnNaVVJsWm1sdWFYUnBiMjRnWlhoMFpXNWtjeUJFWldacGJtbDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdZMjl1ZEdWdWRDQTlJR1ZzYkdsd2MybHpMQ0FnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdibTlYYUdsMFpYTndZV05sVUdGeWRDQTlJRzVsZHlCT2IxZG9hWFJsYzNCaFkyVlFZWEowS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJRDBnYm1WM0lGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDaGpiMjUwWlc1MEtTeGNiaUFnSUNBZ0lDQWdJQ0J3WVhKMGN5QTlJRnRjYmlBZ0lDQWdJQ0FnSUNBZ0lHNXZWMmhwZEdWemNHRmpaVkJoY25Rc1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRk41YldKdmJGQmhjblJjYmlBZ0lDQWdJQ0FnSUNCZE8xeHVYRzRnSUNBZ2MzVndaWElvY0dGeWRITXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKbGJHeHBjSE5wY3lJc0luTndaV05wWVd4VGVXMWliMnh6SWl3aVRHOXZhMEZvWldGa1RXOWthV1pwWlhKU2RXeGxSR1ZtYVc1cGRHbHZiaUlzSW1OdmJuUmxiblFpTENKdWIxZG9hWFJsYzNCaFkyVlFZWEowSWl3aVRtOVhhR2wwWlhOd1lXTmxVR0Z5ZENJc0luUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDSXNJbFJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ0lzSW5CaGNuUnpJaXdpUkdWbWFXNXBkR2x2YmlKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVclFpeEpRVUZCTEZsQlFXTXNWMEZCWkN4alFVRmpMRU5CUVVFN1FVRkZkRUlzU1VGQlFTeFhRVUZsTEd0RFFVRm1MR1ZCUVdVc1JVRkJRVHRCUVVOVUxFbEJRVUVzWVVGQkswSXNhME5CUVM5Q0xDdENRVUVyUWl4RlFVRkJPMEZCUXpkQ0xFbEJRVUVzWlVGQmFVTXNhME5CUVdwRExHbERRVUZwUXl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRk9hRVU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUlFTeEpRVUZOTEVGQlFVVkJMRkZCUVZFc1IwRkJTME1zV1VGQll5eG5Ra0ZCTTBKRUxGRkJRVkVzUVVGQmJVSXNRVUZCUXp0QlFVVnlRaXhKUVVGQkxFRkJRVTFGTEN0Q1FVRXJRaXhwUWtOV2FrUXNRVVJWV1Rzd1JFRldaanM3WVVGVmNVSkJMQ3RDUVVFclFqczRSRUZXY0VRN1VVRlpTU3hKUVVGTlF5eFBRVUZQTEVkQlFVZElMRkZCUVZFc1JVRkRiRUpKTEdkQ1FVRm5RaXhIUVVGSExFbEJRVWxETEdGQlFXZENMRlZCUVVVc1JVRkRla05ETEd0Q1FVRnJRaXhIUVVGSExFbEJRVWxETEdWQlFXdENMRk5CUVVOS0xFOUJRVThzUTBGQlF5eEZRVU53UkVzc1MwRkJTeXhIUVVGSE8xbEJRMDVLTEdkQ1FVRm5RanRaUVVOb1FrVXNhMEpCUVd0Q08xTkJRMjVDTEVGQlFVTTdhVU5CUlVaRkxFdEJRVXM3T3p0RFFVVmtMRU5CV2pSRVF5eFhRVUZWTEZOQldYUkZPMnRDUVZwdlFsQXNLMEpCUVN0Q0xFRkJWbkJFSW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9tb2RpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL21vZGlmaWVyXCIpKTtcbnZhciBfbG9va0FoZWFkTW9kaWZpZXJSdWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9sb29rQWhlYWRNb2RpZmllclJ1bGVcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIExvb2tBaGVhZE1vZGlmaWVyUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhMb29rQWhlYWRNb2RpZmllclJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTG9va0FoZWFkTW9kaWZpZXJSdWxlKTtcbiAgICBmdW5jdGlvbiBMb29rQWhlYWRNb2RpZmllclJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb29rQWhlYWRNb2RpZmllclJ1bGUpO1xuICAgICAgICB2YXIgbmFtZSA9IF9ydWxlTmFtZXMuTG9va0FoZWFkTW9kaWZpZXJSdWxlTmFtZSwgbG9va0FoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBfbG9va0FoZWFkTW9kaWZpZXJSdWxlLmRlZmF1bHQoKSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbG9va0FoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX21vZGlmaWVyLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIExvb2tBaGVhZE1vZGlmaWVyUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBMb29rQWhlYWRNb2RpZmllclJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDJ4dmIydEJhR1ZoWkUxdlpHbG1hV1Z5TG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdVblZzWlNCbWNtOXRJRndpTGk0dmNuVnNaVndpTzF4dWFXMXdiM0owSUUxdlpHbG1hV1Z5UWs1R1RtOWtaU0JtY205dElGd2lMaTR2Ym05a1pTOWlibVl2Ylc5a2FXWnBaWEpjSWp0Y2JtbHRjRzl5ZENCTWIyOXJRV2hsWVdSTmIyUnBabWxsY2xKMWJHVkVaV1pwYm1sMGFXOXVJR1p5YjIwZ1hDSXVMaTlrWldacGJtbDBhVzl1TDJ4dmIydEJhR1ZoWkUxdlpHbG1hV1Z5VW5Wc1pWd2lPMXh1WEc1cGJYQnZjblFnZXlCTWIyOXJRV2hsWVdSTmIyUnBabWxsY2xKMWJHVk9ZVzFsSUgwZ1puSnZiU0JjSWk0dUwzSjFiR1ZPWVcxbGMxd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5Qk1iMjlyUVdobFlXUk5iMlJwWm1sbGNsSjFiR1VnWlhoMFpXNWtjeUJTZFd4bElIdGNiaUFnWTI5dWMzUnlkV04wYjNJb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYm1GdFpTQTlJRXh2YjJ0QmFHVmhaRTF2WkdsbWFXVnlVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnYkc5dmEwRm9aV0ZrVFc5a2FXWnBaWEpTZFd4bFJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCTWIyOXJRV2hsWVdSTmIyUnBabWxsY2xKMWJHVkVaV1pwYm1sMGFXOXVLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ1lXMWlhV2QxYjNWeklEMGdabUZzYzJVc1hHNGdJQ0FnSUNBZ0lDQWdaR1ZtYVc1cGRHbHZibk1nUFNCYlhHNGdJQ0FnSUNBZ0lDQWdJQ0JzYjI5clFXaGxZV1JOYjJScFptbGxjbEoxYkdWRVpXWnBibWwwYVc5dVhHNGdJQ0FnSUNBZ0lDQWdYU3hjYmlBZ0lDQWdJQ0FnSUNCT2IyUmxJRDBnVFc5a2FXWnBaWEpDVGtaT2IyUmxPMXh1SUNBZ0lGeHVJQ0FnSUhOMWNHVnlLRzVoYldVc0lHRnRZbWxuZFc5MWN5d2daR1ZtYVc1cGRHbHZibk1zSUU1dlpHVXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKTWIyOXJRV2hsWVdSTmIyUnBabWxsY2xKMWJHVWlMQ0p1WVcxbElpd2lURzl2YTBGb1pXRmtUVzlrYVdacFpYSlNkV3hsVG1GdFpTSXNJbXh2YjJ0QmFHVmhaRTF2WkdsbWFXVnlVblZzWlVSbFptbHVhWFJwYjI0aUxDSk1iMjlyUVdobFlXUk5iMlJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SWl3aVlXMWlhV2QxYjNWeklpd2laR1ZtYVc1cGRHbHZibk1pTENKT2IyUmxJaXdpVFc5a2FXWnBaWEpDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBVc1NVRkJRU3hUUVVGelFpeHJRMEZCZEVJc2MwSkJRWE5DTEVWQlFVRTdRVUZEVGl4SlFVRkJMSE5DUVVGeFF5eHJRMEZCY2tNc2NVTkJRWEZETEVWQlFVRTdRVUZGZGtNc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCT3pzN096czdPenM3T3pzN096czdTMEZPZUVRN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlJaU3hKUVVGQkxFRkJRVTFCTEhGQ1FVRnhRaXhwUWtOU2RrTXNRVVJSV1Rzd1EwRlNaanM3WVVGUmNVSkJMSEZDUVVGeFFqdHZSRUZTTVVNN1VVRlZTU3hKUVVGTlF5eEpRVUZKTEVkQlFVZERMRlZCUVhsQ0xEQkNRVUZCTEVWQlEyaERReXdyUWtGQkswSXNSMEZCUnl4SlFVRkpReXh6UWtGQkswSXNWVUZCUlN4RlFVTjJSVU1zVTBGQlV5eEhRVUZITEV0QlFVc3NSVUZEYWtKRExGZEJRVmNzUjBGQlJ6dFpRVU5hU0N3clFrRkJLMEk3VTBGRGFFTXNSVUZEUkVrc1NVRkJTU3hIUVVGSFF5eFRRVUZsTEZGQlFVRXNRVUZCUXp0cFEwRkZka0pRTEVsQlFVa3NSVUZCUlVrc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFWcHJSRVVzUzBGQlNTeFRRVmwwUkR0clFrRmFiMEpVTEhGQ1FVRnhRaXhCUVZJeFF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfZGVmaW5pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb25cIikpO1xudmFyIF9ub1doaXRlc3BhY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9wYXJ0L3Rlcm1pbmFsL25vV2hpdGVzcGFjZVwiKSk7XG52YXIgX3Rlcm1pbmFsU3ltYm9sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC90ZXJtaW5hbC90ZXJtaW5hbFN5bWJvbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgZXhjbGFtYXRpb25NYXJrID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmV4Y2xhbWF0aW9uTWFyaztcbnZhciBBbWJpZ3VvdXNNb2RpZmllclJ1bGVEZWZpbml0aW9uID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihEZWZpbml0aW9uKSB7XG4gICAgX2luaGVyaXRzKEFtYmlndW91c01vZGlmaWVyUnVsZURlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQW1iaWd1b3VzTW9kaWZpZXJSdWxlRGVmaW5pdGlvbik7XG4gICAgZnVuY3Rpb24gQW1iaWd1b3VzTW9kaWZpZXJSdWxlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFtYmlndW91c01vZGlmaWVyUnVsZURlZmluaXRpb24pO1xuICAgICAgICB2YXIgY29udGVudCA9IGV4Y2xhbWF0aW9uTWFyaywgbm9XaGl0ZXNwYWNlUGFydCA9IG5ldyBfbm9XaGl0ZXNwYWNlLmRlZmF1bHQoKSwgdGVybWluYWxTeW1ib2xQYXJ0ID0gbmV3IF90ZXJtaW5hbFN5bWJvbC5kZWZhdWx0KGNvbnRlbnQpLCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnQsXG4gICAgICAgICAgICB0ZXJtaW5hbFN5bWJvbFBhcnRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEFtYmlndW91c01vZGlmaWVyUnVsZURlZmluaXRpb247XG59KF9kZWZpbml0aW9uLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQW1iaWd1b3VzTW9kaWZpZXJSdWxlRGVmaW5pdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwyRnRZbWxuZFc5MWMwMXZaR2xtYVdWeVVuVnNaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElIc2djM0JsWTJsaGJGTjViV0p2YkhNZ2ZTQm1jbTl0SUZ3aWIyTmpZVzB0YkdWNFpYSnpYQ0k3WEc1Y2JtbHRjRzl5ZENCRVpXWnBibWwwYVc5dUlHWnliMjBnWENJdUxpOWtaV1pwYm1sMGFXOXVYQ0k3WEc1cGJYQnZjblFnVG05WGFHbDBaWE53WVdObFVHRnlkQ0JtY205dElGd2lMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOXViMWRvYVhSbGMzQmhZMlZjSWp0Y2JtbHRjRzl5ZENCVVpYSnRhVzVoYkZONWJXSnZiRkJoY25RZ1puSnZiU0JjSWk0dUwzQmhjblF2ZEdWeWJXbHVZV3d2ZEdWeWJXbHVZV3hUZVcxaWIyeGNJanRjYmx4dVkyOXVjM1FnZXlCbGVHTnNZVzFoZEdsdmJrMWhjbXNnZlNBOUlITndaV05wWVd4VGVXMWliMnh6TzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJCYldKcFozVnZkWE5OYjJScFptbGxjbEoxYkdWRVpXWnBibWwwYVc5dUlHVjRkR1Z1WkhNZ1JHVm1hVzVwZEdsdmJpQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtDa2dlMXh1SUNBZ0lHTnZibk4wSUdOdmJuUmxiblFnUFNCbGVHTnNZVzFoZEdsdmJrMWhjbXNzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0J1YjFkb2FYUmxjM0JoWTJWUVlYSjBJRDBnYm1WM0lFNXZWMmhwZEdWemNHRmpaVkJoY25Rb0tTeGNiaUFnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRk41YldKdmJGQmhjblFnUFNCdVpYY2dWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBLR052Ym5SbGJuUXBMRnh1SUNBZ0lDQWdJQ0FnSUhCaGNuUnpJRDBnVzF4dUlDQWdJQ0FnSUNBZ0lDQWdibTlYYUdsMFpYTndZV05sVUdGeWRDeGNiaUFnSUNBZ0lDQWdJQ0FnSUhSbGNtMXBibUZzVTNsdFltOXNVR0Z5ZEZ4dUlDQWdJQ0FnSUNBZ0lGMDdYRzVjYmlBZ0lDQnpkWEJsY2lod1lYSjBjeWxjYmlBZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYkltVjRZMnhoYldGMGFXOXVUV0Z5YXlJc0luTndaV05wWVd4VGVXMWliMnh6SWl3aVFXMWlhV2QxYjNWelRXOWthV1pwWlhKU2RXeGxSR1ZtYVc1cGRHbHZiaUlzSW1OdmJuUmxiblFpTENKdWIxZG9hWFJsYzNCaFkyVlFZWEowSWl3aVRtOVhhR2wwWlhOd1lXTmxVR0Z5ZENJc0luUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDSXNJbFJsY20xcGJtRnNVM2x0WW05c1VHRnlkQ0lzSW5CaGNuUnpJaXdpUkdWbWFXNXBkR2x2YmlKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVclFpeEpRVUZCTEZsQlFXTXNWMEZCWkN4alFVRmpMRU5CUVVFN1FVRkZkRUlzU1VGQlFTeFhRVUZsTEd0RFFVRm1MR1ZCUVdVc1JVRkJRVHRCUVVOVUxFbEJRVUVzWVVGQkswSXNhME5CUVM5Q0xDdENRVUVyUWl4RlFVRkJPMEZCUXpkQ0xFbEJRVUVzWlVGQmFVTXNhME5CUVdwRExHbERRVUZwUXl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRk9hRVU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUlFTeEpRVUZOTEVGQlFVVkJMR1ZCUVdVc1IwRkJTME1zV1VGQll5eG5Ra0ZCYkVORUxHVkJRV1VzUVVGQmJVSXNRVUZCUXp0QlFVVTFRaXhKUVVGQkxFRkJRVTFGTEN0Q1FVRXJRaXhwUWtOV2FrUXNRVVJWV1Rzd1JFRldaanM3WVVGVmNVSkJMQ3RDUVVFclFqczRSRUZXY0VRN1VVRlpTU3hKUVVGTlF5eFBRVUZQTEVkQlFVZElMR1ZCUVdVc1JVRkRla0pKTEdkQ1FVRm5RaXhIUVVGSExFbEJRVWxETEdGQlFXZENMRlZCUVVVc1JVRkRla05ETEd0Q1FVRnJRaXhIUVVGSExFbEJRVWxETEdWQlFXdENMRk5CUVVOS0xFOUJRVThzUTBGQlF5eEZRVU53UkVzc1MwRkJTeXhIUVVGSE8xbEJRMDVLTEdkQ1FVRm5RanRaUVVOb1FrVXNhMEpCUVd0Q08xTkJRMjVDTEVGQlFVTTdhVU5CUlVaRkxFdEJRVXM3T3p0RFFVVmtMRU5CV2pSRVF5eFhRVUZWTEZOQldYUkZPMnRDUVZwdlFsQXNLMEpCUVN0Q0xFRkJWbkJFSW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9tb2RpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL21vZGlmaWVyXCIpKTtcbnZhciBfYW1iaWd1b3VzTW9kaWZpZXJSdWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9hbWJpZ3VvdXNNb2RpZmllclJ1bGVcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIEFtYmlndW91c01vZGlmaWVyUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhBbWJpZ3VvdXNNb2RpZmllclJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQW1iaWd1b3VzTW9kaWZpZXJSdWxlKTtcbiAgICBmdW5jdGlvbiBBbWJpZ3VvdXNNb2RpZmllclJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbWJpZ3VvdXNNb2RpZmllclJ1bGUpO1xuICAgICAgICB2YXIgbmFtZSA9IF9ydWxlTmFtZXMuQW1iaWd1b3VzTW9kaWZpZXJSdWxlTmFtZSwgYW1iaWd1b3VzTW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBfYW1iaWd1b3VzTW9kaWZpZXJSdWxlLmRlZmF1bHQoKSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgYW1iaWd1b3VzTW9kaWZpZXJSdWxlRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX21vZGlmaWVyLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFtYmlndW91c01vZGlmaWVyUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBBbWJpZ3VvdXNNb2RpZmllclJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDJGdFltbG5kVzkxYzAxdlpHbG1hV1Z5TG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdVblZzWlNCbWNtOXRJRndpTGk0dmNuVnNaVndpTzF4dWFXMXdiM0owSUUxdlpHbG1hV1Z5UWs1R1RtOWtaU0JtY205dElGd2lMaTR2Ym05a1pTOWlibVl2Ylc5a2FXWnBaWEpjSWp0Y2JtbHRjRzl5ZENCQmJXSnBaM1Z2ZFhOTmIyUnBabWxsY2xKMWJHVkVaV1pwYm1sMGFXOXVJR1p5YjIwZ1hDSXVMaTlrWldacGJtbDBhVzl1TDJGdFltbG5kVzkxYzAxdlpHbG1hV1Z5VW5Wc1pWd2lPMXh1WEc1cGJYQnZjblFnZXlCQmJXSnBaM1Z2ZFhOTmIyUnBabWxsY2xKMWJHVk9ZVzFsSUgwZ1puSnZiU0JjSWk0dUwzSjFiR1ZPWVcxbGMxd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QkJiV0pwWjNWdmRYTk5iMlJwWm1sbGNsSjFiR1VnWlhoMFpXNWtjeUJTZFd4bElIdGNiaUFnWTI5dWMzUnlkV04wYjNJb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYm1GdFpTQTlJRUZ0WW1sbmRXOTFjMDF2WkdsbWFXVnlVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnWVcxaWFXZDFiM1Z6VFc5a2FXWnBaWEpTZFd4bFJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCQmJXSnBaM1Z2ZFhOTmIyUnBabWxsY2xKMWJHVkVaV1pwYm1sMGFXOXVLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ1lXMWlhV2QxYjNWeklEMGdabUZzYzJVc1hHNGdJQ0FnSUNBZ0lDQWdaR1ZtYVc1cGRHbHZibk1nUFNCYlhHNGdJQ0FnSUNBZ0lDQWdJQ0JoYldKcFozVnZkWE5OYjJScFptbGxjbEoxYkdWRVpXWnBibWwwYVc5dVhHNGdJQ0FnSUNBZ0lDQWdYU3hjYmlBZ0lDQWdJQ0FnSUNCT2IyUmxJRDBnVFc5a2FXWnBaWEpDVGtaT2IyUmxPMXh1SUNBZ0lGeHVJQ0FnSUhOMWNHVnlLRzVoYldVc0lHRnRZbWxuZFc5MWN5d2daR1ZtYVc1cGRHbHZibk1zSUU1dlpHVXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKQmJXSnBaM1Z2ZFhOTmIyUnBabWxsY2xKMWJHVWlMQ0p1WVcxbElpd2lRVzFpYVdkMWIzVnpUVzlrYVdacFpYSlNkV3hsVG1GdFpTSXNJbUZ0WW1sbmRXOTFjMDF2WkdsbWFXVnlVblZzWlVSbFptbHVhWFJwYjI0aUxDSkJiV0pwWjNWdmRYTk5iMlJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SWl3aVlXMWlhV2QxYjNWeklpd2laR1ZtYVc1cGRHbHZibk1pTENKT2IyUmxJaXdpVFc5a2FXWnBaWEpDVGtaT2IyUmxJaXdpVW5Wc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNXVUZCV1N4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVnBRaXhKUVVGQkxFdEJRVk1zYTBOQlFWUXNVMEZCVXl4RlFVRkJPMEZCUTBVc1NVRkJRU3hUUVVGelFpeHJRMEZCZEVJc2MwSkJRWE5DTEVWQlFVRTdRVUZEVGl4SlFVRkJMSE5DUVVGeFF5eHJRMEZCY2tNc2NVTkJRWEZETEVWQlFVRTdRVUZGZGtNc1NVRkJRU3hWUVVGakxGZEJRV1FzWTBGQll5eERRVUZCT3pzN096czdPenM3T3pzN096czdTMEZPZUVRN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlJaU3hKUVVGQkxFRkJRVTFCTEhGQ1FVRnhRaXhwUWtOU2RrTXNRVVJSV1Rzd1EwRlNaanM3WVVGUmNVSkJMSEZDUVVGeFFqdHZSRUZTTVVNN1VVRlZTU3hKUVVGTlF5eEpRVUZKTEVkQlFVZERMRlZCUVhsQ0xEQkNRVUZCTEVWQlEyaERReXdyUWtGQkswSXNSMEZCUnl4SlFVRkpReXh6UWtGQkswSXNWVUZCUlN4RlFVTjJSVU1zVTBGQlV5eEhRVUZITEV0QlFVc3NSVUZEYWtKRExGZEJRVmNzUjBGQlJ6dFpRVU5hU0N3clFrRkJLMEk3VTBGRGFFTXNSVUZEUkVrc1NVRkJTU3hIUVVGSFF5eFRRVUZsTEZGQlFVRXNRVUZCUXp0cFEwRkZka0pRTEVsQlFVa3NSVUZCUlVrc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFWcHJSRVVzUzBGQlNTeFRRVmwwUkR0clFrRmFiMEpVTEhGQ1FVRnhRaXhCUVZJeFF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3Rlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiKSk7XG52YXIgX3Rlcm1pbmFsMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvdGVybWluYWxcIikpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpe1xuICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBSZWd1bGFyRXhwcmVzc2lvblBhcnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFRlcm1pbmFsUGFydCkge1xuICAgIF9pbmhlcml0cyhSZWd1bGFyRXhwcmVzc2lvblBhcnQsIFRlcm1pbmFsUGFydCk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZWd1bGFyRXhwcmVzc2lvblBhcnQpO1xuICAgIGZ1bmN0aW9uIFJlZ3VsYXJFeHByZXNzaW9uUGFydChyZWd1bGFyRXhwcmVzc2lvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVndWxhckV4cHJlc3Npb25QYXJ0KTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICBfdGhpcy5yZWd1bGFyRXhwcmVzc2lvbiA9IHJlZ3VsYXJFeHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhSZWd1bGFyRXhwcmVzc2lvblBhcnQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksIG5leHRTaWduaWZpY2FudFRva2VuID0gc3RhdGUuZ2V0TmV4dFNpZ25pZmljYW50VG9rZW4oKSwgc2lnbmlmaWNhbnRUb2tlbiA9IG5leHRTaWduaWZpY2FudFRva2VuOyAvLy9cbiAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHNpZ25pZmljYW50VG9rZW4uZ2V0Q29udGVudCgpLCBtYXRjaGVzID0gY29udGVudC5tYXRjaCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdE1hdGNoID0gKDAsIF9hcnJheSkuZmlyc3QobWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RNYXRjaCA9PT0gY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IF90ZXJtaW5hbDEuZGVmYXVsdC5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0ZXJtaW5hbE5vZGUgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHRlcm1pbmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXNTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVndWxhckV4cHJlc3Npb25TdHJpbmcgPSB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uLnRvU3RyaW5nKCksIHN0cmluZyA9IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nOyAvLy9cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoUmVndWxhckV4cHJlc3Npb25QYXJ0LnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBSZWd1bGFyRXhwcmVzc2lvblBhcnQsIHRoaXMucmVndWxhckV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJlZ3VsYXJFeHByZXNzaW9uUGFydDtcbn0oX3Rlcm1pbmFsLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVndWxhckV4cHJlc3Npb25QYXJ0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lYSjBMM1JsY20xcGJtRnNMM0psWjNWc1lYSkZlSEJ5WlhOemFXOXVMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4UVlYSjBJR1p5YjIwZ1hDSXVMaTh1TGk5d1lYSjBMM1JsY20xcGJtRnNYQ0k3WEc1cGJYQnZjblFnVkdWeWJXbHVZV3hPYjJSbElHWnliMjBnWENJdUxpOHVMaTl1YjJSbEwzUmxjbTFwYm1Gc1hDSTdYRzVjYm1sdGNHOXlkQ0I3SUdacGNuTjBJSDBnWm5KdmJTQmNJaTR1THk0dUwzVjBhV3hwZEdsbGN5OWhjbkpoZVZ3aU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxCaGNuUWdaWGgwWlc1a2N5QlVaWEp0YVc1aGJGQmhjblFnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWh5WldkMWJHRnlSWGh3Y21WemMybHZiaWtnZTF4dUlDQWdJSE4xY0dWeUtDazdYRzVjYmlBZ0lDQjBhR2x6TG5KbFozVnNZWEpGZUhCeVpYTnphVzl1SUQwZ2NtVm5kV3hoY2tWNGNISmxjM05wYjI0N1hHNGdJSDFjYmx4dUlDQndZWEp6WlNodWIyUmxjeXdnYzNSaGRHVXNJR05oYkd4aVlXTnJLU0I3WEc0Z0lDQWdiR1YwSUhCaGNuTmxaRHRjYmx4dUlDQWdJR3hsZENCMFpYSnRhVzVoYkU1dlpHVWdQU0J1ZFd4c08xeHVJQ0FnSUZ4dUlDQWdJR052Ym5OMElITmhkbVZrU1c1a1pYZ2dQU0J6ZEdGMFpTNW5aWFJUWVhabFpFbHVaR1Y0S0Nrc1hHNWNkRngwSUNBZ0lDQWdibVY0ZEZOcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCemRHRjBaUzVuWlhST1pYaDBVMmxuYm1sbWFXTmhiblJVYjJ0bGJpZ3BMRnh1WEhSY2RGeDBYSFJjZEhOcFoyNXBabWxqWVc1MFZHOXJaVzRnUFNCdVpYaDBVMmxuYm1sbWFXTmhiblJVYjJ0bGJqc2dMeTh2WEc1Y2JpQWdJQ0JwWmlBb2MybG5ibWxtYVdOaGJuUlViMnRsYmlBaFBUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ1kyOXVjM1FnWTI5dWRHVnVkQ0E5SUhOcFoyNXBabWxqWVc1MFZHOXJaVzR1WjJWMFEyOXVkR1Z1ZENncExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYldGMFkyaGxjeUE5SUdOdmJuUmxiblF1YldGMFkyZ29kR2hwY3k1eVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlrN1hHNWNiaUFnSUNBZ0lHbG1JQ2h0WVhSamFHVnpJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1pwY25OMFRXRjBZMmdnUFNCbWFYSnpkQ2h0WVhSamFHVnpLVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9abWx5YzNSTllYUmphQ0E5UFQwZ1kyOXVkR1Z1ZENrZ2UxeHVJQ0FnSUNBZ0lDQWdJSFJsY20xcGJtRnNUbTlrWlNBOUlGUmxjbTFwYm1Gc1RtOWtaUzVtY205dFUybG5ibWxtYVdOaGJuUlViMnRsYmloemFXZHVhV1pwWTJGdWRGUnZhMlZ1S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUhCaGNuTmxaQ0E5SUNoMFpYSnRhVzVoYkU1dlpHVWdJVDA5SUc1MWJHd3BPMXh1WEc0Z0lDQWdhV1lnS0hCaGNuTmxaQ2tnZTF4dUlDQWdJQ0FnYm05a1pYTXVjSFZ6YUNoMFpYSnRhVzVoYkU1dlpHVXBPMXh1WEc0Z0lDQWdJQ0JwWmlBb1kyRnNiR0poWTJzZ0lUMDlJRzUxYkd3cElIdGNiaUFnSUNBZ0lDQWdjR0Z5YzJWa0lEMGdZMkZzYkdKaFkyc29LVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9JWEJoY25ObFpDa2dlMXh1SUNBZ0lDQWdJQ0FnSUc1dlpHVnpMbkJ2Y0NncE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLQ0Z3WVhKelpXUXBJSHRjYmlBZ0lDQWdJSE4wWVhSbExtSmhZMnQwY21GamF5aHpZWFpsWkVsdVpHVjRLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200Z2NHRnljMlZrTzF4dUlDQjlYRzVjYmlBZ1lYTlRkSEpwYm1jb0tTQjdYRzRnSUNBZ1kyOXVjM1FnY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjVUZEhKcGJtY2dQU0IwYUdsekxuSmxaM1ZzWVhKRmVIQnlaWE56YVc5dUxuUnZVM1J5YVc1bktDa3NYRzVjZEZ4MElDQWdJQ0FnYzNSeWFXNW5JRDBnY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjVUZEhKcGJtYzdJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJSE4wY21sdVp6dGNiaUFnZlZ4dVhHNGdJR05zYjI1bEtDa2dleUJ5WlhSMWNtNGdjM1Z3WlhJdVkyeHZibVVvVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhKMExDQjBhR2x6TG5KbFozVnNZWEpGZUhCeVpYTnphVzl1S1RzZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklsSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVVHRnlkQ0lzSW5KbFozVnNZWEpGZUhCeVpYTnphVzl1SWl3aWNHRnljMlVpTENKdWIyUmxjeUlzSW5OMFlYUmxJaXdpWTJGc2JHSmhZMnNpTENKd1lYSnpaV1FpTENKMFpYSnRhVzVoYkU1dlpHVWlMQ0p6WVhabFpFbHVaR1Y0SWl3aVoyVjBVMkYyWldSSmJtUmxlQ0lzSW01bGVIUlRhV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2laMlYwVG1WNGRGTnBaMjVwWm1sallXNTBWRzlyWlc0aUxDSnphV2R1YVdacFkyRnVkRlJ2YTJWdUlpd2lZMjl1ZEdWdWRDSXNJbWRsZEVOdmJuUmxiblFpTENKdFlYUmphR1Z6SWl3aWJXRjBZMmdpTENKbWFYSnpkRTFoZEdOb0lpd2labWx5YzNRaUxDSlVaWEp0YVc1aGJFNXZaR1VpTENKbWNtOXRVMmxuYm1sbWFXTmhiblJVYjJ0bGJpSXNJbkIxYzJnaUxDSndiM0FpTENKaVlXTnJkSEpoWTJzaUxDSmhjMU4wY21sdVp5SXNJbkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVVM1J5YVc1bklpd2lkRzlUZEhKcGJtY2lMQ0p6ZEhKcGJtY2lMQ0pqYkc5dVpTSXNJbFJsY20xcGJtRnNVR0Z5ZENKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWNVFpeEpRVUZCTEZOQlFYRkNMR3REUVVGeVFpeHhRa0ZCY1VJc1JVRkJRVHRCUVVOeVFpeEpRVUZCTEZWQlFYRkNMR3REUVVGeVFpeHhRa0ZCY1VJc1JVRkJRVHRCUVVWNFFpeEpRVUZCTEUxQlFYVkNMRmRCUVhaQ0xIVkNRVUYxUWl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJURGRETzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzd1FrRkJRVHM3T3pzN096czdPenRUUVVGQk96czdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096dDNRMEZCUVRzN096czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGUFpTeEpRVUZCTEVGQlFVMUJMSEZDUVVGeFFpeHBRa05RZGtNc1FVUlBXVHRyUkVGUVpqczdZVUZQY1VKQkxIRkNRVUZ4UWl4RFFVTTFRa01zYVVKQlFXbENPMjlFUVZJdlFqczdhVU5GUVVFc1EwWlRXVHRSUVVWU0xFMUJRVXRCTEdsQ1FVRnBRaXhIUVVGSFFTeHBRa0ZCYVVJc1EwRkJRenM3T3pzN1dVRkhOME5ETEVkQlFVc3NSVUZCVEVFc1QwRkJTenRaUldSUUxFOUdZMFZCTEZOQlFVRkJMRXRCUVVzc1EwRkJRME1zUzBGQlN5eEZRVUZGUXl4TFFVRkxMRVZCUVVWRExGRkJRVkVzUlVGQlJUdG5Ra0ZETlVJc1NVRkJTVU1zVFVGQlRTeEJRVUZETzJkQ1FVVllMRWxCUVVsRExGbEJRVmtzUjBGQlJ5eEpRVUZKTEVGQlFVTTdaMEpCUlhoQ0xFbEJRVTFETEZWQlFWVXNSMEZCUjBvc1MwRkJTeXhEUVVGRFN5eGhRVUZoTEVWQlFVVXNSVUZEY0VORExHOUNRVUZ2UWl4SFFVRkhUaXhMUVVGTExFTkJRVU5QTEhWQ1FVRjFRaXhGUVVGRkxFVkJRM3BFUXl4blFrRkJaMElzUjBGQlIwWXNiMEpCUVc5Q0xFRkJRVU1zUlVGQlF5eEhRVUZITzJkQ1FVVTNReXhKUVVGSlJTeG5Ra0ZCWjBJc1MwRkJTeXhKUVVGSkxFVkJRVVU3YjBKQlF6ZENMRWxCUVUxRExFOUJRVThzUjBGQlIwUXNaMEpCUVdkQ0xFTkJRVU5GTEZWQlFWVXNSVUZCUlN4RlFVTjJRME1zVDBGQlR5eEhRVUZIUml4UFFVRlBMRU5CUVVOSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTm1MR2xDUVVGcFFpeERRVUZETEVGQlFVTTdiMEpCUlhSRUxFbEJRVWxqTEU5QlFVOHNTMEZCU3l4SlFVRkpMRVZCUVVVN2QwSkJRM0JDTEVsQlFVMUZMRlZCUVZVc1IwRkJSME1zUTBGQlFVRXNSMEZCUVVFc1RVRkJTeXhCUVVGVExFTkJRVUVzVDBGQlVrZ3NUMEZCVHl4RFFVRkRMRUZCUVVNN2QwSkJSV3hETEVsQlFVbEZMRlZCUVZVc1MwRkJTMG9zVDBGQlR5eEZRVUZGT3pSQ1FVTXhRazRzV1VGQldTeEhRVUZIV1N4VlFVRlpMRk5CUVVORExHOUNRVUZ2UWl4RFFVRkRVaXhuUWtGQlowSXNRMEZCUXl4RFFVRkRPM2xDUVVOd1JUdHhRa0ZEUmp0cFFrRkRSanRuUWtGRlJFNHNUVUZCVFN4SFFVRkpReXhaUVVGWkxFdEJRVXNzU1VGQlNTeEJRVUZETEVOQlFVTTdaMEpCUldwRExFbEJRVWxFTEUxQlFVMHNSVUZCUlR0dlFrRkRWa2dzUzBGQlN5eERRVUZEYTBJc1NVRkJTU3hEUVVGRFpDeFpRVUZaTEVOQlFVTXNRMEZCUXp0dlFrRkZla0lzU1VGQlNVWXNVVUZCVVN4TFFVRkxMRWxCUVVrc1JVRkJSVHQzUWtGRGNrSkRMRTFCUVUwc1IwRkJSMFFzVVVGQlVTeEZRVUZGTEVOQlFVTTdkMEpCUlhCQ0xFbEJRVWtzUTBGQlEwTXNUVUZCVFN4RlFVRkZPelJDUVVOWVNDeExRVUZMTEVOQlFVTnRRaXhIUVVGSExFVkJRVVVzUTBGQlF6dDVRa0ZEWWp0eFFrRkRSanRwUWtGRFJqdG5Ra0ZGUkN4SlFVRkpMRU5CUVVOb1FpeE5RVUZOTEVWQlFVVTdiMEpCUTFoR0xFdEJRVXNzUTBGQlEyMUNMRk5CUVZNc1EwRkJRMllzVlVGQlZTeERRVUZETEVOQlFVTTdhVUpCUXpkQ08yZENRVVZFTEU5QlFVOUdMRTFCUVUwc1EwRkJRenRoUVVObU96czdXVUZGUkd0Q0xFZEJRVkVzUlVGQlVrRXNWVUZCVVR0WlJYcEVWaXhQUm5sRVJVRXNVMEZCUVVFc1VVRkJVU3hIUVVGSE8yZENRVU5VTEVsQlFVMURMSFZDUVVGMVFpeEhRVUZITEVsQlFVa3NRMEZCUTNoQ0xHbENRVUZwUWl4RFFVRkRlVUlzVVVGQlVTeEZRVUZGTEVWQlF6ZEVReXhOUVVGTkxFZEJRVWRHTEhWQ1FVRjFRaXhCUVVGRExFVkJRVU1zUjBGQlJ6dG5Ra0ZGZWtNc1QwRkJUMFVzVFVGQlRTeERRVUZETzJGQlEyWTdPenRaUVVWRVF5eEhRVUZMTEVWQlFVeEJMRTlCUVVzN1dVVm9SVkFzVDBablJVVkJMRk5CUVVGQkxFdEJRVXNzUjBGQlJ6dG5Ra0ZCUlN4UFFVRlBMSEZDUVhwRVJUVkNMSEZDUVVGeFFpeGhRWGxFYWtJMFFpeFBRVUZMTEVWQlFWZ3NTVUZCU3l4RFFVRkJMRmxCUVU4MVFpeHhRa0ZCY1VJc1JVRkJSU3hKUVVGSkxFTkJRVU5ETEdsQ1FVRnBRaXhGUVVGRk8yRkJRVVU3TzAxQmFFVm9SanM3UTBGcFJVTXNRMEV4Ukd0RU5FSXNVMEZCV1N4VFFUQkVPVVE3YTBKQk1VUnZRamRDTEhGQ1FVRnhRaXhCUVZBeFF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG52YXIgX3JlZ3VsYXJFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcGFydC90ZXJtaW5hbC9yZWd1bGFyRXhwcmVzc2lvblwiKSk7XG52YXIgX2FycmF5ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxpdGllcy9hcnJheVwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgUmVndWxhckV4cHJlc3Npb25CTkZOb2RlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBfaW5oZXJpdHMoUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLCBOb25UZXJtaW5hbE5vZGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVndWxhckV4cHJlc3Npb25CTkZOb2RlKTtcbiAgICBmdW5jdGlvbiBSZWd1bGFyRXhwcmVzc2lvbkJORk5vZGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWd1bGFyRXhwcmVzc2lvbkJORk5vZGUpO1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJyZWd1bGFyRXhwcmVzc2lvblwiLCAvXlxcLygoPzpcXFxcLnxbXlxcL10pKilcXC8kLyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFJlZ3VsYXJFeHByZXNzaW9uQk5GTm9kZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuZXJhdGVQYXJ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQYXJ0KGxvb2tBaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciByZWd1bGFyRXhwcmVzc2lvbiA9IHRoaXMuZ2V0UmVndWxhckV4cHJlc3Npb24oKSwgcmVndWxhckV4cHJlc3Npb25QYXJ0ID0gbmV3IF9yZWd1bGFyRXhwcmVzc2lvbi5kZWZhdWx0KHJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25QYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0UmVndWxhckV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWd1bGFyRXhwcmVzc2lvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLCBmaXJzdENoaWxkTm9kZSA9ICgwLCBfYXJyYXkpLmZpcnN0KGNoaWxkTm9kZXMpLCB0ZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksIG1hdGNoZXMgPSB0ZXJtaW5hbE5vZGVDb250ZW50Lm1hdGNoKHRoaXMucmVndWxhckV4cHJlc3Npb24pLCBzZWNvbmRNYXRjaCA9ICgwLCBfYXJyYXkpLnNlY29uZChtYXRjaGVzKSwgcGF0dGVybiA9IHNlY29uZE1hdGNoLCByZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocGF0dGVybik7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiByZWd1bGFyRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25UZXJtaW5hbC5kZWZhdWx0LmZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMoUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUmVndWxhckV4cHJlc3Npb25CTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWd1bGFyRXhwcmVzc2lvbkJORk5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTl1YjJSbEwySnVaaTl5WldkMWJHRnlSWGh3Y21WemMybHZiaTVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNUbTlrWlNCbWNtOXRJRndpTGk0dkxpNHZibTlrWlM5dWIyNVVaWEp0YVc1aGJGd2lPMXh1YVcxd2IzSjBJRkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVVR0Z5ZENCbWNtOXRJRndpTGk0dkxpNHZjR0Z5ZEM5MFpYSnRhVzVoYkM5eVpXZDFiR0Z5Ulhod2NtVnpjMmx2Ymx3aU8xeHVYRzVwYlhCdmNuUWdleUJtYVhKemRDd2djMlZqYjI1a0lIMGdabkp2YlNCY0lpNHVMeTR1TDNWMGFXeHBkR2xsY3k5aGNuSmhlVndpTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJTWldkMWJHRnlSWGh3Y21WemMybHZia0pPUms1dlpHVWdaWGgwWlc1a2N5Qk9iMjVVWlhKdGFXNWhiRTV2WkdVZ2UxeHVJQ0J5WldkMWJHRnlSWGh3Y21WemMybHZiaUE5SUM5ZVhGd3ZLQ2cvT2x4Y1hGd3VmRnRlWEZ3dlhTa3FLVnhjTHlRdk8xeHVYRzRnSUdkbGJtVnlZWFJsVUdGeWRDaHNiMjlyUVdobFlXUXBJSHRjYmlBZ0lDQmpiMjV6ZENCeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlBOUlIUm9hWE11WjJWMFVtVm5kV3hoY2tWNGNISmxjM05wYjI0b0tTeGNiaUFnSUNBZ0lDQWdJQ0J5WldkMWJHRnlSWGh3Y21WemMybHZibEJoY25RZ1BTQnVaWGNnVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhKMEtISmxaM1ZzWVhKRmVIQnlaWE56YVc5dUtUdGNibHh1SUNBZ0lISmxkSFZ5YmlCeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmxCaGNuUTdYRzRnSUgxY2JseHVJQ0JuWlhSU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmlncElIdGNiaUFnSUNCamIyNXpkQ0JqYUdsc1pFNXZaR1Z6SUQwZ2RHaHBjeTVuWlhSRGFHbHNaRTV2WkdWektDa3NYRzRnSUNBZ0lDQWdJQ0FnWm1seWMzUkRhR2xzWkU1dlpHVWdQU0JtYVhKemRDaGphR2xzWkU1dlpHVnpLU3hjYmlBZ0lDQWdJQ0FnSUNCMFpYSnRhVzVoYkU1dlpHVWdQU0JtYVhKemRFTm9hV3hrVG05a1pTd2dJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lIUmxjbTFwYm1Gc1RtOWtaVU52Ym5SbGJuUWdQU0IwWlhKdGFXNWhiRTV2WkdVdVoyVjBRMjl1ZEdWdWRDZ3BMRnh1SUNBZ0lDQWdJQ0FnSUcxaGRHTm9aWE1nUFNCMFpYSnRhVzVoYkU1dlpHVkRiMjUwWlc1MExtMWhkR05vS0hSb2FYTXVjbVZuZFd4aGNrVjRjSEpsYzNOcGIyNHBMRnh1SUNBZ0lDQWdJQ0FnSUhObFkyOXVaRTFoZEdOb0lEMGdjMlZqYjI1a0tHMWhkR05vWlhNcExGeHVJQ0FnSUNBZ0lDQWdJSEJoZEhSbGNtNGdQU0J6WldOdmJtUk5ZWFJqYUN3Z0x5OHZYRzRnSUNBZ0lDQWdJQ0FnY21WbmRXeGhja1Y0Y0hKbGMzTnBiMjRnUFNCdVpYY2dVbVZuUlhod0tIQmhkSFJsY200cE95QWdMeTh2WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjbVZuZFd4aGNrVjRjSEpsYzNOcGIyNDdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZKMWJHVk9ZVzFsUVc1a1EyaHBiR1JPYjJSbGN5aHlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWtnZXlCeVpYUjFjbTRnVG05dVZHVnliV2x1WVd4T2IyUmxMbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTW9VbVZuZFd4aGNrVjRjSEpsYzNOcGIyNUNUa1pPYjJSbExDQnlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWs3SUgxY2JuMWNibHh1SWwwc0ltNWhiV1Z6SWpwYklsSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVFrNUdUbTlrWlNJc0luSmxaM1ZzWVhKRmVIQnlaWE56YVc5dUlpd2laMlZ1WlhKaGRHVlFZWEowSWl3aWJHOXZhMEZvWldGa0lpd2laMlYwVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjRpTENKeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmxCaGNuUWlMQ0pTWldkMWJHRnlSWGh3Y21WemMybHZibEJoY25RaUxDSmphR2xzWkU1dlpHVnpJaXdpWjJWMFEyaHBiR1JPYjJSbGN5SXNJbVpwY25OMFEyaHBiR1JPYjJSbElpd2labWx5YzNRaUxDSjBaWEp0YVc1aGJFNXZaR1VpTENKMFpYSnRhVzVoYkU1dlpHVkRiMjUwWlc1MElpd2laMlYwUTI5dWRHVnVkQ0lzSW0xaGRHTm9aWE1pTENKdFlYUmphQ0lzSW5ObFkyOXVaRTFoZEdOb0lpd2ljMlZqYjI1a0lpd2ljR0YwZEdWeWJpSXNJbEpsWjBWNGNDSXNJbVp5YjIxU2RXeGxUbUZ0WlVGdVpFTm9hV3hrVG05a1pYTWlMQ0p5ZFd4bFRtRnRaU0lzSWs1dmJsUmxjbTFwYm1Gc1RtOWtaU0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVUwUWl4SlFVRkJMRmxCUVhkQ0xHdERRVUY0UWl4M1FrRkJkMElzUlVGQlFUdEJRVU5zUWl4SlFVRkJMR3RDUVVGMVF5eHJRMEZCZGtNc2RVTkJRWFZETEVWQlFVRTdRVUZGTTBNc1NVRkJRU3hOUVVGMVFpeFhRVUYyUWl4MVFrRkJkVUlzUTBGQlFUczdPenM3T3pzN096czdPenM3T3poRVFVeHlSRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3T3pzN096dFZRVUZCT3p0M1FrRkJRVHM3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlQyVXNTVUZCUVN4QlFVRk5RU3gzUWtGQmQwSXNhVUpEVURORExFRkVUMkU3ZDBSQlVHWTdPMkZCVDNGQ1FTeDNRa0ZCZDBJN2RVUkJVRGRET3pzMlEwRkJRVHRSUVZGRlF5d3JRMEZCUVVFc2JVSkJRV2xDTERKQ1FVRTBRaXhCUlZJdlF5eERSbEVyUXpzN096czdXVUZGTjBORExFZEJRVmtzUlVGQldrRXNZMEZCV1R0WlJWWmtMRTlHVlVWQkxGTkJRVUZCTEZsQlFWa3NRMEZCUTBNc1UwRkJVeXhGUVVGRk8yZENRVU4wUWl4SlFVRk5SaXhwUWtGQmFVSXNSMEZCUnl4SlFVRkpMRU5CUVVOSExHOUNRVUZ2UWl4RlFVRkZMRVZCUXk5RFF5eHhRa0ZCY1VJc1IwRkJSeXhKUVVGSlF5eHJRa0ZCY1VJc1UwRkJRMHdzYVVKQlFXbENMRU5CUVVNc1FVRkJRenRuUWtGRk0wVXNUMEZCVDBrc2NVSkJRWEZDTEVOQlFVTTdZVUZET1VJN096dFpRVVZFUkN4SFFVRnZRaXhGUVVGd1FrRXNjMEpCUVc5Q08xbEZha0owUWl4UFJtbENSVUVzVTBGQlFVRXNiMEpCUVc5Q0xFZEJRVWM3WjBKQlEzSkNMRWxCUVUxSExGVkJRVlVzUjBGQlJ5eEpRVUZKTEVOQlFVTkRMR0ZCUVdFc1JVRkJSU3hGUVVOcVEwTXNZMEZCWXl4SFFVRkhReXhEUVVGQlFTeEhRVUZCUVN4TlFVRkxMRUZCUVZrc1EwRkJRU3hQUVVGWVNDeFZRVUZWTEVOQlFVTXNSVUZEYkVOSkxGbEJRVmtzUjBGQlIwWXNZMEZCWXl4RlFVTTNRa2NzYlVKQlFXMUNMRWRCUVVkRUxGbEJRVmtzUTBGQlEwVXNWVUZCVlN4RlFVRkZMRVZCUXk5RFF5eFBRVUZQTEVkQlFVZEdMRzFDUVVGdFFpeERRVUZEUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRFpDeHBRa0ZCYVVJc1EwRkJReXhGUVVNelJHVXNWMEZCVnl4SFFVRkhReXhEUVVGQlFTeEhRVUZCUVN4TlFVRk5MRUZCUVZNc1EwRkJRU3hSUVVGU1NDeFBRVUZQTEVOQlFVTXNSVUZETjBKSkxFOUJRVThzUjBGQlIwWXNWMEZCVnl4RlFVTnlRbVlzYVVKQlFXbENMRWRCUVVjc1NVRkJTV3RDTEUxQlFVMHNRMEZCUTBRc1QwRkJUeXhEUVVGRExFRkJRVU1zUlVGQlJTeEhRVUZITzJkQ1FVVnVSQ3hQUVVGUGFrSXNhVUpCUVdsQ0xFTkJRVU03WVVGRE1VSTdPenM3V1VGRlRXMUNMRWRCUVhsQ0xFVkJRWHBDUVN3eVFrRkJlVUk3V1VVNVFteERMRTlHT0VKRkxGTkJRVTlCTEhsQ1FVRjVRaXhEUVVGRFF5eFJRVUZSTEVWQlFVVmtMRlZCUVZVc1JVRkJSVHRuUWtGQlJTeFBRVUZQWlN4WlFVRmxMRk5CUVVOR0xIbENRVUY1UWl4RFFVRkRjRUlzZDBKQlFYZENMRVZCUVVWeFFpeFJRVUZSTEVWQlFVVmtMRlZCUVZVc1EwRkJReXhEUVVGRE8yRkJRVVU3TzAxQk9VSTVTanM3UTBFclFrTXNRMEY0UW5GRVpTeFpRVUZsTEZOQmQwSndSVHRyUWtGNFFtOUNkRUlzZDBKQlFYZENMRUZCVURkREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9yZWd1bGFyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uXCIpKTtcbnZhciBfc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL3NpZ25pZmljYW50VG9rZW5UeXBlXCIpKTtcbnZhciBfcnVsZU5hbWVzID0gcmVxdWlyZShcIi4uL3J1bGVOYW1lc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciByZWd1bGFyRXhwcmVzc2lvblR5cGUgPSBfb2NjYW1MZXhlcnMudHlwZXMucmVndWxhckV4cHJlc3Npb25UeXBlO1xudmFyIFJlZ3VsYXJFeHByZXNzaW9uUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhSZWd1bGFyRXhwcmVzc2lvblJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVndWxhckV4cHJlc3Npb25SdWxlKTtcbiAgICBmdW5jdGlvbiBSZWd1bGFyRXhwcmVzc2lvblJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWd1bGFyRXhwcmVzc2lvblJ1bGUpO1xuICAgICAgICB2YXIgcmVndWxhckV4cHJlc3Npb25TaWduaWZpY2FudFRva2VuVHlwZSA9IHJlZ3VsYXJFeHByZXNzaW9uVHlwZSwgcmVndWxhckV4cHJlc3Npb25TaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBuZXcgX3NpZ25pZmljYW50VG9rZW5UeXBlLmRlZmF1bHQocmVndWxhckV4cHJlc3Npb25TaWduaWZpY2FudFRva2VuVHlwZSksIG5hbWUgPSBfcnVsZU5hbWVzLlJlZ3VsYXJFeHByZXNzaW9uUnVsZU5hbWUsIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfcmVndWxhckV4cHJlc3Npb24uZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gUmVndWxhckV4cHJlc3Npb25SdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZ3VsYXJFeHByZXNzaW9uUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMM0psWjNWc1lYSkZlSEJ5WlhOemFXOXVMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ2V5QjBlWEJsY3lCOUlHWnliMjBnWENKdlkyTmhiUzFzWlhobGNuTmNJanRjYmx4dWFXMXdiM0owSUZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdWY0lqdGNibWx0Y0c5eWRDQlNaV2QxYkdGeVJYaHdjbVZ6YzJsdmJrSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwzSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVhDSTdYRzVwYlhCdmNuUWdVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dUwzTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lGSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVVuVnNaVTVoYldVZ2ZTQm1jbTl0SUZ3aUxpNHZjblZzWlU1aGJXVnpYQ0k3WEc1Y2JtTnZibk4wSUhzZ2NtVm5kV3hoY2tWNGNISmxjM05wYjI1VWVYQmxJSDBnUFNCMGVYQmxjenRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdVbVZuZFd4aGNrVjRjSEpsYzNOcGIyNVNkV3hsSUdWNGRHVnVaSE1nVW5Wc1pTQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtDa2dlMXh1SUNBZ0lHTnZibk4wSUhKbFozVnNZWEpGZUhCeVpYTnphVzl1VTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dVZ1BTQnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsUjVjR1VzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0J5WldkMWJHRnlSWGh3Y21WemMybHZibE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsUkdWbWFXNXBkR2x2YmlBOUlHNWxkeUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlVSbFptbHVhWFJwYjI0b2NtVm5kV3hoY2tWNGNISmxjM05wYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pTa3NYRzRnSUNBZ0lDQWdJQ0FnYm1GdFpTQTlJRkpsWjNWc1lYSkZlSEJ5WlhOemFXOXVVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnWVcxaWFXZDFiM1Z6SUQwZ1ptRnNjMlVzWEc0Z0lDQWdJQ0FnSUNBZ1pHVm1hVzVwZEdsdmJuTWdQU0JiWEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxSR1ZtYVc1cGRHbHZibHh1SUNBZ0lDQWdJQ0FnSUYwc1hHNGdJQ0FnSUNBZ0lDQWdUbTlrWlNBOUlGSmxaM1ZzWVhKRmVIQnlaWE56YVc5dVFrNUdUbTlrWlR0Y2JpQWdJQ0JjYmlBZ0lDQnpkWEJsY2lodVlXMWxMQ0JoYldKcFozVnZkWE1zSUdSbFptbHVhWFJwYjI1ekxDQk9iMlJsS1Z4dUlDQjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2ljbVZuZFd4aGNrVjRjSEpsYzNOcGIyNVVlWEJsSWl3aWRIbHdaWE1pTENKU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxKMWJHVWlMQ0p5WldkMWJHRnlSWGh3Y21WemMybHZibE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsSWl3aWNtVm5kV3hoY2tWNGNISmxjM05wYjI1VGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pVUmxabWx1YVhScGIyNGlMQ0pUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlVSbFptbHVhWFJwYjI0aUxDSnVZVzFsSWl3aVVtVm5kV3hoY2tWNGNISmxjM05wYjI1U2RXeGxUbUZ0WlNJc0ltRnRZbWxuZFc5MWN5SXNJbVJsWm1sdWFYUnBiMjV6SWl3aVRtOWtaU0lzSWxKbFozVnNZWEpGZUhCeVpYTnphVzl1UWs1R1RtOWtaU0lzSWxKMWJHVWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZjMElzU1VGQlFTeFpRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPMEZCUlc1Q0xFbEJRVUVzUzBGQlV5eHJRMEZCVkN4VFFVRlRMRVZCUVVFN1FVRkRWeXhKUVVGQkxHdENRVUVyUWl4clEwRkJMMElzSzBKQlFTdENMRVZCUVVFN1FVRkRla0lzU1VGQlFTeHhRa0ZCYjBNc2EwTkJRWEJETEc5RFFVRnZReXhGUVVGQk8wRkJSWEpETEVsQlFVRXNWVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHM3T3pzN096czdPenM3T3pzN08wdEJVbmhFT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdPenM3T3p0MVFrRkJRVHM3UzBGQlFUczdPenN5UWtGQlFUczdPenM3T3pzN2NVWkJRVUU3T3pzN096czdPenM3T3p0dFJVRkJRVHM3YVVSQlFVRTdPenM3TzBGQlZVRXNTVUZCVFN4QlFVRkZRU3h4UWtGQmNVSXNSMEZCUzBNc1dVRkJTeXhQUVVFdlFrUXNjVUpCUVhGQ0xFRkJRVlVzUVVGQlF6dEJRVVY2UWl4SlFVRkJMRUZCUVUxRkxIRkNRVUZ4UWl4cFFrTmFka01zUVVSWldUc3dRMEZhWmpzN1lVRlpjVUpCTEhGQ1FVRnhRanR2UkVGYU1VTTdVVUZqU1N4SlFVRk5ReXh4UTBGQmNVTXNSMEZCUjBnc2NVSkJRWEZDTEVWQlF6ZEVTU3dyUTBGQkswTXNSMEZCUnl4SlFVRkpReXh4UWtGQk9FSXNVMEZCUTBZc2NVTkJRWEZETEVOQlFVTXNSVUZETTBoSExFbEJRVWtzUjBGQlIwTXNWVUZCZVVJc01FSkJRVUVzUlVGRGFFTkRMRk5CUVZNc1IwRkJSeXhMUVVGTExFVkJRMnBDUXl4WFFVRlhMRWRCUVVjN1dVRkRXa3dzSzBOQlFTdERPMU5CUTJoRUxFVkJRMFJOTEVsQlFVa3NSMEZCUjBNc2EwSkJRWGRDTEZGQlFVRXNRVUZCUXp0cFEwRkZhRU5NTEVsQlFVa3NSVUZCUlVVc1UwRkJVeXhGUVVGRlF5eFhRVUZYTEVWQlFVVkRMRWxCUVVrN096dERRVVV6UXl4RFFXSnJSRVVzUzBGQlNTeFRRV0YwUkR0clFrRmliMEpXTEhGQ1FVRnhRaXhCUVZveFF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vblRlcm1pbmFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiKSk7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBRdWFudGlmaWVyQk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKFF1YW50aWZpZXJCTkZOb2RlLCBOb25UZXJtaW5hbE5vZGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUXVhbnRpZmllckJORk5vZGUpO1xuICAgIGZ1bmN0aW9uIFF1YW50aWZpZXJCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVhbnRpZmllckJORk5vZGUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhRdWFudGlmaWVyQk5GTm9kZSwgbnVsbCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2Rlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25vblRlcm1pbmFsLmRlZmF1bHQuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhRdWFudGlmaWVyQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFF1YW50aWZpZXJCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBRdWFudGlmaWVyQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOXhkV0Z1ZEdsbWFXVnlMbXB6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklsd2lkWE5sSUhOMGNtbGpkRndpTzF4dVhHNXBiWEJ2Y25RZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUdaeWIyMGdYQ0l1TGk4dUxpOXViMlJsTDI1dmJsUmxjbTFwYm1Gc1hDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGRjFZVzUwYVdacFpYSkNUa1pPYjJSbElHVjRkR1Z1WkhNZ1RtOXVWR1Z5YldsdVlXeE9iMlJsSUh0Y2JpQWdjM1JoZEdsaklHWnliMjFTZFd4bFRtRnRaVUZ1WkVOb2FXeGtUbTlrWlhNb2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBJSHNnY21WMGRYSnVJRTV2YmxSbGNtMXBibUZzVG05a1pTNW1jbTl0VW5Wc1pVNWhiV1ZCYm1SRGFHbHNaRTV2WkdWektGRjFZVzUwYVdacFpYSkNUa1pPYjJSbExDQnlkV3hsVG1GdFpTd2dZMmhwYkdST2IyUmxjeWs3SUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKUmRXRnVkR2xtYVdWeVFrNUdUbTlrWlNJc0ltWnliMjFTZFd4bFRtRnRaVUZ1WkVOb2FXeGtUbTlrWlhNaUxDSnlkV3hsVG1GdFpTSXNJbU5vYVd4a1RtOWtaWE1pTENKT2IyNVVaWEp0YVc1aGJFNXZaR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGTkVJc1NVRkJRU3haUVVGM1FpeHJRMEZCZUVJc2QwSkJRWGRDTEVWQlFVRTdPenM3T3pzN096czdPenM3T3pzNFJFRkdjRVE3YzBOQlFVRTdOa1JCUVVFN2FVVkJRVUU3T3pzN2QwVkJRVUU3WjBWQlFVRTdPenM3T3p0TFFVRkJPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCU1dVc1NVRkJRU3hCUVVGTlFTeHBRa0ZCYVVJc2FVSkRTbTVETEVGRVNWazdhVVJCU21ZN08yRkJTWEZDUVN4cFFrRkJhVUk3WjBSQlNuUkRPenM3T3p0WlFVdFRReXhIUVVGNVFpeEZRVUY2UWtFc01rSkJRWGxDTzFsRlRHeERMRTlHUzBVc1UwRkJUMEVzZVVKQlFYbENMRU5CUVVORExGRkJRVkVzUlVGQlJVTXNWVUZCVlN4RlFVRkZPMmRDUVVGRkxFOUJRVTlETEZsQlFXVXNVMEZCUTBnc2VVSkJRWGxDTEVOQlFVTkVMR2xDUVVGcFFpeEZRVUZGUlN4UlFVRlJMRVZCUVVWRExGVkJRVlVzUTBGQlF5eERRVUZETzJGQlFVVTdPMDFCVEhaS096dERRVTFETEVOQlJqaERReXhaUVVGbExGTkJSVGRFTzJ0Q1FVWnZRa29zYVVKQlFXbENMRUZCU25SREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uXCIpKTtcbnZhciBfbm9XaGl0ZXNwYWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhcnQvdGVybWluYWwvdGVybWluYWxTeW1ib2xcIikpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRGVmaW5pdGlvbikge1xuICAgIF9pbmhlcml0cyhRdWFudGlmaWVyUnVsZURlZmluaXRpb24sIERlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBRdWFudGlmaWVyUnVsZURlZmluaXRpb24odGVybWluYWxTeW1ib2xDb250ZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24pO1xuICAgICAgICB2YXIgY29udGVudCA9IHRlcm1pbmFsU3ltYm9sQ29udGVudCwgbm9XaGl0ZXNwYWNlUGFydCA9IG5ldyBfbm9XaGl0ZXNwYWNlLmRlZmF1bHQoKSwgdGVybWluYWxTeW1ib2xQYXJ0ID0gbmV3IF90ZXJtaW5hbFN5bWJvbC5kZWZhdWx0KGNvbnRlbnQpLCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnQsXG4gICAgICAgICAgICB0ZXJtaW5hbFN5bWJvbFBhcnRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbjtcbn0oX2RlZmluaXRpb24uZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBRdWFudGlmaWVyUnVsZURlZmluaXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMM0YxWVc1MGFXWnBaWEpTZFd4bExtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dlpHVm1hVzVwZEdsdmJsd2lPMXh1YVcxd2IzSjBJRTV2VjJocGRHVnpjR0ZqWlZCaGNuUWdabkp2YlNCY0lpNHVMM0JoY25RdmRHVnliV2x1WVd3dmJtOVhhR2wwWlhOd1lXTmxYQ0k3WEc1cGJYQnZjblFnVkdWeWJXbHVZV3hUZVcxaWIyeFFZWEowSUdaeWIyMGdYQ0l1TGk5d1lYSjBMM1JsY20xcGJtRnNMM1JsY20xcGJtRnNVM2x0WW05c1hDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGRjFZVzUwYVdacFpYSlNkV3hsUkdWbWFXNXBkR2x2YmlCbGVIUmxibVJ6SUVSbFptbHVhWFJwYjI0Z2UxeHVJQ0JqYjI1emRISjFZM1J2Y2loMFpYSnRhVzVoYkZONWJXSnZiRU52Ym5SbGJuUXBJSHRjYmlBZ0lDQmpiMjV6ZENCamIyNTBaVzUwSUQwZ2RHVnliV2x1WVd4VGVXMWliMnhEYjI1MFpXNTBMQ0FnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdibTlYYUdsMFpYTndZV05sVUdGeWRDQTlJRzVsZHlCT2IxZG9hWFJsYzNCaFkyVlFZWEowS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdkR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJRDBnYm1WM0lGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDaGpiMjUwWlc1MEtTeGNiaUFnSUNBZ0lDQWdJQ0J3WVhKMGN5QTlJRnRjYmlBZ0lDQWdJQ0FnSUNBZ0lHNXZWMmhwZEdWemNHRmpaVkJoY25Rc1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwWlhKdGFXNWhiRk41YldKdmJGQmhjblJjYmlBZ0lDQWdJQ0FnSUNCZE8xeHVYRzRnSUNBZ2MzVndaWElvY0dGeWRITXBYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKUmRXRnVkR2xtYVdWeVVuVnNaVVJsWm1sdWFYUnBiMjRpTENKMFpYSnRhVzVoYkZONWJXSnZiRU52Ym5SbGJuUWlMQ0pqYjI1MFpXNTBJaXdpYm05WGFHbDBaWE53WVdObFVHRnlkQ0lzSWs1dlYyaHBkR1Z6Y0dGalpWQmhjblFpTENKMFpYSnRhVzVoYkZONWJXSnZiRkJoY25RaUxDSlVaWEp0YVc1aGJGTjViV0p2YkZCaGNuUWlMQ0p3WVhKMGN5SXNJa1JsWm1sdWFYUnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEZsQlFWa3NRMEZCUXpzN08wVkJRV0k3ZDBKQlFVRTdRVUZGZFVJc1NVRkJRU3hYUVVGbExHdERRVUZtTEdWQlFXVXNSVUZCUVR0QlFVTlVMRWxCUVVFc1lVRkJLMElzYTBOQlFTOUNMQ3RDUVVFclFpeEZRVUZCTzBGQlF6ZENMRWxCUVVFc1pVRkJhVU1zYTBOQlFXcERMR2xEUVVGcFF5eEZRVUZCT3pzN096czdPenM3T3pzN096czdTMEZLYUVVN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRk5aU3hKUVVGQkxFRkJRVTFCTEhkQ1FVRjNRaXhwUWtOT01VTXNRVVJOV1R0dFJFRk9aanM3WVVGTmNVSkJMSGRDUVVGM1FpeERRVU12UWtNc2NVSkJRWEZDTzNWRVFWQnVRenRSUVZGSkxFbEJRVTFETEU5QlFVOHNSMEZCUjBRc2NVSkJRWEZDTEVWQlF5OUNSU3huUWtGQlowSXNSMEZCUnl4SlFVRkpReXhoUVVGblFpeFZRVUZGTEVWQlEzcERReXhyUWtGQmEwSXNSMEZCUnl4SlFVRkpReXhsUVVGclFpeFRRVUZEU2l4UFFVRlBMRU5CUVVNc1JVRkRjRVJMTEV0QlFVc3NSMEZCUnp0WlFVTk9TaXhuUWtGQlowSTdXVUZEYUVKRkxHdENRVUZyUWp0VFFVTnVRaXhCUVVGRE8ybERRVVZHUlN4TFFVRkxPenM3UTBGRlpDeERRVnB4UkVNc1YwRkJWU3hUUVZrdlJEdHJRa0ZhYjBKU0xIZENRVUYzUWl4QlFVNDNReUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfcXVhbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3F1YW50aWZpZXJcIikpO1xudmFyIF9xdWFudGlmaWVyUnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIHF1ZXN0aW9uTWFyayA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy5xdWVzdGlvbk1hcms7XG52YXIgT3B0aW9uYWxRdWFudGlmaWVyUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhPcHRpb25hbFF1YW50aWZpZXJSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE9wdGlvbmFsUXVhbnRpZmllclJ1bGUpO1xuICAgIGZ1bmN0aW9uIE9wdGlvbmFsUXVhbnRpZmllclJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25hbFF1YW50aWZpZXJSdWxlKTtcbiAgICAgICAgdmFyIG5hbWUgPSBfcnVsZU5hbWVzLk9wdGlvbmFsUXVhbnRpZmllclJ1bGVOYW1lLCBvcHRpb25hbFF1YW50aWZpZXJUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSBxdWVzdGlvbk1hcmssIG9wdGlvbmFsUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gbmV3IF9xdWFudGlmaWVyUnVsZS5kZWZhdWx0KG9wdGlvbmFsUXVhbnRpZmllclRlcm1pbmFsU3ltYm9sQ29udGVudCksIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfcXVhbnRpZmllci5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBPcHRpb25hbFF1YW50aWZpZXJSdWxlO1xufShfcnVsZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE9wdGlvbmFsUXVhbnRpZmllclJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDI5d2RHbHZibUZzVVhWaGJuUnBabWxsY2k1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJSHNnYzNCbFkybGhiRk41YldKdmJITWdmU0JtY205dElGd2liMk5qWVcwdGJHVjRaWEp6WENJN1hHNWNibWx0Y0c5eWRDQlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxYQ0k3WEc1cGJYQnZjblFnVVhWaGJuUnBabWxsY2tKT1JrNXZaR1VnWm5KdmJTQmNJaTR1TDI1dlpHVXZZbTVtTDNGMVlXNTBhV1pwWlhKY0lqdGNibWx0Y0c5eWRDQlJkV0Z1ZEdsbWFXVnlVblZzWlVSbFptbHVhWFJwYjI0Z1puSnZiU0JjSWk0dUwyUmxabWx1YVhScGIyNHZjWFZoYm5ScFptbGxjbEoxYkdWY0lqdGNibHh1YVcxd2IzSjBJSHNnVDNCMGFXOXVZV3hSZFdGdWRHbG1hV1Z5VW5Wc1pVNWhiV1VnZlNCbWNtOXRJRndpTGk0dmNuVnNaVTVoYldWelhDSTdYRzVjYm1OdmJuTjBJSHNnY1hWbGMzUnBiMjVOWVhKcklIMGdQU0J6Y0dWamFXRnNVM2x0WW05c2N6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1QzQjBhVzl1WVd4UmRXRnVkR2xtYVdWeVVuVnNaU0JsZUhSbGJtUnpJRkoxYkdVZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lncElIdGNiaUFnSUNCamIyNXpkQ0J1WVcxbElEMGdUM0IwYVc5dVlXeFJkV0Z1ZEdsbWFXVnlVblZzWlU1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnYjNCMGFXOXVZV3hSZFdGdWRHbG1hV1Z5VkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MElEMGdjWFZsYzNScGIyNU5ZWEpyTENBdkx5OWNiaUFnSUNBZ0lDQWdJQ0J2Y0hScGIyNWhiRkYxWVc1MGFXWnBaWEpTZFd4bFJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCUmRXRnVkR2xtYVdWeVVuVnNaVVJsWm1sdWFYUnBiMjRvYjNCMGFXOXVZV3hSZFdGdWRHbG1hV1Z5VkdWeWJXbHVZV3hUZVcxaWIyeERiMjUwWlc1MEtTeGNiaUFnSUNBZ0lDQWdJQ0JoYldKcFozVnZkWE1nUFNCbVlXeHpaU3hjYmlBZ0lDQWdJQ0FnSUNCa1pXWnBibWwwYVc5dWN5QTlJRnRjYmlBZ0lDQWdJQ0FnSUNBZ0lHOXdkR2x2Ym1Gc1VYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1WEc0Z0lDQWdJQ0FnSUNBZ1hTeGNiaUFnSUNBZ0lDQWdJQ0JPYjJSbElEMGdVWFZoYm5ScFptbGxja0pPUms1dlpHVTdYRzRnSUNBZ1hHNGdJQ0FnYzNWd1pYSW9ibUZ0WlN3Z1lXMWlhV2QxYjNWekxDQmtaV1pwYm1sMGFXOXVjeXdnVG05a1pTbGNiaUFnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSW5GMVpYTjBhVzl1VFdGeWF5SXNJbk53WldOcFlXeFRlVzFpYjJ4eklpd2lUM0IwYVc5dVlXeFJkV0Z1ZEdsbWFXVnlVblZzWlNJc0ltNWhiV1VpTENKUGNIUnBiMjVoYkZGMVlXNTBhV1pwWlhKU2RXeGxUbUZ0WlNJc0ltOXdkR2x2Ym1Gc1VYVmhiblJwWm1sbGNsUmxjbTFwYm1Gc1UzbHRZbTlzUTI5dWRHVnVkQ0lzSW05d2RHbHZibUZzVVhWaGJuUnBabWxsY2xKMWJHVkVaV1pwYm1sMGFXOXVJaXdpVVhWaGJuUnBabWxsY2xKMWJHVkVaV1pwYm1sMGFXOXVJaXdpWVcxaWFXZDFiM1Z6SWl3aVpHVm1hVzVwZEdsdmJuTWlMQ0pPYjJSbElpd2lVWFZoYm5ScFptbGxja0pPUms1dlpHVWlMQ0pTZFd4bElsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJTdENMRWxCUVVFc1dVRkJZeXhYUVVGa0xHTkJRV01zUTBGQlFUdEJRVVUxUWl4SlFVRkJMRXRCUVZNc2EwTkJRVlFzVTBGQlV5eEZRVUZCTzBGQlEwa3NTVUZCUVN4WFFVRjNRaXhyUTBGQmVFSXNkMEpCUVhkQ0xFVkJRVUU3UVVGRGFrSXNTVUZCUVN4bFFVRTRRaXhyUTBGQk9VSXNPRUpCUVRoQ0xFVkJRVUU3UVVGRmVFSXNTVUZCUVN4VlFVRmpMRmRCUVdRc1kwRkJZeXhEUVVGQk96czdPenM3T3pzN096czdPenM3UzBGU2VrUTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZWUVN4SlFVRk5MRUZCUVVWQkxGbEJRVmtzUjBGQlMwTXNXVUZCWXl4blFrRkJMMEpFTEZsQlFWa3NRVUZCYlVJc1FVRkJRenRCUVVWNlFpeEpRVUZCTEVGQlFVMUZMSE5DUVVGelFpeHBRa05hZUVNc1FVUlpXVHN5UTBGYVpqczdZVUZaY1VKQkxITkNRVUZ6UWp0eFJFRmFNME03VVVGalNTeEpRVUZOUXl4SlFVRkpMRWRCUVVkRExGVkJRVEJDTERKQ1FVRkJMRVZCUTJwRFF5eDFRMEZCZFVNc1IwRkJSMHdzV1VGQldTeEZRVU4wUkUwc1owTkJRV2RETEVkQlFVY3NTVUZCU1VNc1pVRkJkMElzVTBGQlEwWXNkVU5CUVhWRExFTkJRVU1zUlVGRGVFZEhMRk5CUVZNc1IwRkJSeXhMUVVGTExFVkJRMnBDUXl4WFFVRlhMRWRCUVVjN1dVRkRXa2dzWjBOQlFXZERPMU5CUTJwRExFVkJRMFJKTEVsQlFVa3NSMEZCUjBNc1YwRkJhVUlzVVVGQlFTeEJRVUZETzJsRFFVVjZRbElzU1VGQlNTeEZRVUZGU3l4VFFVRlRMRVZCUVVWRExGZEJRVmNzUlVGQlJVTXNTVUZCU1RzN08wTkJSVE5ETEVOQlltMUVSU3hMUVVGSkxGTkJZWFpFTzJ0Q1FXSnZRbFlzYzBKQlFYTkNMRUZCV2pOREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9xdWFudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9kZS9ibmYvcXVhbnRpZmllclwiKSk7XG52YXIgX3F1YW50aWZpZXJSdWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9xdWFudGlmaWVyUnVsZVwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgcGx1cyA9IF9vY2NhbUxleGVycy5zcGVjaWFsU3ltYm9scy5wbHVzO1xudmFyIE9uZU9yTW9yZVF1YW50aWZpZXJSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSdWxlKSB7XG4gICAgX2luaGVyaXRzKE9uZU9yTW9yZVF1YW50aWZpZXJSdWxlLCBSdWxlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE9uZU9yTW9yZVF1YW50aWZpZXJSdWxlKTtcbiAgICBmdW5jdGlvbiBPbmVPck1vcmVRdWFudGlmaWVyUnVsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9uZU9yTW9yZVF1YW50aWZpZXJSdWxlKTtcbiAgICAgICAgdmFyIG5hbWUgPSBfcnVsZU5hbWVzLk9uZU9yTW9yZVF1YW50aWZpZXJSdWxlTmFtZSwgb25lT3JNb3JlUXVhbnRpZmllclRlcm1pbmFsU3ltYm9sQ29udGVudCA9IHBsdXMsIG9uZU9yTW9yZVF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBfcXVhbnRpZmllclJ1bGUuZGVmYXVsdChvbmVPck1vcmVRdWFudGlmaWVyVGVybWluYWxTeW1ib2xDb250ZW50KSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgb25lT3JNb3JlUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uXG4gICAgICAgIF0sIE5vZGUgPSBfcXVhbnRpZmllci5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBPbmVPck1vcmVRdWFudGlmaWVyUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBPbmVPck1vcmVRdWFudGlmaWVyUnVsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eWRXeGxMMjl1WlU5eVRXOXlaVkYxWVc1MGFXWnBaWEl1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJSE53WldOcFlXeFRlVzFpYjJ4eklIMGdabkp2YlNCY0ltOWpZMkZ0TFd4bGVHVnljMXdpTzF4dVhHNXBiWEJ2Y25RZ1VuVnNaU0JtY205dElGd2lMaTR2Y25Wc1pWd2lPMXh1YVcxd2IzSjBJRkYxWVc1MGFXWnBaWEpDVGtaT2IyUmxJR1p5YjIwZ1hDSXVMaTl1YjJSbEwySnVaaTl4ZFdGdWRHbG1hV1Z5WENJN1hHNXBiWEJ2Y25RZ1VYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dUwzRjFZVzUwYVdacFpYSlNkV3hsWENJN1hHNWNibWx0Y0c5eWRDQjdJRTl1WlU5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU0I5SUdaeWIyMGdYQ0l1TGk5eWRXeGxUbUZ0WlhOY0lqdGNibHh1WTI5dWMzUWdleUJ3YkhWeklIMGdQU0J6Y0dWamFXRnNVM2x0WW05c2N6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1QyNWxUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1VnWlhoMFpXNWtjeUJTZFd4bElIdGNiaUFnWTI5dWMzUnlkV04wYjNJb0tTQjdYRzRnSUNBZ1kyOXVjM1FnYm1GdFpTQTlJRTl1WlU5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bFRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNCdmJtVlBjazF2Y21WUmRXRnVkR2xtYVdWeVZHVnliV2x1WVd4VGVXMWliMnhEYjI1MFpXNTBJRDBnY0d4MWN5d2dMeTh2WEc0Z0lDQWdJQ0FnSUNBZ2IyNWxUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SUQwZ2JtVjNJRkYxWVc1MGFXWnBaWEpTZFd4bFJHVm1hVzVwZEdsdmJpaHZibVZQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlWR1Z5YldsdVlXeFRlVzFpYjJ4RGIyNTBaVzUwS1N4Y2JpQWdJQ0FnSUNBZ0lDQmhiV0pwWjNWdmRYTWdQU0JtWVd4elpTeGNiaUFnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1Y3lBOUlGdGNiaUFnSUNBZ0lDQWdJQ0FnSUc5dVpVOXlUVzl5WlZGMVlXNTBhV1pwWlhKU2RXeGxSR1ZtYVc1cGRHbHZibHh1SUNBZ0lDQWdJQ0FnSUYwc1hHNGdJQ0FnSUNBZ0lDQWdUbTlrWlNBOUlGRjFZVzUwYVdacFpYSkNUa1pPYjJSbE8xeHVJQ0FnSUZ4dUlDQWdJSE4xY0dWeUtHNWhiV1VzSUdGdFltbG5kVzkxY3l3Z1pHVm1hVzVwZEdsdmJuTXNJRTV2WkdVcFhHNGdJSDFjYm4xY2JpSmRMQ0p1WVcxbGN5STZXeUp3YkhWeklpd2ljM0JsWTJsaGJGTjViV0p2YkhNaUxDSlBibVZQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlVblZzWlNJc0ltNWhiV1VpTENKUGJtVlBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaVTVoYldVaUxDSnZibVZQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlWR1Z5YldsdVlXeFRlVzFpYjJ4RGIyNTBaVzUwSWl3aWIyNWxUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SWl3aVVYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SWl3aVlXMWlhV2QxYjNWeklpd2laR1ZtYVc1cGRHbHZibk1pTENKT2IyUmxJaXdpVVhWaGJuUnBabWxsY2tKT1JrNXZaR1VpTENKU2RXeGxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSU3RDTEVsQlFVRXNXVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHRCUVVVMVFpeEpRVUZCTEV0QlFWTXNhME5CUVZRc1UwRkJVeXhGUVVGQk8wRkJRMGtzU1VGQlFTeFhRVUYzUWl4clEwRkJlRUlzZDBKQlFYZENMRVZCUVVFN1FVRkRha0lzU1VGQlFTeGxRVUU0UWl4clEwRkJPVUlzT0VKQlFUaENMRVZCUVVFN1FVRkZka0lzU1VGQlFTeFZRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRlNNVVE3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGVlFTeEpRVUZOTEVGQlFVVkJMRWxCUVVrc1IwRkJTME1zV1VGQll5eG5Ra0ZCZGtKRUxFbEJRVWtzUVVGQmJVSXNRVUZCUXp0QlFVVnFRaXhKUVVGQkxFRkJRVTFGTEhWQ1FVRjFRaXhwUWtOYWVrTXNRVVJaV1RzMFEwRmFaanM3WVVGWmNVSkJMSFZDUVVGMVFqdHpSRUZhTlVNN1VVRmpTU3hKUVVGTlF5eEpRVUZKTEVkQlFVZERMRlZCUVRKQ0xEUkNRVUZCTEVWQlEyeERReXgzUTBGQmQwTXNSMEZCUjB3c1NVRkJTU3hGUVVNdlEwMHNhVU5CUVdsRExFZEJRVWNzU1VGQlNVTXNaVUZCZDBJc1UwRkJRMFlzZDBOQlFYZERMRU5CUVVNc1JVRkRNVWRITEZOQlFWTXNSMEZCUnl4TFFVRkxMRVZCUTJwQ1F5eFhRVUZYTEVkQlFVYzdXVUZEV2tnc2FVTkJRV2xETzFOQlEyeERMRVZCUTBSSkxFbEJRVWtzUjBGQlIwTXNWMEZCYVVJc1VVRkJRU3hCUVVGRE8ybERRVVY2UWxJc1NVRkJTU3hGUVVGRlN5eFRRVUZUTEVWQlFVVkRMRmRCUVZjc1JVRkJSVU1zU1VGQlNUczdPME5CUlRORExFTkJZbTlFUlN4TFFVRkpMRk5CWVhoRU8ydENRV0p2UWxZc2RVSkJRWFZDTEVGQldqVkRJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9vY2NhbUxleGVycyA9IHJlcXVpcmUoXCJvY2NhbS1sZXhlcnNcIik7XG52YXIgX3J1bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlXCIpKTtcbnZhciBfcXVhbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3F1YW50aWZpZXJcIikpO1xudmFyIF9xdWFudGlmaWVyUnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIikpO1xudmFyIF9ydWxlTmFtZXMgPSByZXF1aXJlKFwiLi4vcnVsZU5hbWVzXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIGFzdGVyaXNrID0gX29jY2FtTGV4ZXJzLnNwZWNpYWxTeW1ib2xzLmFzdGVyaXNrO1xudmFyIFplcm9Pck1vcmVRdWFudGlmaWVyUnVsZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUnVsZSkge1xuICAgIF9pbmhlcml0cyhaZXJvT3JNb3JlUXVhbnRpZmllclJ1bGUsIFJ1bGUpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoWmVyb09yTW9yZVF1YW50aWZpZXJSdWxlKTtcbiAgICBmdW5jdGlvbiBaZXJvT3JNb3JlUXVhbnRpZmllclJ1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBaZXJvT3JNb3JlUXVhbnRpZmllclJ1bGUpO1xuICAgICAgICB2YXIgbmFtZSA9IF9ydWxlTmFtZXMuWmVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZSwgemVyb09yTW9yZVF1YW50aWZpZXJUZXJtaW5hbFN5bWJvbENvbnRlbnQgPSBhc3RlcmlzaywgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBfcXVhbnRpZmllclJ1bGUuZGVmYXVsdCh6ZXJvT3JNb3JlUXVhbnRpZmllclRlcm1pbmFsU3ltYm9sQ29udGVudCksIGFtYmlndW91cyA9IGZhbHNlLCBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgXSwgTm9kZSA9IF9xdWFudGlmaWVyLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIFplcm9Pck1vcmVRdWFudGlmaWVyUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBaZXJvT3JNb3JlUXVhbnRpZmllclJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDNwbGNtOVBjazF2Y21WUmRXRnVkR2xtYVdWeUxtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnZXlCemNHVmphV0ZzVTNsdFltOXNjeUI5SUdaeWIyMGdYQ0p2WTJOaGJTMXNaWGhsY25OY0lqdGNibHh1YVcxd2IzSjBJRkoxYkdVZ1puSnZiU0JjSWk0dUwzSjFiR1ZjSWp0Y2JtbHRjRzl5ZENCUmRXRnVkR2xtYVdWeVFrNUdUbTlrWlNCbWNtOXRJRndpTGk0dmJtOWtaUzlpYm1ZdmNYVmhiblJwWm1sbGNsd2lPMXh1YVcxd2IzSjBJRkYxWVc1MGFXWnBaWEpTZFd4bFJHVm1hVzVwZEdsdmJpQm1jbTl0SUZ3aUxpNHZaR1ZtYVc1cGRHbHZiaTl4ZFdGdWRHbG1hV1Z5VW5Wc1pWd2lPMXh1WEc1cGJYQnZjblFnZXlCYVpYSnZUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZPWVcxbElIMGdabkp2YlNCY0lpNHVMM0oxYkdWT1lXMWxjMXdpTzF4dVhHNWpiMjV6ZENCN0lHRnpkR1Z5YVhOcklIMGdQU0J6Y0dWamFXRnNVM2x0WW05c2N6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1dtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSlNkV3hsSUdWNGRHVnVaSE1nVW5Wc1pTQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtDa2dlMXh1SUNBZ0lHTnZibk4wSUc1aGJXVWdQU0JhWlhKdlQzSk5iM0psVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lIcGxjbTlQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlWR1Z5YldsdVlXeFRlVzFpYjJ4RGIyNTBaVzUwSUQwZ1lYTjBaWEpwYzJzc0lDOHZMMXh1SUNBZ0lDQWdJQ0FnSUhwbGNtOVBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaVVJsWm1sdWFYUnBiMjRnUFNCdVpYY2dVWFZoYm5ScFptbGxjbEoxYkdWRVpXWnBibWwwYVc5dUtIcGxjbTlQY2sxdmNtVlJkV0Z1ZEdsbWFXVnlWR1Z5YldsdVlXeFRlVzFpYjJ4RGIyNTBaVzUwS1N4Y2JpQWdJQ0FnSUNBZ0lDQmhiV0pwWjNWdmRYTWdQU0JtWVd4elpTeGNiaUFnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1Y3lBOUlGdGNiaUFnSUNBZ0lDQWdJQ0FnSUhwbGNtOVBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaVVJsWm1sdWFYUnBiMjVjYmlBZ0lDQWdJQ0FnSUNCZExGeHVJQ0FnSUNBZ0lDQWdJRTV2WkdVZ1BTQlJkV0Z1ZEdsbWFXVnlRazVHVG05a1pUdGNiaUFnSUNCY2JpQWdJQ0J6ZFhCbGNpaHVZVzFsTENCaGJXSnBaM1Z2ZFhNc0lHUmxabWx1YVhScGIyNXpMQ0JPYjJSbEtWeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpWVhOMFpYSnBjMnNpTENKemNHVmphV0ZzVTNsdFltOXNjeUlzSWxwbGNtOVBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaU0lzSW01aGJXVWlMQ0phWlhKdlQzSk5iM0psVVhWaGJuUnBabWxsY2xKMWJHVk9ZVzFsSWl3aWVtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSlVaWEp0YVc1aGJGTjViV0p2YkVOdmJuUmxiblFpTENKNlpYSnZUM0pOYjNKbFVYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SWl3aVVYVmhiblJwWm1sbGNsSjFiR1ZFWldacGJtbDBhVzl1SWl3aVlXMWlhV2QxYjNWeklpd2laR1ZtYVc1cGRHbHZibk1pTENKT2IyUmxJaXdpVVhWaGJuUnBabWxsY2tKT1JrNXZaR1VpTENKU2RXeGxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3haUVVGWkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSU3RDTEVsQlFVRXNXVUZCWXl4WFFVRmtMR05CUVdNc1EwRkJRVHRCUVVVMVFpeEpRVUZCTEV0QlFWTXNhME5CUVZRc1UwRkJVeXhGUVVGQk8wRkJRMGtzU1VGQlFTeFhRVUYzUWl4clEwRkJlRUlzZDBKQlFYZENMRVZCUVVFN1FVRkRha0lzU1VGQlFTeGxRVUU0UWl4clEwRkJPVUlzT0VKQlFUaENMRVZCUVVFN1FVRkZkRUlzU1VGQlFTeFZRVUZqTEZkQlFXUXNZMEZCWXl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN1MwRlNNMFE3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3TzNWQ1FVRkJPenRMUVVGQk96czdPekpDUVVGQk96czdPenM3T3p0eFJrRkJRVHM3T3pzN096czdPenM3TzIxRlFVRkJPenRwUkVGQlFUczdPenM3UVVGVlFTeEpRVUZOTEVGQlFVVkJMRkZCUVZFc1IwRkJTME1zV1VGQll5eG5Ra0ZCTTBKRUxGRkJRVkVzUVVGQmJVSXNRVUZCUXp0QlFVVnlRaXhKUVVGQkxFRkJRVTFGTEhkQ1FVRjNRaXhwUWtOYU1VTXNRVVJaV1RzMlEwRmFaanM3WVVGWmNVSkJMSGRDUVVGM1FqdDFSRUZhTjBNN1VVRmpTU3hKUVVGTlF5eEpRVUZKTEVkQlFVZERMRlZCUVRSQ0xEWkNRVUZCTEVWQlEyNURReXg1UTBGQmVVTXNSMEZCUjB3c1VVRkJVU3hGUVVOd1JFMHNhME5CUVd0RExFZEJRVWNzU1VGQlNVTXNaVUZCZDBJc1UwRkJRMFlzZVVOQlFYbERMRU5CUVVNc1JVRkROVWRITEZOQlFWTXNSMEZCUnl4TFFVRkxMRVZCUTJwQ1F5eFhRVUZYTEVkQlFVYzdXVUZEV2tnc2EwTkJRV3RETzFOQlEyNURMRVZCUTBSSkxFbEJRVWtzUjBGQlIwTXNWMEZCYVVJc1VVRkJRU3hCUVVGRE8ybERRVVY2UWxJc1NVRkJTU3hGUVVGRlN5eFRRVUZUTEVWQlFVVkRMRmRCUVZjc1JVRkJSVU1zU1VGQlNUczdPME5CUlRORExFTkJZbkZFUlN4TFFVRkpMRk5CWVhwRU8ydENRV0p2UWxZc2QwSkJRWGRDTEVGQldqZERJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub25UZXJtaW5hbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIikpO1xudmFyIF9zaWduaWZpY2FudFRva2VuVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIikpO1xudmFyIF9hcnJheSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFNpZ25pZmljYW50VG9rZW5UeXBlQk5GTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9uVGVybWluYWxOb2RlKSB7XG4gICAgX2luaGVyaXRzKFNpZ25pZmljYW50VG9rZW5UeXBlQk5GTm9kZSwgTm9uVGVybWluYWxOb2RlKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNpZ25pZmljYW50VG9rZW5UeXBlQk5GTm9kZSk7XG4gICAgZnVuY3Rpb24gU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlKTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVndWxhckV4cHJlc3Npb25cIiwgL15cXFsoW15cXF1dKyldJC8pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdlbmVyYXRlUGFydFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlUGFydChsb29rQWhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5UeXBlKCksIHNpZ25pZmljYW50VG9rZW5UeXBlUGFydCA9IG5ldyBfc2lnbmlmaWNhbnRUb2tlblR5cGUuZGVmYXVsdChzaWduaWZpY2FudFRva2VuVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW5UeXBlUGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFNpZ25pZmljYW50VG9rZW5UeXBlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2lnbmlmaWNhbnRUb2tlblR5cGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSwgZmlyc3RDaGlsZE5vZGUgPSAoMCwgX2FycmF5KS5maXJzdChjaGlsZE5vZGVzKSwgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLCBtYXRjaGVzID0gdGVybWluYWxOb2RlQ29udGVudC5tYXRjaCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKSwgc2Vjb25kTWF0Y2ggPSAoMCwgX2FycmF5KS5zZWNvbmQobWF0Y2hlcyksIHNpZ25pZmljYW50VG9rZW5UeXBlID0gc2Vjb25kTWF0Y2g7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub25UZXJtaW5hbC5kZWZhdWx0LmZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMoU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlO1xufShfbm9uVGVybWluYWwuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGU7XG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25pZmljYW50VG9rZW5UeXBlQk5GTm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXViMlJsTDJKdVppOXphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElFNXZibFJsY20xcGJtRnNUbTlrWlNCbWNtOXRJRndpTGk0dkxpNHZibTlrWlM5dWIyNVVaWEp0YVc1aGJGd2lPMXh1YVcxd2IzSjBJRk5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsVUdGeWRDQm1jbTl0SUZ3aUxpNHZMaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOXphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVndpTzF4dVhHNXBiWEJ2Y25RZ2V5Qm1hWEp6ZEN3Z2MyVmpiMjVrSUgwZ1puSnZiU0JjSWk0dUx5NHVMM1YwYVd4cGRHbGxjeTloY25KaGVWd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QlRhV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVUpPUms1dlpHVWdaWGgwWlc1a2N5Qk9iMjVVWlhKdGFXNWhiRTV2WkdVZ2UxeHVJQ0J5WldkMWJHRnlSWGh3Y21WemMybHZiaUE5SUM5ZVhGeGJLRnRlWEZ4ZFhTc3BYU1F2TzF4dVhHNGdJR2RsYm1WeVlYUmxVR0Z5ZENoc2IyOXJRV2hsWVdRcElIdGNiaUFnSUNCamIyNXpkQ0J6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlNBOUlIUm9hWE11WjJWMFUybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVW9LU3hjYmlBZ0lDQWdJQ0FnSUNCemFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pWQmhjblFnUFNCdVpYY2dVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZRWVhKMEtITnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxLVHRjYmx4dUlDQWdJSEpsZEhWeWJpQnphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVkJoY25RN1hHNGdJSDFjYmx4dUlDQm5aWFJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlNncElIdGNiaUFnSUNCamIyNXpkQ0JqYUdsc1pFNXZaR1Z6SUQwZ2RHaHBjeTVuWlhSRGFHbHNaRTV2WkdWektDa3NYRzRnSUNBZ0lDQWdJQ0FnWm1seWMzUkRhR2xzWkU1dlpHVWdQU0JtYVhKemRDaGphR2xzWkU1dlpHVnpLU3hjYmlBZ0lDQWdJQ0FnSUNCMFpYSnRhVzVoYkU1dlpHVWdQU0JtYVhKemRFTm9hV3hrVG05a1pTd2dJQzh2TDF4dUlDQWdJQ0FnSUNBZ0lIUmxjbTFwYm1Gc1RtOWtaVU52Ym5SbGJuUWdQU0IwWlhKdGFXNWhiRTV2WkdVdVoyVjBRMjl1ZEdWdWRDZ3BMRnh1SUNBZ0lDQWdJQ0FnSUcxaGRHTm9aWE1nUFNCMFpYSnRhVzVoYkU1dlpHVkRiMjUwWlc1MExtMWhkR05vS0hSb2FYTXVjbVZuZFd4aGNrVjRjSEpsYzNOcGIyNHBMRnh1SUNBZ0lDQWdJQ0FnSUhObFkyOXVaRTFoZEdOb0lEMGdjMlZqYjI1a0tHMWhkR05vWlhNcExGeHVJQ0FnSUNBZ0lDQWdJSE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsSUQwZ2MyVmpiMjVrVFdGMFkyZzdJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJSE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsTzF4dUlDQjlYRzVjYmlBZ2MzUmhkR2xqSUdaeWIyMVNkV3hsVG1GdFpVRnVaRU5vYVd4a1RtOWtaWE1vY25Wc1pVNWhiV1VzSUdOb2FXeGtUbTlrWlhNcElIc2djbVYwZFhKdUlFNXZibFJsY20xcGJtRnNUbTlrWlM1bWNtOXRVblZzWlU1aGJXVkJibVJEYUdsc1pFNXZaR1Z6S0ZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFFrNUdUbTlrWlN3Z2NuVnNaVTVoYldVc0lHTm9hV3hrVG05a1pYTXBPeUI5WEc1OVhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZDVGtaT2IyUmxPMXh1WEc1Y2JpSmRMQ0p1WVcxbGN5STZXeUpUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlVKT1JrNXZaR1VpTENKeVpXZDFiR0Z5Ulhod2NtVnpjMmx2YmlJc0ltZGxibVZ5WVhSbFVHRnlkQ0lzSW14dmIydEJhR1ZoWkNJc0luTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxJaXdpWjJWMFUybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVWlMQ0p6YVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZCaGNuUWlMQ0pUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZCaGNuUWlMQ0pqYUdsc1pFNXZaR1Z6SWl3aVoyVjBRMmhwYkdST2IyUmxjeUlzSW1acGNuTjBRMmhwYkdST2IyUmxJaXdpWm1seWMzUWlMQ0owWlhKdGFXNWhiRTV2WkdVaUxDSjBaWEp0YVc1aGJFNXZaR1ZEYjI1MFpXNTBJaXdpWjJWMFEyOXVkR1Z1ZENJc0ltMWhkR05vWlhNaUxDSnRZWFJqYUNJc0luTmxZMjl1WkUxaGRHTm9JaXdpYzJWamIyNWtJaXdpWm5KdmJWSjFiR1ZPWVcxbFFXNWtRMmhwYkdST2IyUmxjeUlzSW5KMWJHVk9ZVzFsSWl3aVRtOXVWR1Z5YldsdVlXeE9iMlJsSWl3aWJXOWtkV3hsSWl3aVpYaHdiM0owY3lKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1dVRkJXU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVVMFFpeEpRVUZCTEZsQlFYZENMR3REUVVGNFFpeDNRa0ZCZDBJc1JVRkJRVHRCUVVObUxFbEJRVUVzY1VKQlFUQkRMR3REUVVFeFF5d3dRMEZCTUVNc1JVRkJRVHRCUVVWcVJDeEpRVUZCTEUxQlFYVkNMRmRCUVhaQ0xIVkNRVUYxUWl4RFFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJUSEpFTzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN096czdPMVZCUVVFN08zZENRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlBaU3hKUVVGQkxFRkJRVTFCTERKQ1FVRXlRaXhwUWtGNVFqZERMRUZCZWtKWk96SkVRVkJtT3p0aFFVOXhRa0VzTWtKQlFUSkNPekJFUVZCb1JEczdOa05CUVVFN1VVRlJSVU1zSzBOQlFVRkJMRzFDUVVGcFFpeHJRa0ZCYlVJc1FVTlNkRU1zUTBSUmMwTTdPenM3TzFsQlJYQkRReXhIUVVGWkxFVkJRVnBCTEdOQlFWazdXVU5XWkN4UFJGVkZRU3hUUVVGQlFTeFpRVUZaTEVOQlFVTkRMRk5CUVZNc1JVRkJSVHRuUWtGRGRFSXNTVUZCVFVNc2IwSkJRVzlDTEVkQlFVY3NTVUZCU1N4RFFVRkRReXgxUWtGQmRVSXNSVUZCUlN4RlFVTnlSRU1zZDBKQlFYZENMRWRCUVVjc1NVRkJTVU1zY1VKQlFYZENMRk5CUVVOSUxHOUNRVUZ2UWl4RFFVRkRMRUZCUVVNN1owSkJSWEJHTEU5QlFVOUZMSGRDUVVGM1FpeERRVUZETzJGQlEycERPenM3V1VGRlJFUXNSMEZCZFVJc1JVRkJka0pCTEhsQ1FVRjFRanRaUTJwQ2VrSXNUMFJwUWtWQkxGTkJRVUZCTEhWQ1FVRjFRaXhIUVVGSE8yZENRVU40UWl4SlFVRk5SeXhWUVVGVkxFZEJRVWNzU1VGQlNTeERRVUZEUXl4aFFVRmhMRVZCUVVVc1JVRkRha05ETEdOQlFXTXNSMEZCUjBNc1EwRkJRVUVzUjBGQlFVRXNUVUZCU3l4QlFVRlpMRU5CUVVFc1QwRkJXRWdzVlVGQlZTeERRVUZETEVWQlEyeERTU3haUVVGWkxFZEJRVWRHTEdOQlFXTXNSVUZETjBKSExHMUNRVUZ0UWl4SFFVRkhSQ3haUVVGWkxFTkJRVU5GTEZWQlFWVXNSVUZCUlN4RlFVTXZRME1zVDBGQlR5eEhRVUZIUml4dFFrRkJiVUlzUTBGQlEwY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJRMllzYVVKQlFXbENMRU5CUVVNc1JVRkRNMFJuUWl4WFFVRlhMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTFCUVUwc1FVRkJVeXhEUVVGQkxGRkJRVkpJTEU5QlFVOHNRMEZCUXl4RlFVTTNRbGdzYjBKQlFXOUNMRWRCUVVkaExGZEJRVmNzUVVGQlF5eEZRVUZETEVkQlFVYzdaMEpCUlRkRExFOUJRVTlpTEc5Q1FVRnZRaXhEUVVGRE8yRkJRemRDT3pzN08xbEJSVTFsTEVkQlFYbENMRVZCUVhwQ1FTd3lRa0ZCZVVJN1dVTTNRbXhETEU5RU5rSkZMRk5CUVU5QkxIbENRVUY1UWl4RFFVRkRReXhSUVVGUkxFVkJRVVZhTEZWQlFWVXNSVUZCUlR0blFrRkJSU3hQUVVGUFlTeFpRVUZsTEZOQlFVTkdMSGxDUVVGNVFpeERRVUZEYmtJc01rSkJRVEpDTEVWQlFVVnZRaXhSUVVGUkxFVkJRVVZhTEZWQlFWVXNRMEZCUXl4RFFVRkRPMkZCUVVVN08wMUJOMEpxU3pzN1EwRTRRa01zUTBGMlFuZEVZU3haUVVGbExGTkJkVUoyUlR0clFrRjJRbTlDY2tJc01rSkJRVEpDTEVGQlVHaEVPMEZCWjBOQmMwSXNUVUZCVFN4RFFVRkRReXhQUVVGUExFZEJRVWQyUWl3eVFrRkJNa0lzUTBGQlF5SjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtTGV4ZXJzID0gcmVxdWlyZShcIm9jY2FtLWxleGVyc1wiKTtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9zaWduaWZpY2FudFRva2VuVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vZGUvYm5mL3NpZ25pZmljYW50VG9rZW5UeXBlXCIpKTtcbnZhciBfc2lnbmlmaWNhbnRUb2tlblR5cGUxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiKSk7XG52YXIgX3J1bGVOYW1lcyA9IHJlcXVpcmUoXCIuLi9ydWxlTmFtZXNcIik7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgdHlwZVR5cGUgPSBfb2NjYW1MZXhlcnMudHlwZXMudHlwZVR5cGU7XG52YXIgU2lnbmlmaWNhbnRUb2tlblR5cGVSdWxlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSdWxlKSB7XG4gICAgX2luaGVyaXRzKFNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSwgUnVsZSk7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTaWduaWZpY2FudFRva2VuVHlwZVJ1bGUpO1xuICAgIGZ1bmN0aW9uIFNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSk7XG4gICAgICAgIHZhciB0eXBlU2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0eXBlVHlwZSwgdHlwZVNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiA9IG5ldyBfc2lnbmlmaWNhbnRUb2tlblR5cGUxLmRlZmF1bHQodHlwZVNpZ25pZmljYW50VG9rZW5UeXBlKSwgbmFtZSA9IF9ydWxlTmFtZXMuU2lnbmlmaWNhbnRUb2tlblR5cGVSdWxlTmFtZSwgYW1iaWd1b3VzID0gZmFsc2UsIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgdHlwZVNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvblxuICAgICAgICBdLCBOb2RlID0gX3NpZ25pZmljYW50VG9rZW5UeXBlLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBhbWJpZ3VvdXMsIGRlZmluaXRpb25zLCBOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25pZmljYW50VG9rZW5UeXBlUnVsZTtcbn0oX3J1bGUuZGVmYXVsdCk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaWduaWZpY2FudFRva2VuVHlwZVJ1bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXlkV3hsTDNOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbExtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnZXlCMGVYQmxjeUI5SUdaeWIyMGdYQ0p2WTJOaGJTMXNaWGhsY25OY0lqdGNibHh1YVcxd2IzSjBJRkoxYkdVZ1puSnZiU0JjSWk0dUwzSjFiR1ZjSWp0Y2JtbHRjRzl5ZENCVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pVSk9SazV2WkdVZ1puSnZiU0JjSWk0dUwyNXZaR1V2WW01bUwzTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxYQ0k3WEc1cGJYQnZjblFnVTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dWRVpXWnBibWwwYVc5dUlHWnliMjBnWENJdUxpOWtaV1pwYm1sMGFXOXVMM05wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsWENJN1hHNWNibWx0Y0c5eWRDQjdJRk5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsVW5Wc1pVNWhiV1VnZlNCbWNtOXRJRndpTGk0dmNuVnNaVTVoYldWelhDSTdYRzVjYm1OdmJuTjBJSHNnZEhsd1pWUjVjR1VnZlNBOUlIUjVjR1Z6TzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCamJHRnpjeUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZKMWJHVWdaWGgwWlc1a2N5QlNkV3hsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hHNGdJQ0FnWTI5dWMzUWdkSGx3WlZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbElEMGdkSGx3WlZSNWNHVXNJQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQjBlWEJsVTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dWRVpXWnBibWwwYVc5dUlEMGdibVYzSUZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFJHVm1hVzVwZEdsdmJpaDBlWEJsVTJsbmJtbG1hV05oYm5SVWIydGxibFI1Y0dVcExGeHVJQ0FnSUNBZ0lDQWdJRzVoYldVZ1BTQlRhV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVkoxYkdWT1lXMWxMRnh1SUNBZ0lDQWdJQ0FnSUdGdFltbG5kVzkxY3lBOUlHWmhiSE5sTEZ4dUlDQWdJQ0FnSUNBZ0lHUmxabWx1YVhScGIyNXpJRDBnVzF4dUlDQWdJQ0FnSUNBZ0lDQWdkSGx3WlZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFJHVm1hVzVwZEdsdmJseHVJQ0FnSUNBZ0lDQWdJRjBzWEc0Z0lDQWdJQ0FnSUNBZ1RtOWtaU0E5SUZOcFoyNXBabWxqWVc1MFZHOXJaVzVVZVhCbFFrNUdUbTlrWlR0Y2JpQWdJQ0JjYmlBZ0lDQnpkWEJsY2lodVlXMWxMQ0JoYldKcFozVnZkWE1zSUdSbFptbHVhWFJwYjI1ekxDQk9iMlJsS1Z4dUlDQjlYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2lkSGx3WlZSNWNHVWlMQ0owZVhCbGN5SXNJbE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsVW5Wc1pTSXNJblI1Y0dWVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pTSXNJblI1Y0dWVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pVUmxabWx1YVhScGIyNGlMQ0pUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlVSbFptbHVhWFJwYjI0aUxDSnVZVzFsSWl3aVUybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVlNkV3hsVG1GdFpTSXNJbUZ0WW1sbmRXOTFjeUlzSW1SbFptbHVhWFJwYjI1eklpd2lUbTlrWlNJc0lsTnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxRazVHVG05a1pTSXNJbEoxYkdVaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxGbEJRVmtzUTBGQlF6czdPMFZCUVdJN2QwSkJRVUU3UVVGRmMwSXNTVUZCUVN4WlFVRmpMRmRCUVdRc1kwRkJZeXhEUVVGQk8wRkJSVzVDTEVsQlFVRXNTMEZCVXl4clEwRkJWQ3hUUVVGVExFVkJRVUU3UVVGRFl5eEpRVUZCTEhGQ1FVRnJReXhyUTBGQmJFTXNhME5CUVd0RExFVkJRVUU3UVVGREwwSXNTVUZCUVN4elFrRkJiME1zYTBOQlFYQkRMRzlEUVVGdlF5eEZRVUZCTzBGQlJXeERMRWxCUVVFc1ZVRkJZeXhYUVVGa0xHTkJRV01zUTBGQlFUczdPenM3T3pzN096czdPenM3TzB0QlVqTkVPenM3T3pzN096czdPenM3TzAxQlFVRTdlVVJCUVVFN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096c3lRa0ZCUVRzN096czdPenM3Y1VaQlFVRTdPenM3T3pzN096czdPenR0UlVGQlFUczdhVVJCUVVFN096czdPMEZCVlVFc1NVRkJUU3hCUVVGRlFTeFJRVUZSTEVkQlFVdERMRmxCUVVzc1QwRkJiRUpFTEZGQlFWRXNRVUZCVlN4QlFVRkRPMEZCUlZvc1NVRkJRU3hCUVVGTlJTeDNRa0ZCZDBJc2FVSkRXakZETEVGRVdWazdOa05CV21ZN08yRkJXWEZDUVN4M1FrRkJkMEk3ZFVSQldqZERPMUZCWTBrc1NVRkJUVU1zZDBKQlFYZENMRWRCUVVkSUxGRkJRVkVzUlVGRGJrTkpMR3REUVVGclF5eEhRVUZITEVsQlFVbERMSE5DUVVFNFFpeFRRVUZEUml4M1FrRkJkMElzUTBGQlF5eEZRVU5xUjBjc1NVRkJTU3hIUVVGSFF5eFZRVUUwUWl3MlFrRkJRU3hGUVVOdVEwTXNVMEZCVXl4SFFVRkhMRXRCUVVzc1JVRkRha0pETEZkQlFWY3NSMEZCUnp0WlFVTmFUQ3hyUTBGQmEwTTdVMEZEYmtNc1JVRkRSRTBzU1VGQlNTeEhRVUZIUXl4eFFrRkJNa0lzVVVGQlFTeEJRVUZETzJsRFFVVnVRMHdzU1VGQlNTeEZRVUZGUlN4VFFVRlRMRVZCUVVWRExGZEJRVmNzUlVGQlJVTXNTVUZCU1RzN08wTkJSVE5ETEVOQlluRkVSU3hMUVVGSkxGTkJZWHBFTzJ0Q1FXSnZRbFlzZDBKQlFYZENMRUZCV2pkREluMD0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGZpcnN0IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZU1hcEZyb21SdWxlcyhydWxlcykge1xuICBjb25zdCBydWxlTWFwID0ge307XG5cbiAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBydWxlTWFwW3J1bGVOYW1lXSA9IHJ1bGU7XG4gIH0pO1xuXG4gIHJldHVybiBydWxlTWFwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSdWxlRnJvbVJ1bGVzKHJ1bGVzKSB7XG4gIGNvbnN0IGZpcnN0UnVsZSA9IGZpcnN0KHJ1bGVzKSxcbiAgICAgIHN0YXJ0UnVsZSA9IGZpcnN0UnVsZTsgIC8vL1xuXG4gIHJldHVybiBzdGFydFJ1bGU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2JuZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm5mXCIpKTtcbnZhciBfcnVsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGVcIikpO1xudmFyIF9zdGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3N0YXRlXCIpKTtcbnZhciBfbmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvbmFtZVwiKSk7XG52YXIgX3BhcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlL3BhcnRcIikpO1xudmFyIF9ydWxlMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvcnVsZVwiKSk7XG52YXIgX2Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9lcnJvclwiKSk7XG52YXIgX2RvY3VtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9kb2N1bWVudFwiKSk7XG52YXIgX3J1bGVOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9ydWxlTmFtZVwiKSk7XG52YXIgX3dpbGRjYXJkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS93aWxkY2FyZFwiKSk7XG52YXIgX2VuZE9mTGluZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvZW5kT2ZMaW5lXCIpKTtcbnZhciBfcXVhbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvcXVhbnRpZmllclwiKSk7XG52YXIgX2RlZmluaXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlL2RlZmluaXRpb25cIikpO1xudmFyIF9kZWZpbml0aW9ucyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvZGVmaW5pdGlvbnNcIikpO1xudmFyIF90ZXJtaW5hbFBhcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlL3Rlcm1pbmFsUGFydFwiKSk7XG52YXIgX2Nob2ljZU9mUGFydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlL2Nob2ljZU9mUGFydHNcIikpO1xudmFyIF90ZXJtaW5hbFN5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvdGVybWluYWxTeW1ib2xcIikpO1xudmFyIF9ub25UZXJtaW5hbFBhcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ydWxlL25vblRlcm1pbmFsUGFydFwiKSk7XG52YXIgX3NlcXVlbmNlT2ZQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvc2VxdWVuY2VPZlBhcnRzXCIpKTtcbnZhciBfbm9XaGl0ZXNwYWNlUGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvbm9XaGl0ZXNwYWNlUGFydFwiKSk7XG52YXIgX2xvb2tBaGVhZE1vZGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9sb29rQWhlYWRNb2RpZmllclwiKSk7XG52YXIgX2FtYmlndW91c01vZGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9hbWJpZ3VvdXNNb2RpZmllclwiKSk7XG52YXIgX3JlZ3VsYXJFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9yZWd1bGFyRXhwcmVzc2lvblwiKSk7XG52YXIgX29wdGlvbmFsUXVhbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvb3B0aW9uYWxRdWFudGlmaWVyXCIpKTtcbnZhciBfb25lT3JNb3JlUXVhbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3J1bGUvb25lT3JNb3JlUXVhbnRpZmllclwiKSk7XG52YXIgX3plcm9Pck1vcmVRdWFudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS96ZXJvT3JNb3JlUXVhbnRpZmllclwiKSk7XG52YXIgX3NpZ25pZmljYW50VG9rZW5UeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcnVsZS9zaWduaWZpY2FudFRva2VuVHlwZVwiKSk7XG52YXIgX3J1bGVzID0gcmVxdWlyZShcIi4uL3V0aWxpdGllcy9ydWxlc1wiKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG52YXIgQk5GUGFyc2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBCTkZQYXJzZXIoc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCTkZQYXJzZXIpO1xuICAgICAgICB0aGlzLnN0YXJ0UnVsZSA9IHN0YXJ0UnVsZTtcbiAgICAgICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEJORlBhcnNlciwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0U3RhcnRSdWxlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnRSdWxlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFJ1bGVNYXBcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSdWxlTWFwKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwYXJzZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnN0YXJ0UnVsZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfc3RhdGUuZGVmYXVsdC5mcm9tVG9rZW5zQW5kUnVsZU1hcCh0b2tlbnMsIHRoaXMucnVsZU1hcCksIGNhbGxiYWNrID0gbnVsbCwgcnVsZU5vZGUgPSBydWxlLnBhcnNlKHN0YXRlLCBjYWxsYmFjayksIG5vZGUgPSBydWxlTm9kZTsgLy8vXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJydWxlc0Zyb21Ub2tlbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBydWxlc0Zyb21Ub2tlbnModG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVzO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXJzZSh0b2tlbnMpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIG5vZGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydWxlcyA9IG5vZGUuZ2VuZXJhdGVSdWxlcyhfcnVsZS5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZXNMZW5ndGggPSBydWxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGFyZSBubyBydWxlcy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Ob3RoaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vdGhpbmcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVSdWxlID0gbmV3IF9uYW1lLmRlZmF1bHQoKSwgcGFydFJ1bGUgPSBuZXcgX3BhcnQuZGVmYXVsdCgpLCBydWxlUnVsZSA9IG5ldyBfcnVsZTEuZGVmYXVsdCgpLCBlcnJvclJ1bGUgPSBuZXcgX2Vycm9yLmRlZmF1bHQoKSwgZG9jdW1lbnRSdWxlID0gbmV3IF9kb2N1bWVudC5kZWZhdWx0KCksIHJ1bGVOYW1lUnVsZSA9IG5ldyBfcnVsZU5hbWUuZGVmYXVsdCgpLCB3aWxkY2FyZFJ1bGUgPSBuZXcgX3dpbGRjYXJkLmRlZmF1bHQoKSwgZW5kT2ZMaW5lUnVsZSA9IG5ldyBfZW5kT2ZMaW5lLmRlZmF1bHQoKSwgcXVhbnRpZmllclJ1bGUgPSBuZXcgX3F1YW50aWZpZXIuZGVmYXVsdCgpLCBkZWZpbml0aW9uUnVsZSA9IG5ldyBfZGVmaW5pdGlvbi5kZWZhdWx0KCksIGRlZmluaXRpb25zUnVsZSA9IG5ldyBfZGVmaW5pdGlvbnMuZGVmYXVsdCgpLCB0ZXJtaW5hbFBhcnRSdWxlID0gbmV3IF90ZXJtaW5hbFBhcnQuZGVmYXVsdCgpLCBjaG9pY2VPZlBhcnRzUnVsZSA9IG5ldyBfY2hvaWNlT2ZQYXJ0cy5kZWZhdWx0KCksIHRlcm1pbmFsU3ltYm9sUnVsZSA9IG5ldyBfdGVybWluYWxTeW1ib2wuZGVmYXVsdCgpLCBub25UZXJtaW5hbFBhcnRSdWxlID0gbmV3IF9ub25UZXJtaW5hbFBhcnQuZGVmYXVsdCgpLCBzZXF1ZW5jZU9mUGFydHNSdWxlID0gbmV3IF9zZXF1ZW5jZU9mUGFydHMuZGVmYXVsdCgpLCBub1doaXRlc3BhY2VQYXJ0UnVsZSA9IG5ldyBfbm9XaGl0ZXNwYWNlUGFydC5kZWZhdWx0KCksIHJlZ3VsYXJFeHByZXNzaW9uUnVsZSA9IG5ldyBfcmVndWxhckV4cHJlc3Npb24uZGVmYXVsdCgpLCBsb29rQWhlYWRNb2RpZmllclJ1bGUgPSBuZXcgX2xvb2tBaGVhZE1vZGlmaWVyLmRlZmF1bHQoKSwgYW1iaWd1b3VzTW9kaWZpZXJSdWxlID0gbmV3IF9hbWJpZ3VvdXNNb2RpZmllci5kZWZhdWx0KCksIG9wdGlvbmFsUXVhbnRpZmllclJ1bGUgPSBuZXcgX29wdGlvbmFsUXVhbnRpZmllci5kZWZhdWx0KCksIG9uZU9yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IF9vbmVPck1vcmVRdWFudGlmaWVyLmRlZmF1bHQoKSwgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IF96ZXJvT3JNb3JlUXVhbnRpZmllci5kZWZhdWx0KCksIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSA9IG5ldyBfc2lnbmlmaWNhbnRUb2tlblR5cGUuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBydWxlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRSdWxlLFxuICAgICAgICAgICAgICAgICAgICBydWxlUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvblJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRSdWxlLFxuICAgICAgICAgICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlLFxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlLFxuICAgICAgICAgICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0UnVsZSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VPZlBhcnRzUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c1J1bGUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVSdWxlLFxuICAgICAgICAgICAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvblJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsU3ltYm9sUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kT2ZMaW5lUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsZGNhcmRSdWxlLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGlmaWVyUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzTW9kaWZpZXJSdWxlLFxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWRNb2RpZmllclJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJSdWxlLFxuICAgICAgICAgICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUnVsZVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UnVsZSA9ICgwLCBfcnVsZXMpLnN0YXJ0UnVsZUZyb21SdWxlcyhydWxlcyksIHJ1bGVNYXAgPSAoMCwgX3J1bGVzKS5ydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSwgYm5mUGFyc2VyID0gbmV3IEJORlBhcnNlcihzdGFydFJ1bGUsIHJ1bGVNYXApO1xuICAgICAgICAgICAgICAgIHJldHVybiBibmZQYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQk5GUGFyc2VyO1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQk5GUGFyc2VyO1xuX2RlZmluZVByb3BlcnR5KEJORlBhcnNlciwgXCJibmZcIiwgX2JuZi5kZWZhdWx0KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5aWJtWXZjR0Z5YzJWeUxtcHpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1cGJYQnZjblFnWW01bUlHWnliMjBnWENJdUwySnVabHdpTzF4dWFXMXdiM0owSUZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdWY0lqdGNibWx0Y0c5eWRDQlRkR0YwWlNCbWNtOXRJRndpTGk0dmMzUmhkR1ZjSWp0Y2JtbHRjRzl5ZENCT1lXMWxVblZzWlNCbWNtOXRJRndpTGk0dmNuVnNaUzl1WVcxbFhDSTdYRzVwYlhCdmNuUWdVR0Z5ZEZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdVdmNHRnlkRndpTzF4dWFXMXdiM0owSUZKMWJHVlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxMM0oxYkdWY0lqdGNibWx0Y0c5eWRDQkZjbkp2Y2xKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdVdlpYSnliM0pjSWp0Y2JtbHRjRzl5ZENCRWIyTjFiV1Z1ZEZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdVdlpHOWpkVzFsYm5SY0lqdGNibWx0Y0c5eWRDQlNkV3hsVG1GdFpWSjFiR1VnWm5KdmJTQmNJaTR1TDNKMWJHVXZjblZzWlU1aGJXVmNJanRjYm1sdGNHOXlkQ0JYYVd4a1kyRnlaRkoxYkdVZ1puSnZiU0JjSWk0dUwzSjFiR1V2ZDJsc1pHTmhjbVJjSWp0Y2JtbHRjRzl5ZENCRmJtUlBaa3hwYm1WU2RXeGxJR1p5YjIwZ1hDSXVMaTl5ZFd4bEwyVnVaRTltVEdsdVpWd2lPMXh1YVcxd2IzSjBJRkYxWVc1MGFXWnBaWEpTZFd4bElHWnliMjBnWENJdUxpOXlkV3hsTDNGMVlXNTBhV1pwWlhKY0lqdGNibWx0Y0c5eWRDQkVaV1pwYm1sMGFXOXVVblZzWlNCbWNtOXRJRndpTGk0dmNuVnNaUzlrWldacGJtbDBhVzl1WENJN1hHNXBiWEJ2Y25RZ1JHVm1hVzVwZEdsdmJuTlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxMMlJsWm1sdWFYUnBiMjV6WENJN1hHNXBiWEJ2Y25RZ1ZHVnliV2x1WVd4UVlYSjBVblZzWlNCbWNtOXRJRndpTGk0dmNuVnNaUzkwWlhKdGFXNWhiRkJoY25SY0lqdGNibWx0Y0c5eWRDQkRhRzlwWTJWUFpsQmhjblJ6VW5Wc1pTQm1jbTl0SUZ3aUxpNHZjblZzWlM5amFHOXBZMlZQWmxCaGNuUnpYQ0k3WEc1cGJYQnZjblFnVkdWeWJXbHVZV3hUZVcxaWIyeFNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxMM1JsY20xcGJtRnNVM2x0WW05c1hDSTdYRzVwYlhCdmNuUWdUbTl1VkdWeWJXbHVZV3hRWVhKMFVuVnNaU0JtY205dElGd2lMaTR2Y25Wc1pTOXViMjVVWlhKdGFXNWhiRkJoY25SY0lqdGNibWx0Y0c5eWRDQlRaWEYxWlc1alpVOW1VR0Z5ZEhOU2RXeGxJR1p5YjIwZ1hDSXVMaTl5ZFd4bEwzTmxjWFZsYm1ObFQyWlFZWEowYzF3aU8xeHVhVzF3YjNKMElFNXZWMmhwZEdWemNHRmpaVkJoY25SU2RXeGxJR1p5YjIwZ1hDSXVMaTl5ZFd4bEwyNXZWMmhwZEdWemNHRmpaVkJoY25SY0lqdGNibWx0Y0c5eWRDQk1iMjlyUVdobFlXUk5iMlJwWm1sbGNsSjFiR1VnWm5KdmJTQmNJaTR1TDNKMWJHVXZiRzl2YTBGb1pXRmtUVzlrYVdacFpYSmNJanRjYm1sdGNHOXlkQ0JCYldKcFozVnZkWE5OYjJScFptbGxjbEoxYkdVZ1puSnZiU0JjSWk0dUwzSjFiR1V2WVcxaWFXZDFiM1Z6VFc5a2FXWnBaWEpjSWp0Y2JtbHRjRzl5ZENCU1pXZDFiR0Z5Ulhod2NtVnpjMmx2YmxKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdVdmNtVm5kV3hoY2tWNGNISmxjM05wYjI1Y0lqdGNibWx0Y0c5eWRDQlBjSFJwYjI1aGJGRjFZVzUwYVdacFpYSlNkV3hsSUdaeWIyMGdYQ0l1TGk5eWRXeGxMMjl3ZEdsdmJtRnNVWFZoYm5ScFptbGxjbHdpTzF4dWFXMXdiM0owSUU5dVpVOXlUVzl5WlZGMVlXNTBhV1pwWlhKU2RXeGxJR1p5YjIwZ1hDSXVMaTl5ZFd4bEwyOXVaVTl5VFc5eVpWRjFZVzUwYVdacFpYSmNJanRjYm1sdGNHOXlkQ0JhWlhKdlQzSk5iM0psVVhWaGJuUnBabWxsY2xKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdVdmVtVnliMDl5VFc5eVpWRjFZVzUwYVdacFpYSmNJanRjYm1sdGNHOXlkQ0JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZKMWJHVWdabkp2YlNCY0lpNHVMM0oxYkdVdmMybG5ibWxtYVdOaGJuUlViMnRsYmxSNWNHVmNJanRjYmx4dWFXMXdiM0owSUhzZ2MzUmhjblJTZFd4bFJuSnZiVkoxYkdWekxDQnlkV3hsVFdGd1JuSnZiVkoxYkdWeklIMGdabkp2YlNCY0lpNHVMM1YwYVd4cGRHbGxjeTl5ZFd4bGMxd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QkNUa1pRWVhKelpYSWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaHpkR0Z5ZEZKMWJHVXNJSEoxYkdWTllYQXBJSHRjYmlBZ0lDQjBhR2x6TG5OMFlYSjBVblZzWlNBOUlITjBZWEowVW5Wc1pUdGNiaUFnSUNCMGFHbHpMbkoxYkdWTllYQWdQU0J5ZFd4bFRXRndPMXh1SUNCOVhHNWNiaUFnWjJWMFUzUmhjblJTZFd4bEtDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpMbk4wWVhKMFVuVnNaVHRjYmlBZ2ZWeHVYRzRnSUdkbGRGSjFiR1ZOWVhBb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjblZzWlUxaGNEdGNiaUFnZlZ4dVhHNGdJSEJoY25ObEtIUnZhMlZ1Y3l3Z2NuVnNaU0E5SUhSb2FYTXVjM1JoY25SU2RXeGxLU0I3WEc0Z0lDQWdZMjl1YzNRZ2MzUmhkR1VnUFNCVGRHRjBaUzVtY205dFZHOXJaVzV6UVc1a1VuVnNaVTFoY0NoMGIydGxibk1zSUhSb2FYTXVjblZzWlUxaGNDa3NYRzRnSUNBZ0lDQWdJQ0FnWTJGc2JHSmhZMnNnUFNCdWRXeHNMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVk9iMlJsSUQwZ2NuVnNaUzV3WVhKelpTaHpkR0YwWlN3Z1kyRnNiR0poWTJzcExGeHVJQ0FnSUNBZ0lDQWdJRzV2WkdVZ1BTQnlkV3hsVG05a1pUc2dMeTh2WEc1Y2JpQWdJQ0J5WlhSMWNtNGdibTlrWlR0Y2JpQWdmVnh1WEc1Y2RISjFiR1Z6Um5KdmJWUnZhMlZ1Y3loMGIydGxibk1wSUh0Y2JseDBJQ0JzWlhRZ2NuVnNaWE03WEc1Y2JpQWdJQ0JqYjI1emRDQnViMlJsSUQwZ2RHaHBjeTV3WVhKelpTaDBiMnRsYm5NcE8xeHVYRzRnSUNBZ2FXWWdLRzV2WkdVZ1BUMDlJRzUxYkd3cElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loZ1ZHaGxjbVVnYVhNZ2JtOGdibTlrWlM1Z0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCeWRXeGxjeUE5SUc1dlpHVXVaMlZ1WlhKaGRHVlNkV3hsY3loU2RXeGxLVHRjYmx4dUlDQWdJR052Ym5OMElISjFiR1Z6VEdWdVozUm9JRDBnY25Wc1pYTXViR1Z1WjNSb08xeHVYRzRnSUNBZ2FXWWdLSEoxYkdWelRHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9ZRlJvWlhKbElHRnlaU0J1YnlCeWRXeGxjeTVnS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdjblZzWlhNN1hHNGdJSDFjYmx4dUlDQnpkR0YwYVdNZ1ltNW1JRDBnWW01bU8xeHVYRzRnSUhOMFlYUnBZeUJtY205dFRtOTBhR2x1WnlncElIdGNiaUFnSUNCamIyNXpkQ0J1WVcxbFVuVnNaU0E5SUc1bGR5Qk9ZVzFsVW5Wc1pTZ3BMRnh1SUNBZ0lDQWdJQ0FnSUhCaGNuUlNkV3hsSUQwZ2JtVjNJRkJoY25SU2RXeGxLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2NuVnNaVkoxYkdVZ1BTQnVaWGNnVW5Wc1pWSjFiR1VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQmxjbkp2Y2xKMWJHVWdQU0J1WlhjZ1JYSnliM0pTZFd4bEtDa3NYRzRnSUNBZ0lDQWdJQ0FnWkc5amRXMWxiblJTZFd4bElEMGdibVYzSUVSdlkzVnRaVzUwVW5Wc1pTZ3BMRnh1SUNBZ0lDQWdJQ0FnSUhKMWJHVk9ZVzFsVW5Wc1pTQTlJRzVsZHlCU2RXeGxUbUZ0WlZKMWJHVW9LU3hjYmlBZ0lDQWdJQ0FnSUNCM2FXeGtZMkZ5WkZKMWJHVWdQU0J1WlhjZ1YybHNaR05oY21SU2RXeGxLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ1pXNWtUMlpNYVc1bFVuVnNaU0E5SUc1bGR5QkZibVJQWmt4cGJtVlNkV3hsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdjWFZoYm5ScFptbGxjbEoxYkdVZ1BTQnVaWGNnVVhWaGJuUnBabWxsY2xKMWJHVW9LU3hjYmlBZ0lDQWdJQ0FnSUNCa1pXWnBibWwwYVc5dVVuVnNaU0E5SUc1bGR5QkVaV1pwYm1sMGFXOXVVblZzWlNncExGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1sdWFYUnBiMjV6VW5Wc1pTQTlJRzVsZHlCRVpXWnBibWwwYVc5dWMxSjFiR1VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQjBaWEp0YVc1aGJGQmhjblJTZFd4bElEMGdibVYzSUZSbGNtMXBibUZzVUdGeWRGSjFiR1VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQmphRzlwWTJWUFpsQmhjblJ6VW5Wc1pTQTlJRzVsZHlCRGFHOXBZMlZQWmxCaGNuUnpVblZzWlNncExGeHVJQ0FnSUNBZ0lDQWdJSFJsY20xcGJtRnNVM2x0WW05c1VuVnNaU0E5SUc1bGR5QlVaWEp0YVc1aGJGTjViV0p2YkZKMWJHVW9LU3hjYmlBZ0lDQWdJQ0FnSUNCdWIyNVVaWEp0YVc1aGJGQmhjblJTZFd4bElEMGdibVYzSUU1dmJsUmxjbTFwYm1Gc1VHRnlkRkoxYkdVb0tTeGNiaUFnSUNBZ0lDQWdJQ0J6WlhGMVpXNWpaVTltVUdGeWRITlNkV3hsSUQwZ2JtVjNJRk5sY1hWbGJtTmxUMlpRWVhKMGMxSjFiR1VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnViMWRvYVhSbGMzQmhZMlZRWVhKMFVuVnNaU0E5SUc1bGR5Qk9iMWRvYVhSbGMzQmhZMlZRWVhKMFVuVnNaU2dwTEZ4dUlDQWdJQ0FnSUNBZ0lISmxaM1ZzWVhKRmVIQnlaWE56YVc5dVVuVnNaU0E5SUc1bGR5QlNaV2QxYkdGeVJYaHdjbVZ6YzJsdmJsSjFiR1VvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnNiMjlyUVdobFlXUk5iMlJwWm1sbGNsSjFiR1VnUFNCdVpYY2dURzl2YTBGb1pXRmtUVzlrYVdacFpYSlNkV3hsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdZVzFpYVdkMWIzVnpUVzlrYVdacFpYSlNkV3hsSUQwZ2JtVjNJRUZ0WW1sbmRXOTFjMDF2WkdsbWFXVnlVblZzWlNncExGeHVJQ0FnSUNBZ0lDQWdJRzl3ZEdsdmJtRnNVWFZoYm5ScFptbGxjbEoxYkdVZ1BTQnVaWGNnVDNCMGFXOXVZV3hSZFdGdWRHbG1hV1Z5VW5Wc1pTZ3BMRnh1SUNBZ0lDQWdJQ0FnSUc5dVpVOXlUVzl5WlZGMVlXNTBhV1pwWlhKU2RXeGxJRDBnYm1WM0lFOXVaVTl5VFc5eVpWRjFZVzUwYVdacFpYSlNkV3hsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdlbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bElEMGdibVYzSUZwbGNtOVBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaU2dwTEZ4dUlDQWdJQ0FnSUNBZ0lITnBaMjVwWm1sallXNTBWRzlyWlc1VWVYQmxVblZzWlNBOUlHNWxkeUJUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZKMWJHVW9LVHRjYmx4dUlDQWdJR3hsZENCeWRXeGxjeUE5SUZ0Y2JpQWdJQ0FnSUdSdlkzVnRaVzUwVW5Wc1pTeGNiaUFnSUNBZ0lISjFiR1ZTZFd4bExGeHVJQ0FnSUNBZ2JtRnRaVkoxYkdVc1hHNGdJQ0FnSUNCa1pXWnBibWwwYVc5dWMxSjFiR1VzWEc0Z0lDQWdJQ0JrWldacGJtbDBhVzl1VW5Wc1pTeGNiaUFnSUNBZ0lIQmhjblJTZFd4bExGeHVJQ0FnSUNBZ2JtOXVWR1Z5YldsdVlXeFFZWEowVW5Wc1pTeGNiaUFnSUNBZ0lIUmxjbTFwYm1Gc1VHRnlkRkoxYkdVc1hHNGdJQ0FnSUNCdWIxZG9hWFJsYzNCaFkyVlFZWEowVW5Wc1pTeGNiaUFnSUNBZ0lITmxjWFZsYm1ObFQyWlFZWEowYzFKMWJHVXNYRzRnSUNBZ0lDQmphRzlwWTJWUFpsQmhjblJ6VW5Wc1pTeGNiaUFnSUNBZ0lISjFiR1ZPWVcxbFVuVnNaU3hjYmlBZ0lDQWdJSE5wWjI1cFptbGpZVzUwVkc5clpXNVVlWEJsVW5Wc1pTeGNiaUFnSUNBZ0lISmxaM1ZzWVhKRmVIQnlaWE56YVc5dVVuVnNaU3hjYmlBZ0lDQWdJSFJsY20xcGJtRnNVM2x0WW05c1VuVnNaU3hjYmlBZ0lDQWdJR1Z1WkU5bVRHbHVaVkoxYkdVc1hHNGdJQ0FnSUNCM2FXeGtZMkZ5WkZKMWJHVXNYRzRnSUNBZ0lDQnhkV0Z1ZEdsbWFXVnlVblZzWlN4Y2JpQWdJQ0FnSUdGdFltbG5kVzkxYzAxdlpHbG1hV1Z5VW5Wc1pTeGNiaUFnSUNBZ0lHeHZiMnRCYUdWaFpFMXZaR2xtYVdWeVVuVnNaU3hjYmlBZ0lDQWdJRzl3ZEdsdmJtRnNVWFZoYm5ScFptbGxjbEoxYkdVc1hHNGdJQ0FnSUNCdmJtVlBjazF2Y21WUmRXRnVkR2xtYVdWeVVuVnNaU3hjYmlBZ0lDQWdJSHBsY205UGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pTeGNiaUFnSUNBZ0lHVnljbTl5VW5Wc1pWeHVJQ0FnSUYwN1hHNWNiaUFnSUNCamIyNXpkQ0J6ZEdGeWRGSjFiR1VnUFNCemRHRnlkRkoxYkdWR2NtOXRVblZzWlhNb2NuVnNaWE1wTEZ4dUlDQWdJQ0FnSUNBZ0lISjFiR1ZOWVhBZ1BTQnlkV3hsVFdGd1JuSnZiVkoxYkdWektISjFiR1Z6S1N4Y2JpQWdJQ0FnSUNBZ0lDQmlibVpRWVhKelpYSWdQU0J1WlhjZ1FrNUdVR0Z5YzJWeUtITjBZWEowVW5Wc1pTd2djblZzWlUxaGNDazdYRzRnSUNBZ1hHNGdJQ0FnY21WMGRYSnVJR0p1WmxCaGNuTmxjanRjYmlBZ2ZWeHVmVnh1SWwwc0ltNWhiV1Z6SWpwYklrSk9SbEJoY25ObGNpSXNJbk4wWVhKMFVuVnNaU0lzSW5KMWJHVk5ZWEFpTENKblpYUlRkR0Z5ZEZKMWJHVWlMQ0puWlhSU2RXeGxUV0Z3SWl3aWNHRnljMlVpTENKMGIydGxibk1pTENKeWRXeGxJaXdpYzNSaGRHVWlMQ0pUZEdGMFpTSXNJbVp5YjIxVWIydGxibk5CYm1SU2RXeGxUV0Z3SWl3aVkyRnNiR0poWTJzaUxDSnlkV3hsVG05a1pTSXNJbTV2WkdVaUxDSnlkV3hsYzBaeWIyMVViMnRsYm5NaUxDSnlkV3hsY3lJc0lrVnljbTl5SWl3aVoyVnVaWEpoZEdWU2RXeGxjeUlzSWxKMWJHVWlMQ0p5ZFd4bGMweGxibWQwYUNJc0lteGxibWQwYUNJc0ltWnliMjFPYjNSb2FXNW5JaXdpYm1GdFpWSjFiR1VpTENKT1lXMWxVblZzWlNJc0luQmhjblJTZFd4bElpd2lVR0Z5ZEZKMWJHVWlMQ0p5ZFd4bFVuVnNaU0lzSWxKMWJHVlNkV3hsSWl3aVpYSnliM0pTZFd4bElpd2lSWEp5YjNKU2RXeGxJaXdpWkc5amRXMWxiblJTZFd4bElpd2lSRzlqZFcxbGJuUlNkV3hsSWl3aWNuVnNaVTVoYldWU2RXeGxJaXdpVW5Wc1pVNWhiV1ZTZFd4bElpd2lkMmxzWkdOaGNtUlNkV3hsSWl3aVYybHNaR05oY21SU2RXeGxJaXdpWlc1a1QyWk1hVzVsVW5Wc1pTSXNJa1Z1WkU5bVRHbHVaVkoxYkdVaUxDSnhkV0Z1ZEdsbWFXVnlVblZzWlNJc0lsRjFZVzUwYVdacFpYSlNkV3hsSWl3aVpHVm1hVzVwZEdsdmJsSjFiR1VpTENKRVpXWnBibWwwYVc5dVVuVnNaU0lzSW1SbFptbHVhWFJwYjI1elVuVnNaU0lzSWtSbFptbHVhWFJwYjI1elVuVnNaU0lzSW5SbGNtMXBibUZzVUdGeWRGSjFiR1VpTENKVVpYSnRhVzVoYkZCaGNuUlNkV3hsSWl3aVkyaHZhV05sVDJaUVlYSjBjMUoxYkdVaUxDSkRhRzlwWTJWUFpsQmhjblJ6VW5Wc1pTSXNJblJsY20xcGJtRnNVM2x0WW05c1VuVnNaU0lzSWxSbGNtMXBibUZzVTNsdFltOXNVblZzWlNJc0ltNXZibFJsY20xcGJtRnNVR0Z5ZEZKMWJHVWlMQ0pPYjI1VVpYSnRhVzVoYkZCaGNuUlNkV3hsSWl3aWMyVnhkV1Z1WTJWUFpsQmhjblJ6VW5Wc1pTSXNJbE5sY1hWbGJtTmxUMlpRWVhKMGMxSjFiR1VpTENKdWIxZG9hWFJsYzNCaFkyVlFZWEowVW5Wc1pTSXNJazV2VjJocGRHVnpjR0ZqWlZCaGNuUlNkV3hsSWl3aWNtVm5kV3hoY2tWNGNISmxjM05wYjI1U2RXeGxJaXdpVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjVTZFd4bElpd2liRzl2YTBGb1pXRmtUVzlrYVdacFpYSlNkV3hsSWl3aVRHOXZhMEZvWldGa1RXOWthV1pwWlhKU2RXeGxJaXdpWVcxaWFXZDFiM1Z6VFc5a2FXWnBaWEpTZFd4bElpd2lRVzFpYVdkMWIzVnpUVzlrYVdacFpYSlNkV3hsSWl3aWIzQjBhVzl1WVd4UmRXRnVkR2xtYVdWeVVuVnNaU0lzSWs5d2RHbHZibUZzVVhWaGJuUnBabWxsY2xKMWJHVWlMQ0p2Ym1WUGNrMXZjbVZSZFdGdWRHbG1hV1Z5VW5Wc1pTSXNJazl1WlU5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bElpd2llbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bElpd2lXbVZ5YjA5eVRXOXlaVkYxWVc1MGFXWnBaWEpTZFd4bElpd2ljMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZTZFd4bElpd2lVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZTZFd4bElpd2ljM1JoY25SU2RXeGxSbkp2YlZKMWJHVnpJaXdpY25Wc1pVMWhjRVp5YjIxU2RXeGxjeUlzSW1KdVpsQmhjbk5sY2lJc0ltSnVaaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzV1VGQldTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVZuUWl4SlFVRkJMRWxCUVU4c2EwTkJRVkFzVDBGQlR5eEZRVUZCTzBGQlEwNHNTVUZCUVN4TFFVRlRMR3REUVVGVUxGTkJRVk1zUlVGQlFUdEJRVU5TTEVsQlFVRXNUVUZCVlN4clEwRkJWaXhWUVVGVkxFVkJRVUU3UVVGRFVDeEpRVUZCTEV0QlFXTXNhME5CUVdRc1kwRkJZeXhGUVVGQk8wRkJRMlFzU1VGQlFTeExRVUZqTEd0RFFVRmtMR05CUVdNc1JVRkJRVHRCUVVOa0xFbEJRVUVzVFVGQll5eHJRMEZCWkN4alFVRmpMRVZCUVVFN1FVRkRZaXhKUVVGQkxFMUJRV1VzYTBOQlFXWXNaVUZCWlN4RlFVRkJPMEZCUTFvc1NVRkJRU3hUUVVGclFpeHJRMEZCYkVJc2EwSkJRV3RDTEVWQlFVRTdRVUZEYkVJc1NVRkJRU3hUUVVGclFpeHJRMEZCYkVJc2EwSkJRV3RDTEVWQlFVRTdRVUZEYkVJc1NVRkJRU3hUUVVGclFpeHJRMEZCYkVJc2EwSkJRV3RDTEVWQlFVRTdRVUZEYWtJc1NVRkJRU3hWUVVGdFFpeHJRMEZCYmtJc2JVSkJRVzFDTEVWQlFVRTdRVUZEYkVJc1NVRkJRU3hYUVVGdlFpeHJRMEZCY0VJc2IwSkJRVzlDTEVWQlFVRTdRVUZEY0VJc1NVRkJRU3hYUVVGdlFpeHJRMEZCY0VJc2IwSkJRVzlDTEVWQlFVRTdRVUZEYmtJc1NVRkJRU3haUVVGeFFpeHJRMEZCY2tJc2NVSkJRWEZDTEVWQlFVRTdRVUZEY0VJc1NVRkJRU3hoUVVGelFpeHJRMEZCZEVJc2MwSkJRWE5DTEVWQlFVRTdRVUZEY2tJc1NVRkJRU3hqUVVGMVFpeHJRMEZCZGtJc2RVSkJRWFZDTEVWQlFVRTdRVUZEZEVJc1NVRkJRU3hsUVVGM1FpeHJRMEZCZUVJc2QwSkJRWGRDTEVWQlFVRTdRVUZEZGtJc1NVRkJRU3huUWtGQmVVSXNhME5CUVhwQ0xIbENRVUY1UWl4RlFVRkJPMEZCUTNwQ0xFbEJRVUVzWjBKQlFYbENMR3REUVVGNlFpeDVRa0ZCZVVJc1JVRkJRVHRCUVVONFFpeEpRVUZCTEdsQ1FVRXdRaXhyUTBGQk1VSXNNRUpCUVRCQ0xFVkJRVUU3UVVGRGVrSXNTVUZCUVN4clFrRkJNa0lzYTBOQlFUTkNMREpDUVVFeVFpeEZRVUZCTzBGQlF6TkNMRWxCUVVFc2EwSkJRVEpDTEd0RFFVRXpRaXd5UWtGQk1rSXNSVUZCUVR0QlFVTXpRaXhKUVVGQkxHdENRVUV5UWl4clEwRkJNMElzTWtKQlFUSkNMRVZCUVVFN1FVRkRNVUlzU1VGQlFTeHRRa0ZCTkVJc2EwTkJRVFZDTERSQ1FVRTBRaXhGUVVGQk8wRkJRek5DTEVsQlFVRXNiMEpCUVRaQ0xHdERRVUUzUWl3MlFrRkJOa0lzUlVGQlFUdEJRVU0xUWl4SlFVRkJMSEZDUVVFNFFpeHJRMEZCT1VJc09FSkJRVGhDTEVWQlFVRTdRVUZET1VJc1NVRkJRU3h4UWtGQk9FSXNhME5CUVRsQ0xEaENRVUU0UWl4RlFVRkJPMEZCUldRc1NVRkJRU3hOUVVGdlFpeFhRVUZ3UWl4dlFrRkJiMElzUTBGQlFUczdPenM3T3pzN096aEVRVGxDZWtVN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096czdPenM3VlVGQlFUczdkMEpCUVVFN096czdPenM3T3p0QlFXZERaU3hKUVVGQkxFRkJRVTFCTEZOQlFWTXNhVUpEYUVNelFpeEJSR2REV1R0aFFVRk5RU3hUUVVGVExFTkJRMmhDUXl4VFFVRlRMRVZCUVVWRExFOUJRVTg3ZDBOQmFrTm9RenRSUVd0RFNTeEpRVUZKTEVOQlFVTkVMRk5CUVZNc1IwRkJSMEVzVTBGQlV5eERRVUZETzFGQlF6TkNMRWxCUVVrc1EwRkJRME1zVDBGQlR5eEhRVUZIUVN4UFFVRlBMRU5CUVVNN096czdXVUZIZWtKRExFZEJRVmtzUlVGQldrRXNZMEZCV1R0WlJYUkRaQ3hQUm5ORFJVRXNVMEZCUVVFc1dVRkJXU3hIUVVGSE8yZENRVU5pTEU5QlFVOHNTVUZCU1N4RFFVRkRSaXhUUVVGVExFTkJRVU03WVVGRGRrSTdPenRaUVVWRVJ5eEhRVUZWTEVWQlFWWkJMRmxCUVZVN1dVVXhRMW9zVDBZd1EwVkJMRk5CUVVGQkxGVkJRVlVzUjBGQlJ6dG5Ra0ZEV0N4UFFVRlBMRWxCUVVrc1EwRkJRMFlzVDBGQlR5eERRVUZETzJGQlEzSkNPenM3V1VGRlJFY3NSMEZCU3l4RlFVRk1RU3hQUVVGTE8xbEZPVU5RTEU5R09FTkZRU3hUUVVGQlFTeExRVUZMTEVOQlFVTkRMRTFCUVUwc1JVRkJlVUk3YjBKQlFYWkNReXhKUVVGSkxFZEJRVXBCTEN0RFFVRnhRaXhyUWtGQlpDeEpRVUZKTEVOQlFVTk9MRk5CUVZNN1owSkJRMnBETEVsQlFVMVBMRXRCUVVzc1IwRkJSME1zVFVGQlN5eFRRVUZEUXl4dlFrRkJiMElzUTBGQlEwb3NUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJRMG9zVDBGQlR5eERRVUZETEVWQlEzaEVVeXhSUVVGUkxFZEJRVWNzU1VGQlNTeEZRVU5tUXl4UlFVRlJMRWRCUVVkTUxFbEJRVWtzUTBGQlEwWXNTMEZCU3l4RFFVRkRSeXhMUVVGTExFVkJRVVZITEZGQlFWRXNRMEZCUXl4RlFVTjBRMFVzU1VGQlNTeEhRVUZIUkN4UlFVRlJMRUZCUVVNc1JVRkJReXhIUVVGSE8yZENRVVV4UWl4UFFVRlBReXhKUVVGSkxFTkJRVU03WVVGRFlqczdPMWxCUlVaRExFZEJRV1VzUlVGQlprRXNhVUpCUVdVN1dVVjJSR2hDTEU5R2RVUkRRU3hUUVVGQlFTeGxRVUZsTEVOQlFVTlNMRTFCUVUwc1JVRkJSVHRuUWtGRGRFSXNTVUZCU1ZNc1MwRkJTeXhCUVVGRE8yZENRVVZVTEVsQlFVMUdMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU5TTEV0QlFVc3NRMEZCUTBNc1RVRkJUU3hEUVVGRExFRkJRVU03WjBKQlJXaERMRWxCUVVsUExFbEJRVWtzUzBGQlN5eEpRVUZKTEVWQlFVVTdiMEpCUTJwQ0xFMUJRVTBzU1VGQlNVY3NTMEZCU3l4RFFVRkZMRzFDUVVGcFFpeERRVUZGTEVOQlFVTTdhVUpCUTNSRE8yZENRVVZFUkN4TFFVRkxMRWRCUVVkR0xFbEJRVWtzUTBGQlEwa3NZVUZCWVN4RFFVRkRReXhMUVVGSkxGTkJRVU1zUTBGQlF6dG5Ra0ZGYWtNc1NVRkJUVU1zVjBGQlZ5eEhRVUZIU2l4TFFVRkxMRU5CUVVOTExFMUJRVTBzUVVGQlF6dG5Ra0ZGYWtNc1NVRkJTVVFzVjBGQlZ5eExRVUZMTEVOQlFVTXNSVUZCUlR0dlFrRkRja0lzVFVGQlRTeEpRVUZKU0N4TFFVRkxMRU5CUVVVc2NVSkJRVzFDTEVOQlFVVXNRMEZCUXp0cFFrRkRlRU03WjBKQlJVUXNUMEZCVDBRc1MwRkJTeXhEUVVGRE8yRkJRMlE3T3pzN1dVRkpUVTBzUjBGQlZ5eEZRVUZZUVN4aFFVRlhPMWxGTjBWd1FpeFBSalpGUlN4VFFVRlBRU3hYUVVGWExFZEJRVWM3WjBKQlEyNUNMRWxCUVUxRExGRkJRVkVzUjBGQlJ5eEpRVUZKUXl4TFFVRlJMRlZCUVVVc1JVRkRla0pETEZGQlFWRXNSMEZCUnl4SlFVRkpReXhMUVVGUkxGVkJRVVVzUlVGRGVrSkRMRkZCUVZFc1IwRkJSeXhKUVVGSlF5eE5RVUZSTEZWQlFVVXNSVUZEZWtKRExGTkJRVk1zUjBGQlJ5eEpRVUZKUXl4TlFVRlRMRlZCUVVVc1JVRkRNMEpETEZsQlFWa3NSMEZCUnl4SlFVRkpReXhUUVVGWkxGVkJRVVVzUlVGRGFrTkRMRmxCUVZrc1IwRkJSeXhKUVVGSlF5eFRRVUZaTEZWQlFVVXNSVUZEYWtORExGbEJRVmtzUjBGQlJ5eEpRVUZKUXl4VFFVRlpMRlZCUVVVc1JVRkRha05ETEdGQlFXRXNSMEZCUnl4SlFVRkpReXhWUVVGaExGVkJRVVVzUlVGRGJrTkRMR05CUVdNc1IwRkJSeXhKUVVGSlF5eFhRVUZqTEZWQlFVVXNSVUZEY2tORExHTkJRV01zUjBGQlJ5eEpRVUZKUXl4WFFVRmpMRlZCUVVVc1JVRkRja05ETEdWQlFXVXNSMEZCUnl4SlFVRkpReXhaUVVGbExGVkJRVVVzUlVGRGRrTkRMR2RDUVVGblFpeEhRVUZITEVsQlFVbERMR0ZCUVdkQ0xGVkJRVVVzUlVGRGVrTkRMR2xDUVVGcFFpeEhRVUZITEVsQlFVbERMR05CUVdsQ0xGVkJRVVVzUlVGRE0wTkRMR3RDUVVGclFpeEhRVUZITEVsQlFVbERMR1ZCUVd0Q0xGVkJRVVVzUlVGRE4wTkRMRzFDUVVGdFFpeEhRVUZITEVsQlFVbERMR2RDUVVGdFFpeFZRVUZGTEVWQlF5OURReXh0UWtGQmJVSXNSMEZCUnl4SlFVRkpReXhuUWtGQmJVSXNWVUZCUlN4RlFVTXZRME1zYjBKQlFXOUNMRWRCUVVjc1NVRkJTVU1zYVVKQlFXOUNMRlZCUVVVc1JVRkRha1JETEhGQ1FVRnhRaXhIUVVGSExFbEJRVWxETEd0Q1FVRnhRaXhWUVVGRkxFVkJRMjVFUXl4eFFrRkJjVUlzUjBGQlJ5eEpRVUZKUXl4clFrRkJjVUlzVlVGQlJTeEZRVU51UkVNc2NVSkJRWEZDTEVkQlFVY3NTVUZCU1VNc2EwSkJRWEZDTEZWQlFVVXNSVUZEYmtSRExITkNRVUZ6UWl4SFFVRkhMRWxCUVVsRExHMUNRVUZ6UWl4VlFVRkZMRVZCUTNKRVF5eDFRa0ZCZFVJc1IwRkJSeXhKUVVGSlF5eHZRa0ZCZFVJc1ZVRkJSU3hGUVVOMlJFTXNkMEpCUVhkQ0xFZEJRVWNzU1VGQlNVTXNjVUpCUVhkQ0xGVkJRVVVzUlVGRGVrUkRMSGRDUVVGM1FpeEhRVUZITEVsQlFVbERMSEZDUVVGM1FpeFZRVUZGTEVGQlFVTTdaMEpCUldoRkxFbEJRVWwwUkN4TFFVRkxMRWRCUVVjN2IwSkJRMVpsTEZsQlFWazdiMEpCUTFwS0xGRkJRVkU3YjBKQlExSktMRkZCUVZFN2IwSkJRMUp2UWl4bFFVRmxPMjlDUVVObVJpeGpRVUZqTzI5Q1FVTmthRUlzVVVGQlVUdHZRa0ZEVWpCQ0xHMUNRVUZ0UWp0dlFrRkRia0pPTEdkQ1FVRm5RanR2UWtGRGFFSlZMRzlDUVVGdlFqdHZRa0ZEY0VKR0xHMUNRVUZ0UWp0dlFrRkRia0pPTEdsQ1FVRnBRanR2UWtGRGFrSmtMRmxCUVZrN2IwSkJRMXB2UXl4M1FrRkJkMEk3YjBKQlEzaENXaXh4UWtGQmNVSTdiMEpCUTNKQ1VpeHJRa0ZCYTBJN2IwSkJRMnhDV2l4aFFVRmhPMjlDUVVOaVJpeFpRVUZaTzI5Q1FVTmFTU3hqUVVGak8yOUNRVU5rYzBJc2NVSkJRWEZDTzI5Q1FVTnlRa1lzY1VKQlFYRkNPMjlDUVVOeVFra3NjMEpCUVhOQ08yOUNRVU4wUWtVc2RVSkJRWFZDTzI5Q1FVTjJRa1VzZDBKQlFYZENPMjlDUVVONFFuUkRMRk5CUVZNN2FVSkJRMVlzUVVGQlF6dG5Ra0ZGUml4SlFVRk5NMElzVTBGQlV5eEhRVUZIY1VVc1EwRkJRVUVzUjBGQlFVRXNUVUZCYTBJc1FVRkJUeXhEUVVGQkxHOUNRVUZPZGtRc1MwRkJTeXhEUVVGRExFVkJRM0pEWWl4UFFVRlBMRWRCUVVkeFJTeERRVUZCUVN4SFFVRkJRU3hOUVVGblFpeEJRVUZQTEVOQlFVRXNhMEpCUVU1NFJDeExRVUZMTEVOQlFVTXNSVUZEYWtONVJDeFRRVUZUTEVkQlFVY3NTVUZCU1hoRkxGTkJRVk1zUTBGQlEwTXNVMEZCVXl4RlFVRkZReXhQUVVGUExFTkJRVU1zUVVGQlF6dG5Ra0ZGY0VRc1QwRkJUM05GTEZOQlFWTXNRMEZCUXp0aFFVTnNRanM3VFVGMlNVZzdPME5CZDBsRExFVkJRVUU3YTBKQmVFZHZRbmhGTEZOQlFWTXNRVUZvUXpsQ08wRkJNa1ZGTEdkQ1FUTkRiVUpCTEZOQlFWTXNSVUV5UTNKQ2VVVXNTMEZCUnl4RlFVRkhRU3hKUVVGSExGTkJRVU1zUVVFelJXNUNJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgZXhwcmVzc2lvbiAgIDo6PSBleHByZXNzaW9uXyBvcGVyYXRvciBleHByZXNzaW9uIGV4cHJlc3Npb25+KlxuXG4gICAgICAgICAgICAgICAgIHwgZXhwcmVzc2lvbl9cblxuICAgICAgICAgICAgICAgICA7XG5cbiAgb3BlcmF0b3IgICAgIDo6PSBcIitcIlxuXG4gICAgICAgICAgICAgICAgIHwgXCItXCJcblxuICAgICAgICAgICAgICAgICB8IFwiL1wiXG5cbiAgICAgICAgICAgICAgICAgfCBcIipcIlxuXG4gICAgICAgICAgICAgICAgIDtcblxuICB0ZXJtICAgICAgICAgOjo9IC9cXFxcZCsvIDtcblxuICBleHByZXNzaW9uXyAgOjo9IFwiKFwiIGV4cHJlc3Npb24gXCIpXCJcblxuICAgICAgICAgICAgICAgICB8IHRlcm1cblxuICAgICAgICAgICAgICAgICA7XG5cbiAgZXhwcmVzc2lvbn4gIDo6PSBvcGVyYXRvciBleHByZXNzaW9uIDtcbiAgXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJORkxleGVyIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgQk5GUGFyc2VyIGZyb20gXCIuLi9ibmYvcGFyc2VyXCI7XG5cbmltcG9ydCB7IHN0YXJ0UnVsZUZyb21SdWxlcywgcnVsZU1hcEZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZXNcIjtcblxuY29uc3QgYm5mTGV4ZXIgPSBCTkZMZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgYm5mUGFyc2VyID0gQk5GUGFyc2VyLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0Zyb21CTkYoYm5mKSB7XG4gIGNvbnN0IHRva2VucyA9IGJuZkxleGVyLnRva2Vuc0Zyb21CTkYoYm5mKSxcbiAgICAgICAgcnVsZXMgPSBibmZQYXJzZXIucnVsZXNGcm9tVG9rZW5zKHRva2Vucyk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcykge1xuICBjb25zdCBzdGFydFJ1bGUgPSBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBydWxlTWFwID0gcnVsZU1hcEZyb21SdWxlcyhydWxlcyksXG4gICAgICAgIHBhcnNlciA9IG5ldyBDbGFzcyhzdGFydFJ1bGUsIHJ1bGVNYXApO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3N0YXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc3RhdGVcIikpO1xudmFyIF9wYXJzZXIgPSByZXF1aXJlKFwiLi4vdXRpbGl0aWVzL3BhcnNlclwiKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxudmFyIENvbW1vblBhcnNlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQ29tbW9uUGFyc2VyKHN0YXJ0UnVsZSwgcnVsZU1hcCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tbW9uUGFyc2VyKTtcbiAgICAgICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgICAgIHRoaXMucnVsZU1hcCA9IHJ1bGVNYXA7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhDb21tb25QYXJzZXIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFN0YXJ0UnVsZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXJ0UnVsZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRSdWxlTWFwXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZU1hcCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogdGhpcy5zdGFydFJ1bGU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3N0YXRlLmRlZmF1bHQuZnJvbVRva2Vuc0FuZFJ1bGVNYXAodG9rZW5zLCB0aGlzLnJ1bGVNYXApLCBjYWxsYmFjayA9IG51bGwsIHJ1bGVOb2RlID0gcnVsZS5wYXJzZShzdGF0ZSwgY2FsbGJhY2spLCBub2RlID0gcnVsZU5vZGU7IC8vL1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbU5vdGhpbmdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTm90aGluZyhDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBibmYgPSBDbGFzcy5ibmYsIHJ1bGVzID0gKDAsIF9wYXJzZXIpLnJ1bGVzRnJvbUJORihibmYpLCBwYXJzZXIgPSAoMCwgX3BhcnNlcikucGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21CTkZcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQk5GKENsYXNzLCBibmYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZXMgPSAoMCwgX3BhcnNlcikucnVsZXNGcm9tQk5GKGJuZiksIHBhcnNlciA9ICgwLCBfcGFyc2VyKS5wYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVzKENsYXNzLCBydWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXIgPSAoMCwgX3BhcnNlcikucGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBDb21tb25QYXJzZXI7XG59KCk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tb25QYXJzZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWpiMjF0YjI0dmNHRnljMlZ5TG1weklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHdpZFhObElITjBjbWxqZEZ3aU8xeHVYRzVwYlhCdmNuUWdVM1JoZEdVZ1puSnZiU0JjSWk0dUwzTjBZWFJsWENJN1hHNWNibWx0Y0c5eWRDQjdJSEoxYkdWelJuSnZiVUpPUml3Z2NHRnljMlZ5Um5KdmJWSjFiR1Z6SUgwZ1puSnZiU0JjSWk0dUwzVjBhV3hwZEdsbGN5OXdZWEp6WlhKY0lqdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1EyOXRiVzl1VUdGeWMyVnlJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9jM1JoY25SU2RXeGxMQ0J5ZFd4bFRXRndLU0I3WEc0Z0lDQWdkR2hwY3k1emRHRnlkRkoxYkdVZ1BTQnpkR0Z5ZEZKMWJHVTdYRzRnSUNBZ2RHaHBjeTV5ZFd4bFRXRndJRDBnY25Wc1pVMWhjRHRjYmlBZ2ZWeHVYRzRnSUdkbGRGTjBZWEowVW5Wc1pTZ3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeTV6ZEdGeWRGSjFiR1U3WEc0Z0lIMWNibHh1SUNCblpYUlNkV3hsVFdGd0tDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkoxYkdWTllYQTdYRzRnSUgxY2JseHVJQ0J3WVhKelpTaDBiMnRsYm5Nc0lISjFiR1VnUFNCMGFHbHpMbk4wWVhKMFVuVnNaU2tnZTF4dUlDQWdJR052Ym5OMElITjBZWFJsSUQwZ1UzUmhkR1V1Wm5KdmJWUnZhMlZ1YzBGdVpGSjFiR1ZOWVhBb2RHOXJaVzV6TENCMGFHbHpMbkoxYkdWTllYQXBMRnh1SUNBZ0lDQWdJQ0FnSUdOaGJHeGlZV05ySUQwZ2JuVnNiQ3hjYmlBZ0lDQWdJQ0FnSUNCeWRXeGxUbTlrWlNBOUlISjFiR1V1Y0dGeWMyVW9jM1JoZEdVc0lHTmhiR3hpWVdOcktTeGNiaUFnSUNBZ0lDQWdJQ0J1YjJSbElEMGdjblZzWlU1dlpHVTdJQzh2TDF4dVhHNGdJQ0FnY21WMGRYSnVJRzV2WkdVN1hHNGdJSDFjYmx4dUlDQnpkR0YwYVdNZ1puSnZiVTV2ZEdocGJtY29RMnhoYzNNcElIdGNiaUFnSUNCamIyNXpkQ0I3SUdKdVppQjlJRDBnUTJ4aGMzTXNYRzRnSUNBZ0lDQWdJQ0FnY25Wc1pYTWdQU0J5ZFd4bGMwWnliMjFDVGtZb1ltNW1LU3hjYmlBZ0lDQWdJQ0FnSUNCd1lYSnpaWElnUFNCd1lYSnpaWEpHY205dFVuVnNaWE1vUTJ4aGMzTXNJSEoxYkdWektUdGNibHh1SUNBZ0lISmxkSFZ5YmlCd1lYSnpaWEk3WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nWm5KdmJVSk9SaWhEYkdGemN5d2dZbTVtS1NCN1hHNGdJQ0FnWTI5dWMzUWdjblZzWlhNZ1BTQnlkV3hsYzBaeWIyMUNUa1lvWW01bUtTeGNiaUFnSUNBZ0lDQWdJQ0J3WVhKelpYSWdQU0J3WVhKelpYSkdjbTl0VW5Wc1pYTW9RMnhoYzNNc0lISjFiR1Z6S1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJ3WVhKelpYSTdYRzRnSUgxY2JseHVJQ0J6ZEdGMGFXTWdabkp2YlZKMWJHVnpLRU5zWVhOekxDQnlkV3hsY3lrZ2UxeHVJQ0FnSUdOdmJuTjBJSEJoY25ObGNpQTlJSEJoY25ObGNrWnliMjFTZFd4bGN5aERiR0Z6Y3l3Z2NuVnNaWE1wTzF4dVhHNGdJQ0FnY21WMGRYSnVJSEJoY25ObGNqdGNiaUFnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWtOdmJXMXZibEJoY25ObGNpSXNJbk4wWVhKMFVuVnNaU0lzSW5KMWJHVk5ZWEFpTENKblpYUlRkR0Z5ZEZKMWJHVWlMQ0puWlhSU2RXeGxUV0Z3SWl3aWNHRnljMlVpTENKMGIydGxibk1pTENKeWRXeGxJaXdpYzNSaGRHVWlMQ0pUZEdGMFpTSXNJbVp5YjIxVWIydGxibk5CYm1SU2RXeGxUV0Z3SWl3aVkyRnNiR0poWTJzaUxDSnlkV3hsVG05a1pTSXNJbTV2WkdVaUxDSm1jbTl0VG05MGFHbHVaeUlzSWtOc1lYTnpJaXdpWW01bUlpd2ljblZzWlhNaUxDSnlkV3hsYzBaeWIyMUNUa1lpTENKd1lYSnpaWElpTENKd1lYSnpaWEpHY205dFVuVnNaWE1pTENKbWNtOXRRazVHSWl3aVpuSnZiVkoxYkdWeklsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeFpRVUZaTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJXdENMRWxCUVVFc1RVRkJWU3hyUTBGQlZpeFZRVUZWTEVWQlFVRTdRVUZGYTBJc1NVRkJRU3hQUVVGeFFpeFhRVUZ5UWl4eFFrRkJjVUlzUTBGQlFUczdPenM3T3pzN096aEVRVXB1UlR0elEwRkJRVHMyUkVGQlFUdHBSVUZCUVRzN096dDNSVUZCUVR0blJVRkJRVHM3T3pzN096czdRVUZOWlN4SlFVRkJMRUZCUVUxQkxGbEJRVmtzYVVKRFRqbENMRUZFVFZrN1lVRkJUVUVzV1VGQldTeERRVU51UWtNc1UwRkJVeXhGUVVGRlF5eFBRVUZQT3pKRFFWQm9RenRSUVZGSkxFbEJRVWtzUTBGQlEwUXNVMEZCVXl4SFFVRkhRU3hUUVVGVExFTkJRVU03VVVGRE0wSXNTVUZCU1N4RFFVRkRReXhQUVVGUExFZEJRVWRCTEU5QlFVOHNRMEZCUXpzN096dFpRVWQ2UWtNc1IwRkJXU3hGUVVGYVFTeGpRVUZaTzFsRldtUXNUMFpaUlVFc1UwRkJRVUVzV1VGQldTeEhRVUZITzJkQ1FVTmlMRTlCUVU4c1NVRkJTU3hEUVVGRFJpeFRRVUZUTEVOQlFVTTdZVUZEZGtJN096dFpRVVZFUnl4SFFVRlZMRVZCUVZaQkxGbEJRVlU3V1VWb1Fsb3NUMFpuUWtWQkxGTkJRVUZCTEZWQlFWVXNSMEZCUnp0blFrRkRXQ3hQUVVGUExFbEJRVWtzUTBGQlEwWXNUMEZCVHl4RFFVRkRPMkZCUTNKQ096czdXVUZGUkVjc1IwRkJTeXhGUVVGTVFTeFBRVUZMTzFsRmNFSlFMRTlHYjBKRlFTeFRRVUZCUVN4TFFVRkxMRU5CUVVORExFMUJRVTBzUlVGQmVVSTdiMEpCUVhaQ1F5eEpRVUZKTEVkQlFVcEJMQ3REUVVGeFFpeHJRa0ZCWkN4SlFVRkpMRU5CUVVOT0xGTkJRVk03WjBKQlEycERMRWxCUVUxUExFdEJRVXNzUjBGQlIwTXNUVUZCU3l4VFFVRkRReXh2UWtGQmIwSXNRMEZCUTBvc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlEwb3NUMEZCVHl4RFFVRkRMRVZCUTNoRVV5eFJRVUZSTEVkQlFVY3NTVUZCU1N4RlFVTm1ReXhSUVVGUkxFZEJRVWRNTEVsQlFVa3NRMEZCUTBZc1MwRkJTeXhEUVVGRFJ5eExRVUZMTEVWQlFVVkhMRkZCUVZFc1EwRkJReXhGUVVOMFEwVXNTVUZCU1N4SFFVRkhSQ3hSUVVGUkxFRkJRVU1zUlVGQlF5eEhRVUZITzJkQ1FVVXhRaXhQUVVGUFF5eEpRVUZKTEVOQlFVTTdZVUZEWWpzN096dFpRVVZOUXl4SFFVRlhMRVZCUVZoQkxHRkJRVmM3V1VVM1FuQkNMRTlHTmtKRkxGTkJRVTlCTEZkQlFWY3NRMEZCUTBNc1MwRkJTeXhGUVVGRk8yZENRVU40UWl4SlFVRk5MRUZCUVVWRExFZEJRVWNzUjBGQlMwUXNTMEZCU3l4RFFVRmlReXhIUVVGSExFRkJRVlVzUlVGRFprTXNTMEZCU3l4SFFVRkhReXhEUVVGQlFTeEhRVUZCUVN4UFFVRlpMRUZCUVVzc1EwRkJRU3hqUVVGS1JpeEhRVUZITEVOQlFVTXNSVUZEZWtKSExFMUJRVTBzUjBGQlIwTXNRMEZCUVVFc1IwRkJRVUVzVDBGQlpTeEJRVUZqTEVOQlFVRXNhVUpCUVdKTUxFdEJRVXNzUlVGQlJVVXNTMEZCU3l4RFFVRkRMRUZCUVVNN1owSkJSVGRETEU5QlFVOUZMRTFCUVUwc1EwRkJRenRoUVVObU96czdXVUZGVFVVc1IwRkJUeXhGUVVGUVFTeFRRVUZQTzFsRmNrTm9RaXhQUm5GRFJTeFRRVUZQUVN4UFFVRlBMRU5CUVVOT0xFdEJRVXNzUlVGQlJVTXNSMEZCUnl4RlFVRkZPMmRDUVVONlFpeEpRVUZOUXl4TFFVRkxMRWRCUVVkRExFTkJRVUZCTEVkQlFVRkJMRTlCUVZrc1FVRkJTeXhEUVVGQkxHTkJRVXBHTEVkQlFVY3NRMEZCUXl4RlFVTjZRa2NzVFVGQlRTeEhRVUZIUXl4RFFVRkJRU3hIUVVGQlFTeFBRVUZsTEVGQlFXTXNRMEZCUVN4cFFrRkJZa3dzUzBGQlN5eEZRVUZGUlN4TFFVRkxMRU5CUVVNc1FVRkJRenRuUWtGRk4wTXNUMEZCVDBVc1RVRkJUU3hEUVVGRE8yRkJRMlk3T3p0WlFVVk5SeXhIUVVGVExFVkJRVlJCTEZkQlFWTTdXVVUxUTJ4Q0xFOUdORU5GTEZOQlFVOUJMRk5CUVZNc1EwRkJRMUFzUzBGQlN5eEZRVUZGUlN4TFFVRkxMRVZCUVVVN1owSkJRemRDTEVsQlFVMUZMRTFCUVUwc1IwRkJSME1zUTBGQlFVRXNSMEZCUVVFc1QwRkJaU3hCUVVGakxFTkJRVUVzYVVKQlFXSk1MRXRCUVVzc1JVRkJSVVVzUzBGQlN5eERRVUZETEVGQlFVTTdaMEpCUlRkRExFOUJRVTlGTEUxQlFVMHNRMEZCUXp0aFFVTm1PenROUVdoRVNEczdRMEZwUkVNc1JVRkJRVHRyUWtFelEyOUNia0lzV1VGQldTeEJRVTVxUXlKOSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfYm5mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ibmZcIikpO1xudmFyIF9wYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb21tb24vcGFyc2VyXCIpKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgQmFzaWNQYXJzZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbW1vblBhcnNlcikge1xuICAgIF9pbmhlcml0cyhCYXNpY1BhcnNlciwgQ29tbW9uUGFyc2VyKTtcbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJhc2ljUGFyc2VyKTtcbiAgICBmdW5jdGlvbiBCYXNpY1BhcnNlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2ljUGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQmFzaWNQYXJzZXIsIG51bGwsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21Ob3RoaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU5vdGhpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZXIuZGVmYXVsdC5mcm9tTm90aGluZyhCYXNpY1BhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tQk5GXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJORihibmYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlci5kZWZhdWx0LmZyb21CTkYoQmFzaWNQYXJzZXIsIGJuZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZXMocnVsZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlci5kZWZhdWx0LmZyb21SdWxlcyhCYXNpY1BhcnNlciwgcnVsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEJhc2ljUGFyc2VyO1xufShfcGFyc2VyLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzaWNQYXJzZXI7XG5fZGVmaW5lUHJvcGVydHkoQmFzaWNQYXJzZXIsIFwiYm5mXCIsIF9ibmYuZGVmYXVsdCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWlZWE5wWXk5d1lYSnpaWEl1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQmlibVlnWm5KdmJTQmNJaTR2WW01bVhDSTdYRzVwYlhCdmNuUWdRMjl0Ylc5dVVHRnljMlZ5SUdaeWIyMGdYQ0l1TGk5amIyMXRiMjR2Y0dGeWMyVnlYQ0k3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdOc1lYTnpJRUpoYzJsalVHRnljMlZ5SUdWNGRHVnVaSE1nUTI5dGJXOXVVR0Z5YzJWeUlIdGNiaUFnYzNSaGRHbGpJR0p1WmlBOUlHSnVaanRjYmx4dUlDQnpkR0YwYVdNZ1puSnZiVTV2ZEdocGJtY29LU0I3SUhKbGRIVnliaUJEYjIxdGIyNVFZWEp6WlhJdVpuSnZiVTV2ZEdocGJtY29RbUZ6YVdOUVlYSnpaWElwT3lCOVhHNWNiaUFnYzNSaGRHbGpJR1p5YjIxQ1RrWW9ZbTVtS1NCN0lISmxkSFZ5YmlCRGIyMXRiMjVRWVhKelpYSXVabkp2YlVKT1JpaENZWE5wWTFCaGNuTmxjaXdnWW01bUtUc2dmVnh1WEc0Z0lITjBZWFJwWXlCbWNtOXRVblZzWlhNb2NuVnNaWE1wSUhzZ2NtVjBkWEp1SUVOdmJXMXZibEJoY25ObGNpNW1jbTl0VW5Wc1pYTW9RbUZ6YVdOUVlYSnpaWElzSUhKMWJHVnpLVHNnZlZ4dWZWeHVJbDBzSW01aGJXVnpJanBiSWtKaGMybGpVR0Z5YzJWeUlpd2labkp2YlU1dmRHaHBibWNpTENKRGIyMXRiMjVRWVhKelpYSWlMQ0ptY205dFFrNUdJaXdpWW01bUlpd2labkp2YlZKMWJHVnpJaXdpY25Wc1pYTWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZaMElzU1VGQlFTeEpRVUZQTEd0RFFVRlFMRTlCUVU4c1JVRkJRVHRCUVVORkxFbEJRVUVzVDBGQmEwSXNhME5CUVd4Q0xHdENRVUZyUWl4RlFVRkJPenM3T3pzN096czdPenM3T3pzN09FUkJTRE5ETzNORFFVRkJPelpFUVVGQk8ybEZRVUZCT3pzN08zZEZRVUZCTzJkRlFVRkJPenM3T3pzN096czdPMVZCUVVFN08zZENRVUZCT3pzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRkxaU3hKUVVGQkxFRkJRVTFCTEZkQlFWY3NhVUpEVERkQ0xFRkVTMWs3ZDBOQlRHWTdPMkZCUzNGQ1FTeFhRVUZYT3pCRFFVeG9RenM3T3pzN1dVRlJVME1zUjBGQlZ5eEZRVUZZUVN4aFFVRlhPMWxGVW5CQ0xFOUdVVVVzVTBGQlQwRXNWMEZCVnl4SFFVRkhPMmRDUVVGRkxFOUJRVTlETEU5QlFWa3NVMEZCUTBRc1YwRkJWeXhEUVVGRFJDeFhRVUZYTEVOQlFVTXNRMEZCUXp0aFFVRkZPenM3V1VGRkwwUkhMRWRCUVU4c1JVRkJVRUVzVTBGQlR6dFpSVlpvUWl4UFJsVkZMRk5CUVU5QkxFOUJRVThzUTBGQlEwTXNSMEZCUnl4RlFVRkZPMmRDUVVGRkxFOUJRVTlHTEU5QlFWa3NVMEZCUTBNc1QwRkJUeXhEUVVGRFNDeFhRVUZYTEVWQlFVVkpMRWRCUVVjc1EwRkJReXhEUVVGRE8yRkJRVVU3T3p0WlFVVXZSRU1zUjBGQlV5eEZRVUZVUVN4WFFVRlRPMWxGV214Q0xFOUdXVVVzVTBGQlQwRXNVMEZCVXl4RFFVRkRReXhMUVVGTExFVkJRVVU3WjBKQlFVVXNUMEZCVDBvc1QwRkJXU3hUUVVGRFJ5eFRRVUZUTEVOQlFVTk1MRmRCUVZjc1JVRkJSVTBzUzBGQlN5eERRVUZETEVOQlFVTTdZVUZCUlRzN1RVRmFhRVk3TzBOQllVTXNRMEZTZDBOS0xFOUJRVmtzVTBGUmNFUTdhMEpCVW05Q1JpeFhRVUZYTEVGQlRHaERPMEZCVFVVc1owSkJSRzFDUVN4WFFVRlhMRVZCUTNaQ1NTeExRVUZITEVWQlFVZEJMRWxCUVVjc1UwRkJReXhCUVU1dVFpSjkiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3dpbGRjYXJkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0L3Rlcm1pbmFsL3dpbGRjYXJkXCIpKTtcbnZhciBfZW5kT2ZMaW5lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZVwiKSk7XG52YXIgX3Rlcm1pbmFsU3ltYm9sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0L3Rlcm1pbmFsL3Rlcm1pbmFsU3ltYm9sXCIpKTtcbnZhciBfcmVndWxhckV4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnQvdGVybWluYWwvcmVndWxhckV4cHJlc3Npb25cIikpO1xudmFyIF9zaWduaWZpY2FudFRva2VuVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZVwiKSk7XG52YXIgX3J1bGVOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCIpKTtcbnZhciBfb3B0aW9uYWxQYXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiKSk7XG52YXIgX3plcm9Pck1vcmVQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFydC9ub25UZXJtaW5hbC96ZXJvT3JNb3JlUGFydHNcIikpO1xudmFyIF9vbmVPck1vcmVQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFydC9ub25UZXJtaW5hbC9vbmVPck1vcmVQYXJ0c1wiKSk7XG52YXIgX3NlcXVlbmNlT2ZQYXJ0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIikpO1xudmFyIF9jaG9pY2VPZlBhcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJ0L25vblRlcm1pbmFsL2Nob2ljZU9mUGFydHNcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxudmFyIF9kZWZhdWx0ID0ge1xuICAgIFdpbGRjYXJkUGFydDogX3dpbGRjYXJkLmRlZmF1bHQsXG4gICAgRW5kT2ZMaW5lUGFydDogX2VuZE9mTGluZS5kZWZhdWx0LFxuICAgIFRlcm1pbmFsU3ltYm9sUGFydDogX3Rlcm1pbmFsU3ltYm9sLmRlZmF1bHQsXG4gICAgUmVndWxhckV4cHJlc3Npb25QYXJ0OiBfcmVndWxhckV4cHJlc3Npb24uZGVmYXVsdCxcbiAgICBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQ6IF9zaWduaWZpY2FudFRva2VuVHlwZS5kZWZhdWx0LFxuICAgIFJ1bGVOYW1lUGFydDogX3J1bGVOYW1lLmRlZmF1bHQsXG4gICAgT3B0aW9uYWxQYXJ0UGFydDogX29wdGlvbmFsUGFydC5kZWZhdWx0LFxuICAgIFplcm9Pck1vcmVQYXJ0c1BhcnQ6IF96ZXJvT3JNb3JlUGFydHMuZGVmYXVsdCxcbiAgICBPbmVPck1vcmVQYXJ0c1BhcnQ6IF9vbmVPck1vcmVQYXJ0cy5kZWZhdWx0LFxuICAgIFNlcXVlbmNlT2ZQYXJ0c1BhcnQ6IF9zZXF1ZW5jZU9mUGFydHMuZGVmYXVsdCxcbiAgICBDaG9pY2VPZlBhcnRzUGFydDogX2Nob2ljZU9mUGFydHMuZGVmYXVsdFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OXdZWEowY3k1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJRmRwYkdSallYSmtVR0Z5ZENCbWNtOXRJRndpTGk5d1lYSjBMM1JsY20xcGJtRnNMM2RwYkdSallYSmtYQ0k3WEc1cGJYQnZjblFnUlc1a1QyWk1hVzVsVUdGeWRDQm1jbTl0SUZ3aUxpOXdZWEowTDNSbGNtMXBibUZzTDJWdVpFOW1UR2x1WlZ3aU8xeHVhVzF3YjNKMElGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDQm1jbTl0SUZ3aUxpOXdZWEowTDNSbGNtMXBibUZzTDNSbGNtMXBibUZzVTNsdFltOXNYQ0k3WEc1cGJYQnZjblFnVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhKMElHWnliMjBnWENJdUwzQmhjblF2ZEdWeWJXbHVZV3d2Y21WbmRXeGhja1Y0Y0hKbGMzTnBiMjVjSWp0Y2JtbHRjRzl5ZENCVGFXZHVhV1pwWTJGdWRGUnZhMlZ1Vkhsd1pWQmhjblFnWm5KdmJTQmNJaTR2Y0dGeWRDOTBaWEp0YVc1aGJDOXphV2R1YVdacFkyRnVkRlJ2YTJWdVZIbHdaVndpTzF4dWFXMXdiM0owSUZKMWJHVk9ZVzFsVUdGeWRDQm1jbTl0SUZ3aUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wzSjFiR1ZPWVcxbFhDSTdYRzVwYlhCdmNuUWdUM0IwYVc5dVlXeFFZWEowVUdGeWRDQm1jbTl0SUZ3aUxpOXdZWEowTDI1dmJsUmxjbTFwYm1Gc0wyOXdkR2x2Ym1Gc1VHRnlkRndpTzF4dWFXMXdiM0owSUZwbGNtOVBjazF2Y21WUVlYSjBjMUJoY25RZ1puSnZiU0JjSWk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5NlpYSnZUM0pOYjNKbFVHRnlkSE5jSWp0Y2JtbHRjRzl5ZENCUGJtVlBjazF2Y21WUVlYSjBjMUJoY25RZ1puSnZiU0JjSWk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5dmJtVlBjazF2Y21WUVlYSjBjMXdpTzF4dWFXMXdiM0owSUZObGNYVmxibU5sVDJaUVlYSjBjMUJoY25RZ1puSnZiU0JjSWk0dmNHRnlkQzl1YjI1VVpYSnRhVzVoYkM5elpYRjFaVzVqWlU5bVVHRnlkSE5jSWp0Y2JtbHRjRzl5ZENCRGFHOXBZMlZQWmxCaGNuUnpVR0Z5ZENCbWNtOXRJRndpTGk5d1lYSjBMMjV2YmxSbGNtMXBibUZzTDJOb2IybGpaVTltVUdGeWRITmNJanRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnZTF4dUlDQlhhV3hrWTJGeVpGQmhjblFzWEc0Z0lFVnVaRTltVEdsdVpWQmhjblFzWEc0Z0lGUmxjbTFwYm1Gc1UzbHRZbTlzVUdGeWRDeGNiaUFnVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhKMExGeHVJQ0JUYVdkdWFXWnBZMkZ1ZEZSdmEyVnVWSGx3WlZCaGNuUXNYRzRnSUZKMWJHVk9ZVzFsVUdGeWRDeGNiaUFnVDNCMGFXOXVZV3hRWVhKMFVHRnlkQ3hjYmlBZ1dtVnliMDl5VFc5eVpWQmhjblJ6VUdGeWRDeGNiaUFnVDI1bFQzSk5iM0psVUdGeWRITlFZWEowTEZ4dUlDQlRaWEYxWlc1alpVOW1VR0Z5ZEhOUVlYSjBMRnh1SUNCRGFHOXBZMlZQWmxCaGNuUnpVR0Z5ZEZ4dWZUdGNiaUpkTENKdVlXMWxjeUk2V3lKWGFXeGtZMkZ5WkZCaGNuUWlMQ0pGYm1SUFpreHBibVZRWVhKMElpd2lWR1Z5YldsdVlXeFRlVzFpYjJ4UVlYSjBJaXdpVW1WbmRXeGhja1Y0Y0hKbGMzTnBiMjVRWVhKMElpd2lVMmxuYm1sbWFXTmhiblJVYjJ0bGJsUjVjR1ZRWVhKMElpd2lVblZzWlU1aGJXVlFZWEowSWl3aVQzQjBhVzl1WVd4UVlYSjBVR0Z5ZENJc0lscGxjbTlQY2sxdmNtVlFZWEowYzFCaGNuUWlMQ0pQYm1WUGNrMXZjbVZRWVhKMGMxQmhjblFpTENKVFpYRjFaVzVqWlU5bVVHRnlkSE5RWVhKMElpd2lRMmh2YVdObFQyWlFZWEowYzFCaGNuUWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRmxCUVZrc1EwRkJRenM3TzBWQlFXSTdkMEpCUVVFN1FVRkZlVUlzU1VGQlFTeFRRVUV3UWl4clEwRkJNVUlzTUVKQlFUQkNMRVZCUVVFN1FVRkRla0lzU1VGQlFTeFZRVUV5UWl4clEwRkJNMElzTWtKQlFUSkNMRVZCUVVFN1FVRkRkRUlzU1VGQlFTeGxRVUZuUXl4clEwRkJhRU1zWjBOQlFXZERMRVZCUVVFN1FVRkROMElzU1VGQlFTeHJRa0ZCYlVNc2EwTkJRVzVETEcxRFFVRnRReXhGUVVGQk8wRkJRMmhETEVsQlFVRXNjVUpCUVhORExHdERRVUYwUXl4elEwRkJjME1zUlVGQlFUdEJRVU5zUkN4SlFVRkJMRk5CUVRaQ0xHdERRVUUzUWl3MlFrRkJOa0lzUlVGQlFUdEJRVU42UWl4SlFVRkJMR0ZCUVdsRExHdERRVUZxUXl4cFEwRkJhVU1zUlVGQlFUdEJRVU01UWl4SlFVRkJMR2RDUVVGdlF5eHJRMEZCY0VNc2IwTkJRVzlETEVWQlFVRTdRVUZEY2tNc1NVRkJRU3hsUVVGdFF5eHJRMEZCYmtNc2JVTkJRVzFETEVWQlFVRTdRVUZEYkVNc1NVRkJRU3huUWtGQmIwTXNhME5CUVhCRExHOURRVUZ2UXl4RlFVRkJPMEZCUTNSRExFbEJRVUVzWTBGQmEwTXNhME5CUVd4RExHdERRVUZyUXl4RlFVRkJPenM3T3pzN1pVRkZha1E3U1VOa1ppeEJSR1ZGUVN4WlFVRlpMRVZCUVZwQkxGTkJRVmtzVVVGQldrRTdTVU5tUml4QlJHZENSVU1zWVVGQllTeEZRVUZpUVN4VlFVRmhMRkZCUVdKQk8wbERhRUpHTEVGRWFVSkZReXhyUWtGQmEwSXNSVUZCYkVKQkxHVkJRV3RDTEZGQlFXeENRVHRKUTJwQ1JpeEJSR3RDUlVNc2NVSkJRWEZDTEVWQlFYSkNRU3hyUWtGQmNVSXNVVUZCY2tKQk8wbERiRUpHTEVGRWJVSkZReXgzUWtGQmQwSXNSVUZCZUVKQkxIRkNRVUYzUWl4UlFVRjRRa0U3U1VOdVFrWXNRVVJ2UWtWRExGbEJRVmtzUlVGQldrRXNVMEZCV1N4UlFVRmFRVHRKUTNCQ1JpeEJSSEZDUlVNc1owSkJRV2RDTEVWQlFXaENRU3hoUVVGblFpeFJRVUZvUWtFN1NVTnlRa1lzUVVSelFrVkRMRzFDUVVGdFFpeEZRVUZ1UWtFc1owSkJRVzFDTEZGQlFXNUNRVHRKUTNSQ1JpeEJSSFZDUlVNc2EwSkJRV3RDTEVWQlFXeENRU3hsUVVGclFpeFJRVUZzUWtFN1NVTjJRa1lzUVVSM1FrVkRMRzFDUVVGdFFpeEZRVUZ1UWtFc1owSkJRVzFDTEZGQlFXNUNRVHRKUTNoQ1JpeEJSSGxDUlVNc2FVSkJRV2xDTEVWQlFXcENRU3hqUVVGcFFpeFJRVUZxUWtFN1EwRkRSRHN3UWtFeFFrUWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJORlBhcnNlciB9IGZyb20gXCIuL2JuZi9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFzaWNQYXJzZXIgfSBmcm9tIFwiLi9iYXNpYy9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIi4vY29tbW9uL3BhcnNlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bGUgfSBmcm9tIFwiLi9ydWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRzIH0gZnJvbSBcIi4vcGFydHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydFR5cGVzIH0gZnJvbSBcIi4vcGFydFR5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlZmluaXRpb24gfSBmcm9tIFwiLi9kZWZpbml0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL25vZGUvdGVybWluYWxcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cblxuXG4gICAgc3R5bGVzaGVldCAgICAgICAgICAgICAgICAgOjo9ICggbWVkaWEgfCBydWxlU2V0IHwgZGVjbGFyYXRpb24gfCBlcnJvciApKyA7XG5cblxuXG5cblxuICAgIG1lZGlhICAgICAgICAgICAgICAgICAgICAgIDo6PSBcIkBtZWRpYVwiIG1lZGlhUXVlcmllcyBcIntcIiAoIHJ1bGVTZXQgfCBkZWNsYXJhdGlvbiApKiBcIn1cIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBtZWRpYVF1ZXJpZXMgICAgICAgICAgICAgICA6Oj0gIG1lZGlhUXVlcnkgKCBcIixcIiBtZWRpYVF1ZXJ5ICkqIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIG1lZGlhUXVlcnkgICAgICAgICAgICAgICAgIDo6PSAgXCJub3RcIj8gKCBcIm9ubHlcIj8gbWVkaWFUeXBlIFwiYW5kXCIgKT8gbWVkaWFFeHByZXNzaW9uICggXCJhbmRcIiBtZWRpYUV4cHJlc3Npb24gKSogO1xuXG5cbiAgICBtZWRpYVR5cGUgICAgICAgICAgICAgICAgICA6Oj0gIFwiYWxsXCIgfCBcInByaW50XCIgfCBcInNjcmVlblwiIHwgXCJzcGVlY2hcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBtZWRpYUV4cHJlc3Npb24gICAgICAgICAgICA6Oj0gIFwiKFwiIFtpZGVudGlmaWVyXSAoIFwiOlwiIGV4cHJlc3Npb24gKT8gXCIpXCIgO1xuXG5cblxuXG5cbiAgICBydWxlU2V0ICAgICAgICAgICAgICAgICAgICA6Oj0gIHNlbGVjdG9ycyBcIntcIiBkZWNsYXJhdGlvbiogXCJ9XCIgO1xuICAgIFxuICAgIFxuICAgIHNlbGVjdG9ycyAgICAgICAgICAgICAgICAgIDo6PSAgc2VsZWN0b3IgKCBcIixcIiBzZWxlY3RvciApKiA7XG5cblxuICAgIHNlbGVjdG9yICAgICAgICAgICAgICAgICAgIDo6PSAgKCBjbGFzcyB8IHBzZXVkb0NsYXNzIHwgcHNldWRvRWxlbWVudCB8IGF0dHJpYnV0ZSApKyA7XG5cblxuXG5cblxuICAgIGRlY2xhcmF0aW9uICAgICAgICAgICAgICAgIDo6PSAgcHJvcGVydHkgXCI6XCIgZXhwcmVzc2lvbiAoIFwiLFwiIGV4cHJlc3Npb24gKSogcHJpb3JpdHk/IFwiO1wiIDtcblxuXG4gICAgY2xhc3MgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIi5cIjxOT19XSElURVNQQUNFPltpZGVudGlmaWVyXSBwYXJlbnRoZXNpc2VkU2VsZWN0b3I/IDtcblxuXG4gICAgcHNldWRvQ2xhc3MgICAgICAgICAgICAgICAgOjo9ICBcIjpcIjxOT19XSElURVNQQUNFPltpZGVudGlmaWVyXSBwYXJlbnRoZXNpc2VkU2VsZWN0b3I/IDtcblxuXG4gICAgcHNldWRvRWxlbWVudCAgICAgICAgICAgICAgOjo9ICBcIjo6XCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBhcmVudGhlc2lzZWRTZWxlY3RvciAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIoXCIgc2VsZWN0b3IgPE5PX1dISVRFU1BBQ0U+XCIpXCIgO1xuXG5cbiAgICBhdHRyaWJ1dGUgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcIj1cIiB8IFwifj1cIiB8IFwifD1cIiApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbaWRlbnRpZmllcl0gfCBbc3RyaW5nLWxpdGVyYWxdIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJdXCJcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBwcm9wZXJ0eSAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXSA7XG5cblxuICAgIGV4cHJlc3Npb24gICAgICAgICAgICAgICAgIDo6PSAgdGVybSAoIFwiLFwiPyB0ZXJtICkqIDtcblxuXG4gICAgcHJpb3JpdHkgICAgICAgICAgICAgICAgICAgOjo9ICBcIiFpbXBvcnRhbnRcIiA7XG5cblxuXG5cblxuICAgIHRlcm0gICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW3VuYXJ5LW9wZXJhdG9yXT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW3BlcmNlbnRhZ2VdIHwgW2ZyZXF1ZW5jeV0gfCBbZnJhY3Rpb25dIHwgW2xlbmd0aF0gfCBbYW5nbGVdIHwgW3JlbXNdIHwgW2Vtc10gfCBbdGltZV0gfCBbbnVtYmVyXSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVyaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyaW5nLWxpdGVyYWxdK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbG91cl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIHVyaSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJ1cmxcIjxOT19XSElURVNQQUNFPlwiKFwiIFtzdHJpbmctbGl0ZXJhbF0gXCIpXCIgO1xuXG5cbiAgICBmdW5jdGlvbiAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXTxOT19XSElURVNQQUNFPlwiKFwiIGV4cHJlc3Npb24gXCIpXCIgO1xuXG5cblxuXG5cbiAgICBlcnJvciAgICAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU1NQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhDU1NQYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihDU1NQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKENTU1BhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnRyaW0gPSB0cmltO1xuZXhwb3J0cy5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuZXhwb3J0cy5maWZ0aCA9IGV4cG9ydHMuZm91cnRoID0gZXhwb3J0cy50aGlyZCA9IGV4cG9ydHMuc2Vjb25kID0gZXhwb3J0cy5wdXNoID0gZXhwb3J0cy5jbGVhciA9IHZvaWQgMDtcbnZhciBfbmVjZXNzYXJ5ID0gcmVxdWlyZShcIm5lY2Vzc2FyeVwiKTtcbnZhciBjbGVhciA9IF9uZWNlc3NhcnkuYXJyYXlVdGlsaXRpZXMuY2xlYXIsIHB1c2ggPSBfbmVjZXNzYXJ5LmFycmF5VXRpbGl0aWVzLnB1c2gsIHNlY29uZCA9IF9uZWNlc3NhcnkuYXJyYXlVdGlsaXRpZXMuc2Vjb25kLCB0aGlyZCA9IF9uZWNlc3NhcnkuYXJyYXlVdGlsaXRpZXMudGhpcmQsIGZvdXJ0aCA9IF9uZWNlc3NhcnkuYXJyYXlVdGlsaXRpZXMuZm91cnRoLCBmaWZ0aCA9IF9uZWNlc3NhcnkuYXJyYXlVdGlsaXRpZXMuZmlmdGg7XG5leHBvcnRzLmNsZWFyID0gY2xlYXI7XG5leHBvcnRzLnB1c2ggPSBwdXNoO1xuZXhwb3J0cy5zZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnRoaXJkID0gdGhpcmQ7XG5leHBvcnRzLmZvdXJ0aCA9IGZvdXJ0aDtcbmV4cG9ydHMuZmlmdGggPSBmaWZ0aDtcbmZ1bmN0aW9uIHRyaW0oYXJyYXksIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgdmFyIHN0YXJ0LCBkZWxldGVDb3VudDtcbiAgICBpZiAoZW5kSW5kZXggIT09IEluZmluaXR5KSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kSW5kZXggKyAxO1xuICAgICAgICBhcnJheS5zcGxpY2Uoc3RhcnQpO1xuICAgIH1cbiAgICBzdGFydCA9IDA7XG4gICAgZGVsZXRlQ291bnQgPSBzdGFydEluZGV4O1xuICAgIGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXkpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBlbGVtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgZWxlbWVudHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHMuc29tZShmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5pbmNsdWRlcyhlbGVtZW50KTtcbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5MWRHbHNhWFJwWlhNdllYSnlZWGt1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYQ0oxYzJVZ2MzUnlhV04wWENJN1hHNWNibWx0Y0c5eWRDQjdJR0Z5Y21GNVZYUnBiR2wwYVdWeklIMGdabkp2YlNCY0ltNWxZMlZ6YzJGeWVWd2lPMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdleUJqYkdWaGNpd2djSFZ6YUN3Z2MyVmpiMjVrTENCMGFHbHlaQ3dnWm05MWNuUm9MQ0JtYVdaMGFDQjlJRDBnWVhKeVlYbFZkR2xzYVhScFpYTTdYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUIwY21sdEtHRnljbUY1TENCemRHRnlkRWx1WkdWNExDQmxibVJKYm1SbGVDa2dlMXh1SUNCc1pYUWdjM1JoY25Rc1hHNGdJQ0FnSUNCa1pXeGxkR1ZEYjNWdWREdGNibHh1SUNCcFppQW9aVzVrU1c1a1pYZ2dJVDA5SUVsdVptbHVhWFI1S1NCN1hHNGdJQ0FnYzNSaGNuUWdQU0JsYm1SSmJtUmxlQ0FySURFN1hHNWNiaUFnSUNCaGNuSmhlUzV6Y0d4cFkyVW9jM1JoY25RcE8xeHVJQ0I5WEc1Y2JpQWdjM1JoY25RZ1BTQXdPMXh1SUNCa1pXeGxkR1ZEYjNWdWRDQTlJSE4wWVhKMFNXNWtaWGc3WEc1Y2JpQWdZWEp5WVhrdWMzQnNhV05sS0hOMFlYSjBMQ0JrWld4bGRHVkRiM1Z1ZENrN1hHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJwYm1Oc2RXUmxjeWhoY25KaGVTd2dMaTR1Wld4bGJXVnVkSE1wSUh0Y2JpQWdjbVYwZFhKdUlHVnNaVzFsYm5SekxuTnZiV1VvS0dWc1pXMWxiblFwSUQwK0lHRnljbUY1TG1sdVkyeDFaR1Z6S0dWc1pXMWxiblFwS1R0Y2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKMGNtbHRJaXdpYVc1amJIVmtaWE1pTENKamJHVmhjaUlzSW1GeWNtRjVWWFJwYkdsMGFXVnpJaXdpY0hWemFDSXNJbk5sWTI5dVpDSXNJblJvYVhKa0lpd2labTkxY25Sb0lpd2labWxtZEdnaUxDSmhjbkpoZVNJc0luTjBZWEowU1c1a1pYZ2lMQ0psYm1SSmJtUmxlQ0lzSW5OMFlYSjBJaXdpWkdWc1pYUmxRMjkxYm5RaUxDSkpibVpwYm1sMGVTSXNJbk53YkdsalpTSXNJbVZzWlcxbGJuUnpJaXdpYzI5dFpTSXNJbVZzWlcxbGJuUWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRU5CUVZrc1YwRkJRU3hEUVVGRE96czdSVUZCWWp0UlFVMW5Ra0VzU1VGQlNTeEhRVUZLUVN4SlFVRkpMRUZCVG5CQ08xRkJjMEpuUWtNc1VVRkJVU3hIUVVGU1FTeFJRVUZSTEVGQmRFSjRRanQxUjBGQlFUdEJRVVVyUWl4SFFVRlhMRU5CUVZnc1ZVRkJWenRCUVVWdVF5eEhRVUZMTEVOQlFVZERMRXRCUVVzc1IwRkJlVU5ETEZWQlFXTXNaMEpCUVRWRVJDeExRVUZMTEVWQlFVVkZMRWxCUVVrc1IwRkJiVU5FTEZWQlFXTXNaMEpCUVhKRVF5eEpRVUZKTEVWQlFVVkRMRTFCUVUwc1IwRkJNa0pHTEZWQlFXTXNaMEpCUVM5RFJTeE5RVUZOTEVWQlFVVkRMRXRCUVVzc1IwRkJiMEpJTEZWQlFXTXNaMEpCUVhaRFJ5eExRVUZMTEVWQlFVVkRMRTFCUVUwc1IwRkJXVW9zVlVGQll5eG5Ra0ZCYUVOSkxFMUJRVTBzUlVGQlJVTXNTMEZCU3l4SFFVRkxUQ3hWUVVGakxHZENRVUY0UWtzc1MwRkJTenRSUVVGNlEwNHNTMEZCU3l4SFFVRk1RU3hMUVVGTExFRkJTbkJDTzFGQlNYTkNSU3hKUVVGSkxFZEJRVXBCTEVsQlFVa3NRVUZLTVVJN1VVRkpORUpETEUxQlFVMHNSMEZCVGtFc1RVRkJUU3hCUVVwc1F6dFJRVWx2UTBNc1MwRkJTeXhIUVVGTVFTeExRVUZMTEVGQlNucERPMUZCU1RKRFF5eE5RVUZOTEVkQlFVNUJMRTFCUVUwc1FVRktha1E3VVVGSmJVUkRMRXRCUVVzc1IwRkJURUVzUzBGQlN5eEJRVXA0UkR0VFFVMW5RbElzU1VGQlNTeERRVUZEVXl4TFFVRkxMRVZCUVVWRExGVkJRVlVzUlVGQlJVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1NVRkRha1FzUjBGQlJ5eERRVUZEUXl4TFFVRkxMRVZCUTB4RExGZEJRVmM3U1VGRlppeEZRVUZGTEVWQlFVVkdMRkZCUVZFc1MwRkJTMGNzVVVGQlVTeEZRVUZGTEVOQlFVTTdVVUZETVVKR0xFdEJRVXNzUjBGQlIwUXNVVUZCVVN4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVWeVFrWXNTMEZCU3l4RFFVRkRUU3hOUVVGTkxFTkJRVU5JTEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUTNSQ0xFTkJRVU03U1VGRlJFRXNTMEZCU3l4SFFVRkhMRU5CUVVNc1EwRkJRenRKUVVOV1F5eFhRVUZYTEVkQlFVZElMRlZCUVZVc1EwRkJRenRKUVVWNlFrUXNTMEZCU3l4RFFVRkRUU3hOUVVGTkxFTkJRVU5JTEV0QlFVc3NSVUZCUlVNc1YwRkJWeXhEUVVGRExFTkJRVU03UVVGRGJrTXNRMEZCUXp0VFFVVmxXaXhSUVVGUkxFTkJRVU5STEV0QlFVc3NSVUZCWlN4RFFVRkRPMGxCUVdRc1IwRkJSMDhzUTBGQlNDeEhRVUZYTEVOQlFWZ3NTVUZCVnl4SFFVRllMRk5CUVZjc1EwRkJXQ3hOUVVGWExFVkJRVkpCTEZGQlFWRXNSMEZCV0N4SFFVRlhMRTlCUVZnc1NVRkJWeXhIUVVGWUxFTkJRVmNzUjBGQldDeEpRVUZYTEVkQlFWZ3NRMEZCVnl4UFFVRllMRWxCUVZjc1IwRkJXQ3hEUVVGWExFVkJRVmdzU1VGQlZ5eEhRVUZZTEVsQlFWY3NSVUZCV0N4SlFVRlhMRWRCUVZnc1EwRkJRenRSUVVGRlFTeFJRVUZSTEVOQlFWZ3NTVUZCVnl4SFFVRllMRU5CUVZjc1NVRkJXQ3hUUVVGWExFTkJRVmdzU1VGQlZ5eERRM1JDTTBNc1EwUnpRakpETzBsQlFVUXNRMEZCUXp0SlFVTjZReXhOUVVGTkxFTkJRVU5CTEZGQlFWRXNRMEZCUTBNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlVFTXNUMEZCVHp0bFFVRkxWQ3hMUVVGTExFTkJRVU5TTEZGQlFWRXNRMEZCUTJsQ0xFOUJRVTg3TzBGQlF6RkVMRU5CUVVNaWZRPT0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IGNsZWFyLCB0cmltLCBzZWNvbmQsIHRoaXJkLCBmb3VydGggfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcblxuY29uc3QgeyBFWENMQU1BVElPTl9NQVJLX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByZWFkIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRJbmRleCwgZW5kSW5kZXgsIHVuaXF1ZSkge1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgIHRoaXMudW5pcXVlID0gdW5pcXVlO1xuICB9XG5cbiAgYWRqdXN0Tm9kZXMobm9kZXMpIHtcbiAgICBpZiAodGhpcy51bmlxdWUpIHtcbiAgICAgIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZXNMZW5ndGggPiAxKSB7XG4gICAgICAgIGNsZWFyKG5vZGVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpbShub2RlcywgdGhpcy5zdGFydEluZGV4LCB0aGlzLmVuZEluZGV4KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZnJvbVNwcmVhZEV4cHJlc3Npb24oc3ByZWFkRXhwcmVzc2lvbikge1xuICAgIGxldCBzdGFydEluZGV4ID0gMCxcbiAgICAgICAgZW5kSW5kZXggPSBJbmZpbml0eSxcbiAgICAgICAgdW5pcXVlID0gZmFsc2U7XG5cbiAgICBpZiAoc3ByZWFkRXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNwcmVhZEV4cHJlc3Npb24gPT09IEVYQ0xBTUFUSU9OX01BUktfQ0hBUkFDVEVSKSB7XG4gICAgICAgIHVuaXF1ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZWdFeHAgPSAvXFxbKFxcZCspPyhcXC5cXC5cXC4pPyhcXGQrKT9dLyxcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHNwcmVhZEV4cHJlc3Npb24ubWF0Y2gocmVnRXhwKSxcbiAgICAgICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyksXG4gICAgICAgICAgICAgIHRoaXJkTWF0Y2ggPSB0aGlyZChtYXRjaGVzKSxcbiAgICAgICAgICAgICAgZm91cnRoTWF0Y2ggPSBmb3VydGgobWF0Y2hlcyk7XG5cbiAgICAgICAgaWYgKHNlY29uZE1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gcGFyc2VJbnQoc2Vjb25kTWF0Y2gpO1xuXG4gICAgICAgICAgaWYgKHRoaXJkTWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VydGhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kSW5kZXggPSBwYXJzZUludChmb3VydGhNYXRjaCk7XG5cbiAgICAgICAgICBpZiAodGhpcmRNYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3ByZWFkID0gbmV3IFNwcmVhZChzdGFydEluZGV4LCBlbmRJbmRleCwgdW5pcXVlKTtcblxuICAgIHJldHVybiBzcHJlYWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFNwcmVhZCBmcm9tIFwiLi9zcHJlYWRcIjtcblxuaW1wb3J0IHsgaW5jbHVkZXMsIHB1c2gsIGNsZWFyLCBzZWNvbmQsIHRoaXJkLCBmb3VydGgsIGZpZnRoIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmNvbnN0IHsgV0lMRENBUkRfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKHJ1bGVOYW1lcywgdHlwZXMsIHNwcmVhZCwgc3ViUXVlcnksICBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpIHtcbiAgICB0aGlzLnJ1bGVOYW1lcyA9IHJ1bGVOYW1lcztcbiAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJRdWVyeSA9IHN1YlF1ZXJ5O1xuICAgIHRoaXMubWF4aW11bURlcHRoID0gbWF4aW11bURlcHRoO1xuICAgIHRoaXMuaW5maW5pdGVEZXNjZW50ID0gaW5maW5pdGVEZXNjZW50O1xuICAgIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMgPSBpbnRlcm1lZGlhdGVOb2RlcztcbiAgfVxuXG4gIGV4ZWN1dGUobm9kZSwgZGVwdGggPSAwLCBtYXhpbXVtRGVwdGggPSB0aGlzLm1heGltdW1EZXB0aCkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB0aGlzLmZpbmQobm9kZSwgZGVwdGgsIG1heGltdW1EZXB0aCk7XG5cbiAgICB0aGlzLmFwcGx5KG5vZGVzLCBkZXB0aCwgbWF4aW11bURlcHRoKTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGNsZWFyKHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuICB9XG5cbiAgZmluZChub2RlLCBkZXB0aCwgbWF4aW11bURlcHRoKSB7XG4gICAgaWYgKGRlcHRoID4gbWF4aW11bURlcHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgICBub2RlTm9uVGVybWluYWxOb2RlID0gIW5vZGVUZXJtaW5hbE5vZGU7XG5cbiAgICBsZXQgZm91bmQ7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgICAgdHlwZSA9IHRlcm1pbmFsTm9kZS5nZXRUeXBlKCk7XG5cbiAgICAgIGZvdW5kID0gaW5jbHVkZXModGhpcy50eXBlcywgdHlwZSwgV0lMRENBUkRfQ0hBUkFDVEVSKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgICBmb3VuZCA9IGluY2x1ZGVzKHRoaXMucnVsZU5hbWVzLCBydWxlTmFtZSwgV0lMRENBUkRfQ0hBUkFDVEVSKTtcbiAgICB9XG5cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIGNvbnN0IGludGVybWVkaWF0ZU5vZGUgPSBub2RlOyAvLy9cblxuICAgICAgdGhpcy5pbnRlcm1lZGlhdGVOb2Rlcy5wdXNoKGludGVybWVkaWF0ZU5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluZmluaXRlRGVzY2VudCkge1xuICAgICAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgZGVwdGgrKztcblxuICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCk7XG5cbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHRoaXMuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCkge1xuICAgIHRoaXMuc3ByZWFkLmFkanVzdE5vZGVzKHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgaWYgKHRoaXMuc3ViUXVlcnkgPT09IG51bGwpIHtcbiAgICAgIHB1c2gobm9kZXMsIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVybWVkaWF0ZU5vZGVzLmZvckVhY2goKGludGVybWVkaWF0ZU5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSA9IGludGVybWVkaWF0ZU5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbnRlcm1lZGlhdGVOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKTtcblxuICAgICAgICAgIHRoaXMuc3ViUXVlcnkuY2xlYXIoKTtcblxuICAgICAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB0aGlzLnN1YlF1ZXJ5LmZpbmQoY2hpbGROb2RlLCBkZXB0aCwgbWF4aW11bURlcHRoKSk7XG5cbiAgICAgICAgICB0aGlzLnN1YlF1ZXJ5LmFwcGx5KG5vZGVzLCBkZXB0aCwgbWF4aW11bURlcHRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb21TdWJFeHByZXNzaW9uQW5kVHlwZXMoc3ViRXhwcmVzaW9uLCB0eXBlcykge1xuICAgIGxldCBxdWVyeSA9IG51bGw7XG5cbiAgICBpZiAoc3ViRXhwcmVzaW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0eXBlc0xlbmd0aCA9IHR5cGVzLmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVzTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBzdWJFeHByZXNpb247ICAvLy9cblxuICAgICAgICBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvbihleHByZXNzaW9uLCBtYXhpbXVtRGVwdGggPSBJbmZpbml0eSkge1xuICAgIGNvbnN0IHJlZ0V4cCA9IC9eXFwvKFxcLyk/KFteL1xcWyFdKykoXFxbW15cXF1dK118ISk/KFxcLy4qKT8kLyxcbiAgICAgICAgICBtYXRjaGVzID0gZXhwcmVzc2lvbi5tYXRjaChyZWdFeHApLFxuICAgICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpLFxuICAgICAgICAgIHRoaXJkTWF0Y2ggPSB0aGlyZChtYXRjaGVzKSxcbiAgICAgICAgICBmb3VydGhNYXRjaCA9IGZvdXJ0aChtYXRjaGVzKSxcbiAgICAgICAgICBmaWZ0aE1hdGNoID0gZmlmdGgobWF0Y2hlcyksXG4gICAgICAgICAgc2VsZWN0b3JzID0gdGhpcmRNYXRjaC5zcGxpdChcInxcIiksXG4gICAgICAgICAgc3ViRXhwcmVzc2lvbiA9IGZpZnRoTWF0Y2ggfHwgbnVsbCxcbiAgICAgICAgICBzcHJlYWRFeHByZXNzaW9uID0gZm91cnRoTWF0Y2ggfHwgbnVsbCxcbiAgICAgICAgICB0eXBlcyA9IHR5cGVzRnJvbVNlbGVjdG9ycyhzZWxlY3RvcnMpLFxuICAgICAgICAgIHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21TZWxlY3RvcnNBbmRUeXBlcyhzZWxlY3RvcnMsIHR5cGVzKSxcbiAgICAgICAgICBzcHJlYWQgPSBTcHJlYWQuZnJvbVNwcmVhZEV4cHJlc3Npb24oc3ByZWFkRXhwcmVzc2lvbiksXG4gICAgICAgICAgc3ViUXVlcnkgPSBRdWVyeS5mcm9tU3ViRXhwcmVzc2lvbkFuZFR5cGVzKHN1YkV4cHJlc3Npb24sIHR5cGVzKSxcbiAgICAgICAgICBpbmZpbml0ZURlc2NlbnQgPSAoc2Vjb25kTWF0Y2ggPT09IFwiL1wiKSwgIC8vL1xuICAgICAgICAgIGludGVybWVkaWF0ZU5vZGVzID0gW10sXG4gICAgICAgICAgcXVlcnkgPSBuZXcgUXVlcnkocnVsZU5hbWVzLCB0eXBlcywgc3ByZWFkLCBzdWJRdWVyeSwgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKTtcbiAgICBcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHlwZXNGcm9tU2VsZWN0b3JzKHNlbGVjdG9ycykge1xuICBjb25zdCB0eXBlcyA9IFtdO1xuXG4gIHNlbGVjdG9ycy5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yVHlwZVNlbGVjdG9yID0gaXNTZWxlY3RvclR5cGVTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICBpZiAoc2VsZWN0b3JUeXBlU2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzZWxlY3Rvci5zdWJzdHJpbmcoMSk7XG5cbiAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdHlwZXM7XG59XG5cbmZ1bmN0aW9uIGlzU2VsZWN0b3JUeXBlU2VsZWN0b3Ioc2VsZWN0b3IpIHsgcmV0dXJuIC9eQC8udGVzdChzZWxlY3Rvcik7IH1cblxuZnVuY3Rpb24gcnVsZU5hbWVzRnJvbVNlbGVjdG9ycyhzZWxlY3RvcnMpIHsgcmV0dXJuIHNlbGVjdG9ycy5maWx0ZXIoaXNTZWxlY3RvclJ1bGVOYW1lU2VsZWN0b3IpOyB9XG5cbmZ1bmN0aW9uIGlzU2VsZWN0b3JSdWxlTmFtZVNlbGVjdG9yKHNlbGVjdG9yKSB7IHJldHVybiAvXlteQF0vLnRlc3Qoc2VsZWN0b3IpOyB9XG5cbmZ1bmN0aW9uIHJ1bGVOYW1lc0Zyb21TZWxlY3RvcnNBbmRUeXBlcyhzZWxlY3RvcnMsIHR5cGVzKSB7XG4gIGxldCBydWxlTmFtZXMgPSBbXTtcblxuICBjb25zdCB0eXBlc0xlbmd0aCA9IHR5cGVzLmxlbmd0aDtcblxuICBpZiAodHlwZXNMZW5ndGggPT09IDApIHtcbiAgICBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tU2VsZWN0b3JzKHNlbGVjdG9ycyk7XG4gIH1cblxuICByZXR1cm4gcnVsZU5hbWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUXVlcnkgZnJvbSBcIi4uL3F1ZXJ5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUJ5Q2xhc3Mobm9kZSwgQ2xhc3MsIG5vZGVzID0gW10pIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDbGFzcykge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IG5vZGUuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHF1ZXJ5QnlDbGFzcyhjaGlsZE5vZGUsIENsYXNzLCBub2RlcykpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlCeUNsYXNzZXMobm9kZSwgQ2xhc3Nlcywgbm9kZXMgPSBbXSkge1xuICBDbGFzc2VzLnNvbWUoKENsYXNzKSA9PiB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDbGFzcykge1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IG5vZGUuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHF1ZXJ5QnlDbGFzc2VzKGNoaWxkTm9kZSwgQ2xhc3Nlcywgbm9kZXMpKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5QnlFeHByZXNzaW9uKG5vZGUsIGV4cHJlc3Npb24sIG1heGltdW1EZXB0aCkge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24sIG1heGltdW1EZXB0aCksXG4gICAgICAgIG5vZGVzID0gcXVlcnkuZXhlY3V0ZShub2RlKTtcblxuICByZXR1cm4gbm9kZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcXVlcnlCeUNsYXNzLFxuICBxdWVyeUJ5Q2xhc3NlcyxcbiAgcXVlcnlCeUV4cHJlc3Npb25cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUXVlcnkgfSBmcm9tIFwiLi9xdWVyeVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBxdWVyeVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9xdWVyeVwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgSEVBRCA9IFwiaGVhZFwiO1xuZXhwb3J0IGNvbnN0IFNUWUxFID0gXCJzdHlsZVwiO1xuZXhwb3J0IGNvbnN0IENIQVJBQ1RFUlMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcbmV4cG9ydCBjb25zdCBUV09fU1BBQ0VTID0gXCIgIFwiO1xuZXhwb3J0IGNvbnN0IEZPVVJfU1BBQ0VTID0gXCIgICAgXCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FX0xFTkdUSCA9IDY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMocXVlcnksIG5vZGUsIHRva2Vucykge1xuICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0KG5vZGVzKTtcblxuICBub2RlID0gZmlyc3ROb2RlOyAvLy9cblxuICBjb25zdCBjb250ZW50ID0gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3QgZmlyc3RTaWduaWZpY2FudFRva2VuID0gbm9kZS5nZXRGaXJzdFNpZ25pZmljYW50VG9rZW4oKSxcbiAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW4gPSBub2RlLmdldExhc3RTaWduaWZpY2FudFRva2VuKCksXG4gICAgICAgIGZpcnN0VG9rZW4gPSBmaXJzdFNpZ25pZmljYW50VG9rZW4sIC8vL1xuICAgICAgICBsYXN0VG9rZW4gPSBsYXN0U2lnbmlmaWNhbnRUb2tlbiwgLy8vXG4gICAgICAgIGZpcnN0VG9rZW5JbmRleCA9IHRva2Vucy5pbmRleE9mKGZpcnN0VG9rZW4pLFxuICAgICAgICBsYXN0VG9rZW5JbmRleCA9IHRva2Vucy5pbmRleE9mKGxhc3RUb2tlbik7XG5cbiAgbGV0IGNvbnRlbnQgPSBFTVBUWV9TVFJJTkc7XG5cbiAgZm9yIChsZXQgaW5kZXggPSBmaXJzdFRva2VuSW5kZXg7IGluZGV4IDw9IGxhc3RUb2tlbkluZGV4OyBpbmRleCsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaW5kZXhdLFxuICAgICAgICAgIHRva2VuQ29udGVudCA9IHRva2VuLmdldENvbnRlbnQoKTtcblxuICAgIGNvbnRlbnQgKz0gdG9rZW5Db250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLWRvbVwiO1xuXG5pbXBvcnQgeyBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29udGVudFwiO1xuXG5jb25zdCBwcm9wZXJ0eVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb24oXCIvKi9wcm9wZXJ0eVwiKSxcbiAgICAgIGV4cHJlc3Npb25RdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uKFwiLyovZXhwcmVzc2lvblwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSwgZXhwcmVzc2lvbikge1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0UHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydHk7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG4gIH1cblxuICBjaGVja01hdGNoZXMoZGVjbGFyYXRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGRlY2xhcmF0aW9ucy5zb21lKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBkZWNsYXJhdGlvbi5nZXRQcm9wZXJ0eSgpLFxuICAgICAgICAgICAgcHJvcGVydGllc01hdGNoID0gKHByb3BlcnR5ID09PSB0aGlzLnByb3BlcnR5KTtcblxuICAgICAgaWYgKHByb3BlcnRpZXNNYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50LCBsYXN0KSB7XG4gICAgY29uc3QgY3NzID0gbGFzdCA/XG4gICAgICAgICAgICAgICAgYCR7aW5kZW50fSR7dGhpcy5wcm9wZXJ0eX06ICR7dGhpcy5leHByZXNzaW9ufTtgIDpcbiAgICAgICAgICAgICAgICAgIGAke2luZGVudH0ke3RoaXMucHJvcGVydHl9OiAke3RoaXMuZXhwcmVzc2lvbn07XFxuYDtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgcHJvcGVydHlDb250ZW50ID0gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMocHJvcGVydHlRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBleHByZXNzaW9uQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKGV4cHJlc3Npb25RdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5Q29udGVudCwgLy8vXG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Db250ZW50LCAvLy9cbiAgICAgICAgICBkZWNsYXJhdGlvbiA9IG5ldyBEZWNsYXJhdGlvbihwcm9wZXJ0eSwgZXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tZG9tXCI7XG5cbmltcG9ydCBEZWNsYXJhdGlvbiBmcm9tIFwiLi9kZWNsYXJhdGlvblwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IGRlY2xhcmF0aW9uUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvbihcIi8qL2RlY2xhcmF0aW9uXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNsYXJhdGlvbnMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGZvcndhcmRzRm9yRWFjaChjYWxsYmFjaykge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGZpcnN0SW5kZXggPSAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IGZpcnN0SW5kZXg7IGluZGV4IDw9IGxhc3RJbmRleDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmFycmF5W2luZGV4XTtcblxuICAgICAgY2FsbGJhY2soZGVjbGFyYXRpb24sIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBiYWNrd2FyZHNGb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5hcnJheS5sZW5ndGgsXG4gICAgICAgICAgZmlyc3RJbmRleCA9IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gbGFzdEluZGV4OyBpbmRleCA+PSBmaXJzdEluZGV4OyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuYXJyYXlbaW5kZXhdO1xuXG4gICAgICBjYWxsYmFjayhkZWNsYXJhdGlvbiwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHVuc2hpZnQoZGVjbGFyYXRpb25zKSB7XG4gICAgZGVjbGFyYXRpb25zLmJhY2t3YXJkc0ZvckVhY2goKGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZGVjbGFyYXRpb24uY2hlY2tNYXRjaGVzKHRoaXMuYXJyYXkpOyAvLy9cblxuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChkZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGlmIChpbmRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZW50ID0gY2xhc3NOYW1lOyAvLy9cblxuICAgICAgY2xhc3NOYW1lID0gbnVsbDsgLy8vXG4gICAgfVxuXG4gICAgbGV0IGNzcyA9IEVNUFRZX1NUUklORztcblxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmFycmF5LnJlZHVjZSgoZGVjbGFyYXRpb25zQ1NTLCBkZWNsYXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IChpbmRleCA9PT0gbGFzdEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25DU1MgPSBkZWNsYXJhdGlvbi5hc0NTUyhpbmRlbnQsIGxhc3QpO1xuXG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyArPSBkZWNsYXJhdGlvbkNTUztcblxuICAgICAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25zQ1NTO1xuICAgICAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICBjc3MgPSBkZWNsYXJhdGlvbnNDU1M7ICAvLy9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNzcyA9IGAuJHtjbGFzc05hbWV9IHtcbiR7ZGVjbGFyYXRpb25zQ1NTfVxufVxuXG5gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlcyA9IGRlY2xhcmF0aW9uUXVlcnkuZXhlY3V0ZShub2RlKSxcbiAgICAgICAgICBhcnJheSA9IGRlY2xhcmF0aW9uTm9kZXMubWFwKChkZWNsYXJhdGlvbk5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBkZWNsYXJhdGlvbk5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbi5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGVjbGFyYXRpb25zID0gbmV3IERlY2xhcmF0aW9ucyhhcnJheSk7XG5cbiAgICByZXR1cm4gZGVjbGFyYXRpb25zO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLWRvbVwiO1xuXG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29udGVudFwiO1xuXG5jb25zdCBzZWxlY3RvcnNRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uKFwiLy9zZWxlY3RvcnNcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVTZXQge1xuICBjb25zdHJ1Y3RvcihzZWxlY3RvcnMsIGRlY2xhcmF0aW9ucykge1xuICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICB9XG5cbiAgZ2V0U2VsZWN0b3JzKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycztcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnM7XG4gIH1cblxuICB1bnNoaWZ0KHJ1bGVTZXQpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBydWxlU2V0LmdldERlY2xhcmF0aW9ucygpO1xuXG4gICAgdGhpcy5kZWNsYXJhdGlvbnMudW5zaGlmdChkZWNsYXJhdGlvbnMpO1xuICB9XG5cbiAgZmluZE1hdGNoaW5nUnVsZVNldChydWxlU2V0cykge1xuICAgIGNvbnN0IG1hdGNoaW5nUnVsZVNldCA9IHJ1bGVTZXRzLmZpbmQoKHJ1bGVTZXQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHJ1bGVTZXQuZ2V0U2VsZWN0b3JzKCksXG4gICAgICAgICAgICBzZWxlY3RvcnNNYXRjaCA9IChzZWxlY3RvcnMgPT09IHRoaXMuc2VsZWN0b3JzKSxcbiAgICAgICAgICAgIHJ1bGVTZXRzTWF0Y2ggPSBzZWxlY3RvcnNNYXRjaDsgLy8vXG5cbiAgICAgIGlmIChydWxlU2V0c01hdGNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pIHx8IG51bGw7IC8vL1xuXG4gICAgcmV0dXJuIG1hdGNoaW5nUnVsZVNldDtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgbGV0IGNzcyA9IEVNUFRZX1NUUklORztcblxuICAgIGNvbnN0IGRlY2xhcmF0aW9uc0NTUyA9IHRoaXMuZGVjbGFyYXRpb25zLmFzQ1NTKGAgICR7aW5kZW50fWApO1xuXG4gICAgaWYgKGRlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgY3NzID0gYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ke3RoaXMuc2VsZWN0b3JzfSB7XG4ke2RlY2xhcmF0aW9uc0NTU31cbiR7aW5kZW50fX1cblxuYDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbGVjdG9yc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgZGVjbGFyYXRpb25zID0gRGVjbGFyYXRpb25zLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgbWVkaWEgPSBuZXcgUnVsZVNldChzZWxlY3RvcnMsIGRlY2xhcmF0aW9ucyk7XG5cbiAgICByZXR1cm4gbWVkaWE7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JzRnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gIGNvbnN0IHNlbGVjdG9yc05vZGVDb250ZW50ID0gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMoc2VsZWN0b3JzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgIHNlbGVjdG9ycyA9IGAke3NlbGVjdG9yc05vZGVDb250ZW50fWA7XG5cbiAgcmV0dXJuIHNlbGVjdG9ycztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tZG9tXCI7XG5cbmltcG9ydCBSdWxlU2V0IGZyb20gXCIuL3J1bGVTZXRcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCBydWxlU2V0UXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvbihcIi8qL3J1bGVTZXRcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVTZXRzIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICB1bnNoaWZ0KHJ1bGVTZXRzKSB7XG4gICAgcnVsZVNldHMuZm9yRWFjaCgocnVsZVNldCkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hpbmdSdWxlU2V0ID0gcnVsZVNldC5maW5kTWF0Y2hpbmdSdWxlU2V0KHRoaXMuYXJyYXkpOyAvLy9cblxuICAgICAgKG1hdGNoaW5nUnVsZVNldCA9PT0gbnVsbCkgP1xuICAgICAgICB0aGlzLmFycmF5LnVuc2hpZnQocnVsZVNldCkgOlxuICAgICAgICAgIG1hdGNoaW5nUnVsZVNldC51bnNoaWZ0KHJ1bGVTZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGNvbnN0IGNzcyA9IHRoaXMuYXJyYXkucmVkdWNlKChjc3MsIHJ1bGVTZXQpID0+IHtcbiAgICAgIGNvbnN0IHJ1bGVTZXRDU1MgPSBydWxlU2V0LmFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KTtcblxuICAgICAgY3NzICs9IHJ1bGVTZXRDU1M7XG5cbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgcnVsZVNldE5vZGVzID0gcnVsZVNldFF1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBydWxlU2V0Tm9kZXMubWFwKChydWxlU2V0Tm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHJ1bGVTZXROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVTZXQgPSBSdWxlU2V0LmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBydWxlU2V0O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHJ1bGVTZXRzID0gbmV3IFJ1bGVTZXRzKGFycmF5KTtcblxuICAgIHJldHVybiBydWxlU2V0cztcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1kb21cIjtcblxuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3J1bGVTZXRzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyBUV09fU1BBQ0VTLCBGT1VSX1NQQUNFUyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IG1lZGlhUXVlcmllc1F1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb24oXCIvbWVkaWEvbWVkaWFRdWVyaWVzXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZWRpYSB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhUXVlcmllcywgZGVjbGFyYXRpb25zLCBydWxlU2V0cykge1xuICAgIHRoaXMubWVkaWFRdWVyaWVzID0gbWVkaWFRdWVyaWVzO1xuICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgfVxuXG4gIGdldE1lZGlhUXVlcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZWRpYVF1ZXJpZXM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zO1xuICB9XG5cbiAgZ2V0UnVsZVNldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZVNldHM7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUpIHtcbiAgICBsZXQgY3NzID0gXCJcIjtcblxuICAgIGNvbnN0IHJ1bGVTZXRzQ1NTID0gdGhpcy5ydWxlU2V0cy5hc0NTUyhjbGFzc05hbWUsIFRXT19TUEFDRVMpLFxuICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyA9IHRoaXMuZGVjbGFyYXRpb25zLmFzQ1NTKGNsYXNzTmFtZSwgRk9VUl9TUEFDRVMpO1xuXG4gICAgaWYgKChydWxlU2V0c0NTUyAhPT0gbnVsbCkgfHwgKGRlY2xhcmF0aW9uc0NTUyAhPT0gbnVsbCkpIHtcbiAgICAgIGNzcyA9IGBAbWVkaWEgJHt0aGlzLm1lZGlhUXVlcmllc30ge1xuJHtkZWNsYXJhdGlvbnNDU1N9JHtydWxlU2V0c0NTU31cbn1cblxuYDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IG1lZGlhUXVlcmllcyA9IG1lZGlhUXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgZGVjbGFyYXRpb25zID0gRGVjbGFyYXRpb25zLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcnVsZVNldHMgPSBSdWxlU2V0cy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIG1lZGlhID0gbmV3IE1lZGlhKG1lZGlhUXVlcmllcywgZGVjbGFyYXRpb25zLCBydWxlU2V0cyk7XG5cbiAgICByZXR1cm4gbWVkaWE7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVkaWFRdWVyaWVzRnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gIGNvbnN0IG1lZGlhUXVlcmllc05vZGVDb250ZW50ID0gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMobWVkaWFRdWVyaWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgIG1lZGlhUXVlcmllcyA9IGAke21lZGlhUXVlcmllc05vZGVDb250ZW50fWA7XG5cbiAgcmV0dXJuIG1lZGlhUXVlcmllcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tZG9tXCI7XG5cbmltcG9ydCBNZWRpYSBmcm9tIFwiLi9tZWRpYVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IG1lZGlhUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvbihcIi9zdHlsZXNoZWV0L21lZGlhXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZWRpYXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIHVuc2hpZnQobWVkaWFzKSB7XG4gICAgbWVkaWFzLmZvckVhY2goKG1lZGlhKSA9PiB7XG4gICAgICB0aGlzLmFycmF5LnVuc2hpZnQobWVkaWEpO1xuICAgIH0pO1xuICB9XG5cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUpIHtcbiAgICBjb25zdCBjc3MgPSB0aGlzLmFycmF5LnJlZHVjZSgoY3NzLCBtZWRpYSkgPT4ge1xuICAgICAgY29uc3QgbWVkaWFDU1MgPSBtZWRpYS5hc0NTUyhjbGFzc05hbWUpO1xuXG4gICAgICBjc3MgKz0gbWVkaWFDU1M7XG5cbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgbWVkaWFOb2RlcyA9IG1lZGlhUXVlcnkuZXhlY3V0ZShub2RlKSxcbiAgICAgICAgICBhcnJheSA9IG1lZGlhTm9kZXMubWFwKChtZWRpYU5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBtZWRpYU5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgbWVkaWEgPSBNZWRpYS5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWVkaWE7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFzID0gbmV3IE1lZGlhcyhhcnJheSk7XG5cbiAgICByZXR1cm4gbWVkaWFzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBNZWRpYXMgZnJvbSBcIi4vc3R5bGUvbWVkaWFzXCI7XG5pbXBvcnQgUnVsZVNldHMgZnJvbSBcIi4vc3R5bGUvcnVsZVNldHNcIjtcbmltcG9ydCBEZWNsYXJhdGlvbnMgZnJvbSBcIi4vc3R5bGUvZGVjbGFyYXRpb25zXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlIHtcbiAgY29uc3RydWN0b3IoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgbWVkaWFzKSB7XG4gICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XG4gICAgdGhpcy5ydWxlU2V0cyA9IHJ1bGVTZXRzO1xuICAgIHRoaXMubWVkaWFzID0gbWVkaWFzO1xuICB9XG5cbiAgZ2V0RGVjbGFyYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFJ1bGVTZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVTZXRzO1xuICB9XG5cbiAgZ2V0TWVkaWFzKCkge1xuICAgIHJldHVybiB0aGlzLm1lZGlhcztcbiAgfVxuXG4gIGV4dGVuZHMoc3VwZXJTdHlsZSkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHN1cGVyU3R5bGUuZ2V0RGVjbGFyYXRpb25zKCksXG4gICAgICAgICAgcnVsZVNldHMgPSBzdXBlclN0eWxlLmdldFJ1bGVTZXRzKCksXG4gICAgICAgICAgbWVkaWFzID0gc3VwZXJTdHlsZS5nZXRNZWRpYXMoKTtcblxuICAgIHRoaXMudW5zaGlmdChkZWNsYXJhdGlvbnMsIHJ1bGVTZXRzLCBtZWRpYXMpO1xuICB9XG5cbiAgdW5zaGlmdChkZWNsYXJhdGlvbnMsIHJ1bGVTZXRzLCBtZWRpYXMpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9ucy51bnNoaWZ0KGRlY2xhcmF0aW9ucyk7XG4gICAgdGhpcy5ydWxlU2V0cy51bnNoaWZ0KHJ1bGVTZXRzKTtcbiAgICB0aGlzLm1lZGlhcy51bnNoaWZ0KG1lZGlhcyk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhjbGFzc05hbWUsIFwiICBcIiksXG4gICAgICAgICAgcnVsZVNldHNDU1MgPSB0aGlzLnJ1bGVTZXRzLmFzQ1NTKGNsYXNzTmFtZSwgXCJcIiksXG4gICAgICAgICAgbWVkaWFzQ1NTID0gdGhpcy5tZWRpYXMuYXNDU1MoY2xhc3NOYW1lKSxcbiAgICAgICAgICBjc3MgPSBgJHtkZWNsYXJhdGlvbnNDU1N9JHtydWxlU2V0c0NTU30ke21lZGlhc0NTU31gO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBEZWNsYXJhdGlvbnMuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBydWxlU2V0cyA9IFJ1bGVTZXRzLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgbWVkaWFzID0gTWVkaWFzLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgc3R5bGUgPSBuZXcgU3R5bGUoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgbWVkaWFzKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3R5bGUgZnJvbSBcIi4uL3N0eWxlXCI7XG5pbXBvcnQgQ1NTTGV4ZXIgZnJvbSBcIi4uL2Nzcy9sZXhlclwiO1xuaW1wb3J0IENTU1BhcnNlciBmcm9tIFwiLi4vY3NzL3BhcnNlclwiO1xuXG5pbXBvcnQgeyBIRUFELCBTVFlMRSwgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCBjc3NMZXhlciA9IENTU0xleGVyLmZyb21Ob3RoaW5nKCksXG4gICAgICBjc3NQYXJzZXIgPSBDU1NQYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuaWYgKCFnbG9iYWxUaGlzLnN0eWxlTWFwKSB7XG4gIGdsb2JhbFRoaXMuc3R5bGVNYXAgPSB7fTtcbn1cblxuY29uc3QgeyBzdHlsZU1hcCB9ID0gZ2xvYmFsVGhpcztcblxuZnVuY3Rpb24gcmVuZGVyU3R5bGUoc3R5bGUpIHtcbiAgY29uc3QgaGVhZERPTUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEhFQUQpLFxuICAgICAgICBzdHlsZURPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFNUWUxFKSxcbiAgICAgICAgaW5uZXJIVE1MID0gYFxuICAgICAgICBcbiR7c3R5bGV9YDtcblxuICBPYmplY3QuYXNzaWduKHN0eWxlRE9NRWxlbWVudCwge1xuICAgIGlubmVySFRNTFxuICB9KTtcblxuICBoZWFkRE9NRWxlbWVudC5hcHBlbmRDaGlsZChzdHlsZURPTUVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdHlsZXMoKSB7XG4gIGNvbnN0IHN0eWxlc0NTUyA9IHJldHJpZXZlU3R5bGVzQ1NTKCksXG4gICAgICAgIHN0eWxlID0gc3R5bGVzQ1NTOyAgLy8vXG5cbiAgcmVuZGVyU3R5bGUoc3R5bGUpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSwgc3VwZXJTdHlsZSA9IG51bGwpIHtcbiAgY29uc3Qgc3RyaW5ncyA9IGFyZ3Muc2hpZnQoKSxcdC8vL1xuICAgICAgICBjb250ZW50ID0gc3RyaW5ncy5yZWR1Y2UoKGNvbnRlbnQsIHN0cmluZywgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcblxuICAgICAgICAgIGNvbnRlbnQgPSAoYXJnICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgICAgICAgICAgICBgJHtjb250ZW50fSR7c3RyaW5nfSR7YXJnfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7Y29udGVudH0ke3N0cmluZ31gO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0sIEVNUFRZX1NUUklORyksXG4gICAgICAgIHRva2VucyA9IGNzc0xleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3NzUGFyc2VyLnBhcnNlKHRva2VucyksXG4gICAgICAgIHN0eWxlID0gU3R5bGUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICAgICAgICBpZiAoc3VwZXJTdHlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0eWxlLmV4dGVuZHMoc3VwZXJTdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZU1hcFtjbGFzc05hbWVdID0gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlU3R5bGUoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVNYXBbY2xhc3NOYW1lXSB8fCBudWxsO1xuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzLFxuICBnZW5lcmF0ZVN0eWxlLFxuICByZXRyaWV2ZVN0eWxlXG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZVN0eWxlc0NTUygpIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlTWFwKSxcbiAgICAgICAgc3R5bGVzQ1NTID0gY2xhc3NOYW1lcy5yZWR1Y2UoKHN0eWxlc0NTUywgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgc3R5bGVDU1MgPSBzdHlsZS5hc0NTUyhjbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3R5bGVzQ1NTICs9IHN0eWxlQ1NTO1xuXG4gICAgICAgICAgcmV0dXJuIHN0eWxlc0NTUztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gc3R5bGVzQ1NTO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDSEFSQUNURVJTLCBFTVBUWV9TVFJJTkcsIENMQVNTX05BTUVfTEVOR1RIIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCBsZW5ndGggPSBDTEFTU19OQU1FX0xFTkdUSCxcbiAgICAgIGNoYXJhY3RlcnMgPSBDSEFSQUNURVJTLFxuICAgICAgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuXG5jb25zdCBjbGFzc05hbWVzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNsYXNzTmFtZSgpIHtcbiAgbGV0IGNsYXNzTmFtZSA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgbGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXJzW2luZGV4XTtcblxuICAgIGNsYXNzTmFtZSArPSBjaGFyYWN0ZXI7XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUgPSBjbGFzc05hbWVzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG5cbiAgaWYgKCFjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlQ2xhc3NOYW1lKGVsZW1lbnQpIHtcbiAgY29uc3QgeyBjbGFzc05hbWUgfSA9IGVsZW1lbnQucmVhY3RGdW5jdGlvbiB8fCBlbGVtZW50LnJlYWN0Q29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2VuZXJhdGVDbGFzc05hbWUsXG4gIHJldHJpZXZlQ2xhc3NOYW1lXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHRhZ05hbWVzIH0gZnJvbSBcIi4vdGFnTmFtZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTTGV4ZXIgfSBmcm9tIFwiLi9jc3MvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTUGFyc2VyIH0gZnJvbSBcIi4vY3NzL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHlsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3R5bGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsYXNzTmFtZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc05hbWVcIjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGFzcyhhcmd1bWVudCkgeyByZXR1cm4gaXNTdWJjbGFzc09mKGFyZ3VtZW50LCBFbGVtZW50KTsgfSAgLy8vXG5cbmZ1bmN0aW9uIGlzU3ViY2xhc3NPZihhcmd1bWVudCwgQ2xhc3MpIHtcbiAgbGV0IHN1YmNsYXNzID0gZmFsc2U7XG5cbiAgaWYgKGFyZ3VtZW50Lm5hbWUgPT09IENsYXNzLm5hbWUpIHsgICAvLy9cbiAgICBzdWJjbGFzcyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgYXJndW1lbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJndW1lbnQpOyAvLy9cblxuICAgIGlmIChhcmd1bWVudCAhPT0gbnVsbCkge1xuICAgICAgc3ViY2xhc3MgPSBpc1N1YmNsYXNzT2YoYXJndW1lbnQsIENsYXNzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ViY2xhc3M7XG59IiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgQ0xBU1NfTkFNRSA9IFwiY2xhc3NOYW1lXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2Vhc3kgPSByZXF1aXJlKFwiZWFzeVwiKTtcbnZhciBfd2l0aFN0eWxlID0gcmVxdWlyZShcIndpdGgtc3R5bGVcIik7XG52YXIgX2NsYXNzID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzL2NsYXNzXCIpO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG52YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7XG4gICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbn1cbnZhciBnZW5lcmF0ZUNsYXNzTmFtZSA9IF93aXRoU3R5bGUuY2xhc3NOYW1lVXRpbGl0aWVzLmdlbmVyYXRlQ2xhc3NOYW1lLCByZW5kZXJTdHlsZSA9IF93aXRoU3R5bGUuc3R5bGVzVXRpbGl0aWVzLnJlbmRlclN0eWxlLCByZW5kZXJTdHlsZXMgPSBfd2l0aFN0eWxlLnN0eWxlc1V0aWxpdGllcy5yZW5kZXJTdHlsZXMsIGdlbmVyYXRlU3R5bGUgPSBfd2l0aFN0eWxlLnN0eWxlc1V0aWxpdGllcy5nZW5lcmF0ZVN0eWxlLCByZXRyaWV2ZVN0eWxlID0gX3dpdGhTdHlsZS5zdHlsZXNVdGlsaXRpZXMucmV0cmlldmVTdHlsZTtcbmZ1bmN0aW9uIHdpdGhTdHlsZShDbGFzc09yRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8vXG4gICAgICAgIHZhciBfY2xhc3NOYW1lID0gQ2xhc3NPckZ1bmN0aW9uLmNsYXNzTmFtZSwgY2xhc3NOYW1lID0gX2NsYXNzTmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9jbGFzc05hbWU7XG4gICAgICAgIHZhciBzdXBlclN0eWxlID0gcmV0cmlldmVTdHlsZShjbGFzc05hbWUpO1xuICAgICAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuICAgICAgICBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSwgc3VwZXJTdHlsZSk7XG4gICAgICAgIHZhciBDbGFzc09yRnVuY3Rpb25DbGFzcyA9ICgwLCBfY2xhc3MpLmlzQ2xhc3MoQ2xhc3NPckZ1bmN0aW9uKTtcbiAgICAgICAgaWYgKENsYXNzT3JGdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgQ2xhc3MxID0gQ2xhc3NPckZ1bmN0aW9uOyAvLy9cbiAgICAgICAgICAgIENsYXNzT3JGdW5jdGlvbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBfaW5oZXJpdHMoX2NsYXNzMSwgQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoX2NsYXNzMSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX2NsYXNzMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzczEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MxLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJmcm9tQ2xhc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQ2xhc3MoX0NsYXNzLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVtYWluaW5nQXJndW1lbnRzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdBcmd1bWVudHNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgXyRfQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXyRfQ2xhc3MgPSBDbGFzczEpLmZyb21DbGFzcy5hcHBseShfJF9DbGFzcywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVtYWluaW5nQXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jbGFzczE7XG4gICAgICAgICAgICB9KENsYXNzMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgRnVuY3Rpb24gPSBDbGFzc09yRnVuY3Rpb247IC8vL1xuICAgICAgICAgICAgQ2xhc3NPckZ1bmN0aW9uID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBhcHBlbmRDbGFzc05hbWVUb1Byb3BlcnRpZXMoY2xhc3NOYW1lLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ2xhc3NPckZ1bmN0aW9uLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIENsYXNzT3JGdW5jdGlvbjtcbiAgICB9O1xufVxuT2JqZWN0LmFzc2lnbih3aXRoU3R5bGUsIHtcbiAgICByZW5kZXJTdHlsZTogcmVuZGVyU3R5bGUsXG4gICAgcmVuZGVyU3R5bGVzOiByZW5kZXJTdHlsZXNcbn0pO1xudmFyIF9kZWZhdWx0ID0gd2l0aFN0eWxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5fd2l0aFN0eWxlLnRhZ05hbWVzLmZvckVhY2goZnVuY3Rpb24odGFnTmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aXRoU3R5bGUsIHRhZ05hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGNsYXNzTmFtZSA9IGdlbmVyYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVTdHlsZShhcmdzLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBGdW5jdGlvbiA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Vhc3kuUmVhY3QuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oRnVuY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbmZ1bmN0aW9uIGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpIHtcbiAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfY29uc3RhbnRzLkNMQVNTX05BTUUpID8gcHJvcGVydGllcyA6IF9vYmplY3RTcHJlYWQoe30sIHByb3BlcnRpZXMsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9KTsgLy8vXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5M2FYUm9VM1I1YkdVdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0I3SUZKbFlXTjBJSDBnWm5KdmJTQmNJbVZoYzNsY0lqdGNibWx0Y0c5eWRDQjdJSFJoWjA1aGJXVnpMQ0J6ZEhsc1pYTlZkR2xzYVhScFpYTXNJR05zWVhOelRtRnRaVlYwYVd4cGRHbGxjeUI5SUdaeWIyMGdYQ0ozYVhSb0xYTjBlV3hsWENJN1hHNWNibWx0Y0c5eWRDQjdJR2x6UTJ4aGMzTWdmU0JtY205dElGd2lMaTkxZEdsc2FYUnBaWE12WTJ4aGMzTmNJanRjYm1sdGNHOXlkQ0I3SUVOTVFWTlRYMDVCVFVVZ2ZTQm1jbTl0SUZ3aUxpOWpiMjV6ZEdGdWRITmNJanRjYmx4dVkyOXVjM1FnZXlCblpXNWxjbUYwWlVOc1lYTnpUbUZ0WlNCOUlEMGdZMnhoYzNOT1lXMWxWWFJwYkdsMGFXVnpMRnh1SUNBZ0lDQWdleUJ5Wlc1a1pYSlRkSGxzWlN3Z2NtVnVaR1Z5VTNSNWJHVnpMQ0JuWlc1bGNtRjBaVk4wZVd4bExDQnlaWFJ5YVdWMlpWTjBlV3hsSUgwZ1BTQnpkSGxzWlhOVmRHbHNhWFJwWlhNN1hHNWNibVoxYm1OMGFXOXVJSGRwZEdoVGRIbHNaU2hEYkdGemMwOXlSblZ1WTNScGIyNHBJSHRjYmlBZ2NtVjBkWEp1SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUdOdmJuTjBJR0Z5WjNNZ1BTQmJMaTR1WVhKbmRXMWxiblJ6WFRzZ0lDOHZMMXh1WEc0Z0lDQWdiR1YwSUhzZ1kyeGhjM05PWVcxbElEMGdiblZzYkNCOUlEMGdRMnhoYzNOUGNrWjFibU4wYVc5dU8xeHVYRzRnSUNBZ1kyOXVjM1FnYzNWd1pYSlRkSGxzWlNBOUlISmxkSEpwWlhabFUzUjViR1VvWTJ4aGMzTk9ZVzFsS1R0Y2JseHVJQ0FnSUdOc1lYTnpUbUZ0WlNBOUlHZGxibVZ5WVhSbFEyeGhjM05PWVcxbEtDazdYRzVjYmlBZ0lDQm5aVzVsY21GMFpWTjBlV3hsS0dGeVozTXNJR05zWVhOelRtRnRaU3dnYzNWd1pYSlRkSGxzWlNrN1hHNWNiaUFnSUNCamIyNXpkQ0JEYkdGemMwOXlSblZ1WTNScGIyNURiR0Z6Y3lBOUlHbHpRMnhoYzNNb1EyeGhjM05QY2taMWJtTjBhVzl1S1R0Y2JseHVJQ0FnSUdsbUlDaERiR0Z6YzA5eVJuVnVZM1JwYjI1RGJHRnpjeWtnZTF4dUlDQWdJQ0FnWTI5dWMzUWdRMnhoYzNNZ1BTQkRiR0Z6YzA5eVJuVnVZM1JwYjI0N0lDQXZMeTljYmx4dUlDQWdJQ0FnUTJ4aGMzTlBja1oxYm1OMGFXOXVJRDBnWTJ4aGMzTWdaWGgwWlc1a2N5QkRiR0Z6Y3lCN1hHNGdJQ0FnSUNBZ0lITjBZWFJwWXlCbWNtOXRRMnhoYzNNb1gwTnNZWE56TENCd2NtOXdaWEowYVdWekxDQXVMaTV5WlcxaGFXNXBibWRCY21kMWJXVnVkSE1wSUh0Y2JpQWdJQ0FnSUNBZ0lDQndjbTl3WlhKMGFXVnpJRDBnWVhCd1pXNWtRMnhoYzNOT1lXMWxWRzlRY205d1pYSjBhV1Z6S0dOc1lYTnpUbUZ0WlN3Z2NISnZjR1Z5ZEdsbGN5azdYRzVjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnUTJ4aGMzTXVabkp2YlVOc1lYTnpLRjlEYkdGemN5d2djSEp2Y0dWeWRHbGxjeXdnTGk0dWNtVnRZV2x1YVc1blFYSm5kVzFsYm5SektUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVHRjYmx4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmpiMjV6ZENCR2RXNWpkR2x2YmlBOUlFTnNZWE56VDNKR2RXNWpkR2x2YmpzZ0x5OHZYRzVjYmlBZ0lDQWdJRU5zWVhOelQzSkdkVzVqZEdsdmJpQTlJQ2h3Y205d1pYSjBhV1Z6S1NBOVBpQjdYRzRnSUNBZ0lDQWdJSEJ5YjNCbGNuUnBaWE1nUFNCaGNIQmxibVJEYkdGemMwNWhiV1ZVYjFCeWIzQmxjblJwWlhNb1kyeGhjM05PWVcxbExDQndjbTl3WlhKMGFXVnpLVHRjYmx4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnUm5WdVkzUnBiMjRvY0hKdmNHVnlkR2xsY3lrN1hHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgxY2JseHVJQ0FnSUU5aWFtVmpkQzVoYzNOcFoyNG9RMnhoYzNOUGNrWjFibU4wYVc5dUxDQjdYRzRnSUNBZ0lDQmpiR0Z6YzA1aGJXVmNiaUFnSUNCOUtUdGNibHh1SUNBZ0lISmxkSFZ5YmlCRGJHRnpjMDl5Um5WdVkzUnBiMjQ3WEc0Z0lIMDdYRzU5WEc1Y2JrOWlhbVZqZEM1aGMzTnBaMjRvZDJsMGFGTjBlV3hsTENCN1hHNGdJSEpsYm1SbGNsTjBlV3hsTEZ4dUlDQnlaVzVrWlhKVGRIbHNaWE5jYm4wcE8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQjNhWFJvVTNSNWJHVTdYRzVjYm5SaFowNWhiV1Z6TG1admNrVmhZMmdvS0hSaFowNWhiV1VwSUQwK0lIdGNiaUFnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtIZHBkR2hUZEhsc1pTd2dkR0ZuVG1GdFpTd2dlMXh1SUNBZ0lHZGxkRG9nS0NrZ1BUNGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0JqYjI1emRDQmhjbWR6SUQwZ1d5NHVMbUZ5WjNWdFpXNTBjMTBzSUNBdkx5OWNiaUFnSUNBZ0lDQWdJQ0FnSUdOc1lYTnpUbUZ0WlNBOUlHZGxibVZ5WVhSbFEyeGhjM05PWVcxbEtDazdYRzVjYmlBZ0lDQWdJR2RsYm1WeVlYUmxVM1I1YkdVb1lYSm5jeXdnWTJ4aGMzTk9ZVzFsS1R0Y2JseHVJQ0FnSUNBZ1kyOXVjM1FnUm5WdVkzUnBiMjRnUFNBb2NISnZjR1Z5ZEdsbGN5a2dQVDRnZTF4dUlDQWdJQ0FnSUNCd2NtOXdaWEowYVdWeklEMGdZWEJ3Wlc1a1EyeGhjM05PWVcxbFZHOVFjbTl3WlhKMGFXVnpLR05zWVhOelRtRnRaU3dnY0hKdmNHVnlkR2xsY3lrN1hHNWNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGSmxZV04wTG1OeVpXRjBaVVZzWlcxbGJuUW9kR0ZuVG1GdFpTd2djSEp2Y0dWeWRHbGxjeWs3WEc0Z0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNCUFltcGxZM1F1WVhOemFXZHVLRVoxYm1OMGFXOXVMQ0I3WEc0Z0lDQWdJQ0FnSUdOc1lYTnpUbUZ0WlZ4dUlDQWdJQ0FnZlNrN1hHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCR2RXNWpkR2x2Ymp0Y2JpQWdJQ0I5WEc0Z0lIMHBPMXh1ZlNrN1hHNWNibVoxYm1OMGFXOXVJR0Z3Y0dWdVpFTnNZWE56VG1GdFpWUnZVSEp2Y0dWeWRHbGxjeWhqYkdGemMwNWhiV1VzSUhCeWIzQmxjblJwWlhNcElIdGNiaUFnY0hKdmNHVnlkR2xsY3lBOUlIQnliM0JsY25ScFpYTXVhR0Z6VDNkdVVISnZjR1Z5ZEhrb1EweEJVMU5mVGtGTlJTa2dQeUJ3Y205d1pYSjBhV1Z6SURvZ2V5QXVMaTV3Y205d1pYSjBhV1Z6TENCamJHRnpjMDVoYldVZ2ZUc2dMeTh2WEc1Y2JpQWdjbVYwZFhKdUlIQnliM0JsY25ScFpYTTdYRzU5WEc0aVhTd2libUZ0WlhNaU9sc2laMlZ1WlhKaGRHVkRiR0Z6YzA1aGJXVWlMQ0pqYkdGemMwNWhiV1ZWZEdsc2FYUnBaWE1pTENKeVpXNWtaWEpUZEhsc1pTSXNJbk4wZVd4bGMxVjBhV3hwZEdsbGN5SXNJbkpsYm1SbGNsTjBlV3hsY3lJc0ltZGxibVZ5WVhSbFUzUjViR1VpTENKeVpYUnlhV1YyWlZOMGVXeGxJaXdpZDJsMGFGTjBlV3hsSWl3aVEyeGhjM05QY2taMWJtTjBhVzl1SWl3aVlYSm5jeUlzSW1GeVozVnRaVzUwY3lJc0ltTnNZWE56VG1GdFpTSXNJbk4xY0dWeVUzUjViR1VpTENKRGJHRnpjMDl5Um5WdVkzUnBiMjVEYkdGemN5SXNJbWx6UTJ4aGMzTWlMQ0pEYkdGemN5SXNJbVp5YjIxRGJHRnpjeUlzSWw5RGJHRnpjeUlzSW5CeWIzQmxjblJwWlhNaUxDSnlaVzFoYVc1cGJtZEJjbWQxYldWdWRITWlMQ0poY0hCbGJtUkRiR0Z6YzA1aGJXVlViMUJ5YjNCbGNuUnBaWE1pTENKR2RXNWpkR2x2YmlJc0lrOWlhbVZqZENJc0ltRnpjMmxuYmlJc0luUmhaMDVoYldWeklpd2labTl5UldGamFDSXNJblJoWjA1aGJXVWlMQ0prWldacGJtVlFjbTl3WlhKMGVTSXNJbWRsZENJc0lsSmxZV04wSWl3aVkzSmxZWFJsUld4bGJXVnVkQ0lzSW1oaGMwOTNibEJ5YjNCbGNuUjVJaXdpUTB4QlUxTmZUa0ZOUlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1EwRkJXU3hYUVVGQkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSWE5DTEVkQlFVMHNRMEZCVGl4TFFVRk5PMEZCUTJ0RExFZEJRVmtzUTBGQldpeFZRVUZaTzBGQlJXeEVMRWRCUVcxQ0xFTkJRVzVDTEUxQlFXMUNPMEZCUTJoQ0xFZEJRV0VzUTBGQllpeFZRVUZoT3p0NVJFRk9lRU03ZFVWQlFVRTdPenM3T3pzN096czdPenM3T3pzN096czdPemhFUVVGQk8zTkRRVUZCT3paRVFVRkJPMmxGUVVGQk96czdPM2RGUVVGQk8yZEZRVUZCT3pzN096czdPenM3TzFWQlFVRTdPM2RDUVVGQk96czdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPMlZCUVVFN096dHhSRUZCUVR0VlFVRkJPenM3T3pzN096czdPenM3ZFVKQlFVRTdPMHRCUVVFN096czdPenM3TWtKQlFVRTdPenM3T3pzN0swUkJRVUU3T3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZSUVN4SFFVRkxMRU5CUVVkQkxHbENRVUZwUWl4SFFVRkxReXhWUVVGclFpeHZRa0ZCZUVORUxHbENRVUZwUWl4RlFVTnFRa1VzVjBGQlZ5eEhRVUZwUkVNc1ZVRkJaU3hwUWtGQk0wVkVMRmRCUVZjc1JVRkJSVVVzV1VGQldTeEhRVUZ0UTBRc1ZVRkJaU3hwUWtGQk9VUkRMRmxCUVZrc1JVRkJSVU1zWVVGQllTeEhRVUZ2UWtZc1ZVRkJaU3hwUWtGQmFFUkZMR0ZCUVdFc1JVRkJSVU1zWVVGQllTeEhRVUZMU0N4VlFVRmxMR2xDUVVGcVEwY3NZVUZCWVR0VFFVVjBSRU1zVTBGQlV5eERRVUZEUXl4bFFVRmxMRVZCUVVVc1EwRkJRenRKUVVOdVF5eE5RVUZOTEVOQlFVTXNVVUZCVVN4SFFVRkhMRU5CUVVNN1VVRkRha0lzUjBGQlN5eERRVUZEUXl4SlFVRkpMRGhDUVVGUFF5eFRRVUZUTEVkQlFVa3NSVUZCUnl4QlFVRklMRU5CUVVjN1VVRkZha01zUjBGQlJ5eGpRVUYzUWtZc1pVRkJaU3hEUVVGd1EwY3NVMEZCVXl4RlFVRlVRU3hUUVVGVExESkNRVUZITEVsQlFVazdVVUZGZEVJc1IwRkJTeXhEUVVGRFF5eFZRVUZWTEVkQlFVZE9MR0ZCUVdFc1EwRkJRMHNzVTBGQlV6dFJRVVV4UTBFc1UwRkJVeXhIUVVGSFdDeHBRa0ZCYVVJc1JVRkJSU3hEUVVGRE8xRkJSV2hEU3l4aFFVRmhMRU5CUVVOSkxFbEJRVWtzUlVGQlJVVXNVMEZCVXl4RlFVRkZReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFJRVVV6UXl4SFFVRkxMRU5CUVVORExHOUNRVUZ2UWl4UFFVRkhReXhOUVVGUExGVkJRVU5PTEdWQlFXVTdVVUZGY0VRc1JVRkJSU3hGUVVGRlN5eHZRa0ZCYjBJc1JVRkJSU3hEUVVGRE8xbEJRM3BDTEVkQlFVc3NRMEZCUTBVc1RVRkJTeXhIUVVGSFVDeGxRVUZsTEVWQlFVY3NSVUZCUnl4QlFVRklMRU5CUVVjN1dVRkZia05CTEdWQlFXVXNhVUpCUVVjc1VVRkJVVHQ1UTBFMVFtaERPenM3YTBSQlFVRTdPenM3TzNkQ1FUWkNaVkVzUjBGQlV5eEZRVUZVUVN4RFFVRlRPeXRDUVVGb1FpeFJRVUZSTEVOQlFVUkJMRk5CUVZNc1EwRkJRME1zVFVGQlRTeEZRVUZGUXl4VlFVRlZMRVZCUVhsQ0xFTkJRVU03TkVKQlFYaENMRWRCUVVkRExFTkJRVWdzUjBGQmNVSXNRMEZCY2tJc1NVRkJjVUlzUjBGQmNrSXNVMEZCY1VJc1EwRkJja0lzVFVGQmNVSXNSVUZCYkVKQkxHdENRVUZyUWl4SFFVRnlRaXhIUVVGeFFpeFBRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeERRVUZ4UWl4SFFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4RFFVRnhRaXhQUVVGeVFpeEpRVUZ4UWl4SFFVRnlRaXhEUVVGeFFpeEZRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeEpRVUZ4UWl4RlFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4RFFVRkRPMmREUVVGRlFTeHJRa0ZCYTBJc1EwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQmNrSXNVMEZCY1VJc1EwRkJja0lzU1VGQmNVSXNRME0zUW14RkxFTkVOa0pyUlRzMFFrRkJSQ3hEUVVGRE8yZERRVWRxUkVvc1VVRkJTenMwUWtGR1drY3NWVUZCVlN4SFFVRkhSU3d5UWtGQk1rSXNRMEZCUTFRc1UwRkJVeXhGUVVGRlR5eFZRVUZWTEVOQlFVTXNRMEZCUXpzMFFrRkZhRVVzVFVGQlRTeEZRVUZEU0N4UlFVRkxMRWRCUVV4QkxFMUJRVXNzUlVGQlEwTXNVMEZCVXl4RFFVRm1SQ3hMUVVFd1JDeERRVUV4UkVFc1VVRkJTeXhGUVVGTVFTeERRVUZETzJkRFFVRmxSU3hOUVVGTk8yZERRVUZGUXl4VlFVRlZPelJDUVVGMVFpeERRVUZETEVOQlFURkVTQ3hOUVVFd1JDeHZRa0ZCYmtKSkxHdENRVUZyUWp0M1FrRkRiRVVzUTBGQlF6czdhMEpCYWtOVU96dGpRVFJDYzBOS0xFMUJRVXNzUTBGTmNFTXNRMEZCUXp0UlFVVktMRU5CUVVNc1RVRkJUU3hEUVVGRE8xbEJRMDRzUjBGQlN5eERRVUZEVFN4UlFVRlJMRWRCUVVkaUxHVkJRV1VzUlVGQlJTeEZRVUZITEVGQlFVZ3NRMEZCUnp0WlFVVnlRMEVzWlVGQlpTeEhRVUZITEZGQlFWRXNRMEZCVUZVc1ZVRkJWU3hGUVVGTExFTkJRVU03WjBKQlEycERRU3hWUVVGVkxFZEJRVWRGTERKQ1FVRXlRaXhEUVVGRFZDeFRRVUZUTEVWQlFVVlBMRlZCUVZVc1EwRkJReXhEUVVGRE8yZENRVVZvUlN4TlFVRk5MRU5CUVVOSExGRkJRVkVzUTBGQlEwZ3NWVUZCVlR0WlFVTTFRaXhEUVVGRExFTkJRVU03VVVGRFNpeERRVUZETzFGQlJVUkpMRTFCUVUwc1EwRkJRME1zVFVGQlRTeERRVUZEWml4bFFVRmxMRVZCUVVVc1EwRkJRenRaUVVNNVFrY3NVMEZCVXl4RlFVRlVRU3hUUVVGVE8xRkJRMWdzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGU0N4TlFVRk5MRU5CUVVOSUxHVkJRV1U3U1VGRGVFSXNRMEZCUXp0QlFVTklMRU5CUVVNN1FVRkZSR01zVFVGQlRTeERRVUZEUXl4TlFVRk5MRU5CUVVOb1FpeFRRVUZUTEVWQlFVVXNRMEZCUXp0SlFVTjRRa3dzVjBGQlZ5eEZRVUZZUVN4WFFVRlhPMGxCUTFoRkxGbEJRVmtzUlVGQldrRXNXVUZCV1R0QlFVTmtMRU5CUVVNc1EwRkJReXhEUVVGRE8yVkJSVmxITEZOQlFWTTdNRUpCTTBSNFFqdEJRVFpFUVdsQ0xGVkJRVkVzVlVGQlEwTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJVRU1zVDBGQlR5eEZRVUZMTEVOQlFVTTdTVUZETjBKS0xFMUJRVTBzUTBGQlEwc3NZMEZCWXl4RFFVRkRjRUlzVTBGQlV5eEZRVUZGYlVJc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRGVrTkZMRWRCUVVjc1JVRkJSU3hSUVVGUk8yMUNRVUZHTEZGQlFWRXNSMEZCUnl4RFFVRkRPMmRDUVVOeVFpeEhRVUZMTEVOQlFVTnVRaXhKUVVGSkxEaENRVUZQUXl4VFFVRlRMRWRCUTNCQ1F5eFRRVUZUTEVkQlFVZFlMR2xDUVVGcFFqdG5Ra0ZGYmtOTExHRkJRV0VzUTBGQlEwa3NTVUZCU1N4RlFVRkZSU3hUUVVGVExFTkJRVU1zUTBGQlF6dG5Ra0ZGTDBJc1IwRkJTeXhEUVVGRFZTeFJRVUZSTEVkQlFVY3NVVUZCVVN4RFFVRlFTQ3hWUVVGVkxFVkJRVXNzUTBGQlF6dHZRa0ZEYUVOQkxGVkJRVlVzUjBGQlIwVXNNa0pCUVRKQ0xFTkJRVU5VTEZOQlFWTXNSVUZCUlU4c1ZVRkJWU3hEUVVGRExFTkJRVU03YjBKQlJXaEZMRTFCUVUwc1EwRkJRMWNzUzBGQlN5eFBRVUZEUXl4aFFVRmhMRU5CUVVOS0xFOUJRVThzUlVGQlJWSXNWVUZCVlR0blFrRkRhRVFzUTBGQlF6dG5Ra0ZGUkVrc1RVRkJUU3hEUVVGRFF5eE5RVUZOTEVOQlFVTkdMRkZCUVZFc1JVRkJSU3hEUVVGRE8yOUNRVU4yUWxZc1UwRkJVeXhGUVVGVVFTeFRRVUZUTzJkQ1FVTllMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVVZJTEUxQlFVMHNRMEZCUTFVc1VVRkJVVHRaUVVOcVFpeERRVUZET3p0SlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMHdzUTBGQlF5eERRVUZETEVOQlFVTTdVMEZGVFVRc01rSkJRVEpDTEVOQlFVTlVMRk5CUVZNc1JVRkJSVThzVlVGQlZTeEZRVUZGTEVOQlFVTTdTVUZETTBSQkxGVkJRVlVzUjBGQlIwRXNWVUZCVlN4RFFVRkRZU3hqUVVGakxFTkJRVU5ETEZWQlFWVXNaVUZCU1dRc1ZVRkJWU3h4UWtGQlVVRXNWVUZCVlR0UlFVRkZVQ3hUUVVGVExFVkJRVlJCTEZOQlFWTTdUVUZCUlN4RFFVRkRMRU5CUVVNc1JVRkJSeXhCUVVGSUxFTkJRVWM3U1VGRmJrY3NUVUZCVFN4RFFVRkRUeXhWUVVGVk8wRkJRMjVDTEVOQlFVTWlmUT09IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCIuL3dpdGhTdHlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFU0NBUEVfS0VZX1NUT1BTX0RSQUdHSU5HX09QVElPTiA9IFwiRVNDQVBFX0tFWV9TVE9QU19EUkFHR0lOR1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEVTQ0FQRV9LRVlfU1RPUFNfRFJBR0dJTkdfT1BUSU9OXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgUm93RGl2IGV4dGVuZHMgRWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInJvd1wiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShSb3dEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZ3JvdzogMTtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmNsYXNzIFJvd3NEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwicm93c1wiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShSb3dzRGl2KWBcblxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWdyb3c6IDE7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBDb2x1bW5EaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29sdW1uXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKENvbHVtbkRpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgQ29sdW1uc0RpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb2x1bW5zXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKENvbHVtbnNEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZ3JvdzogMTtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmNsYXNzIFNpemVhYmxlRGl2IGV4dGVuZHMgRWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInNpemVhYmxlXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFNpemVhYmxlRGl2KWBcblxuICBkaXNwbGF5OiBmbGV4O1xuICBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBBVVRPID0gXCJhdXRvXCI7XG5leHBvcnQgY29uc3QgQ1VSU09SID0gXCJjdXJzb3JcIjtcbmV4cG9ydCBjb25zdCBDT0xfUkVTSVpFID0gXCJjb2wtcmVzaXplXCI7XG5leHBvcnQgY29uc3QgUk9XX1JFU0laRSA9IFwicm93LXJlc2l6ZVwiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRV9LRVlfQ09ERSA9IDI3O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBCb2R5IH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IHsgQVVUTywgQ1VSU09SLCBDT0xfUkVTSVpFLCBST1dfUkVTSVpFIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IGJvZHkgPSBuZXcgQm9keSgpO1xuXG5sZXQgcHJldmlvdXNDdXJzb3I7ICAvLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtblJlc2l6ZUN1cnNvcigpIHtcbiAgY29uc3QgY3VycmVudEN1cnNvciA9IGdldEN1cnJlbnRDdXJzb3IoKTtcblxuICBpZiAoY3VycmVudEN1cnNvciAhPT0gQ09MX1JFU0laRSkge1xuICAgIHByZXZpb3VzQ3Vyc29yID0gY3VycmVudEN1cnNvcjtcblxuICAgIHNldEN1cnNvcihDT0xfUkVTSVpFKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm93UmVzaXplQ3Vyc29yKCkge1xuICBjb25zdCBjdXJyZW50Q3Vyc29yID0gZ2V0Q3VycmVudEN1cnNvcigpO1xuXG4gIGlmIChjdXJyZW50Q3Vyc29yICE9PSBST1dfUkVTSVpFKSB7XG4gICAgcHJldmlvdXNDdXJzb3IgPSBjdXJyZW50Q3Vyc29yO1xuXG4gICAgc2V0Q3Vyc29yKFJPV19SRVNJWkUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEN1cnNvcigpIHtcbiAgc2V0Q3Vyc29yKHByZXZpb3VzQ3Vyc29yKTsgLy8vXG59XG5cbmZ1bmN0aW9uIHNldEN1cnNvcihjdXJzb3IpIHtcbiAgY29uc3QgY3NzID0ge1xuICAgIGN1cnNvclxuICB9O1xuXG4gIGJvZHkuY3NzKGNzcyk7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnJlbnRDdXJzb3IgPSBib2R5LmNzcyhDVVJTT1IpIHx8IEFVVE87XG5cbiAgcmV0dXJuIGN1cnJlbnRDdXJzb3I7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2Vhc3lXaXRoU3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJlYXN5LXdpdGgtc3R5bGVcIikpO1xudmFyIF9lYXN5ID0gcmVxdWlyZShcImVhc3lcIik7XG52YXIgX3NpemVhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGl2L3NpemVhYmxlXCIpKTtcbnZhciBfY3Vyc29yID0gcmVxdWlyZShcIi4uL2N1cnNvclwiKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBfb3B0aW9ucyA9IHJlcXVpcmUoXCIuLi9vcHRpb25zXCIpO1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gW1xuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodCAhPSBudWxsICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXSkge1xuICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywge1xuICAgICAgICByYXc6IHtcbiAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgICAgfVxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG4gICAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcbiAgICAgICAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuICAgIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gICAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcbiAgICAgICAgXCJcXG5cXG4gIGZsZXgtc2hyaW5rOiAwO1xcblxcblwiXG4gICAgXSk7XG4gICAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xufVxudmFyIEJMVVJfRVZFTlRfVFlQRSA9IF9lYXN5LmV2ZW50VHlwZXMuQkxVUl9FVkVOVF9UWVBFLCBEUkFHX0VWRU5UX1RZUEUgPSBfZWFzeS5ldmVudFR5cGVzLkRSQUdfRVZFTlRfVFlQRSwgTU9VU0VVUF9FVkVOVF9UWVBFID0gX2Vhc3kuZXZlbnRUeXBlcy5NT1VTRVVQX0VWRU5UX1RZUEUsIFNUT1BfRFJBR19FVkVOVF9UWVBFID0gX2Vhc3kuZXZlbnRUeXBlcy5TVE9QX0RSQUdfRVZFTlRfVFlQRSwgU1RBUlRfRFJBR19FVkVOVF9UWVBFID0gX2Vhc3kuZXZlbnRUeXBlcy5TVEFSVF9EUkFHX0VWRU5UX1RZUEU7XG52YXIgU3BsaXR0ZXJEaXYgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKEVsZW1lbnQpIHtcbiAgICBfaW5oZXJpdHMoU3BsaXR0ZXJEaXYsIEVsZW1lbnQpO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU3BsaXR0ZXJEaXYpO1xuICAgIGZ1bmN0aW9uIFNwbGl0dGVyRGl2KHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGxpdHRlckRpdik7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhTcGxpdHRlckRpdiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaXNPcHRpb25QcmVzZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcHRpb25QcmVzZW50KG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25QcmVzZW50ID0gISF0aGlzLm9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uUHJlc2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2V0T3B0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInVuc2V0T3B0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZXRPcHRpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib25EcmFnXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGRyYWdIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IERSQUdfRVZFTlRfVFlQRSwgaGFuZGxlciA9IGRyYWdIYW5kbGVyOyAvLy9cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9mZkRyYWdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZmZEcmFnKGRyYWdIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IERSQUdfRVZFTlRfVFlQRSwgaGFuZGxlciA9IGRyYWdIYW5kbGVyOyAvLy9cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9uU3RvcERyYWdcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblN0b3BEcmFnKHN0b3BEcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBTVE9QX0RSQUdfRVZFTlRfVFlQRSwgaGFuZGxlciA9IHN0b3BEcmFnSGFuZGxlcjsgLy8vXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvZmZTdG9wRHJhZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9mZlN0b3BEcmFnKHN0b3BEcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBTVE9QX0RSQUdfRVZFTlRfVFlQRSwgaGFuZGxlciA9IHN0b3BEcmFnSGFuZGxlcjsgLy8vXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvblN0YXJ0RHJhZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3RhcnREcmFnKHN0b3BEcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBTVEFSVF9EUkFHX0VWRU5UX1RZUEUsIGhhbmRsZXIgPSBzdG9wRHJhZ0hhbmRsZXI7IC8vL1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib2ZmU3RhcnREcmFnXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmU3RhcnREcmFnKHN0b3BEcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBTVEFSVF9EUkFHX0VWRU5UX1RZUEUsIGhhbmRsZXIgPSBzdG9wRHJhZ0hhbmRsZXI7IC8vL1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2FsbEhhbmRsZXJzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbEhhbmRsZXJzKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmluZ0FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmZpbmRFdmVudExpc3RlbmVycyhldmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2hhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZXZlbnRMaXN0ZW5lci5oYW5kbGVyLCBoYW5kbGVyRWxlbWVudCA9IGV2ZW50TGlzdGVuZXIuZWxlbWVudCwgZWxlbWVudCA9IF90aGlzOyAvLy9cbiAgICAgICAgICAgICAgICAgICAgKF9oYW5kbGVyID0gaGFuZGxlcikuY2FsbC5hcHBseShfaGFuZGxlciwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlbWFpbmluZ0FyZ3VtZW50cyksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZW5hYmxlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImRpc2FibGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImlzRGlzYWJsZWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IHRoaXMuaGFzQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc0RyYWdnaW5nXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmhhc0NsYXNzKFwiZHJhZ2dpbmdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYWdnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0RGlyZWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdFbGVtZW50KCksIHByZXZpb3VzU2libGluZ0VsZW1lbnQgPSB0aGlzLmdldFByZXZpb3VzU2libGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YobmV4dFNpYmxpbmdFbGVtZW50LCBfc2l6ZWFibGUuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZihwcmV2aW91c1NpYmxpbmdFbGVtZW50LCBfc2l6ZWFibGUuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRTaXplYWJsZURpdlwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemVhYmxlRGl2KCkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplYWJsZURpdjtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXROZXh0U2libGluZ0VsZW1lbnQoKSwgcHJldmlvdXNTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZihuZXh0U2libGluZ0VsZW1lbnQsIF9zaXplYWJsZS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplYWJsZURpdiA9IG5leHRTaWJsaW5nRWxlbWVudDsgLy8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZihwcmV2aW91c1NpYmxpbmdFbGVtZW50LCBfc2l6ZWFibGUuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZWFibGVEaXYgPSBwcmV2aW91c1NpYmxpbmdFbGVtZW50OyAvLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemVhYmxlRGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic3RhcnREcmFnXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnREcmFnKCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBTVEFSVF9EUkFHX0VWRU5UX1RZUEUsIGVzY2FwZUtleVN0b3BzRHJhZ2dpbmdPcHRpb25QcmVzZW50ID0gdGhpcy5pc09wdGlvblByZXNlbnQoX29wdGlvbnMuRVNDQVBFX0tFWV9TVE9QU19EUkFHR0lOR19PUFRJT04pO1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVLZXlTdG9wc0RyYWdnaW5nT3B0aW9uUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgICBfZWFzeS53aW5kb3cub25LZXlEb3duKHRoaXMua2V5RG93bkhhbmRsZXIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsYXNzKFwiZHJhZ2dpbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsSGFuZGxlcnMoZXZlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInN0b3BEcmFnXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcERyYWcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFNUT1BfRFJBR19FVkVOVF9UWVBFLCBlc2NhcGVLZXlTdG9wc0RyYWdnaW5nT3B0aW9uUHJlc2VudCA9IHRoaXMuaXNPcHRpb25QcmVzZW50KF9vcHRpb25zLkVTQ0FQRV9LRVlfU1RPUFNfRFJBR0dJTkdfT1BUSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlS2V5U3RvcHNEcmFnZ2luZ09wdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Vhc3kud2luZG93Lm9mZktleURvd24odGhpcy5rZXlEb3duSGFuZGxlciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxIYW5kbGVycyhldmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibW91c2VVcEhhbmRsZXJcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZVVwSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wRHJhZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICgwLCBfY3Vyc29yKS5yZXNldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1vdXNlT3V0SGFuZGxlclwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfY3Vyc29yKS5yZXNldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwia2V5RG93bkhhbmRsZXJcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlEb3duSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gX2NvbnN0YW50cy5FU0NBUEVfS0VZX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wRHJhZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICgwLCBfY3Vyc29yKS5yZXNldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImRpZE1vdW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlkTW91bnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzLCBvbkRyYWcgPSBfcHJvcGVydGllcy5vbkRyYWcsIG9uU3RvcERyYWcgPSBfcHJvcGVydGllcy5vblN0b3BEcmFnLCBvblN0YXJ0RHJhZyA9IF9wcm9wZXJ0aWVzLm9uU3RhcnREcmFnLCBkaXNhYmxlZCA9IF9wcm9wZXJ0aWVzLmRpc2FibGVkLCBkcmFnSGFuZGxlciA9IG9uRHJhZywgc3RvcERyYWdIYW5kbGVyID0gb25TdG9wRHJhZywgc3RhcnREcmFnSGFuZGxlciA9IG9uU3RhcnREcmFnOyAvLy9cbiAgICAgICAgICAgICAgICBkaXNhYmxlZCA9PT0gdHJ1ZSA/IHRoaXMuZGlzYWJsZSgpIDogdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICBkcmFnSGFuZGxlciAmJiB0aGlzLm9uRHJhZyhkcmFnSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgc3RvcERyYWdIYW5kbGVyICYmIHRoaXMub25TdG9wRHJhZyhzdG9wRHJhZ0hhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZ0hhbmRsZXIgJiYgdGhpcy5vblN0YXJ0RHJhZyhzdGFydERyYWdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfZWFzeS53aW5kb3cub24oXCJcIi5jb25jYXQoQkxVUl9FVkVOVF9UWVBFLCBcIiBcIikuY29uY2F0KE1PVVNFVVBfRVZFTlRfVFlQRSksIHRoaXMubW91c2VVcEhhbmRsZXIsIHRoaXMpOyAvLy9cbiAgICAgICAgICAgICAgICBfZWFzeS53aW5kb3cub25Nb3VzZU1vdmUodGhpcy5tb3VzZU1vdmVIYW5kbGVyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VEb3duKHRoaXMubW91c2VEb3duSGFuZGxlciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlT3Zlcih0aGlzLm1vdXNlT3ZlckhhbmRsZXIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU91dCh0aGlzLm1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ3aWxsVW5tb3VudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcywgb25EcmFnID0gX3Byb3BlcnRpZXMub25EcmFnLCBvblN0b3BEcmFnID0gX3Byb3BlcnRpZXMub25TdG9wRHJhZywgb25TdGFydERyYWcgPSBfcHJvcGVydGllcy5vblN0YXJ0RHJhZywgZHJhZ0hhbmRsZXIgPSBvbkRyYWcsIHN0b3BEcmFnSGFuZGxlciA9IG9uU3RvcERyYWcsIHN0YXJ0RHJhZ0hhbmRsZXIgPSBvblN0YXJ0RHJhZzsgLy8vXG4gICAgICAgICAgICAgICAgZHJhZ0hhbmRsZXIgJiYgdGhpcy5vZmZEcmFnKGRyYWdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBzdG9wRHJhZ0hhbmRsZXIgJiYgdGhpcy5vZmZTdG9wRHJhZyhzdG9wRHJhZ0hhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZ0hhbmRsZXIgJiYgdGhpcy5vZmZTdGFydERyYWcoc3RhcnREcmFnSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX2Vhc3kud2luZG93Lm9mZihcIlwiLmNvbmNhdChCTFVSX0VWRU5UX1RZUEUsIFwiIFwiKS5jb25jYXQoTU9VU0VVUF9FVkVOVF9UWVBFKSwgdGhpcy5tb3VzZVVwSGFuZGxlciwgdGhpcyk7IC8vL1xuICAgICAgICAgICAgICAgIF9lYXN5LndpbmRvdy5vZmZNb3VzZU1vdmUodGhpcy5tb3VzZU1vdmVIYW5kbGVyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZk1vdXNlRG93bih0aGlzLm1vdXNlRG93bkhhbmRsZXIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmTW91c2VPdmVyKHRoaXMubW91c2VPdmVySGFuZGxlciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZNb3VzZU91dCh0aGlzLm1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpbml0aWFsaXNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbUNsYXNzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUNsYXNzKENsYXNzLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRpb25zMSA9IHByb3BlcnRpZXMub3B0aW9ucywgb3B0aW9ucyA9IF9vcHRpb25zMSA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uczEsIHNwbGl0dGVyRGl2ID0gX2Vhc3kuRWxlbWVudC5mcm9tQ2xhc3MoQ2xhc3MsIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGxpdHRlckRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBTcGxpdHRlckRpdjtcbn0oX3dyYXBOYXRpdmVTdXBlcihfZWFzeS5FbGVtZW50KSk7XG5fZGVmaW5lUHJvcGVydHkoU3BsaXR0ZXJEaXYsIFwidGFnTmFtZVwiLCBcImRpdlwiKTtcbl9kZWZpbmVQcm9wZXJ0eShTcGxpdHRlckRpdiwgXCJkZWZhdWx0UHJvcGVydGllc1wiLCB7XG4gICAgY2xhc3NOYW1lOiBcInNwbGl0dGVyXCJcbn0pO1xuX2RlZmluZVByb3BlcnR5KFNwbGl0dGVyRGl2LCBcImlnbm9yZWRQcm9wZXJ0aWVzXCIsIFtcbiAgICBcIm9uRHJhZ1wiLFxuICAgIFwib3B0aW9uc1wiLFxuICAgIFwiZGlzYWJsZWRcIixcbiAgICBcIm9uU3RvcERyYWdcIixcbiAgICBcIm9uU3RhcnREcmFnXCJcbl0pO1xudmFyIF9kZWZhdWx0ID0gKDAsIF9lYXN5V2l0aFN0eWxlKS5kZWZhdWx0KFNwbGl0dGVyRGl2KShfdGVtcGxhdGVPYmplY3QoKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a2FYWXZjM0JzYVhSMFpYSXVhbk1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2JtbHRjRzl5ZENCM2FYUm9VM1I1YkdVZ1puSnZiU0JjSW1WaGMza3RkMmwwYUMxemRIbHNaVndpT3lBZ0x5OHZYRzVjYm1sdGNHOXlkQ0I3SUhkcGJtUnZkeXdnUld4bGJXVnVkQ3dnWlhabGJuUlVlWEJsY3lCOUlHWnliMjBnWENKbFlYTjVYQ0k3WEc1Y2JtbHRjRzl5ZENCVGFYcGxZV0pzWlVScGRpQm1jbTl0SUZ3aUxpNHZaR2wyTDNOcGVtVmhZbXhsWENJN1hHNWNibWx0Y0c5eWRDQjdJSEpsYzJWMFEzVnljMjl5SUgwZ1puSnZiU0JjSWk0dUwyTjFjbk52Y2x3aU8xeHVhVzF3YjNKMElIc2dSVk5EUVZCRlgwdEZXVjlEVDBSRklIMGdabkp2YlNCY0lpNHVMMk52Ym5OMFlXNTBjMXdpTzF4dWFXMXdiM0owSUhzZ1JWTkRRVkJGWDB0RldWOVRWRTlRVTE5RVVrRkhSMGxPUjE5UFVGUkpUMDRnZlNCbWNtOXRJRndpTGk0dmIzQjBhVzl1YzF3aU8xeHVYRzVqYjI1emRDQjdJRUpNVlZKZlJWWkZUbFJmVkZsUVJTd2dSRkpCUjE5RlZrVk9WRjlVV1ZCRkxDQk5UMVZUUlZWUVgwVldSVTVVWDFSWlVFVXNJRk5VVDFCZlJGSkJSMTlGVmtWT1ZGOVVXVkJGTENCVFZFRlNWRjlFVWtGSFgwVldSVTVVWDFSWlVFVWdmU0E5SUdWMlpXNTBWSGx3WlhNN1hHNWNibU5zWVhOeklGTndiR2wwZEdWeVJHbDJJR1Y0ZEdWdVpITWdSV3hsYldWdWRDQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtITmxiR1ZqZEc5eUxDQnZjSFJwYjI1ektTQjdYRzRnSUNBZ2MzVndaWElvYzJWc1pXTjBiM0lwTzF4dVhHNGdJQ0FnZEdocGN5NXZjSFJwYjI1eklEMGdiM0IwYVc5dWN6dGNiaUFnZlZ4dVhHNGdJR2x6VDNCMGFXOXVVSEpsYzJWdWRDaHZjSFJwYjI0cElIdGNiaUFnSUNCamIyNXpkQ0J2Y0hScGIyNVFjbVZ6Wlc1MElEMGdJU0YwYUdsekxtOXdkR2x2Ym5OYmIzQjBhVzl1WFR0Y2JseHVJQ0FnSUhKbGRIVnliaUJ2Y0hScGIyNVFjbVZ6Wlc1ME8xeHVJQ0I5WEc1Y2JpQWdjMlYwVDNCMGFXOXVjeWh2Y0hScGIyNXpLU0I3WEc0Z0lDQWdkR2hwY3k1dmNIUnBiMjV6SUQwZ2IzQjBhVzl1Y3p0Y2JpQWdmVnh1WEc0Z0lITmxkRTl3ZEdsdmJpaHZjSFJwYjI0cElIdGNiaUFnSUNCMGFHbHpMbTl3ZEdsdmJuTmJiM0IwYVc5dVhTQTlJSFJ5ZFdVN1hHNGdJSDFjYmx4dUlDQjFibk5sZEU5d2RHbHZiaWh2Y0hScGIyNHBJSHRjYmlBZ0lDQmtaV3hsZEdVb2RHaHBjeTV2Y0hScGIyNXpXMjl3ZEdsdmJsMHBPMXh1SUNCOVhHNWNiaUFnYjI1RWNtRm5LR1J5WVdkSVlXNWtiR1Z5TENCbGJHVnRaVzUwS1NCN1hHNGdJQ0FnWTI5dWMzUWdaWFpsYm5SVWVYQmxJRDBnUkZKQlIxOUZWa1ZPVkY5VVdWQkZMRnh1SUNBZ0lDQWdJQ0FnSUdoaGJtUnNaWElnUFNCa2NtRm5TR0Z1Wkd4bGNqc2dJQzh2TDF4dVhHNGdJQ0FnZEdocGN5NWhaR1JGZG1WdWRFeHBjM1JsYm1WeUtHVjJaVzUwVkhsd1pTd2dhR0Z1Wkd4bGNpd2daV3hsYldWdWRDazdYRzRnSUgxY2JseHVJQ0J2Wm1aRWNtRm5LR1J5WVdkSVlXNWtiR1Z5TENCbGJHVnRaVzUwS1NCN1hHNGdJQ0FnWTI5dWMzUWdaWFpsYm5SVWVYQmxJRDBnUkZKQlIxOUZWa1ZPVkY5VVdWQkZMRnh1SUNBZ0lDQWdJQ0FnSUdoaGJtUnNaWElnUFNCa2NtRm5TR0Z1Wkd4bGNqc2dJQzh2TDF4dVhHNGdJQ0FnZEdocGN5NXlaVzF2ZG1WRmRtVnVkRXhwYzNSbGJtVnlLR1YyWlc1MFZIbHdaU3dnYUdGdVpHeGxjaXdnWld4bGJXVnVkQ2s3WEc0Z0lIMWNibHh1SUNCdmJsTjBiM0JFY21GbktITjBiM0JFY21GblNHRnVaR3hsY2l3Z1pXeGxiV1Z1ZENrZ2UxeHVJQ0FnSUdOdmJuTjBJR1YyWlc1MFZIbHdaU0E5SUZOVVQxQmZSRkpCUjE5RlZrVk9WRjlVV1ZCRkxGeHVJQ0FnSUNBZ0lDQWdJR2hoYm1Sc1pYSWdQU0J6ZEc5d1JISmhaMGhoYm1Sc1pYSTdJQ0F2THk5Y2JseHVJQ0FnSUhSb2FYTXVZV1JrUlhabGJuUk1hWE4wWlc1bGNpaGxkbVZ1ZEZSNWNHVXNJR2hoYm1Sc1pYSXNJR1ZzWlcxbGJuUXBPMXh1SUNCOVhHNWNiaUFnYjJabVUzUnZjRVJ5WVdjb2MzUnZjRVJ5WVdkSVlXNWtiR1Z5TENCbGJHVnRaVzUwS1NCN1hHNGdJQ0FnWTI5dWMzUWdaWFpsYm5SVWVYQmxJRDBnVTFSUFVGOUVVa0ZIWDBWV1JVNVVYMVJaVUVVc1hHNGdJQ0FnSUNBZ0lDQWdhR0Z1Wkd4bGNpQTlJSE4wYjNCRWNtRm5TR0Z1Wkd4bGNqc2dJQzh2TDF4dVhHNGdJQ0FnZEdocGN5NXlaVzF2ZG1WRmRtVnVkRXhwYzNSbGJtVnlLR1YyWlc1MFZIbHdaU3dnYUdGdVpHeGxjaXdnWld4bGJXVnVkQ2s3WEc0Z0lIMWNibHh1SUNCdmJsTjBZWEowUkhKaFp5aHpkRzl3UkhKaFowaGhibVJzWlhJc0lHVnNaVzFsYm5RcElIdGNiaUFnSUNCamIyNXpkQ0JsZG1WdWRGUjVjR1VnUFNCVFZFRlNWRjlFVWtGSFgwVldSVTVVWDFSWlVFVXNYRzRnSUNBZ0lDQWdJQ0FnYUdGdVpHeGxjaUE5SUhOMGIzQkVjbUZuU0dGdVpHeGxjanNnSUM4dkwxeHVYRzRnSUNBZ2RHaHBjeTVoWkdSRmRtVnVkRXhwYzNSbGJtVnlLR1YyWlc1MFZIbHdaU3dnYUdGdVpHeGxjaXdnWld4bGJXVnVkQ2s3WEc0Z0lIMWNibHh1SUNCdlptWlRkR0Z5ZEVSeVlXY29jM1J2Y0VSeVlXZElZVzVrYkdWeUxDQmxiR1Z0Wlc1MEtTQjdYRzRnSUNBZ1kyOXVjM1FnWlhabGJuUlVlWEJsSUQwZ1UxUkJVbFJmUkZKQlIxOUZWa1ZPVkY5VVdWQkZMRnh1SUNBZ0lDQWdJQ0FnSUdoaGJtUnNaWElnUFNCemRHOXdSSEpoWjBoaGJtUnNaWEk3SUNBdkx5OWNibHh1SUNBZ0lIUm9hWE11Y21WdGIzWmxSWFpsYm5STWFYTjBaVzVsY2lobGRtVnVkRlI1Y0dVc0lHaGhibVJzWlhJc0lHVnNaVzFsYm5RcE8xeHVJQ0I5WEc1Y2JpQWdZMkZzYkVoaGJtUnNaWEp6S0dWMlpXNTBWSGx3WlN3Z0xpNHVjbVZ0WVdsdWFXNW5RWEpuZFcxbGJuUnpLU0I3WEc0Z0lDQWdZMjl1YzNRZ1pYWmxiblJNYVhOMFpXNWxjbk1nUFNCMGFHbHpMbVpwYm1SRmRtVnVkRXhwYzNSbGJtVnljeWhsZG1WdWRGUjVjR1VwTzF4dVhHNGdJQ0FnWlhabGJuUk1hWE4wWlc1bGNuTXVabTl5UldGamFDZ29aWFpsYm5STWFYTjBaVzVsY2lrZ1BUNGdlMXh1SUNBZ0lDQWdZMjl1YzNRZ2V5Qm9ZVzVrYkdWeUxDQmxiR1Z0Wlc1ME9pQm9ZVzVrYkdWeVJXeGxiV1Z1ZENCOUlEMGdaWFpsYm5STWFYTjBaVzVsY2l4Y2JpQWdJQ0FnSUNBZ0lDQWdJR1ZzWlcxbGJuUWdQU0IwYUdsek95QXZMeTljYmx4dUlDQWdJQ0FnYUdGdVpHeGxjaTVqWVd4c0tHaGhibVJzWlhKRmJHVnRaVzUwTENBdUxpNXlaVzFoYVc1cGJtZEJjbWQxYldWdWRITXNJR1ZzWlcxbGJuUXBPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNWNiaUFnWlc1aFlteGxLQ2tnZTF4dUlDQWdJSFJvYVhNdWNtVnRiM1psUTJ4aGMzTW9YQ0prYVhOaFlteGxaRndpS1R0Y2JpQWdmVnh1WEc0Z0lHUnBjMkZpYkdVb0tTQjdYRzRnSUNBZ2RHaHBjeTVoWkdSRGJHRnpjeWhjSW1ScGMyRmliR1ZrWENJcE8xeHVJQ0I5WEc1Y2JpQWdhWE5FYVhOaFlteGxaQ2dwSUh0Y2JpQWdJQ0JqYjI1emRDQmthWE5oWW14bFpDQTlJSFJvYVhNdWFHRnpRMnhoYzNNb1hDSmthWE5oWW14bFpGd2lLVHRjYmlBZ0lDQmNiaUFnSUNCeVpYUjFjbTRnWkdsellXSnNaV1E3WEc0Z0lIMWNibHh1SUNCcGMwUnlZV2RuYVc1bktDa2dlMXh1SUNBZ0lHTnZibk4wSUdSeVlXZG5hVzVuSUQwZ2RHaHBjeTVvWVhORGJHRnpjeWhjSW1SeVlXZG5hVzVuWENJcE8xeHVJQ0FnSUZ4dUlDQWdJSEpsZEhWeWJpQmtjbUZuWjJsdVp6dGNiaUFnZlZ4dUlDQmNiaUFnWjJWMFJHbHlaV04wYVc5dUtDa2dlMXh1SUNBZ0lHeGxkQ0JrYVhKbFkzUnBiMjQ3WEc1Y2JpQWdJQ0JqYjI1emRDQnVaWGgwVTJsaWJHbHVaMFZzWlcxbGJuUWdQU0IwYUdsekxtZGxkRTVsZUhSVGFXSnNhVzVuUld4bGJXVnVkQ2dwTEZ4dUlDQWdJQ0FnSUNBZ0lIQnlaWFpwYjNWelUybGliR2x1WjBWc1pXMWxiblFnUFNCMGFHbHpMbWRsZEZCeVpYWnBiM1Z6VTJsaWJHbHVaMFZzWlcxbGJuUW9LVHRjYmx4dUlDQWdJR2xtSUNodVpYaDBVMmxpYkdsdVowVnNaVzFsYm5RZ2FXNXpkR0Z1WTJWdlppQlRhWHBsWVdKc1pVUnBkaWtnZTF4dUlDQWdJQ0FnWkdseVpXTjBhVzl1SUQwZ0t6RTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLSEJ5WlhacGIzVnpVMmxpYkdsdVowVnNaVzFsYm5RZ2FXNXpkR0Z1WTJWdlppQlRhWHBsWVdKc1pVUnBkaWtnZTF4dUlDQWdJQ0FnWkdseVpXTjBhVzl1SUQwZ0xURTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUdScGNtVmpkR2x2Ymp0Y2JpQWdmVnh1WEc0Z0lHZGxkRk5wZW1WaFlteGxSR2wyS0NrZ2UxeHVJQ0FnSUd4bGRDQnphWHBsWVdKc1pVUnBkanRjYmx4dUlDQWdJR052Ym5OMElHNWxlSFJUYVdKc2FXNW5SV3hsYldWdWRDQTlJSFJvYVhNdVoyVjBUbVY0ZEZOcFlteHBibWRGYkdWdFpXNTBLQ2tzWEc0Z0lDQWdJQ0FnSUNBZ2NISmxkbWx2ZFhOVGFXSnNhVzVuUld4bGJXVnVkQ0E5SUhSb2FYTXVaMlYwVUhKbGRtbHZkWE5UYVdKc2FXNW5SV3hsYldWdWRDZ3BPMXh1WEc0Z0lDQWdhV1lnS0c1bGVIUlRhV0pzYVc1blJXeGxiV1Z1ZENCcGJuTjBZVzVqWlc5bUlGTnBlbVZoWW14bFJHbDJLU0I3WEc0Z0lDQWdJQ0J6YVhwbFlXSnNaVVJwZGlBOUlHNWxlSFJUYVdKc2FXNW5SV3hsYldWdWREc2dMeTh2WEc0Z0lDQWdmVnh1WEc0Z0lDQWdhV1lnS0hCeVpYWnBiM1Z6VTJsaWJHbHVaMFZzWlcxbGJuUWdhVzV6ZEdGdVkyVnZaaUJUYVhwbFlXSnNaVVJwZGlrZ2UxeHVJQ0FnSUNBZ2MybDZaV0ZpYkdWRWFYWWdQU0J3Y21WMmFXOTFjMU5wWW14cGJtZEZiR1Z0Wlc1ME95QXZMeTljYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200Z2MybDZaV0ZpYkdWRWFYWTdYRzRnSUgxY2JseHVJQ0J6ZEdGeWRFUnlZV2NvS1NCN1hHNGdJQ0FnWTI5dWMzUWdaWFpsYm5SVWVYQmxJRDBnVTFSQlVsUmZSRkpCUjE5RlZrVk9WRjlVV1ZCRkxGeHVJQ0FnSUNBZ0lDQWdJR1Z6WTJGd1pVdGxlVk4wYjNCelJISmhaMmRwYm1kUGNIUnBiMjVRY21WelpXNTBJRDBnZEdocGN5NXBjMDl3ZEdsdmJsQnlaWE5sYm5Rb1JWTkRRVkJGWDB0RldWOVRWRTlRVTE5RVVrRkhSMGxPUjE5UFVGUkpUMDRwTzF4dVhHNGdJQ0FnYVdZZ0tHVnpZMkZ3WlV0bGVWTjBiM0J6UkhKaFoyZHBibWRQY0hScGIyNVFjbVZ6Wlc1MEtTQjdYRzRnSUNBZ0lDQjNhVzVrYjNjdWIyNUxaWGxFYjNkdUtIUm9hWE11YTJWNVJHOTNia2hoYm1Sc1pYSXNJSFJvYVhNcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhSb2FYTXVZV1JrUTJ4aGMzTW9YQ0prY21GbloybHVaMXdpS1R0Y2JseHVJQ0FnSUhSb2FYTXVZMkZzYkVoaGJtUnNaWEp6S0dWMlpXNTBWSGx3WlNsY2JpQWdmVnh1WEc0Z0lITjBiM0JFY21GbktDa2dlMXh1SUNBZ0lHTnZibk4wSUdWMlpXNTBWSGx3WlNBOUlGTlVUMUJmUkZKQlIxOUZWa1ZPVkY5VVdWQkZMRnh1SUNBZ0lDQWdJQ0FnSUdWelkyRndaVXRsZVZOMGIzQnpSSEpoWjJkcGJtZFBjSFJwYjI1UWNtVnpaVzUwSUQwZ2RHaHBjeTVwYzA5d2RHbHZibEJ5WlhObGJuUW9SVk5EUVZCRlgwdEZXVjlUVkU5UVUxOUVVa0ZIUjBsT1IxOVBVRlJKVDA0cE8xeHVYRzRnSUNBZ2FXWWdLR1Z6WTJGd1pVdGxlVk4wYjNCelJISmhaMmRwYm1kUGNIUnBiMjVRY21WelpXNTBLU0I3WEc0Z0lDQWdJQ0IzYVc1a2IzY3ViMlptUzJWNVJHOTNiaWgwYUdsekxtdGxlVVJ2ZDI1SVlXNWtiR1Z5TENCMGFHbHpLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQjBhR2x6TG5KbGJXOTJaVU5zWVhOektGd2laSEpoWjJkcGJtZGNJaWs3WEc1Y2JpQWdJQ0IwYUdsekxtTmhiR3hJWVc1a2JHVnljeWhsZG1WdWRGUjVjR1VwTzF4dUlDQjlYRzVjYmlBZ2JXOTFjMlZWY0VoaGJtUnNaWElvWlhabGJuUXNJR1ZzWlcxbGJuUXBJSHRjYmlBZ0lDQmpiMjV6ZENCa2FYTmhZbXhsWkNBOUlIUm9hWE11YVhORWFYTmhZbXhsWkNncE8xeHVYRzRnSUNBZ2FXWWdLQ0ZrYVhOaFlteGxaQ2tnZTF4dUlDQWdJQ0FnWTI5dWMzUWdaSEpoWjJkcGJtY2dQU0IwYUdsekxtbHpSSEpoWjJkcGJtY29LVHRjYmx4dUlDQWdJQ0FnYVdZZ0tHUnlZV2RuYVc1bktTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWMzUnZjRVJ5WVdjb0tUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdjbVZ6WlhSRGRYSnpiM0lvS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCdGIzVnpaVTkxZEVoaGJtUnNaWElvWlhabGJuUXNJR1ZzWlcxbGJuUXBJSHRjYmlBZ0lDQmpiMjV6ZENCa2FYTmhZbXhsWkNBOUlIUm9hWE11YVhORWFYTmhZbXhsWkNncE8xeHVYRzRnSUNBZ2FXWWdLQ0ZrYVhOaFlteGxaQ2tnZTF4dUlDQWdJQ0FnWTI5dWMzUWdaSEpoWjJkcGJtY2dQU0IwYUdsekxtbHpSSEpoWjJkcGJtY29LVHRjYmx4dUlDQWdJQ0FnYVdZZ0tDRmtjbUZuWjJsdVp5a2dlMXh1SUNBZ0lDQWdJQ0J5WlhObGRFTjFjbk52Y2lncE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHdGxlVVJ2ZDI1SVlXNWtiR1Z5S0dWMlpXNTBMQ0JsYkdWdFpXNTBLU0I3WEc0Z0lDQWdZMjl1YzNRZ2V5QnJaWGxEYjJSbElIMGdQU0JsZG1WdWREdGNibHh1SUNBZ0lHbG1JQ2hyWlhsRGIyUmxJRDA5UFNCRlUwTkJVRVZmUzBWWlgwTlBSRVVwSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJR1J5WVdkbmFXNW5JRDBnZEdocGN5NXBjMFJ5WVdkbmFXNW5LQ2s3WEc1Y2JpQWdJQ0FnSUdsbUlDaGtjbUZuWjJsdVp5a2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuTjBiM0JFY21GbktDazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSEpsYzJWMFEzVnljMjl5S0NrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ1pHbGtUVzkxYm5Rb0tTQjdYRzRnSUNBZ1kyOXVjM1FnZXlCdmJrUnlZV2NzSUc5dVUzUnZjRVJ5WVdjc0lHOXVVM1JoY25SRWNtRm5MQ0JrYVhOaFlteGxaQ0I5SUQwZ2RHaHBjeTV3Y205d1pYSjBhV1Z6TEZ4dUlDQWdJQ0FnSUNBZ0lHUnlZV2RJWVc1a2JHVnlJRDBnYjI1RWNtRm5MQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnpkRzl3UkhKaFowaGhibVJzWlhJZ1BTQnZibE4wYjNCRWNtRm5MQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnpkR0Z5ZEVSeVlXZElZVzVrYkdWeUlEMGdiMjVUZEdGeWRFUnlZV2M3SUM4dkwxeHVYRzRnSUNBZ0tHUnBjMkZpYkdWa0lEMDlQU0IwY25WbEtTQS9JQzh2TDF4dUlDQWdJQ0FnZEdocGN5NWthWE5oWW14bEtDa2dPbHh1SUNBZ0lDQWdJQ0IwYUdsekxtVnVZV0pzWlNncE8xeHVYRzRnSUNBZ1pISmhaMGhoYm1Sc1pYSWdKaVlnZEdocGN5NXZia1J5WVdjb1pISmhaMGhoYm1Sc1pYSXBPMXh1SUNBZ0lITjBiM0JFY21GblNHRnVaR3hsY2lBbUppQjBhR2x6TG05dVUzUnZjRVJ5WVdjb2MzUnZjRVJ5WVdkSVlXNWtiR1Z5S1R0Y2JpQWdJQ0J6ZEdGeWRFUnlZV2RJWVc1a2JHVnlJQ1ltSUhSb2FYTXViMjVUZEdGeWRFUnlZV2NvYzNSaGNuUkVjbUZuU0dGdVpHeGxjaWs3WEc1Y2JpQWdJQ0IzYVc1a2IzY3ViMjRvWUNSN1FreFZVbDlGVmtWT1ZGOVVXVkJGZlNBa2UwMVBWVk5GVlZCZlJWWkZUbFJmVkZsUVJYMWdMQ0IwYUdsekxtMXZkWE5sVlhCSVlXNWtiR1Z5TENCMGFHbHpLVHNnSUM4dkwxeHVYRzRnSUNBZ2QybHVaRzkzTG05dVRXOTFjMlZOYjNabEtIUm9hWE11Ylc5MWMyVk5iM1psU0dGdVpHeGxjaXdnZEdocGN5azdYRzVjYmlBZ0lDQjBhR2x6TG05dVRXOTFjMlZFYjNkdUtIUm9hWE11Ylc5MWMyVkViM2R1U0dGdVpHeGxjaXdnZEdocGN5azdYRzRnSUNBZ2RHaHBjeTV2YmsxdmRYTmxUM1psY2loMGFHbHpMbTF2ZFhObFQzWmxja2hoYm1Sc1pYSXNJSFJvYVhNcE8xeHVJQ0FnSUhSb2FYTXViMjVOYjNWelpVOTFkQ2gwYUdsekxtMXZkWE5sVDNWMFNHRnVaR3hsY2l3Z2RHaHBjeWs3WEc0Z0lIMWNibHh1SUNCM2FXeHNWVzV0YjNWdWRDZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCN0lHOXVSSEpoWnl3Z2IyNVRkRzl3UkhKaFp5d2diMjVUZEdGeWRFUnlZV2NnZlNBOUlIUm9hWE11Y0hKdmNHVnlkR2xsY3l4Y2JpQWdJQ0FnSUNBZ0lDQmtjbUZuU0dGdVpHeGxjaUE5SUc5dVJISmhaeXdnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdjM1J2Y0VSeVlXZElZVzVrYkdWeUlEMGdiMjVUZEc5d1JISmhaeXdnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdjM1JoY25SRWNtRm5TR0Z1Wkd4bGNpQTlJRzl1VTNSaGNuUkVjbUZuT3lBdkx5OWNibHh1SUNBZ0lHUnlZV2RJWVc1a2JHVnlJQ1ltSUhSb2FYTXViMlptUkhKaFp5aGtjbUZuU0dGdVpHeGxjaWs3WEc0Z0lDQWdjM1J2Y0VSeVlXZElZVzVrYkdWeUlDWW1JSFJvYVhNdWIyWm1VM1J2Y0VSeVlXY29jM1J2Y0VSeVlXZElZVzVrYkdWeUtUdGNiaUFnSUNCemRHRnlkRVJ5WVdkSVlXNWtiR1Z5SUNZbUlIUm9hWE11YjJabVUzUmhjblJFY21GbktITjBZWEowUkhKaFowaGhibVJzWlhJcE8xeHVYRzRnSUNBZ2QybHVaRzkzTG05bVppaGdKSHRDVEZWU1gwVldSVTVVWDFSWlVFVjlJQ1I3VFU5VlUwVlZVRjlGVmtWT1ZGOVVXVkJGZldBc0lIUm9hWE11Ylc5MWMyVlZjRWhoYm1Sc1pYSXNJSFJvYVhNcE95QWdMeTh2WEc1Y2JpQWdJQ0IzYVc1a2IzY3ViMlptVFc5MWMyVk5iM1psS0hSb2FYTXViVzkxYzJWTmIzWmxTR0Z1Wkd4bGNpd2dkR2hwY3lrN1hHNWNiaUFnSUNCMGFHbHpMbTltWmsxdmRYTmxSRzkzYmloMGFHbHpMbTF2ZFhObFJHOTNia2hoYm1Sc1pYSXNJSFJvYVhNcE8xeHVJQ0FnSUhSb2FYTXViMlptVFc5MWMyVlBkbVZ5S0hSb2FYTXViVzkxYzJWUGRtVnlTR0Z1Wkd4bGNpd2dkR2hwY3lrN1hHNGdJQ0FnZEdocGN5NXZabVpOYjNWelpVOTFkQ2gwYUdsekxtMXZkWE5sVDNWMFNHRnVaR3hsY2l3Z2RHaHBjeWs3WEc0Z0lIMWNibHh1SUNCcGJtbDBhV0ZzYVhObEtDa2dlMXh1SUNBZ0lIUm9hWE11YzJWMFNXNXBkR2xoYkZOMFlYUmxLQ2s3WEc0Z0lIMWNibHh1SUNCemRHRjBhV01nZEdGblRtRnRaU0E5SUZ3aVpHbDJYQ0k3WEc1Y2JpQWdjM1JoZEdsaklHUmxabUYxYkhSUWNtOXdaWEowYVdWeklEMGdlMXh1SUNBZ0lHTnNZWE56VG1GdFpUb2dYQ0p6Y0d4cGRIUmxjbHdpWEc0Z0lIMDdYRzVjYmlBZ2MzUmhkR2xqSUdsbmJtOXlaV1JRY205d1pYSjBhV1Z6SUQwZ1cxeHVJQ0FnSUZ3aWIyNUVjbUZuWENJc1hHNGdJQ0FnWENKdmNIUnBiMjV6WENJc1hHNGdJQ0FnWENKa2FYTmhZbXhsWkZ3aUxGeHVJQ0FnSUZ3aWIyNVRkRzl3UkhKaFoxd2lMRnh1SUNBZ0lGd2liMjVUZEdGeWRFUnlZV2RjSWx4dUlDQmRPMXh1WEc0Z0lITjBZWFJwWXlCbWNtOXRRMnhoYzNNb1EyeGhjM01zSUhCeWIzQmxjblJwWlhNcElIdGNiaUFnSUNCamIyNXpkQ0I3SUc5d2RHbHZibk1nUFNCN2ZTQjlJRDBnY0hKdmNHVnlkR2xsY3l4Y2JpQWdJQ0FnSUNBZ0lDQnpjR3hwZEhSbGNrUnBkaUE5SUVWc1pXMWxiblF1Wm5KdmJVTnNZWE56S0VOc1lYTnpMQ0J3Y205d1pYSjBhV1Z6TENCdmNIUnBiMjV6S1R0Y2JseHVJQ0FnSUhKbGRIVnliaUJ6Y0d4cGRIUmxja1JwZGp0Y2JpQWdmVnh1ZlZ4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCM2FYUm9VM1I1YkdVb1UzQnNhWFIwWlhKRWFYWXBZRnh1WEc0Z0lHWnNaWGd0YzJoeWFXNXJPaUF3TzF4dVhHNWdPMXh1SWwwc0ltNWhiV1Z6SWpwYklrSk1WVkpmUlZaRlRsUmZWRmxRUlNJc0ltVjJaVzUwVkhsd1pYTWlMQ0pFVWtGSFgwVldSVTVVWDFSWlVFVWlMQ0pOVDFWVFJWVlFYMFZXUlU1VVgxUlpVRVVpTENKVFZFOVFYMFJTUVVkZlJWWkZUbFJmVkZsUVJTSXNJbE5VUVZKVVgwUlNRVWRmUlZaRlRsUmZWRmxRUlNJc0lsTndiR2wwZEdWeVJHbDJJaXdpYzJWc1pXTjBiM0lpTENKdmNIUnBiMjV6SWl3aWFYTlBjSFJwYjI1UWNtVnpaVzUwSWl3aWIzQjBhVzl1SWl3aWIzQjBhVzl1VUhKbGMyVnVkQ0lzSW5ObGRFOXdkR2x2Ym5NaUxDSnpaWFJQY0hScGIyNGlMQ0oxYm5ObGRFOXdkR2x2YmlJc0ltOXVSSEpoWnlJc0ltUnlZV2RJWVc1a2JHVnlJaXdpWld4bGJXVnVkQ0lzSW1WMlpXNTBWSGx3WlNJc0ltaGhibVJzWlhJaUxDSmhaR1JGZG1WdWRFeHBjM1JsYm1WeUlpd2liMlptUkhKaFp5SXNJbkpsYlc5MlpVVjJaVzUwVEdsemRHVnVaWElpTENKdmJsTjBiM0JFY21Gbklpd2ljM1J2Y0VSeVlXZElZVzVrYkdWeUlpd2liMlptVTNSdmNFUnlZV2NpTENKdmJsTjBZWEowUkhKaFp5SXNJbTltWmxOMFlYSjBSSEpoWnlJc0ltTmhiR3hJWVc1a2JHVnljeUlzSW5KbGJXRnBibWx1WjBGeVozVnRaVzUwY3lJc0ltVjJaVzUwVEdsemRHVnVaWEp6SWl3aVptbHVaRVYyWlc1MFRHbHpkR1Z1WlhKeklpd2labTl5UldGamFDSXNJbVYyWlc1MFRHbHpkR1Z1WlhJaUxDSm9ZVzVrYkdWeVJXeGxiV1Z1ZENJc0ltTmhiR3dpTENKbGJtRmliR1VpTENKeVpXMXZkbVZEYkdGemN5SXNJbVJwYzJGaWJHVWlMQ0poWkdSRGJHRnpjeUlzSW1selJHbHpZV0pzWldRaUxDSmthWE5oWW14bFpDSXNJbWhoYzBOc1lYTnpJaXdpYVhORWNtRm5aMmx1WnlJc0ltUnlZV2RuYVc1bklpd2laMlYwUkdseVpXTjBhVzl1SWl3aVpHbHlaV04wYVc5dUlpd2libVY0ZEZOcFlteHBibWRGYkdWdFpXNTBJaXdpWjJWMFRtVjRkRk5wWW14cGJtZEZiR1Z0Wlc1MElpd2ljSEpsZG1sdmRYTlRhV0pzYVc1blJXeGxiV1Z1ZENJc0ltZGxkRkJ5WlhacGIzVnpVMmxpYkdsdVowVnNaVzFsYm5RaUxDSlRhWHBsWVdKc1pVUnBkaUlzSW1kbGRGTnBlbVZoWW14bFJHbDJJaXdpYzJsNlpXRmliR1ZFYVhZaUxDSnpkR0Z5ZEVSeVlXY2lMQ0psYzJOaGNHVkxaWGxUZEc5d2MwUnlZV2RuYVc1blQzQjBhVzl1VUhKbGMyVnVkQ0lzSWtWVFEwRlFSVjlMUlZsZlUxUlBVRk5mUkZKQlIwZEpUa2RmVDFCVVNVOU9JaXdpZDJsdVpHOTNJaXdpYjI1TFpYbEViM2R1SWl3aWEyVjVSRzkzYmtoaGJtUnNaWElpTENKemRHOXdSSEpoWnlJc0ltOW1aa3RsZVVSdmQyNGlMQ0p0YjNWelpWVndTR0Z1Wkd4bGNpSXNJbVYyWlc1MElpd2ljbVZ6WlhSRGRYSnpiM0lpTENKdGIzVnpaVTkxZEVoaGJtUnNaWElpTENKclpYbERiMlJsSWl3aVJWTkRRVkJGWDB0RldWOURUMFJGSWl3aVpHbGtUVzkxYm5RaUxDSndjbTl3WlhKMGFXVnpJaXdpYzNSaGNuUkVjbUZuU0dGdVpHeGxjaUlzSW05dUlpd2liMjVOYjNWelpVMXZkbVVpTENKdGIzVnpaVTF2ZG1WSVlXNWtiR1Z5SWl3aWIyNU5iM1Z6WlVSdmQyNGlMQ0p0YjNWelpVUnZkMjVJWVc1a2JHVnlJaXdpYjI1TmIzVnpaVTkyWlhJaUxDSnRiM1Z6WlU5MlpYSklZVzVrYkdWeUlpd2liMjVOYjNWelpVOTFkQ0lzSW5kcGJHeFZibTF2ZFc1MElpd2liMlptSWl3aWIyWm1UVzkxYzJWTmIzWmxJaXdpYjJabVRXOTFjMlZFYjNkdUlpd2liMlptVFc5MWMyVlBkbVZ5SWl3aWIyWm1UVzkxYzJWUGRYUWlMQ0pwYm1sMGFXRnNhWE5sSWl3aWMyVjBTVzVwZEdsaGJGTjBZWFJsSWl3aVpuSnZiVU5zWVhOeklpd2lRMnhoYzNNaUxDSnpjR3hwZEhSbGNrUnBkaUlzSWtWc1pXMWxiblFpTENKMFlXZE9ZVzFsSWl3aVpHVm1ZWFZzZEZCeWIzQmxjblJwWlhNaUxDSmpiR0Z6YzA1aGJXVWlMQ0pwWjI1dmNtVmtVSEp2Y0dWeWRHbGxjeUlzSW5kcGRHaFRkSGxzWlNKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1EwRkJXU3hYUVVGQkxFTkJRVU03T3p0RlFVRmlPM2RDUVVGQk8wRkJSWE5DTEVkQlFXbENMRU5CUVdwQ0xHTkJRV2xDTzBGQlJVc3NSMEZCVFN4RFFVRk9MRXRCUVUwN1FVRkZNVUlzUjBGQmFVSXNRMEZCYWtJc1UwRkJhVUk3UVVGRllpeEhRVUZYTEVOQlFWZ3NUMEZCVnp0QlFVTlFMRWRCUVdNc1EwRkJaQ3hWUVVGak8wRkJRMGNzUjBGQldTeERRVUZhTEZGQlFWazdPM2xFUVZZM1JEdDFSVUZCUVRzN096czdPenM3T3pzN096czdPenM3T3pzN096dG5Sa0ZCUVRzN096czdPenM3YzBOQlFVRTdPenM3T3p0cFEwRkJRVHM3TzJsRlFVRkJPenRUUVVGQk96czdPenM3T3poRVFVRkJPM05EUVVGQk96WkVRVUZCTzJsRlFVRkJPenM3TzNkRlFVRkJPMmRGUVVGQk96czdPenM3T3pzN08xVkJRVUU3TzNkQ1FVRkJPenM3T3pzN08wdEJRVUU3T3pzN096czdPenM3T3pzN1RVRkJRVHQ1UkVGQlFUczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenQxUWtGQlFUczdTMEZCUVRzN096czdPRUpCUVVFN096czdPenM3T3pzN096c3lRa0ZCUVRzN096czdPenNyUkVGQlFUczdPenM3T3pzN096czdPenR6UTBGQlFUczdPenM3T3pzN096czdPMVZCUVVFN08wdEJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096czdPMUZCZDFKelF5eERRVWwwUXpzN096dExRVFZTUVRzN08wRkJXVUVzUjBGQlN5eERRVUZIUVN4bFFVRmxMRWRCUVhWR1F5eExRVUZWTEZsQlFXaElSQ3hsUVVGbExFVkJRVVZGTEdWQlFXVXNSMEZCYzBWRUxFdEJRVlVzV1VGQkwwWkRMR1ZCUVdVc1JVRkJSVU1zYTBKQlFXdENMRWRCUVd0RVJpeExRVUZWTEZsQlFUbEZSU3hyUWtGQmEwSXNSVUZCUlVNc2IwSkJRVzlDTEVkQlFUUkNTQ3hMUVVGVkxGbEJRVEZFUnl4dlFrRkJiMElzUlVGQlJVTXNjVUpCUVhGQ0xFZEJRVXRLTEV0QlFWVXNXVUZCY0VOSkxIRkNRVUZ4UWp0QlFVVjZSeXhIUVVGTExFTkJRVU5ETEZkQlFWY3NhVUpCUVdwQ0xGRkJRVkU3YlVOQlpGSTdPMkZCWTAxQkxGZEJRVmNzUTBGRFNFTXNVVUZCVVN4RlFVRkZReXhQUVVGUE96QkRRV1l2UWpzN2EwTkJaMEpWUkN4UlFVRlJMRU5EYUVKc1FpeERSR2RDYjBJN1kwRkZXRU1zVDBGQlR5eEhRVUZIUVN4UFFVRlBMRU5CUVVNN096czdPMWxCUjNwQ1F5eEhRVUZsTEVWQlFXWkJMRU5CUVdVN2JVSkJRV1pCTEZGQlFWRXNRMEZCVWtFc1pVRkJaU3hEUVVGRFF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0blFrRkRka0lzUjBGQlN5eERRVUZEUXl4aFFVRmhMRXRCUVVzc1NVRkJTU3hEUVVGRFNDeFBRVUZQTEVOQlFVTkZMRTFCUVUwN1owSkJSVE5ETEUxQlFVMHNRMEZCUTBNc1lVRkJZVHRaUVVOMFFpeERRVUZET3pzN1dVRkZSRU1zUjBGQlZTeEZRVUZXUVN4RFFVRlZPMjFDUVVGV1FTeFJRVUZSTEVOQlFWSkJMRlZCUVZVc1EwRkJRMG9zVDBGQlR5eEZRVUZGTEVOQlFVTTdaMEpCUTI1Q0xFbEJRVWtzUTBGQlEwRXNUMEZCVHl4SFFVRkhRU3hQUVVGUExFTkJRVU03V1VGRGVrSXNRMEZCUXpzN08xbEJSVVJMTEVkQlFWTXNSVUZCVkVFc1EwRkJVenR0UWtGQlZFRXNVVUZCVVN4RFFVRlNRU3hUUVVGVExFTkJRVU5JTEUxQlFVMHNSVUZCUlN4RFFVRkRPMmRDUVVOcVFpeEpRVUZKTEVOQlFVTkdMRTlCUVU4c1EwRkJRMFVzVFVGQlRTeEpRVUZKTEVsQlFVa3NRMEZCUXp0WlFVTTVRaXhEUVVGRE96czdXVUZGUkVrc1IwRkJWeXhGUVVGWVFTeERRVUZYTzIxQ1FVRllRU3hSUVVGUkxFTkJRVkpCTEZkQlFWY3NRMEZCUTBvc1RVRkJUU3hGUVVGRkxFTkJRVU03WjBKQlEyNUNMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU5HTEU5QlFVOHNRMEZCUTBVc1RVRkJUU3hEUVVGRkxFTkJRVU03V1VGREwwSXNRMEZCUXpzN08xbEJSVVJMTEVkQlFVMHNSVUZCVGtFc1EwRkJUVHR0UWtGQlRrRXNVVUZCVVN4RFFVRlNRU3hOUVVGTkxFTkJRVU5ETEZkQlFWY3NSVUZCUlVNc1QwRkJUeXhGUVVGRkxFTkJRVU03WjBKQlF6VkNMRWRCUVVzc1EwRkJRME1zVTBGQlV5eEhRVUZIYUVJc1pVRkJaU3hGUVVNelFtbENMRTlCUVU4c1IwRkJSMGdzVjBGQlZ5eEZRVUZITEVWQlFVY3NRVUZCU0N4RFFVRkhPMmRDUVVWcVF5eEpRVUZKTEVOQlFVTkpMR2RDUVVGblFpeERRVUZEUml4VFFVRlRMRVZCUVVWRExFOUJRVThzUlVGQlJVWXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRja1FzUTBGQlF6czdPMWxCUlVSSkxFZEJRVThzUlVGQlVFRXNRMEZCVHp0dFFrRkJVRUVzVVVGQlVVd3NRMEZCVWtzc1QwRkJUeXhEUVVGRFRDeFhRVUZYTEVWQlFVVkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8yZENRVU0zUWl4SFFVRkxMRU5CUVVORExGTkJRVk1zUjBGQlIyaENMR1ZCUVdVc1JVRkRNMEpwUWl4UFFVRlBMRWRCUVVkSUxGZEJRVmNzUlVGQlJ5eEZRVUZITEVGQlFVZ3NRMEZCUnp0blFrRkZha01zU1VGQlNTeERRVUZEVFN4dFFrRkJiVUlzUTBGQlEwb3NVMEZCVXl4RlFVRkZReXhQUVVGUExFVkJRVVZHTEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUTNoRUxFTkJRVU03T3p0WlFVVkVUU3hIUVVGVkxFVkJRVlpCTEVOQlFWVTdiVUpCUVZaQkxGRkJRVkVzUTBGQlVrRXNWVUZCVlN4RFFVRkRReXhsUVVGbExFVkJRVVZRTEU5QlFVOHNSVUZCUlN4RFFVRkRPMmRDUVVOd1F5eEhRVUZMTEVOQlFVTkRMRk5CUVZNc1IwRkJSMlFzYjBKQlFXOUNMRVZCUTJoRFpTeFBRVUZQTEVkQlFVZExMR1ZCUVdVc1JVRkJSeXhGUVVGSExFRkJRVWdzUTBGQlJ6dG5Ra0ZGY2tNc1NVRkJTU3hEUVVGRFNpeG5Ra0ZCWjBJc1EwRkJRMFlzVTBGQlV5eEZRVUZGUXl4UFFVRlBMRVZCUVVWR0xFOUJRVThzUTBGQlF5eERRVUZETzFsQlEzSkVMRU5CUVVNN096dFpRVVZFVVN4SFFVRlhMRVZCUVZoQkxFTkJRVmM3YlVKQlFWaEJMRkZCUVZFc1EwRkJVa0VzVjBGQlZ5eERRVUZEUkN4bFFVRmxMRVZCUVVWUUxFOUJRVThzUlVGQlJTeERRVUZETzJkQ1FVTnlReXhIUVVGTExFTkJRVU5ETEZOQlFWTXNSMEZCUjJRc2IwSkJRVzlDTEVWQlEyaERaU3hQUVVGUExFZEJRVWRMTEdWQlFXVXNSVUZCUnl4RlFVRkhMRUZCUVVnc1EwRkJSenRuUWtGRmNrTXNTVUZCU1N4RFFVRkRSaXh0UWtGQmJVSXNRMEZCUTBvc1UwRkJVeXhGUVVGRlF5eFBRVUZQTEVWQlFVVkdMRTlCUVU4c1EwRkJReXhEUVVGRE8xbEJRM2hFTEVOQlFVTTdPenRaUVVWRVV5eEhRVUZYTEVWQlFWaEJMRU5CUVZjN2JVSkJRVmhCTEZGQlFWRXNRMEZCVWtFc1YwRkJWeXhEUVVGRFJpeGxRVUZsTEVWQlFVVlFMRTlCUVU4c1JVRkJSU3hEUVVGRE8yZENRVU55UXl4SFFVRkxMRU5CUVVORExGTkJRVk1zUjBGQlIySXNjVUpCUVhGQ0xFVkJRMnBEWXl4UFFVRlBMRWRCUVVkTExHVkJRV1VzUlVGQlJ5eEZRVUZITEVGQlFVZ3NRMEZCUnp0blFrRkZja01zU1VGQlNTeERRVUZEU2l4blFrRkJaMElzUTBGQlEwWXNVMEZCVXl4RlFVRkZReXhQUVVGUExFVkJRVVZHTEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUTNKRUxFTkJRVU03T3p0WlFVVkVWU3hIUVVGWkxFVkJRVnBCTEVOQlFWazdiVUpCUVZwQkxGRkJRVkVzUTBGQlVrRXNXVUZCV1N4RFFVRkRTQ3hsUVVGbExFVkJRVVZRTEU5QlFVOHNSVUZCUlN4RFFVRkRPMmRDUVVOMFF5eEhRVUZMTEVOQlFVTkRMRk5CUVZNc1IwRkJSMklzY1VKQlFYRkNMRVZCUTJwRFl5eFBRVUZQTEVkQlFVZExMR1ZCUVdVc1JVRkJSeXhGUVVGSExFRkJRVWdzUTBGQlJ6dG5Ra0ZGY2tNc1NVRkJTU3hEUVVGRFJpeHRRa0ZCYlVJc1EwRkJRMG9zVTBGQlV5eEZRVUZGUXl4UFFVRlBMRVZCUVVWR0xFOUJRVThzUTBGQlF5eERRVUZETzFsQlEzaEVMRU5CUVVNN096dFpRVVZFVnl4SFFVRlpMRVZCUVZwQkxFTkJRVms3YlVKQlFWcEJMRkZCUVZFc1EwRkJVa0VzV1VGQldTeERRVUZEVml4VFFVRlRMRVZCUVhsQ0xFTkJRVU03WjBKQlFYaENMRWRCUVVkWExFTkJRVWdzUjBGQmNVSXNRMEZCY2tJc1NVRkJjVUlzUjBGQmNrSXNVMEZCY1VJc1EwRkJja0lzVFVGQmNVSXNSVUZCYkVKQkxHdENRVUZyUWl4SFFVRnlRaXhIUVVGeFFpeFBRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeERRVUZ4UWl4SFFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4RFFVRnhRaXhQUVVGeVFpeEpRVUZ4UWl4SFFVRnlRaXhEUVVGeFFpeEZRVUZ5UWl4SlFVRnhRaXhIUVVGeVFpeEpRVUZ4UWl4RlFVRnlRaXhKUVVGeFFpeEhRVUZ5UWl4RFFVRkRPMjlDUVVGRlFTeHJRa0ZCYTBJc1EwRkJja0lzU1VGQmNVSXNSMEZCY2tJc1EwRkJjVUlzU1VGQmNrSXNVMEZCY1VJc1EwRkJja0lzU1VGQmNVSXNRME5xUmk5RExFTkVhVVlyUXp0blFrRkJSQ3hEUVVGRE96dG5Ra0ZETTBNc1IwRkJTeXhEUVVGRFF5eGpRVUZqTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhyUWtGQmEwSXNRMEZCUTJJc1UwRkJVenRuUWtGRmVFUlpMR05CUVdNc1EwRkJRMFVzVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCVUVNc1lVRkJZU3hGUVVGTExFTkJRVU03ZDBKQlNYcERaQ3hSUVVGUE8yOUNRVWhRTEVkQlFVc3NRMEZCUjBFc1QwRkJUeXhIUVVFNFFtTXNZVUZCWVN4RFFVRnNSR1FzVDBGQlR5eEZRVUZYWlN4alFVRmpMRWRCUVV0RUxHRkJRV0VzUTBGQmVrTm9RaXhQUVVGUExFVkJRMnhDUVN4UFFVRlBMRlZCUVZNc1JVRkJSeXhCUVVGSUxFTkJRVWM3Y1VKQlJYcENSU3hSUVVGUExFZEJRVkJCTEU5QlFVOHNSVUZCUTJkQ0xFbEJRVWtzUTBGQldtaENMRXRCUVRSRUxFTkJRVFZFUVN4UlFVRlBMRVZCUVZCQkxFTkJRVU03ZDBKQlFWbGxMR05CUVdNN2IwSkJRV2RETEVOQlFVTXNRMEZCTlVSbUxFMUJRVFJFTEc5Q1FVRTFRbFVzYTBKQlFXdENMRWRCUVd4RVZpeERRVUZETzNkQ1FVRnRSRVlzVDBGQlR6dHZRa0ZCUVN4RFFVRkRMRVZCUVVFc1EwRkJRenRuUWtGREwwUXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRUQ3hEUVVGRE96czdXVUZGUkcxQ0xFZEJRVTBzUlVGQlRrRXNRMEZCVFR0dFFrRkJUa0VzVVVGQlVTeERRVUZTUVN4TlFVRk5MRWRCUVVjc1EwRkJRenRuUWtGRFVpeEpRVUZKTEVOQlFVTkRMRmRCUVZjc1EwRkJReXhEUVVGVkxGVkJRVU1zUTBGQlF6dFpRVU12UWl4RFFVRkRPenM3V1VGRlJFTXNSMEZCVHl4RlFVRlFRU3hEUVVGUE8yMUNRVUZRUVN4UlFVRlJMRU5CUVZKQkxFOUJRVThzUjBGQlJ5eERRVUZETzJkQ1FVTlVMRWxCUVVrc1EwRkJRME1zVVVGQlVTeERRVUZETEVOQlFWVXNWVUZCUXl4RFFVRkRPMWxCUXpWQ0xFTkJRVU03T3p0WlFVVkVReXhIUVVGVkxFVkJRVlpCTEVOQlFWVTdiVUpCUVZaQkxGRkJRVkVzUTBGQlVrRXNWVUZCVlN4SFFVRkhMRU5CUVVNN1owSkJRMW9zUjBGQlN5eERRVUZEUXl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRFF5eFJRVUZSTEVOQlFVTXNRMEZCVlR0blFrRkZla01zVFVGQlRTeERRVUZEUkN4UlFVRlJPMWxCUTJwQ0xFTkJRVU03T3p0WlFVVkVSU3hIUVVGVkxFVkJRVlpCTEVOQlFWVTdiVUpCUVZaQkxGRkJRVkVzUTBGQlVrRXNWVUZCVlN4SFFVRkhMRU5CUVVNN1owSkJRMW9zUjBGQlN5eERRVUZEUXl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRFJpeFJRVUZSTEVOQlFVTXNRMEZCVlR0blFrRkZla01zVFVGQlRTeERRVUZEUlN4UlFVRlJPMWxCUTJwQ0xFTkJRVU03T3p0WlFVVkVReXhIUVVGWkxFVkJRVnBCTEVOQlFWazdiVUpCUVZwQkxGRkJRVkVzUTBGQlVrRXNXVUZCV1N4SFFVRkhMRU5CUVVNN1owSkJRMlFzUjBGQlJ5eERRVUZEUXl4VFFVRlRPMmRDUVVWaUxFZEJRVXNzUTBGQlEwTXNhMEpCUVd0Q0xFZEJRVWNzU1VGQlNTeERRVUZEUXl4eFFrRkJjVUlzU1VGREwwTkRMSE5DUVVGelFpeEhRVUZITEVsQlFVa3NRMEZCUTBNc2VVSkJRWGxDTzJkQ1FVVTNSQ3hGUVVGRkxFVkJRVVZJTEZkQlFYbERMRU5CUVhwRFFTeHJRa0ZCYTBJc1JVRkJXVWtzVTBGQlZ5eFhRVUZGTEVOQlFVTTdiMEpCUXpsRFRDeFRRVUZUTEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOcVFpeERRVUZETzJkQ1FVVkVMRVZCUVVVc1JVRkJSVWNzVjBGQk5rTXNRMEZCTjBOQkxITkNRVUZ6UWl4RlFVRlpSU3hUUVVGWExGZEJRVVVzUTBGQlF6dHZRa0ZEYkVSTUxGTkJRVk1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTJwQ0xFTkJRVU03WjBKQlJVUXNUVUZCVFN4RFFVRkRRU3hUUVVGVE8xbEJRMnhDTEVOQlFVTTdPenRaUVVWRVRTeEhRVUZqTEVWQlFXUkJMRU5CUVdNN2JVSkJRV1JCTEZGQlFWRXNRMEZCVWtFc1kwRkJZeXhIUVVGSExFTkJRVU03WjBKQlEyaENMRWRCUVVjc1EwRkJRME1zVjBGQlZ6dG5Ra0ZGWml4SFFVRkxMRU5CUVVOT0xHdENRVUZyUWl4SFFVRkhMRWxCUVVrc1EwRkJRME1zY1VKQlFYRkNMRWxCUXk5RFF5eHpRa0ZCYzBJc1IwRkJSeXhKUVVGSkxFTkJRVU5ETEhsQ1FVRjVRanRuUWtGRk4wUXNSVUZCUlN4RlFVRkZTQ3hYUVVGNVF5eERRVUY2UTBFc2EwSkJRV3RDTEVWQlFWbEpMRk5CUVZjc1YwRkJSU3hEUVVGRE8yOUNRVU01UTBVc1YwRkJWeXhIUVVGSFRpeHJRa0ZCYTBJc1EwRkJReXhEUVVGRExFVkJRVWNzUVVGQlNDeERRVUZITzJkQ1FVTjJReXhEUVVGRE8yZENRVVZFTEVWQlFVVXNSVUZCUlVVc1YwRkJOa01zUTBGQk4wTkJMSE5DUVVGelFpeEZRVUZaUlN4VFFVRlhMRmRCUVVVc1EwRkJRenR2UWtGRGJFUkZMRmRCUVZjc1IwRkJSMG9zYzBKQlFYTkNMRU5CUVVNc1EwRkJReXhGUVVGSExFRkJRVWdzUTBGQlJ6dG5Ra0ZETTBNc1EwRkJRenRuUWtGRlJDeE5RVUZOTEVOQlFVTkpMRmRCUVZjN1dVRkRjRUlzUTBGQlF6czdPMWxCUlVSRExFZEJRVk1zUlVGQlZFRXNRMEZCVXp0dFFrRkJWRUVzVVVGQlVTeERRVUZTUVN4VFFVRlRMRWRCUVVjc1EwRkJRenRuUWtGRFdDeEhRVUZMTEVOQlFVTndReXhUUVVGVExFZEJRVWRpTEhGQ1FVRnhRaXhGUVVOcVEydEVMRzFEUVVGdFF5eEhRVUZITEVsQlFVa3NRMEZCUXpsRExHVkJRV1VzUTBGQlF5dERMRkZCUVdkRE8yZENRVVZxUnl4RlFVRkZMRVZCUVVWRUxHMURRVUZ0UXl4RlFVRkZMRU5CUVVNN2IwSkJRM2hEUlN4TFFVRk5MRkZCUVVORExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTkRMR05CUVdNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZET1VNc1EwRkJRenRuUWtGRlJDeEpRVUZKTEVOQlFVTndRaXhSUVVGUkxFTkJRVU1zUTBGQlZTeFZRVUZETEVOQlFVTTdaMEpCUlRGQ0xFbEJRVWtzUTBGQlExZ3NXVUZCV1N4RFFVRkRWaXhUUVVGVExFTkJOVW92UWp0WlFUWktSU3hEUVVGRE96czdXVUZGUkRCRExFZEJRVkVzUlVGQlVrRXNRMEZCVVR0dFFrRkJVa0VzVVVGQlVTeERRVUZTUVN4UlFVRlJMRWRCUVVjc1EwRkJRenRuUWtGRFZpeEhRVUZMTEVOQlFVTXhReXhUUVVGVExFZEJRVWRrTEc5Q1FVRnZRaXhGUVVOb1EyMUVMRzFEUVVGdFF5eEhRVUZITEVsQlFVa3NRMEZCUXpsRExHVkJRV1VzUTBGQlF5dERMRkZCUVdkRE8yZENRVVZxUnl4RlFVRkZMRVZCUVVWRUxHMURRVUZ0UXl4RlFVRkZMRU5CUVVNN2IwSkJRM2hEUlN4TFFVRk5MRkZCUVVOSkxGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTkdMR05CUVdNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZETDBNc1EwRkJRenRuUWtGRlJDeEpRVUZKTEVOQlFVTjBRaXhYUVVGWExFTkJRVU1zUTBGQlZTeFZRVUZETEVOQlFVTTdaMEpCUlRkQ0xFbEJRVWtzUTBGQlExUXNXVUZCV1N4RFFVRkRWaXhUUVVGVExFTkJRVU1zUTBGQlF6dFpRVU12UWl4RFFVRkRPenM3V1VGRlJEUkRMRWRCUVdNc1JVRkJaRUVzUTBGQll6dHRRa0ZCWkVFc1VVRkJVU3hEUVVGU1FTeGpRVUZqTEVOQlFVTkRMRXRCUVVzc1JVRkJSVGxETEU5QlFVOHNSVUZCUlN4RFFVRkRPMmRDUVVNNVFpeEhRVUZMTEVOQlFVTjNRaXhSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZEUkN4VlFVRlZPMmRDUVVWb1F5eEZRVUZGTEVkQlFVZERMRkZCUVZFc1JVRkJSU3hEUVVGRE8yOUNRVU5rTEVkQlFVc3NRMEZCUTBjc1VVRkJVU3hIUVVGSExFbEJRVWtzUTBGQlEwUXNWVUZCVlR0dlFrRkZhRU1zUlVGQlJTeEZRVUZGUXl4UlFVRlJMRVZCUVVVc1EwRkJRenQzUWtGRFlpeEpRVUZKTEVOQlFVTm5RaXhSUVVGUkxFVkJRVVVzUTBGQlF6dHZRa0ZEYkVJc1EwRkJRenQzUWtGRlJFa3NUMEZCVnl4bFFVRkZMRU5CUVVNN1owSkJRMmhDTEVOQlFVTTdXVUZEU0N4RFFVRkRPenM3V1VGRlJFTXNSMEZCWlN4RlFVRm1RU3hEUVVGbE8yMUNRVUZtUVN4UlFVRlJMRU5CUVZKQkxHVkJRV1VzUTBGQlEwWXNTMEZCU3l4RlFVRkZPVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdaMEpCUXk5Q0xFZEJRVXNzUTBGQlEzZENMRkZCUVZFc1IwRkJSeXhKUVVGSkxFTkJRVU5FTEZWQlFWVTdaMEpCUldoRExFVkJRVVVzUjBGQlIwTXNVVUZCVVN4RlFVRkZMRU5CUVVNN2IwSkJRMlFzUjBGQlN5eERRVUZEUnl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRFJDeFZRVUZWTzI5Q1FVVm9ReXhGUVVGRkxFZEJRVWRETEZGQlFWRXNSVUZCUlN4RFFVRkRPelJDUVVOa2IwSXNUMEZCVnl4bFFVRkZMRU5CUVVNN2IwSkJRMmhDTEVOQlFVTTdaMEpCUTBnc1EwRkJRenRaUVVOSUxFTkJRVU03T3p0WlFVVkVUQ3hIUVVGakxFVkJRV1JCTEVOQlFXTTdiVUpCUVdSQkxGRkJRVkVzUTBGQlVrRXNZMEZCWXl4RFFVRkRTU3hMUVVGTExFVkJRVVU1UXl4UFFVRlBMRVZCUVVVc1EwRkJRenRuUWtGRE9VSXNSMEZCU3l4RFFVRkhhVVFzVDBGQlR5eEhRVUZMU0N4TFFVRkxMRU5CUVdwQ1J5eFBRVUZQTzJkQ1FVVm1MRVZCUVVVc1JVRkJSVUVzVDBGQlR5eExRVUZMUXl4VlFVRmxMR3RDUVVGRkxFTkJRVU03YjBKQlEyaERMRWRCUVVzc1EwRkJRM1pDTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVORUxGVkJRVlU3YjBKQlJXaERMRVZCUVVVc1JVRkJSVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdkMEpCUTJJc1NVRkJTU3hEUVVGRFowSXNVVUZCVVN4RlFVRkZMRU5CUVVNN2IwSkJRMnhDTEVOQlFVTTdkMEpCUlVSSkxFOUJRVmNzWlVGQlJTeERRVUZETzJkQ1FVTm9RaXhEUVVGRE8xbEJRMGdzUTBGQlF6czdPMWxCUlVSSkxFZEJRVkVzUlVGQlVrRXNRMEZCVVR0dFFrRkJVa0VzVVVGQlVTeERRVUZTUVN4UlFVRlJMRWRCUVVjc1EwRkJRenRuUWtGRFZpeEhRVUZMTEVOQlFXbEVMRmRCUVdVc1IwRkJaaXhKUVVGSkxFTkJRVU5ETEZWQlFWVXNSVUZCTjBSMFJDeE5RVUZOTEVkQlFYZERMRmRCUVdVc1EwRkJOMFJCTEUxQlFVMHNSVUZCUlZFc1ZVRkJWU3hIUVVFMFFpeFhRVUZsTEVOQlFYSkVRU3hWUVVGVkxFVkJRVVZITEZkQlFWY3NSMEZCWlN4WFFVRmxMRU5CUVhwRFFTeFhRVUZYTEVWQlFVVmxMRkZCUVZFc1IwRkJTeXhYUVVGbExFTkJRVFZDUVN4UlFVRlJMRVZCUXpORGVrSXNWMEZCVnl4SFFVRkhSQ3hOUVVGTkxFVkJRM0JDVXl4bFFVRmxMRWRCUVVkRUxGVkJRVlVzUlVGRE5VSXJReXhuUWtGQlowSXNSMEZCUnpWRExGZEJRVmNzUlVGQlJTeEZRVUZITEVGQlFVZ3NRMEZCUnp0blFrRkZlRU5sTEZGQlFWRXNTMEZCU3l4SlFVRkpMRWRCUTJoQ0xFbEJRVWtzUTBGQlEwZ3NUMEZCVHl4TFFVTldMRWxCUVVrc1EwRkJRMFlzVFVGQlRTeEZRVUZGTEVOQlFVTTdaMEpCUld4Q2NFSXNWMEZCVnl4SlFVRkpMRWxCUVVrc1EwRkJRMFFzVFVGQlRTeERRVUZEUXl4WFFVRlhMRU5CUVVNc1EwRkJRenRuUWtGRGVFTlJMR1ZCUVdVc1NVRkJTU3hKUVVGSkxFTkJRVU5FTEZWQlFWVXNRMEZCUTBNc1pVRkJaU3hEUVVGRExFTkJRVU03WjBKQlEzQkVPRU1zWjBKQlFXZENMRWxCUVVrc1NVRkJTU3hEUVVGRE5VTXNWMEZCVnl4RFFVRkRORU1zWjBKQlFXZENMRU5CUVVNc1EwRkJRenRuUWtGRmRrUmlMRXRCUVUwc1VVRkJRMk1zUlVGQlJTeERRVUZGTEVOQlFVRXNSVUZCY1VKd1JTeE5RVUZyUWl4RFFVRnlRMGdzWlVGQlpTeEZRVUZETEVOQlFVTXNTVUZCY1VJc1RVRkJRU3hEUVVGdVFrY3NhMEpCUVd0Q0xFZEJRVWtzU1VGQlNTeERRVUZETWtRc1kwRkJZeXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVVXNSVUZCUnl4QlFVRklMRU5CUVVjN1owSkJSWFJHVEN4TFFVRk5MRkZCUVVObExGZEJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTkRMR2RDUVVGblFpeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVWb1JDeEpRVUZKTEVOQlFVTkRMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU5ETEdkQ1FVRm5RaXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTTVReXhKUVVGSkxFTkJRVU5ETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVORExHZENRVUZuUWl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU01UXl4SlFVRkpMRU5CUVVORExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTmlMR1ZCUVdVc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU01UXl4RFFVRkRPenM3V1VGRlJHTXNSMEZCVnl4RlFVRllRU3hEUVVGWE8yMUNRVUZZUVN4UlFVRlJMRU5CUVZKQkxGZEJRVmNzUjBGQlJ5eERRVUZETzJkQ1FVTmlMRWRCUVVzc1EwRkJkVU1zVjBGQlpTeEhRVUZtTEVsQlFVa3NRMEZCUTFZc1ZVRkJWU3hGUVVGdVJIUkVMRTFCUVUwc1IwRkJPRUlzVjBGQlpTeERRVUZ1UkVFc1RVRkJUU3hGUVVGRlVTeFZRVUZWTEVkQlFXdENMRmRCUVdVc1EwRkJNME5CTEZWQlFWVXNSVUZCUlVjc1YwRkJWeXhIUVVGTExGZEJRV1VzUTBGQkwwSkJMRmRCUVZjc1JVRkRha05XTEZkQlFWY3NSMEZCUjBRc1RVRkJUU3hGUVVOd1FsTXNaVUZCWlN4SFFVRkhSQ3hWUVVGVkxFVkJRelZDSzBNc1owSkJRV2RDTEVkQlFVYzFReXhYUVVGWExFVkJRVVVzUlVGQlJ5eEJRVUZJTEVOQlFVYzdaMEpCUlhwRFZpeFhRVUZYTEVsQlFVa3NTVUZCU1N4RFFVRkRTeXhQUVVGUExFTkJRVU5NTEZkQlFWY3NRMEZCUXl4RFFVRkRPMmRDUVVONlExRXNaVUZCWlN4SlFVRkpMRWxCUVVrc1EwRkJRME1zVjBGQlZ5eERRVUZEUkN4bFFVRmxMRU5CUVVNc1EwRkJRenRuUWtGRGNrUTRReXhuUWtGQlowSXNTVUZCU1N4SlFVRkpMRU5CUVVNelF5eFpRVUZaTEVOQlFVTXlReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRPMmRDUVVWNFJHSXNTMEZCVFN4UlFVRkRkVUlzUjBGQlJ5eERRVUZGTEVOQlFVRXNSVUZCY1VJM1JTeE5RVUZyUWl4RFFVRnlRMGdzWlVGQlpTeEZRVUZETEVOQlFVTXNTVUZCY1VJc1RVRkJRU3hEUVVGdVFrY3NhMEpCUVd0Q0xFZEJRVWtzU1VGQlNTeERRVUZETWtRc1kwRkJZeXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVVXNSVUZCUnl4QlFVRklMRU5CUVVjN1owSkJSWFpHVEN4TFFVRk5MRkZCUVVOM1FpeFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRVaXhuUWtGQlowSXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRmFrUXNTVUZCU1N4RFFVRkRVeXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZEVUN4blFrRkJaMElzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRMME1zU1VGQlNTeERRVUZEVVN4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRFRpeG5Ra0ZCWjBJc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZETDBNc1NVRkJTU3hEUVVGRFR5eFhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRia0lzWlVGQlpTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUXk5RExFTkJRVU03T3p0WlFVVkViMElzUjBGQlZTeEZRVUZXUVN4RFFVRlZPMjFDUVVGV1FTeFJRVUZSTEVOQlFWSkJMRlZCUVZVc1IwRkJSeXhEUVVGRE8yZENRVU5hTEVsQlFVa3NRMEZCUTBNc1pVRkJaU3hGUVVGRkxFTkJRVU03V1VGRGVrSXNRMEZCUXpzN096dFpRV2RDVFVNc1IwRkJVeXhGUVVGVVFTeERRVUZUTzIxQ1FVRm9RaXhSUVVGUkxFTkJRVVJCTEZOQlFWTXNRMEZCUTBNc1MwRkJTeXhGUVVGRmJrSXNWVUZCVlN4RlFVRkZMRU5CUVVNN1owSkJRMjVETEVkQlFVc3NZVUZCYjBKQkxGVkJRVlVzUTBGQk0wSTNSQ3hQUVVGUExFVkJRVkJCTEU5QlFVOHNNRUpCUVVjc1EwRkJReXhEUVVGRExHTkJRMlJwUml4WFFVRlhMRWRCUVVkRExFdEJRVThzVTBGQlEwZ3NVMEZCVXl4RFFVRkRReXhMUVVGTExFVkJRVVZ1UWl4VlFVRlZMRVZCUVVVM1JDeFBRVUZQTzJkQ1FVVm9SU3hOUVVGTkxFTkJRVU5wUml4WFFVRlhPMWxCUTNCQ0xFTkJRVU03TzAxQmNsSklPenR0UWtGak1FSkRMRXRCUVU4N1owSkJRVE5DY0VZc1YwRkJWeXhGUVc5UVVuRkdMRU5CUVU4c1ZVRkJSeXhEUVVGTExFdEJiRkY0UWp0blFrRmpUWEpHTEZkQlFWY3NSVUZ6VUZKelJpeERRVUZwUWl4dlFrRkJSeXhEUVVGRE8wbEJRekZDUXl4VFFVRlRMRVZCUVVVc1EwRkJWVHRCUVVOMlFpeERRVUZETEVOQmRGRklPMmRDUVdOTmRrWXNWMEZCVnl4RlFUQlFVbmRHTEVOQlFXbENMRzlDUVVGSExFTkJRVU03U1VGRE1VSXNRMEZCVVR0SlFVTlNMRU5CUVZNN1NVRkRWQ3hEUVVGVk8wbEJRMVlzUTBGQldUdEpRVU5hTEVOQlFXRTdRVUZEWml4RFFVRkRMRU5CT1ZGSU8yMUNRWGRTWlVNc1kwRkJVeXhWUVVGRGVrWXNWMEZCVnpzd1FrRjRVbkJESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgZXZlbnRUeXBlcyB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBTcGxpdHRlciBmcm9tIFwiLi4vc3BsaXR0ZXJcIjtcblxuaW1wb3J0IHsgY29sdW1uUmVzaXplQ3Vyc29yIH0gZnJvbSBcIi4uLy4uL2N1cnNvclwiO1xuXG5jb25zdCB7IERSQUdfRVZFTlRfVFlQRSB9ID0gZXZlbnRUeXBlcztcblxuY2xhc3MgVmVydGljYWxTcGxpdHRlciBleHRlbmRzIFNwbGl0dGVyIHtcbiAgbW91c2VPdmVySGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5pc0Rpc2FibGVkKCk7XG5cbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICBjb2x1bW5SZXNpemVDdXJzb3IoKTtcbiAgICB9XG4gIH1cblxuICBtb3VzZU1vdmVIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgY29uc3QgeyBwYWdlWCB9ID0gZXZlbnQsXG4gICAgICAgICAgbW91c2VMZWZ0ID0gcGFnZVgsICAvLy9cbiAgICAgICAgICBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmcoKTtcblxuICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgICAgIHNpemVhYmxlRGl2ID0gdGhpcy5nZXRTaXplYWJsZURpdigpO1xuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzTW91c2VMZWZ0ID0gdGhpcy5nZXRQcmV2aW91c01vdXNlTGVmdCgpLFxuICAgICAgICAgICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSB0aGlzLmdldFByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aCgpLFxuICAgICAgICAgICAgICByZWxhdGl2ZU1vdXNlTGVmdCA9IG1vdXNlTGVmdCAtIHByZXZpb3VzTW91c2VMZWZ0O1xuXG4gICAgICAgIGxldCBzaXplYWJsZURpdldpZHRoID0gcHJldmlvdXNTaXplYWJsZURpdldpZHRoIC0gZGlyZWN0aW9uICogcmVsYXRpdmVNb3VzZUxlZnQ7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBzaXplYWJsZURpdldpZHRoLCAvLy9cbiAgICAgICAgICAgICAgZXZlbnRUeXBlID0gRFJBR19FVkVOVF9UWVBFO1xuXG4gICAgICAgIHNpemVhYmxlRGl2LnNldFdpZHRoKHdpZHRoKTtcblxuICAgICAgICBzaXplYWJsZURpdldpZHRoID0gc2l6ZWFibGVEaXYuZ2V0V2lkdGgoKTsgIC8vL1xuXG4gICAgICAgIHRoaXMuY2FsbEhhbmRsZXJzKGV2ZW50VHlwZSwgc2l6ZWFibGVEaXZXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbW91c2VEb3duSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgIGNvbnN0IHsgcGFnZVggfSA9IGV2ZW50LFxuICAgICAgICAgIG1vdXNlTGVmdCA9IHBhZ2VYLCAgLy8vXG4gICAgICAgICAgZGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKTtcblxuICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCksXG4gICAgICAgICAgICBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICAgIHByZXZpb3VzTW91c2VMZWZ0ID0gbW91c2VMZWZ0LCAgLy8vXG4gICAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gc2l6ZWFibGVEaXYuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aCA9IHNpemVhYmxlRGl2V2lkdGg7ICAvLy9cblxuICAgICAgdGhpcy5zZXRQcmV2aW91c01vdXNlTGVmdChwcmV2aW91c01vdXNlTGVmdCk7XG5cbiAgICAgIHRoaXMuc2V0UHJldmlvdXNTaXplYWJsZURpdldpZHRoKHByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aCk7XG5cbiAgICAgIGNvbHVtblJlc2l6ZUN1cnNvcigpO1xuXG4gICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgIHRoaXMuc3RhcnREcmFnKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJldmlvdXNNb3VzZUxlZnQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCksXG4gICAgICAgICAgeyBwcmV2aW91c01vdXNlTGVmdCB9ID0gc3RhdGU7XG5cbiAgICByZXR1cm4gcHJldmlvdXNNb3VzZUxlZnQ7XG4gIH1cblxuICBnZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCksXG4gICAgICAgICAgeyBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggfSA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aDtcbiAgfVxuXG4gIHNldFByZXZpb3VzTW91c2VMZWZ0KHByZXZpb3VzTW91c2VMZWZ0KSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c01vdXNlTGVmdFxuICAgIH0pO1xuICB9XG5cbiAgc2V0UHJldmlvdXNTaXplYWJsZURpdldpZHRoKHByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aCkge1xuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgcHJldmlvdXNTaXplYWJsZURpdldpZHRoXG4gICAgfSk7XG4gIH1cblxuICBzZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcHJldmlvdXNNb3VzZUxlZnQgPSBudWxsLFxuICAgICAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aCA9IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHByZXZpb3VzTW91c2VMZWZ0LFxuICAgICAgcHJldmlvdXNTaXplYWJsZURpdldpZHRoXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInZlcnRpY2FsXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFZlcnRpY2FsU3BsaXR0ZXIpYFxuXG4gIHdpZHRoOiAxcmVtO1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBldmVudFR5cGVzIH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IFNwbGl0dGVyIGZyb20gXCIuLi9zcGxpdHRlclwiO1xuXG5pbXBvcnQgeyByb3dSZXNpemVDdXJzb3IgfSBmcm9tIFwiLi4vLi4vY3Vyc29yXCI7XG5cbmNvbnN0IHsgRFJBR19FVkVOVF9UWVBFIH0gPSBldmVudFR5cGVzO1xuXG5jbGFzcyBIb3Jpem9udGFsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIG1vdXNlT3ZlckhhbmRsZXIoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgcm93UmVzaXplQ3Vyc29yKCk7XG4gICAgfVxuICB9XG5cbiAgbW91c2VNb3ZlSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgIGNvbnN0IHsgcGFnZVkgfSA9IGV2ZW50LFxuICAgICAgICAgIG1vdXNlVG9wID0gcGFnZVksICAvLy9cbiAgICAgICAgICBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmcoKTtcblxuICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgICAgIHNpemVhYmxlRGl2ID0gdGhpcy5nZXRTaXplYWJsZURpdigpO1xuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzTW91c2VUb3AgPSB0aGlzLmdldFByZXZpb3VzTW91c2VUb3AoKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IHRoaXMuZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpLFxuICAgICAgICAgICAgICByZWxhdGl2ZU1vdXNlVG9wID0gbW91c2VUb3AgLSBwcmV2aW91c01vdXNlVG9wO1xuXG4gICAgICAgIGxldCBzaXplYWJsZURpdkhlaWdodCA9IHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgLSBkaXJlY3Rpb24gKiByZWxhdGl2ZU1vdXNlVG9wO1xuXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHNpemVhYmxlRGl2SGVpZ2h0LCAvLy9cbiAgICAgICAgICAgICAgZXZlbnRUeXBlID0gRFJBR19FVkVOVF9UWVBFO1xuXG4gICAgICAgIHNpemVhYmxlRGl2LnNldEhlaWdodChoZWlnaHQpO1xuXG4gICAgICAgIHNpemVhYmxlRGl2SGVpZ2h0ID0gc2l6ZWFibGVEaXYuZ2V0SGVpZ2h0KCk7ICAvLy9cblxuICAgICAgICB0aGlzLmNhbGxIYW5kbGVycyhldmVudFR5cGUsIHNpemVhYmxlRGl2SGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtb3VzZURvd25IYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgY29uc3QgeyBwYWdlWSB9ID0gZXZlbnQsXG4gICAgICAgICAgbW91c2VUb3AgPSBwYWdlWSwgIC8vL1xuICAgICAgICAgIGRpc2FibGVkID0gdGhpcy5pc0Rpc2FibGVkKCk7XG5cbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpLFxuICAgICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgICBwcmV2aW91c01vdXNlVG9wID0gbW91c2VUb3AsICAvLy9cbiAgICAgICAgICAgIHNpemVhYmxlRGl2SGVpZ2h0ID0gc2l6ZWFibGVEaXYuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0ID0gc2l6ZWFibGVEaXZIZWlnaHQ7ICAvLy9cblxuICAgICAgdGhpcy5zZXRQcmV2aW91c01vdXNlVG9wKHByZXZpb3VzTW91c2VUb3ApO1xuXG4gICAgICB0aGlzLnNldFByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQocHJldmlvdXNTaXplYWJsZURpdkhlaWdodCk7XG5cbiAgICAgIHJvd1Jlc2l6ZUN1cnNvcigpO1xuXG4gICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgIHRoaXMuc3RhcnREcmFnKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJldmlvdXNNb3VzZVRvcCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKSxcbiAgICAgICAgICB7IHByZXZpb3VzTW91c2VUb3AgfSA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHByZXZpb3VzTW91c2VUb3A7XG4gIH1cblxuICBnZXRQcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgIHsgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCB9ID0gc3RhdGU7XG5cbiAgICByZXR1cm4gcHJldmlvdXNTaXplYWJsZURpdkhlaWdodDtcbiAgfVxuXG4gIHNldFByZXZpb3VzTW91c2VUb3AocHJldmlvdXNNb3VzZVRvcCkge1xuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgcHJldmlvdXNNb3VzZVRvcFxuICAgIH0pO1xuICB9XG5cbiAgc2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodChwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBzZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcHJldmlvdXNNb3VzZVRvcCA9IG51bGwsXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHByZXZpb3VzTW91c2VUb3AsXG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImhvcml6b250YWxcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoSG9yaXpvbnRhbFNwbGl0dGVyKWBcblxuICBoZWlnaHQ6IDFyZW07XG5cbmA7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIG9wdGlvbnMgfSBmcm9tIFwiLi9vcHRpb25zXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm93RGl2IH0gZnJvbSBcIi4vZGl2L3Jvd1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb3dzRGl2IH0gZnJvbSBcIi4vZGl2L3Jvd3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sdW1uRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2x1bW5zRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtbnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2l6ZWFibGVEaXYgfSBmcm9tIFwiLi9kaXYvc2l6ZWFibGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmVydGljYWxTcGxpdHRlckRpdiB9IGZyb20gXCIuL2Rpdi9zcGxpdHRlci92ZXJ0aWNhbFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIb3Jpem9udGFsU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXIvaG9yaXpvbnRhbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZU9mKGluc3RhbmNlLCBDbGFzcykge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xuXG4gIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgIGlmIChjb25zdHJ1Y3Rvci5uYW1lID09PSBDbGFzcy5uYW1lKSB7ICAvLy9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IpO1xuXG4gICAgICByZXR1cm4gaXNQcm90b3R5cGVJbnN0YW5jZU9mKHByb3RvdHlwZSwgQ2xhc3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQcm90b3R5cGVJbnN0YW5jZU9mKHByb3RvdHlwZSwgQ2xhc3MpIHtcbiAgaWYgKHByb3RvdHlwZSkge1xuICAgIGlmIChwcm90b3R5cGUubmFtZSA9PT0gQ2xhc3MubmFtZSkgeyAgLy8vXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XG5cbiAgICAgIHJldHVybiBpc1Byb3RvdHlwZUluc3RhbmNlT2YocHJvdG90eXBlLCBDbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IGAke3J1bGVOYW1lfV9gO1xuXG4gIHJldHVybiByZWR1Y2VkUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJlcGVhdGVkUnVsZU5hbWUgPSBgJHtydWxlTmFtZX1+YDtcblxuICByZXR1cm4gcmVwZWF0ZWRSdWxlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUpIHtcbiAgY29uc3QgcnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWUucmVwbGFjZSgvXyQvLCBcIlwiKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JlZHVjZWRSdWxlTmFtZU1hdGNoZXNSdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUsIHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lQSA9IHJ1bGVOYW1lOyAvLy9cblxuICBydWxlTmFtZSA9IHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUpO1xuXG4gIGNvbnN0IHJ1bGVOYW1lQiA9IHJ1bGVOYW1lOyAvLy9cblxuICBjb25zdCByZWR1Y2VkUnVsZU5hbWVNYXRjaGVzUnVsZU5hbWUgPSAocnVsZU5hbWVBID09PSBydWxlTmFtZUIpOyAgLy8vXG5cbiAgcmV0dXJuIHJlZHVjZWRSdWxlTmFtZU1hdGNoZXNSdWxlTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgaXNJbnN0YW5jZU9mIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jbGFzc1wiO1xuaW1wb3J0IHsgcmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZSwgcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlTmFtZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlZFJ1bGVGcm9tUnVsZShydWxlLCBydWxlTWFwLCBSZWR1Y2VkUnVsZSkge1xuXHRjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuXHRcdFx0XHRyZWR1Y2VkUnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG5cdGxldCByZWR1Y2VkUnVsZSA9IHJ1bGVNYXBbcmVkdWNlZFJ1bGVOYW1lXSB8fCBudWxsO1xuXG5cdGlmIChyZWR1Y2VkUnVsZSA9PT0gbnVsbCkge1xuICAgIHJlZHVjZWRSdWxlID0gUmVkdWNlZFJ1bGUuZnJvbVJ1bGUocnVsZSk7XG5cbiAgICBydWxlTWFwW3JlZHVjZWRSdWxlTmFtZV0gPSByZWR1Y2VkUnVsZTtcblx0fVxuXG5cdHJldHVybiByZWR1Y2VkUnVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdGVkUnVsZUZyb21SdWxlKHJ1bGUsIHJ1bGVNYXAsIFJlcGVhdGVkUnVsZSkge1xuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICByZXBlYXRlZFJ1bGVOYW1lID0gcmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgbGV0IHJlcGVhdGVkUnVsZSA9IHJ1bGVNYXBbcmVwZWF0ZWRSdWxlTmFtZV0gfHwgbnVsbDtcblxuICBpZiAocmVwZWF0ZWRSdWxlID09PSBudWxsKSB7XG4gICAgcmVwZWF0ZWRSdWxlID0gUmVwZWF0ZWRSdWxlLmZyb21SdWxlKHJ1bGUpO1xuXG4gICAgcnVsZU1hcFtyZXBlYXRlZFJ1bGVOYW1lXSA9IHJlcGVhdGVkUnVsZTtcbiAgfVxuXG4gIHJldHVybiByZXBlYXRlZFJ1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXR0ZW5SdWxlRnJvbVJ1bGUocnVsZSwgcnVsZU1hcCwgUmV3cml0dGVuUnVsZSkge1xuICBsZXQgcmV3cml0dGVuUnVsZTtcblxuICBjb25zdCBydWxlUmV3cml0dGVuUnVsZSA9IGlzSW5zdGFuY2VPZihydWxlLCBSZXdyaXR0ZW5SdWxlKTtcblxuICBpZiAocnVsZVJld3JpdHRlblJ1bGUpIHtcbiAgICByZXdyaXR0ZW5SdWxlID0gcnVsZTsgLy8vXG4gIH0gZWxzZSB7XG4gICAgcmV3cml0dGVuUnVsZSA9IFJld3JpdHRlblJ1bGUuZnJvbVJ1bGUocnVsZSk7XG5cbiAgICBjb25zdCByZXBsYWNlZFJ1bGUgPSBydWxlLCAgLy8vXG4gICAgICAgICAgcmVwbGFjZW1lbnRSdWxlID0gcmV3cml0dGVuUnVsZTsgIC8vL1xuXG4gICAgcmVwbGFjZVJ1bGUocmVwbGFjZWRSdWxlLCByZXBsYWNlbWVudFJ1bGUsIHJ1bGVNYXApO1xuICB9XG5cbiAgcmV0dXJuIHJld3JpdHRlblJ1bGU7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VSdWxlKHJlcGxhY2VkUnVsZSwgcmVwbGFjZW1lbnRSdWxlLCBydWxlTWFwKSB7XG4gIGNvbnN0IHJlcGxhY2VkUnVsZU5hbWUgPSByZXBsYWNlZFJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICByZXBsYWNlbWVudFJ1bGVOYW1lID0gcmVwbGFjZW1lbnRSdWxlLmdldE5hbWUoKTtcblxuICBkZWxldGUgcnVsZU1hcFtyZXBsYWNlZFJ1bGVOYW1lXTtcblxuICBydWxlTWFwW3JlcGxhY2VtZW50UnVsZU5hbWVdID0gcmVwbGFjZW1lbnRSdWxlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgUkVDVVJTSVZFX1RZUEUgPSBcIlJFQ1VSU0lWRV9UWVBFXCI7XG5leHBvcnQgY29uc3QgTEVGVF9SRUNVUlNJVkVfVFlQRSA9IFwiTEVGVF9SRUNVUlNJVkVfVFlQRVwiO1xuZXhwb3J0IGNvbnN0IERJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUgPSBcIkRJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEVcIjtcbmV4cG9ydCBjb25zdCBJTkRJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUgPSBcIklORElSRUNUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRVwiO1xuZXhwb3J0IGNvbnN0IElNUExJQ0lUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRSA9IFwiSU1QTElDSVRMWV9MRUZUX1JFQ1VSU0lWRV9UWVBFXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IFJ1bGVOYW1lUGFydFR5cGUsXG4gICAgICAgIE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICAgICAgICBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSB9ID0gcGFydFR5cGVzO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKSB7XG4gIGNvbnN0IHBhcnROb25UZXJtaW5hbFBhcnQgPSBwYXJ0LmlzTm9uVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhcnROb25UZXJtaW5hbFBhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gcGFydC5nZXRUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUnVsZU5hbWVQYXJ0VHlwZSA6IHtcbiAgICAgICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBwYXJ0LCAgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcmVjdXJzaXZlUnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICAgIGlmICghcmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lcy5wdXNoKHJlY3Vyc2l2ZVJ1bGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZSA6IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRQYXJ0ID0gcGFydDsgIC8vL1xuXG4gICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9uZU9yTW9yZVBhcnRzUGFydFR5cGUgOiB7XG4gICAgICAgICAgY29uc3Qgb25lT3JNb3JlUGFydHNQYXJ0ID0gcGFydDsgIC8vL1xuXG4gICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUgOiB7XG4gICAgICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IHBhcnQ7IC8vL1xuXG4gICAgICAgICAgcGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpOyAgLy8vXG5cbiAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUgOiB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBwYXJ0LCAgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gc2VxdWVuY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpO1xuXG4gICAgICAgICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDaG9pY2VPZlBhcnRzUGFydFR5cGUgOiB7XG4gICAgICAgIGNvbnN0IGNob2ljZU9mUGFydHNQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gY2hvaWNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKTtcblxuICAgICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3QgdHlwZSA9IHBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGUgOiB7XG4gICAgICAgICAgY29uc3QgcnVsZU5hbWVQYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVQYXJ0LmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICAgIGlmICghbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lOyAvLy9cblxuICAgICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5wdXNoKGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3B0aW9uYWxQYXJ0UGFydFR5cGUgOiB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0UGFydCA9IHBhcnQ7IC8vL1xuXG4gICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSA6IHtcbiAgICAgICAgICBjb25zdCBvbmVPck1vcmVQYXJ0c1BhcnQgPSBwYXJ0OyAgLy8vXG5cbiAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIDoge1xuICAgICAgICAgIGNvbnN0IHplcm9Pck1vcmVQYXJ0c1BhcnQgPSBwYXJ0OyAvLy9cblxuICAgICAgICAgIHBhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlIDoge1xuICAgICAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBwYXJ0LCAgLy8vXG4gICAgICAgICAgICAgICAgcGFydHMgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpO1xuXG4gICAgICAgICAgcGFydCA9IGZpcnN0UGFydDsgLy8vXG5cbiAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDaG9pY2VPZlBhcnRzUGFydFR5cGUgOiB7XG4gICAgICAgICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1BhcnQgPSBwYXJ0LCAvLy9cbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGNob2ljZU9mUGFydHNQYXJ0LmdldFBhcnRzKCk7XG5cbiAgICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVjdXJzaXZlUGFydFwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgUnVsZU5hbWVQYXJ0VHlwZSB9ID0gcGFydFR5cGVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uVW5hcnkoZGVmaW5pdGlvbikge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGgsXG4gICAgICAgIGRlZmluaXRpb25VbmFyeSA9IChwYXJ0c0xlbmd0aCA9PT0gMSk7XG5cbiAgcmV0dXJuIGRlZmluaXRpb25VbmFyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkNvbXBsZXgoZGVmaW5pdGlvbikge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBmaXJzdFBhcnRUeXBlID0gZmlyc3RQYXJ0LmdldFR5cGUoKSxcbiAgICAgICAgZmlyc3RQYXJ0VHlwZVJ1bGVOYW1lUGFydFR5cGUgPSAoZmlyc3RQYXJ0VHlwZSA9PT0gUnVsZU5hbWVQYXJ0VHlwZSksXG4gICAgICAgIGZpcnN0UGFydFJ1bGVOYW1lUGFydCA9IGZpcnN0UGFydFR5cGVSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBkZWZpbml0aW9uQ29tcGxleCA9ICFmaXJzdFBhcnRSdWxlTmFtZVBhcnQ7XG5cbiAgcmV0dXJuIGRlZmluaXRpb25Db21wbGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uTG9va0FoZWFkKGRlZmluaXRpb24pIHtcbiAgbGV0IGxvb2tBaGVhZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIGZpcnN0UGFydFR5cGUgPSBmaXJzdFBhcnQuZ2V0VHlwZSgpLFxuICAgICAgICBmaXJzdFBhcnRUeXBlUnVsZU5hbWVQYXJ0VHlwZSA9IChmaXJzdFBhcnRUeXBlID09PSBSdWxlTmFtZVBhcnRUeXBlKSxcbiAgICAgICAgZmlyc3RQYXJ0UnVsZU5hbWVQYXJ0ID0gZmlyc3RQYXJ0VHlwZVJ1bGVOYW1lUGFydFR5cGU7ICAvLy9cblxuICBpZiAoZmlyc3RQYXJ0UnVsZU5hbWVQYXJ0KSB7XG4gICAgY29uc3QgcnVsZU5hbWVQYXJ0ID0gZmlyc3RQYXJ0OyAvLy9cblxuICAgIGxvb2tBaGVhZCA9IHJ1bGVOYW1lUGFydC5pc0xvb2tBaGVhZCgpO1xuICB9XG5cbiAgcmV0dXJuIGxvb2tBaGVhZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgY29uc3QgcmVjdXJzaXZlUnVsZU5hbWVzID0gW10sXG4gICAgICAgIHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuICB9KTtcblxuICByZXR1cm4gcmVjdXJzaXZlUnVsZU5hbWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IFtdLFxuICAgICAgICBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBwYXJ0ID0gZmlyc3RQYXJ0OyAvLy9cblxuICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX29jY2FtUGFyc2VycyA9IHJlcXVpcmUoXCJvY2NhbS1wYXJzZXJzXCIpO1xudmFyIF9ydWxlID0gcmVxdWlyZShcIi4uL3V0aWxpdGllcy9ydWxlXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBfZGVmaW5pdGlvbiA9IHJlcXVpcmUoXCIuLi91dGlsaXRpZXMvZGVmaW5pdGlvblwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIFJlY3Vyc2l2ZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKERlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoUmVjdXJzaXZlRGVmaW5pdGlvbiwgRGVmaW5pdGlvbik7XG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZWN1cnNpdmVEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVEZWZpbml0aW9uKHR5cGUsIHBhcnRzLCBydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWN1cnNpdmVEZWZpbml0aW9uKTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzKTtcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgICAgIF90aGlzLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICBfdGhpcy5yZWN1cnNpdmVSdWxlTmFtZXMgPSByZWN1cnNpdmVSdWxlTmFtZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKFJlY3Vyc2l2ZURlZmluaXRpb24sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFR5cGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRSdWxlTmFtZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGVOYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldFJlY3Vyc2l2ZVJ1bGVOYW1lc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlY3Vyc2l2ZVJ1bGVOYW1lcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVSdWxlTmFtZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZShydWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlTWFwW3RoaXMucnVsZU5hbWVdIHx8IG51bGwsIHJlcGxhY2VkRGVmaW5pdGlvbiA9IHRoaXMuZGVmaW5pdGlvbiwgcmVwbGFjZW1lbnREZWZpbml0aW9uID0gdGhpczsgLy8vXG4gICAgICAgICAgICAgICAgcnVsZS5yZXBsYWNlRGVmaW5pdGlvbihyZXBsYWNlZERlZmluaXRpb24sIHJlcGxhY2VtZW50RGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVBbmREZWZpbml0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lQW5kRGVmaW5pdGlvbihydWxlTmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnNpdmVEZWZpbml0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF90eXBlcy5SRUNVUlNJVkVfVFlQRSwgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksIHJlY3Vyc2l2ZVJ1bGVOYW1lcyA9ICgwLCBfZGVmaW5pdGlvbikucmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiksIHJlY3Vyc2l2ZVJ1bGVOYW1lc0xlbmd0aCA9IHJlY3Vyc2l2ZVJ1bGVOYW1lcy5sZW5ndGgsIGRlZmluaXRpb25SZWN1cnNpdmVEZWZpbml0aW9uID0gcmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvblJlY3Vyc2l2ZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlRGVmaW5pdGlvbiA9IG5ldyBSZWN1cnNpdmVEZWZpbml0aW9uKHR5cGUsIHBhcnRzLCBydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZURlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUmVjdXJzaXZlRGVmaW5pdGlvbjtcbn0oX29jY2FtUGFyc2Vycy5EZWZpbml0aW9uKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3Vyc2l2ZURlZmluaXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMM0psWTNWeWMybDJaUzVxY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVhVzF3YjNKMElIc2dSR1ZtYVc1cGRHbHZiaUI5SUdaeWIyMGdYQ0p2WTJOaGJTMXdZWEp6WlhKelhDSTdYRzVjYm1sdGNHOXlkQ0I3SUdacGJtUlNkV3hsSUgwZ1puSnZiU0JjSWk0dUwzVjBhV3hwZEdsbGN5OXlkV3hsWENJN1hHNXBiWEJ2Y25RZ2V5QlNSVU5WVWxOSlZrVmZWRmxRUlNCOUlHWnliMjBnWENJdUxpOTBlWEJsYzF3aU8xeHVhVzF3YjNKMElIc2djbVZqZFhKemFYWmxVblZzWlU1aGJXVnpSbkp2YlVSbFptbHVhWFJwYjI0Z2ZTQm1jbTl0SUZ3aUxpNHZkWFJwYkdsMGFXVnpMMlJsWm1sdWFYUnBiMjVjSWp0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1kyeGhjM01nVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmlCbGVIUmxibVJ6SUVSbFptbHVhWFJwYjI0Z2UxeHVJQ0JqYjI1emRISjFZM1J2Y2loMGVYQmxMQ0J3WVhKMGN5d2djblZzWlU1aGJXVXNJR1JsWm1sdWFYUnBiMjRzSUhKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lrZ2UxeHVJQ0FnSUhOMWNHVnlLSEJoY25SektUdGNibHh1SUNBZ0lIUm9hWE11ZEhsd1pTQTlJSFI1Y0dVN1hHNGdJQ0FnZEdocGN5NXlkV3hsVG1GdFpTQTlJSEoxYkdWT1lXMWxPMXh1SUNBZ0lIUm9hWE11WkdWbWFXNXBkR2x2YmlBOUlHUmxabWx1YVhScGIyNDdYRzRnSUNBZ2RHaHBjeTV5WldOMWNuTnBkbVZTZFd4bFRtRnRaWE1nUFNCeVpXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNN1hHNGdJSDFjYmx4dUlDQm5aWFJVZVhCbEtDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpMblI1Y0dVN1hHNGdJSDFjYmx4dUlDQm5aWFJTZFd4bFRtRnRaU2dwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eWRXeGxUbUZ0WlR0Y2JpQWdmVnh1WEc0Z0lHZGxkRVJsWm1sdWFYUnBiMjRvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVpHVm1hVzVwZEdsdmJqdGNiaUFnZlZ4dVhHNGdJR2RsZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lncElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NXlaV04xY25OcGRtVlNkV3hsVG1GdFpYTTdYRzRnSUgxY2JseHVJQ0J5WlhCc1lXTmxLSEoxYkdWTllYQXBJSHRjYmlBZ0lDQmpiMjV6ZENCeWRXeGxJRDBnY25Wc1pVMWhjRnQwYUdsekxuSjFiR1ZPWVcxbFhTQjhmQ0J1ZFd4c0xGeHVJQ0FnSUNBZ0lDQWdJSEpsY0d4aFkyVmtSR1ZtYVc1cGRHbHZiaUE5SUhSb2FYTXVaR1ZtYVc1cGRHbHZiaXdnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdjbVZ3YkdGalpXMWxiblJFWldacGJtbDBhVzl1SUQwZ2RHaHBjenNnTHk4dlhHNWNiaUFnSUNCeWRXeGxMbkpsY0d4aFkyVkVaV1pwYm1sMGFXOXVLSEpsY0d4aFkyVmtSR1ZtYVc1cGRHbHZiaXdnY21Wd2JHRmpaVzFsYm5SRVpXWnBibWwwYVc5dUtUdGNiaUFnZlZ4dVhHNGdJSE4wWVhScFl5Qm1jbTl0VW5Wc1pVNWhiV1ZCYm1SRVpXWnBibWwwYVc5dUtISjFiR1ZPWVcxbExDQmtaV1pwYm1sMGFXOXVLU0I3WEc0Z0lDQWdiR1YwSUhKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0Z1BTQnVkV3hzTzF4dVhHNGdJQ0FnWTI5dWMzUWdkSGx3WlNBOUlGSkZRMVZTVTBsV1JWOVVXVkJGTEZ4dUlDQWdJQ0FnSUNBZ0lIQmhjblJ6SUQwZ1pHVm1hVzVwZEdsdmJpNW5aWFJRWVhKMGN5Z3BMRnh1SUNBZ0lDQWdJQ0FnSUhKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lBOUlISmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGMwWnliMjFFWldacGJtbDBhVzl1S0dSbFptbHVhWFJwYjI0cExGeHVJQ0FnSUNBZ0lDQWdJSEpsWTNWeWMybDJaVkoxYkdWT1lXMWxjMHhsYm1kMGFDQTlJSEpsWTNWeWMybDJaVkoxYkdWT1lXMWxjeTVzWlc1bmRHZ3NYRzRnSUNBZ0lDQWdJQ0FnWkdWbWFXNXBkR2x2YmxKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0Z1BTQW9jbVZqZFhKemFYWmxVblZzWlU1aGJXVnpUR1Z1WjNSb0lENGdNQ2s3WEc1Y2JpQWdJQ0JwWmlBb1pHVm1hVzVwZEdsdmJsSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNHBJSHRjYmlBZ0lDQWdJSEpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRnUFNCdVpYY2dVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaWgwZVhCbExDQndZWEowY3l3Z2NuVnNaVTVoYldVc0lHUmxabWx1YVhScGIyNHNJSEpsWTNWeWMybDJaVkoxYkdWT1lXMWxjeWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNDdYRzRnSUgxY2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlpd2lkSGx3WlNJc0luQmhjblJ6SWl3aWNuVnNaVTVoYldVaUxDSmtaV1pwYm1sMGFXOXVJaXdpY21WamRYSnphWFpsVW5Wc1pVNWhiV1Z6SWl3aVoyVjBWSGx3WlNJc0ltZGxkRkoxYkdWT1lXMWxJaXdpWjJWMFJHVm1hVzVwZEdsdmJpSXNJbWRsZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lJc0luSmxjR3hoWTJVaUxDSnlkV3hsVFdGd0lpd2ljblZzWlNJc0luSmxjR3hoWTJWa1JHVm1hVzVwZEdsdmJpSXNJbkpsY0d4aFkyVnRaVzUwUkdWbWFXNXBkR2x2YmlJc0luSmxjR3hoWTJWRVpXWnBibWwwYVc5dUlpd2labkp2YlZKMWJHVk9ZVzFsUVc1a1JHVm1hVzVwZEdsdmJpSXNJbkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRpTENKU1JVTlZVbE5KVmtWZlZGbFFSU0lzSW1kbGRGQmhjblJ6SWl3aWNtVmpkWEp6YVhabFVuVnNaVTVoYldWelJuSnZiVVJsWm1sdWFYUnBiMjRpTENKeVpXTjFjbk5wZG1WU2RXeGxUbUZ0WlhOTVpXNW5kR2dpTENKc1pXNW5kR2dpTENKa1pXWnBibWwwYVc5dVVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpSXNJa1JsWm1sdWFYUnBiMjRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEVOQlFWa3NWMEZCUVN4RFFVRkRPenM3UlVGQllqdDNRa0ZCUVR0QlFVVXlRaXhIUVVGbExFTkJRV1lzWVVGQlpUdEJRVVZxUWl4SFFVRnRRaXhEUVVGdVFpeExRVUZ0UWp0QlFVTmlMRWRCUVZVc1EwRkJWaXhOUVVGVk8wRkJRMUVzUjBGQmVVSXNRMEZCZWtJc1YwRkJlVUk3T3pzN096czdPenM3T3pzN096czRSRUZPTVVVN2MwTkJRVUU3TmtSQlFVRTdhVVZCUVVFN096czdkMFZCUVVFN1owVkJRVUU3T3pzN096dExRVUZCT3pzN096czdPenM3T3pzN08wMUJRVUU3ZVVSQlFVRTdPenM3T3pzN096czdkVUpCUVVFN08wdEJRVUU3T3pzN01rSkJRVUU3T3pzN096czdPM0ZHUVVGQk96czdPenM3T3pzN096czdiVVZCUVVFN08ybEVRVUZCT3pzN096dEJRVkZsTEVkQlFVc3NRMEZCUTBFc2JVSkJRVzFDTEdsQ1FVRjZRaXhSUVVGUk96aERRVkoyUWpzN1lVRlJjVUpCTEcxQ1FVRnRRaXhEUVVNeFFrTXNTVUZCU1N4RlFVRkZReXhMUVVGTExFVkJRVVZETEZGQlFWRXNSVUZCUlVNc1ZVRkJWU3hGUVVGRlF5eHJRa0ZCYTBJN2EwUkJWRzVGT3p0clEwRlZWVWdzUzBGQlN5eERRMVptTEVORVZXbENPMk5CUlZKRUxFbEJRVWtzUjBGQlIwRXNTVUZCU1N4RFFVRkRPMk5CUTFwRkxGRkJRVkVzUjBGQlIwRXNVVUZCVVN4RFFVRkRPMk5CUTNCQ1F5eFZRVUZWTEVkQlFVZEJMRlZCUVZVc1EwRkJRenRqUVVONFFrTXNhMEpCUVd0Q0xFZEJRVWRCTEd0Q1FVRnJRaXhEUVVGRE96czdPenRaUVVjdlEwTXNSMEZCVHl4RlFVRlFRU3hEUVVGUE8yMUNRVUZRUVN4UlFVRlJMRU5CUVZKQkxFOUJRVThzUjBGQlJ5eERRVUZETzJkQ1FVTlVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU5NTEVsQlFVazdXVUZEYkVJc1EwRkJRenM3TzFsQlJVUk5MRWRCUVZjc1JVRkJXRUVzUTBGQlZ6dHRRa0ZCV0VFc1VVRkJVU3hEUVVGU1FTeFhRVUZYTEVkQlFVY3NRMEZCUXp0blFrRkRZaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZEU2l4UlFVRlJPMWxCUTNSQ0xFTkJRVU03T3p0WlFVVkVTeXhIUVVGaExFVkJRV0pCTEVOQlFXRTdiVUpCUVdKQkxGRkJRVkVzUTBGQlVrRXNZVUZCWVN4SFFVRkhMRU5CUVVNN1owSkJRMllzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUTBvc1ZVRkJWVHRaUVVONFFpeERRVUZET3pzN1dVRkZSRXNzUjBGQmNVSXNSVUZCY2tKQkxFTkJRWEZDTzIxQ1FVRnlRa0VzVVVGQlVTeERRVUZTUVN4eFFrRkJjVUlzUjBGQlJ5eERRVUZETzJkQ1FVTjJRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZEU2l4clFrRkJhMEk3V1VGRGFFTXNRMEZCUXpzN08xbEJSVVJMTEVkQlFVOHNSVUZCVUVFc1EwRkJUenR0UWtGQlVFRXNVVUZCVVVNc1EwRkJVa1FzVDBGQlR5eERRVUZEUXl4UFFVRlBMRVZCUVVVc1EwRkJRenRuUWtGRGFFSXNSMEZCU3l4RFFVRkRReXhKUVVGSkxFZEJRVWRFTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVOU0xGRkJRVkVzUzBGQlN5eEpRVUZKTEVWQlEzSkRWU3hyUWtGQmEwSXNSMEZCUnl4SlFVRkpMRU5CUVVOVUxGVkJRVlVzUlVGRGNFTlZMSEZDUVVGeFFpeEhRVUZITEVsQlFVa3NSVUZCUlN4RlFVRkhMRUZCUVVnc1EwRkJSenRuUWtGRmRrTkdMRWxCUVVrc1EwRkJRMGNzYVVKQlFXbENMRU5CUVVOR0xHdENRVUZyUWl4RlFVRkZReXh4UWtGQmNVSXNRMEZCUXl4RFFVRkRPMWxCUTNCRkxFTkJRVU03T3pzN1dVRkZUVVVzUjBGQmVVSXNSVUZCZWtKQkxFTkJRWGxDTzIxQ1FVRm9ReXhSUVVGUkxFTkJRVVJCTEhsQ1FVRjVRaXhEUVVGRFlpeFJRVUZSTEVWQlFVVkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8yZENRVU4wUkN4SFFVRkhMRU5CUVVOaExHMUNRVUZ0UWl4SFFVRkhMRWxCUVVrN1owSkJSVGxDTEVkQlFVc3NRMEZCUTJoQ0xFbEJRVWtzUjBGQlIybENMRTFCUVdNc2FVSkJRM0pDYUVJc1MwRkJTeXhIUVVGSFJTeFZRVUZWTEVOQlFVTmxMRkZCUVZFc1NVRkRNMEprTEd0Q1FVRnJRaXhQUVVGSFpTeFhRVUZuUXl4dFEwRkJRMmhDTEZWQlFWVXNSMEZEYUVWcFFpeDNRa0ZCZDBJc1IwRkJSMmhDTEd0Q1FVRnJRaXhEUVVGRGFVSXNUVUZCVFN4RlFVTndSRU1zTmtKQlFUWkNMRWRCUVVsR0xIZENRVUYzUWl4SFFVRkhMRU5CUVVNN1owSkJSVzVGTEVWQlFVVXNSVUZCUlVVc05rSkJRVFpDTEVWQlFVVXNRMEZCUXp0dlFrRkRiRU5PTEcxQ1FVRnRRaXhIUVVGSExFZEJRVWNzUTBGQlEycENMRzFDUVVGdFFpeERRVUZEUXl4SlFVRkpMRVZCUVVWRExFdEJRVXNzUlVGQlJVTXNVVUZCVVN4RlFVRkZReXhWUVVGVkxFVkJRVVZETEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03WjBKQlEzWkhMRU5CUVVNN1owSkJSVVFzVFVGQlRTeERRVUZEV1N4dFFrRkJiVUk3V1VGRE5VSXNRMEZCUXpzN1RVRjRSRWc3TzBWQlVXbEVUeXhoUVVGVk8ydENRVUYwUTNoQ0xHMUNRVUZ0UWl4QlFWSjRReUo5IiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yZWN1cnNpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL3JlY3Vyc2l2ZVwiKSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIF9kZWZpbml0aW9uID0gcmVxdWlyZShcIi4uL3V0aWxpdGllcy9kZWZpbml0aW9uXCIpO1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxudmFyIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0O1xuICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG59XG52YXIgTGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJlY3Vyc2l2ZURlZmluaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoTGVmdFJlY3Vyc2l2ZURlZmluaXRpb24sIFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTGVmdFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuICAgIGZ1bmN0aW9uIExlZnRSZWN1cnNpdmVEZWZpbml0aW9uKHR5cGUsIHBhcnRzLCBydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbik7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBwYXJ0cywgcnVsZU5hbWUsIGRlZmluaXRpb24sIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gICAgICAgIF90aGlzLmxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0TGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlZnRSZWN1cnNpdmVSdWxlTmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJld3JpdGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXdyaXRlKHJ1bGVNYXApIHtcbiAgICAgICAgICAgIC8vL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVJ1bGVOYW1lQW5kRGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SdWxlTmFtZUFuZERlZmluaXRpb24ocnVsZU5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gKDAsIF9kZWZpbml0aW9uKS5sZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiksIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNMZW5ndGggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmxlbmd0aCwgZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfdHlwZXMuTEVGVF9SRUNVUlNJVkVfVFlQRSwgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksIHJlY3Vyc2l2ZVJ1bGVOYW1lcyA9ICgwLCBfZGVmaW5pdGlvbikucmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gbmV3IExlZnRSZWN1cnNpdmVEZWZpbml0aW9uKHR5cGUsIHBhcnRzLCBydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIExlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xufShfcmVjdXJzaXZlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGVmdFJlY3Vyc2l2ZURlZmluaXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMMnhsWm5SU1pXTjFjbk5wZG1VdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWENKMWMyVWdjM1J5YVdOMFhDSTdYRzVjYm1sdGNHOXlkQ0JTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk5a1pXWnBibWwwYVc5dUwzSmxZM1Z5YzJsMlpWd2lPMXh1WEc1cGJYQnZjblFnZXlCTVJVWlVYMUpGUTFWU1UwbFdSVjlVV1ZCRklIMGdabkp2YlNCY0lpNHVMM1I1Y0dWelhDSTdYRzVwYlhCdmNuUWdleUJ5WldOMWNuTnBkbVZTZFd4bFRtRnRaWE5HY205dFJHVm1hVzVwZEdsdmJpd2diR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsYzBaeWIyMUVaV1pwYm1sMGFXOXVJSDBnWm5KdmJTQmNJaTR1TDNWMGFXeHBkR2xsY3k5a1pXWnBibWwwYVc5dVhDSTdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklFeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1SUdWNGRHVnVaSE1nVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmlCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0hSNWNHVXNJSEJoY25SekxDQnlkV3hsVG1GdFpTd2daR1ZtYVc1cGRHbHZiaXdnY21WamRYSnphWFpsVW5Wc1pVNWhiV1Z6TENCc1pXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpLU0I3WEc0Z0lDQWdjM1Z3WlhJb2RIbHdaU3dnY0dGeWRITXNJSEoxYkdWT1lXMWxMQ0JrWldacGJtbDBhVzl1TENCeVpXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNcE8xeHVYRzRnSUNBZ2RHaHBjeTVzWldaMFVtVmpkWEp6YVhabFVuVnNaVTVoYldWeklEMGdiR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3p0Y2JpQWdmVnh1WEc0Z0lHZGxkRXhsWm5SU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXViR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3p0Y2JpQWdmVnh1WEc0Z0lISmxkM0pwZEdVb2NuVnNaVTFoY0NrZ2UxeHVJQ0FnSUM4dkwxeHVJQ0I5WEc1Y2JpQWdjM1JoZEdsaklHWnliMjFTZFd4bFRtRnRaVUZ1WkVSbFptbHVhWFJwYjI0b2NuVnNaVTVoYldVc0lHUmxabWx1YVhScGIyNHBJSHRjYmlBZ0lDQnNaWFFnYkdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNGdQU0J1ZFd4c08xeHVYRzRnSUNBZ1kyOXVjM1FnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGN5QTlJR3hsWm5SU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlhOR2NtOXRSR1ZtYVc1cGRHbHZiaWhrWldacGJtbDBhVzl1S1N4Y2JpQWdJQ0FnSUNBZ0lDQnNaV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1Z6VEdWdVozUm9JRDBnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGN5NXNaVzVuZEdnc1hHNGdJQ0FnSUNBZ0lDQWdaR1ZtYVc1cGRHbHZia3hsWm5SU1pXTjFjbk5wZG1VZ1BTQW9iR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsYzB4bGJtZDBhQ0ErSURBcE8xeHVYRzRnSUNBZ2FXWWdLR1JsWm1sdWFYUnBiMjVNWldaMFVtVmpkWEp6YVhabEtTQjdYRzRnSUNBZ0lDQmpiMjV6ZENCMGVYQmxJRDBnVEVWR1ZGOVNSVU5WVWxOSlZrVmZWRmxRUlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSEJoY25SeklEMGdaR1ZtYVc1cGRHbHZiaTVuWlhSUVlYSjBjeWdwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZqZFhKemFYWmxVblZzWlU1aGJXVnpJRDBnY21WamRYSnphWFpsVW5Wc1pVNWhiV1Z6Um5KdmJVUmxabWx1YVhScGIyNG9aR1ZtYVc1cGRHbHZiaWs3WEc1Y2JpQWdJQ0FnSUd4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVJRDBnYm1WM0lFeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1S0hSNWNHVXNJSEJoY25SekxDQnlkV3hsVG1GdFpTd2daR1ZtYVc1cGRHbHZiaXdnY21WamRYSnphWFpsVW5Wc1pVNWhiV1Z6TENCc1pXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200Z2JHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjQ3WEc0Z0lIMWNibjFjYmlKZExDSnVZVzFsY3lJNld5Sk1aV1owVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmlJc0luUjVjR1VpTENKd1lYSjBjeUlzSW5KMWJHVk9ZVzFsSWl3aVpHVm1hVzVwZEdsdmJpSXNJbkpsWTNWeWMybDJaVkoxYkdWT1lXMWxjeUlzSW14bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpYTWlMQ0puWlhSTVpXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpJaXdpY21WM2NtbDBaU0lzSW5KMWJHVk5ZWEFpTENKbWNtOXRVblZzWlU1aGJXVkJibVJFWldacGJtbDBhVzl1SWl3aWJHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRpTENKc1pXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpSbkp2YlVSbFptbHVhWFJwYjI0aUxDSnNaV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1Z6VEdWdVozUm9JaXdpYkdWdVozUm9JaXdpWkdWbWFXNXBkR2x2Ymt4bFpuUlNaV04xY25OcGRtVWlMQ0pNUlVaVVgxSkZRMVZTVTBsV1JWOVVXVkJGSWl3aVoyVjBVR0Z5ZEhNaUxDSnlaV04xY25OcGRtVlNkV3hsVG1GdFpYTkdjbTl0UkdWbWFXNXBkR2x2YmlJc0lsSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNGlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRU5CUVZrc1YwRkJRU3hEUVVGRE96czdSVUZCWWp0M1FrRkJRVHRCUVVWblF5eEhRVUY1UWl4RFFVRjZRaXhWUVVGNVFqdEJRVVZ5UWl4SFFVRlZMRU5CUVZZc1RVRkJWVHRCUVVONVF5eEhRVUY1UWl4RFFVRjZRaXhYUVVGNVFqczdPenM3T3pzN096czdPenM3T3poRVFVeG9TRHR6UTBGQlFUczJSRUZCUVR0cFJVRkJRVHM3T3p0M1JVRkJRVHRuUlVGQlFUczdPenM3TzB0QlFVRTdPenM3T3pzN096czdPenM3VFVGQlFUdDVSRUZCUVRzN096czdPenM3T3pzN096czdPM1ZDUVVGQk96dExRVUZCT3pzN096SkNRVUZCT3pzN096czdPenR4UmtGQlFUczdPenM3T3pzN096czdPMjFGUVVGQk96dHBSRUZCUVRzN096czdRVUZQWlN4SFFVRkxMRU5CUVVOQkxIVkNRVUYxUWl4cFFrRkJOMElzVVVGQlVUc3lSRUZRZGtJN08yRkJUM0ZDUVN4MVFrRkJkVUlzUTBGRE9VSkRMRWxCUVVrc1JVRkJSVU1zUzBGQlN5eEZRVUZGUXl4UlFVRlJMRVZCUVVWRExGVkJRVlVzUlVGQlJVTXNhMEpCUVd0Q0xFVkJRVVZETEhOQ1FVRnpRanR6UkVGU00wWTdPMnREUVZOVlRDeEpRVUZKTEVWQlFVVkRMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeEZRVUZGUXl4VlFVRlZMRVZCUVVWRExHdENRVUZyUWl4RFExUXZSQ3hEUkZOcFJUdGpRVVY0UkVNc2MwSkJRWE5DTEVkQlFVZEJMSE5DUVVGelFpeERRVUZET3pzN096dFpRVWQyUkVNc1IwRkJlVUlzUlVGQmVrSkJMRU5CUVhsQ08yMUNRVUY2UWtFc1VVRkJVU3hEUVVGU1FTeDVRa0ZCZVVJc1IwRkJSeXhEUVVGRE8yZENRVU16UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRFJDeHpRa0ZCYzBJN1dVRkRjRU1zUTBGQlF6czdPMWxCUlVSRkxFZEJRVThzUlVGQlVFRXNRMEZCVHp0dFFrRkJVRUVzVVVGQlVVTXNRMEZCVWtRc1QwRkJUeXhEUVVGRFF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVTm9RaXhGUVVGSExFRkJRVWdzUTBGQlJ6dFpRVU5NTEVOQlFVTTdPenM3V1VGRlRVTXNSMEZCZVVJc1JVRkJla0pCTEVOQlFYbENPMjFDUVVGb1F5eFJRVUZSTEVOQlFVUkJMSGxDUVVGNVFpeERRVUZEVUN4UlFVRlJMRVZCUVVWRExGVkJRVlVzUlVGQlJTeERRVUZETzJkQ1FVTjBSQ3hIUVVGSExFTkJRVU5QTEhWQ1FVRjFRaXhIUVVGSExFbEJRVWs3WjBKQlJXeERMRWRCUVVzc1EwRkJRMHdzYzBKQlFYTkNMRTlCUVVkTkxGZEJRVzlETEhWRFFVRkRVaXhWUVVGVkxFZEJRM2hGVXl3MFFrRkJORUlzUjBGQlIxQXNjMEpCUVhOQ0xFTkJRVU5STEUxQlFVMHNSVUZETlVSRExIVkNRVUYxUWl4SFFVRkpSaXcwUWtGQk5FSXNSMEZCUnl4RFFVRkRPMmRDUVVWcVJTeEZRVUZGTEVWQlFVVkZMSFZDUVVGMVFpeEZRVUZGTEVOQlFVTTdiMEpCUXpWQ0xFZEJRVXNzUTBGQlEyUXNTVUZCU1N4SFFVRkhaU3hOUVVGdFFpeHpRa0ZETVVKa0xFdEJRVXNzUjBGQlIwVXNWVUZCVlN4RFFVRkRZU3hSUVVGUkxFbEJRek5DV2l4clFrRkJhMElzVDBGQlIyRXNWMEZCWjBNc2JVTkJRVU5rTEZWQlFWVTdiMEpCUlhSRlR5eDFRa0ZCZFVJc1IwRkJSeXhIUVVGSExFTkJRVU5ZTEhWQ1FVRjFRaXhEUVVGRFF5eEpRVUZKTEVWQlFVVkRMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeEZRVUZGUXl4VlFVRlZMRVZCUVVWRExHdENRVUZyUWl4RlFVRkZReXh6UWtGQmMwSXNRMEZCUXl4RFFVRkRPMmRDUVVOMlNTeERRVUZETzJkQ1FVVkVMRTFCUVUwc1EwRkJRMHNzZFVKQlFYVkNPMWxCUTJoRExFTkJRVU03TzAxQmRFTklPenRGUVU5eFJGRXNWVUZCYlVJN2EwSkJRVzVFYmtJc2RVSkJRWFZDTEVGQlVEVkRJbjA9IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKHJ1bGVOYW1lLCBjaGlsZE5vZGVzKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQW5kQ2hpbGROb2RlcyhSZWR1Y2VkTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJ1bGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgUmVkdWNlZE5vZGUgZnJvbSBcIi4uL25vZGUvcmVkdWNlZFwiO1xuaW1wb3J0IFJlY3Vyc2l2ZURlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb24vcmVjdXJzaXZlXCI7XG5cbmltcG9ydCB7IGlzSW5zdGFuY2VPZiB9IGZyb20gXCIuLi91dGlsaXRpZXMvY2xhc3NcIjtcbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcbmltcG9ydCB7IERJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUsIElORElSRUNUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRSwgSU1QTElDSVRMWV9MRUZUX1JFQ1VSU0lWRV9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZHVjZWRSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIGlzRW1wdHkoKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbnNMZW5ndGggPSB0aGlzLmRlZmluaXRpb25zLmxlbmd0aCxcbiAgICAgICAgICBlbXB0eSA9IChkZWZpbml0aW9uc0xlbmd0aCA9PT0gMCk7XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGUocnVsZSkge1xuICAgIGxldCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnMuZmlsdGVyKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBsZXQga2VlcCA9IHRydWU7XG5cbiAgICAgIGNvbnN0IGRlZmluaXRpb25SZWN1cnNpdmVEZWZpbml0aW9uID0gaXNJbnN0YW5jZU9mKGRlZmluaXRpb24sIFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvblJlY3Vyc2l2ZURlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgcmVjdXJzaXZlRGVmaW5pdGlvbiA9IGRlZmluaXRpb24sIC8vL1xuICAgICAgICAgICAgICB0eXBlID0gcmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRUeXBlKCk7XG5cbiAgICAgICAga2VlcCA9ICh0eXBlICE9PSBESVJFQ1RMWV9MRUZUX1JFQ1VSU0lWRV9UWVBFKSAmJlxuICAgICAgICAgICAgICAgKHR5cGUgIT09IElORElSRUNUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRSkgJiZcbiAgICAgICAgICAgICAgICh0eXBlICE9PSBJTVBMSUNJVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2VlcFxuICAgIH0pO1xuXG4gICAgY29uc3QgbmFtZSA9IHJlZHVjZWRSdWxlTmFtZSxcbiAgICAgICAgICBhbWJpZ3VvdXMgPSBmYWxzZSxcbiAgICAgICAgICBOb25UZXJtaW5hbE5vZGUgPSBSZWR1Y2VkTm9kZSwgIC8vL1xuICAgICAgICAgIHJlZHVjZWRSdWxlID0gbmV3IFJlZHVjZWRSdWxlKG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vblRlcm1pbmFsTm9kZSk7XG5cbiAgICByZXR1cm4gcmVkdWNlZFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVwZWF0ZWROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUFuZENoaWxkTm9kZXMocnVsZU5hbWUsIGNoaWxkTm9kZXMpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVBbmRDaGlsZE5vZGVzKFJlcGVhdGVkTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJ1bGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgUmVwZWF0ZWROb2RlIGZyb20gXCIuLi9ub2RlL3JlcGVhdGVkXCI7XG5cbmltcG9ydCB7IHJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcGVhdGVkUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbVJ1bGUocnVsZSkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgcmVwZWF0ZWRSdWxlTmFtZSA9IHJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG5hbWUgPSByZXBlYXRlZFJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgYW1iaWd1b3VzID0gZmFsc2UsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXSxcbiAgICAgICAgICBOb25UZXJtaW5hbE5vZGUgPSBSZXBlYXRlZE5vZGUsIC8vL1xuICAgICAgICAgIHJlcGVhdGVkUnVsZSA9IG5ldyBSZXBlYXRlZFJ1bGUobmFtZSwgYW1iaWd1b3VzLCBkZWZpbml0aW9ucywgTm9uVGVybWluYWxOb2RlKTtcblxuICAgIHJldHVybiByZXBlYXRlZFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUGFydHMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IFJ1bGVOYW1lUGFydCwgWmVyb09yTW9yZVBhcnRzUGFydCB9ID0gUGFydHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUsIGxvb2tBaGVhZCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJ1bGVOYW1lUGFydCA9IG5ldyBSdWxlTmFtZVBhcnQocnVsZU5hbWUsIGxvb2tBaGVhZCk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lUGFydDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm9Pck1vcmVSdWxlTmFtZVBhcnRQYXJ0RnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lUGFydCA9IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgIHplcm9Pck1vcmVSdWxlTmFtZVBhcnRQYXJ0ID0gbmV3IFplcm9Pck1vcmVQYXJ0c1BhcnQocnVsZU5hbWVQYXJ0KTtcblxuICByZXR1cm4gemVyb09yTW9yZVJ1bGVOYW1lUGFydFBhcnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgeyBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhcnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlTmFtZURlZmluaXRpb24gPSBuZXcgUnVsZU5hbWVEZWZpbml0aW9uKHBhcnRzKTtcblxuICAgIHJldHVybiBydWxlTmFtZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUnVsZSB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBSdWxlTmFtZURlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb24vcnVsZU5hbWVcIjtcbmltcG9ydCBSZWN1cnNpdmVEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uL3JlY3Vyc2l2ZVwiO1xuXG5pbXBvcnQgeyBpc0luc3RhbmNlT2YgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NsYXNzXCI7XG5pbXBvcnQgeyByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5pbXBvcnQgeyBESVJFQ1RMWV9MRUZUX1JFQ1VSU0lWRV9UWVBFLCBJTkRJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUsIElNUExJQ0lUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXdyaXR0ZW5SdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tUnVsZShydWxlKSB7XG4gICAgbGV0IGRlZmluaXRpb25zID0gcnVsZS5nZXREZWZpbml0aW9ucygpO1xuXG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICByZWR1Y2VkUnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHJlZHVjZWRSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJlZHVjZWRSdWxlTmFtZSk7XG5cbiAgICBkZWZpbml0aW9ucyA9IGRlZmluaXRpb25zLmZpbHRlcigoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgbGV0IGtlZXAgPSBmYWxzZTtcblxuICAgICAgY29uc3QgZGVmaW5pdGlvblJlY3Vyc2l2ZURlZmluaXRpb24gPSBpc0luc3RhbmNlT2YoZGVmaW5pdGlvbiwgUmVjdXJzaXZlRGVmaW5pdGlvbik7XG5cbiAgICAgIGlmIChkZWZpbml0aW9uUmVjdXJzaXZlRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCByZWN1cnNpdmVEZWZpbml0aW9uID0gZGVmaW5pdGlvbiwgLy8vXG4gICAgICAgICAgICAgIHR5cGUgPSByZWN1cnNpdmVEZWZpbml0aW9uLmdldFR5cGUoKTtcblxuICAgICAgICBrZWVwID0gKHR5cGUgPT09IERJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUpIHx8XG4gICAgICAgICAgICAgICAodHlwZSA9PT0gSU5ESVJFQ1RMWV9MRUZUX1JFQ1VSU0lWRV9UWVBFKSB8fFxuICAgICAgICAgICAgICAgKHR5cGUgPT09IElNUExJQ0lUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZWVwO1xuICAgIH0pO1xuXG4gICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAuLi5kZWZpbml0aW9ucyxcbiAgICAgIHJlZHVjZWRSdWxlTmFtZURlZmluaXRpb25cbiAgICBdO1xuXG4gICAgY29uc3QgbmFtZSA9IHJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgYW1iaWd1b3VzID0gcnVsZS5pc0FtYmlndW91cygpLFxuICAgICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHJ1bGUuZ2V0Tm9uVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgcmV3cml0dGVuUnVsZSA9IG5ldyBSZXdyaXR0ZW5SdWxlKG5hbWUsIGFtYmlndW91cywgZGVmaW5pdGlvbnMsIE5vblRlcm1pbmFsTm9kZSk7XG5cbiAgICByZXR1cm4gcmV3cml0dGVuUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVQYXJ0cyhwYXJ0cykge1xuICBwYXJ0cyA9IHBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jbG9uZSgpKTtcblxuICByZXR1cm4gcGFydHM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgeyBjbG9uZVBhcnRzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJ0c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXBlYXRlZERlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21EZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICBsZXQgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCk7XG5cbiAgICBwYXJ0cyA9IGNsb25lUGFydHMocGFydHMpOyAgLy8vXG5cbiAgICBwYXJ0cy5zaGlmdCgpOyAgLy8vXG5cbiAgICBjb25zdCByZXBlYXRlZERlZmluaXRpb24gPSBuZXcgUmVwZWF0ZWREZWZpbml0aW9uKHBhcnRzKTtcblxuICAgIHJldHVybiByZXBlYXRlZERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRGVmaW5pdGlvbiB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCB7IGNsb25lUGFydHMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhcnRzXCI7XG5pbXBvcnQgeyBpc0RlZmluaXRpb25Mb29rQWhlYWQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2RlZmluaXRpb25cIjtcbmltcG9ydCB7IHJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUsIHJlZHVjZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcbmltcG9ydCB7IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZSwgemVyb09yTW9yZVJ1bGVOYW1lUGFydFBhcnRGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhcnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbURlZmluaXRpb25BbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUoZGVmaW5pdGlvbiwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gICAgbGV0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gICAgcGFydHMgPSBjbG9uZVBhcnRzKHBhcnRzKTsgIC8vL1xuXG4gICAgcGFydHMuc2hpZnQoKTsgIC8vL1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbkxvb2tBaGVhZCA9IGlzRGVmaW5pdGlvbkxvb2tBaGVhZChkZWZpbml0aW9uKSxcbiAgICAgICAgICBsb29rQWhlYWQgPSBkZWZpbml0aW9uTG9va0FoZWFkLCAgLy8vXG4gICAgICAgICAgcmVwZWF0ZWRSdWxlTmFtZSA9IHJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUobGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSxcbiAgICAgICAgICByZWR1Y2VkTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKGxlZnRSZWN1cnNpdmVSdWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gemVyb09yTW9yZVJ1bGVOYW1lUGFydFBhcnRGcm9tUnVsZU5hbWUocmVwZWF0ZWRSdWxlTmFtZSksXG4gICAgICAgICAgcmVkdWNlZExlZnRSZWN1cnNpdmVSdWxlTmFtZVBhcnQgPSBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUocmVkdWNlZExlZnRSZWN1cnNpdmVSdWxlTmFtZSwgbG9va0FoZWFkKSxcbiAgICAgICAgICByZXdyaXR0ZW5EZWZpbml0aW9uID0gbmV3IFJld3JpdHRlbkRlZmluaXRpb24ocGFydHMpO1xuXG4gICAgcGFydHMudW5zaGlmdChyZWR1Y2VkTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lUGFydCk7XG5cbiAgICBwYXJ0cy5wdXNoKHplcm9Pck1vcmVSZXBlYXRlZFJ1bGVOYW1lUGFydCk7XG5cbiAgICByZXR1cm4gcmV3cml0dGVuRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVkdWNlZFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGUvcmVkdWNlZFwiO1xuaW1wb3J0IFJlcGVhdGVkUnVsZSBmcm9tIFwiLi4vLi4vcnVsZS9yZXBlYXRlZFwiO1xuaW1wb3J0IFJld3JpdHRlblJ1bGUgZnJvbSBcIi4uLy4uL3J1bGUvcmV3cml0dGVuXCI7XG5pbXBvcnQgUmVwZWF0ZWREZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3JlcGVhdGVkXCI7XG5pbXBvcnQgUmV3cml0dGVuRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9yZXdyaXR0ZW5cIjtcbmltcG9ydCBMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9sZWZ0UmVjdXJzaXZlXCI7XG5cbmltcG9ydCB7IERJUkVDVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHJlZHVjZWRSdWxlRnJvbVJ1bGUsIHJlcGVhdGVkUnVsZUZyb21SdWxlLCByZXdyaXR0ZW5SdWxlRnJvbVJ1bGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3J1bGVcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvblVuYXJ5LCBpc0RlZmluaXRpb25Db21wbGV4LCByZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbiwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9kZWZpbml0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gZXh0ZW5kcyBMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiB7XG4gIHJld3JpdGUocnVsZU1hcCkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmdldERlZmluaXRpb24oKSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRoaXMuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0gfHwgbnVsbDtcblxuICAgIGNvbnN0IHJlZHVjZWRSdWxlID0gcmVkdWNlZFJ1bGVGcm9tUnVsZShydWxlLCBydWxlTWFwLCBSZWR1Y2VkUnVsZSksXG4gICAgICAgICAgcmVkdWNlZFJ1bGVFbXB0eSA9IHJlZHVjZWRSdWxlLmlzRW1wdHkoKTtcblxuICAgIGlmIChyZWR1Y2VkUnVsZUVtcHR5KSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uU3RyaW5nID0gZGVmaW5pdGlvbi5hc1N0cmluZygpO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtkZWZpbml0aW9uU3RyaW5nfScgZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbiBvZiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlIGhhcyBubyBzaWJsaW5nIG5vbi1sZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9ucyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSByZXdyaXR0ZW4uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gcnVsZU5hbWU7IC8vL1xuXG4gICAgY29uc3QgcmVwZWF0ZWRSdWxlID0gcmVwZWF0ZWRSdWxlRnJvbVJ1bGUocnVsZSwgcnVsZU1hcCwgUmVwZWF0ZWRSdWxlKSxcbiAgICAgICAgICByZXBlYXRlZERlZmluaXRpb24gPSBSZXBlYXRlZERlZmluaXRpb24uZnJvbURlZmluaXRpb24oZGVmaW5pdGlvbik7XG5cbiAgICByZXBlYXRlZFJ1bGUuYWRkRGVmaW5pdGlvbihyZXBlYXRlZERlZmluaXRpb24pO1xuXG4gICAgY29uc3QgcmV3cml0dGVuUnVsZSA9IHJld3JpdHRlblJ1bGVGcm9tUnVsZShydWxlLCBydWxlTWFwLCBSZXdyaXR0ZW5SdWxlKSxcbiAgICAgICAgICByZXdyaXR0ZW5EZWZpbml0aW9uID0gUmV3cml0dGVuRGVmaW5pdGlvbi5mcm9tRGVmaW5pdGlvbkFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShkZWZpbml0aW9uLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICAgIHJlcGxhY2VtZW50RGVmaW5pdGlvbiA9IHRoaXM7IC8vL1xuXG4gICAgcmV3cml0dGVuUnVsZS5yZXBsYWNlRGVmaW5pdGlvbihyZXBsYWNlbWVudERlZmluaXRpb24sIHJld3JpdHRlbkRlZmluaXRpb24pO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUFuZERlZmluaXRpb24ocnVsZU5hbWUsIGRlZmluaXRpb24pIHtcbiAgICBsZXQgZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IG51bGw7XG5cbiAgICBjb25zdCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uKGRlZmluaXRpb24pLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNMZW5ndGggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmxlbmd0aCxcbiAgICAgICAgICBkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSA9IChsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID4gMCk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUpIHtcbiAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMuc29tZSgobGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJ1bGVOYW1lTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpO1xuXG4gICAgICAgIGlmIChydWxlTmFtZUxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25VbmFyeSA9IGlzRGVmaW5pdGlvblVuYXJ5KGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25VbmFyeSkge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyB1bmFyeSBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSByZXdyaXR0ZW4uYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGVmaW5pdGlvbkNvbXBsZXggPSBpc0RlZmluaXRpb25Db21wbGV4KGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25Db21wbGV4KSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uU3RyaW5nID0gZGVmaW5pdGlvbi5hc1N0cmluZygpO1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtkZWZpbml0aW9uU3RyaW5nfScgZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbiBvZiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlIGlzIGNvbXBsZXggYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgcmV3cml0dGVuLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHR5cGUgPSBESVJFQ1RMWV9MRUZUX1JFQ1VSU0lWRV9UWVBFLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzID0gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbik7XG5cbiAgICAgICAgICBkaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gbmV3IERpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24odHlwZSwgcGFydHMsIHJ1bGVOYW1lLCBkZWZpbml0aW9uLCByZWN1cnNpdmVSdWxlTmFtZXMsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25lY2Vzc2FyeSA9IHJlcXVpcmUoXCJuZWNlc3NhcnlcIik7XG52YXIgX2xlZnRSZWN1cnNpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9kZWZpbml0aW9uL2xlZnRSZWN1cnNpdmVcIikpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIGZpcnN0ID0gX25lY2Vzc2FyeS5hcnJheVV0aWxpdGllcy5maXJzdDtcbnZhciBJbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKExlZnRSZWN1cnNpdmVEZWZpbml0aW9uKSB7XG4gICAgX2luaGVyaXRzKEltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiwgTGVmdFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24odHlwZSwgcGFydHMsIHJ1bGVOYW1lLCBkZWZpbml0aW9uLCByZWN1cnNpdmVSdWxlTmFtZXMsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMsIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgcGFydHMsIHJ1bGVOYW1lLCBkZWZpbml0aW9uLCByZWN1cnNpdmVSdWxlTmFtZXMsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuICAgICAgICBfdGhpcy5sZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhJbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldExlZnRSZWN1cnNpdmVEZWZpbml0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UocnVsZU1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gcnVsZU1hcFt0aGlzLnJ1bGVOYW1lXSB8fCBudWxsLCByZXBsYWNlZERlZmluaXRpb24gPSB0aGlzLmxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLCByZXBsYWNlbWVudERlZmluaXRpb24gPSB0aGlzOyAvLy9cbiAgICAgICAgICAgICAgICBydWxlLnJlcGxhY2VEZWZpbml0aW9uKHJlcGxhY2VkRGVmaW5pdGlvbiwgcmVwbGFjZW1lbnREZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21SdWxlTmFtZUxlZnRSZWN1cnNpdmVSdWxlTmFtZUFuZFJlY3Vyc2l2ZURlZmluaXRpb25zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVJ1bGVOYW1lTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lQW5kUmVjdXJzaXZlRGVmaW5pdGlvbnMocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgcmVjdXJzaXZlRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSBmaW5kTGVmdFJlY3Vyc2l2ZURlZmluaXRpb24ocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgcmVjdXJzaXZlRGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF90eXBlcy5JTVBMSUNJVExZX0xFRlRfUkVDVVJTSVZFX1RZUEUsIHBhcnRzID0gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24uZ2V0UGFydHMoKSwgXyRydWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFJ1bGVOYW1lKCksIGRlZmluaXRpb24gPSBudWxsLCByZWN1cnNpdmVSdWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRSZWN1cnNpdmVSdWxlTmFtZXMoKSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldExlZnRSZWN1cnNpdmVSdWxlTmFtZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gbmV3IEltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbih0eXBlLCBwYXJ0cywgXyRydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gSW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xufShfbGVmdFJlY3Vyc2l2ZS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbjtcbmZ1bmN0aW9uIGZpbmRMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbihydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lLCByZWN1cnNpdmVEZWZpbml0aW9ucykge1xuICAgIHZhciBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IG51bGw7XG4gICAgdmFyIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uc1BhdGggPSBmaW5kTGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aChydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lLCByZWN1cnNpdmVEZWZpbml0aW9ucyk7XG4gICAgaWYgKGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uc1BhdGggIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGZpcnN0TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSBmaXJzdChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoKTtcbiAgICAgICAgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSBmaXJzdExlZnRSZWN1cnNpdmVEZWZpbml0aW9uOyAvLy9cbiAgICB9XG4gICAgcmV0dXJuIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xufVxuZnVuY3Rpb24gZmluZFJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aChydWxlTmFtZSwgcmVjdXJzaXZlUnVsZU5hbWUsIHJlY3Vyc2l2ZURlZmluaXRpb25zKSB7XG4gICAgdmFyIHJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aCA9IG51bGw7XG4gICAgcmVjdXJzaXZlRGVmaW5pdGlvbnMuc29tZShmdW5jdGlvbihyZWN1cnNpdmVEZWZpbml0aW9uLCBpbmRleCkge1xuICAgICAgICB2YXIgcmVjdXJzaXZlRGVmaW5pdGlvblJ1bGVOYW1lID0gcmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRSdWxlTmFtZSgpLCByZWN1cnNpdmVEZWZpbml0aW9uUnVsZU5hbWVSZWN1cnNpdmVSdWxlTmFtZSA9IHJlY3Vyc2l2ZURlZmluaXRpb25SdWxlTmFtZSA9PT0gcmVjdXJzaXZlUnVsZU5hbWU7XG4gICAgICAgIGlmIChyZWN1cnNpdmVEZWZpbml0aW9uUnVsZU5hbWVSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgICAgcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoID0gcmVjdXJzaXZlRGVmaW5pdGlvbnMuc2xpY2UoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoO1xufVxuZnVuY3Rpb24gZmluZExlZnRSZWN1cnNpdmVEZWZpbml0aW9uc1BhdGgocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgcmVjdXJzaXZlRGVmaW5pdGlvbnMpIHtcbiAgICB2YXIgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aCA9IG51bGw7XG4gICAgdmFyIHJlY3Vyc2l2ZVJ1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lLCByZWN1cnNpdmVEZWZpbml0aW9uc1BhdGggPSBmaW5kUmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoKHJ1bGVOYW1lLCByZWN1cnNpdmVSdWxlTmFtZSwgcmVjdXJzaXZlRGVmaW5pdGlvbnMpO1xuICAgIGlmIChyZWN1cnNpdmVEZWZpbml0aW9uc1BhdGggIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aExlZnRSZWN1cnNpdmUgPSBpc1JlY3Vyc2l2ZURlZmluaXRpb25zUGF0aExlZnRSZWN1cnNpdmUocnVsZU5hbWUsIHJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aCk7XG4gICAgICAgIGlmIChyZWN1cnNpdmVEZWZpbml0aW9uc1BhdGhMZWZ0UmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoID0gcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoOyAvLy9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aDtcbn1cbmZ1bmN0aW9uIGlzUmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoTGVmdFJlY3Vyc2l2ZShydWxlTmFtZSwgcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoKSB7XG4gICAgdmFyIHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21SdWxlTmFtZUFuZFJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aChydWxlTmFtZSwgcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoKSwgcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoTGVmdFJlY3Vyc2l2ZSA9IHJlY3Vyc2l2ZURlZmluaXRpb25zUGF0aC5ldmVyeShmdW5jdGlvbihyZWN1cnNpdmVEZWZpbml0aW9uLCBpbmRleCkge1xuICAgICAgICB2YXIgdHlwZSA9IHJlY3Vyc2l2ZURlZmluaXRpb24uZ2V0VHlwZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gX3R5cGVzLkxFRlRfUkVDVVJTSVZFX1RZUEUpIHtcbiAgICAgICAgICAgIHZhciBfJHJ1bGVOYW1lID0gcnVsZU5hbWVzW2luZGV4XSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IHJlY3Vyc2l2ZURlZmluaXRpb24uZ2V0TGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcygpLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMuaW5jbHVkZXMoXyRydWxlTmFtZSk7XG4gICAgICAgICAgICBpZiAobGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZWN1cnNpdmVEZWZpbml0aW9uc1BhdGhMZWZ0UmVjdXJzaXZlO1xufVxuZnVuY3Rpb24gcnVsZU5hbWVzRnJvbVJ1bGVOYW1lQW5kUmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoKHJ1bGVOYW1lLCByZWN1cnNpdmVEZWZpbml0aW9uc1BhdGgpIHtcbiAgICB2YXIgcnVsZU5hbWVzID0gcmVjdXJzaXZlRGVmaW5pdGlvbnNQYXRoLm1hcChmdW5jdGlvbihyZWN1cnNpdmVEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiByZWN1cnNpdmVEZWZpbml0aW9uLmdldFJ1bGVOYW1lKCk7XG4gICAgfSk7XG4gICAgcnVsZU5hbWVzLnB1c2gocnVsZU5hbWUpO1xuICAgIHZhciBmaXJzdFJ1bGVOYW1lID0gcnVsZU5hbWVzLnNoaWZ0KCksIGxhc3RSdWxlTmFtZSA9IGZpcnN0UnVsZU5hbWU7IC8vL1xuICAgIHJ1bGVOYW1lcy5wdXNoKGxhc3RSdWxlTmFtZSk7XG4gICAgcmV0dXJuIHJ1bGVOYW1lcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OWtaV1pwYm1sMGFXOXVMMnhsWm5SU1pXTjFjbk5wZG1VdmFXMXdiR2xqYVhSc2VTNXFjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXMXdiM0owSUhzZ1lYSnlZWGxWZEdsc2FYUnBaWE1nZlNCbWNtOXRJRndpYm1WalpYTnpZWEo1WENJN1hHNWNibWx0Y0c5eWRDQk1aV1owVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmlCbWNtOXRJRndpTGk0dkxpNHZaR1ZtYVc1cGRHbHZiaTlzWldaMFVtVmpkWEp6YVhabFhDSTdYRzVjYm1sdGNHOXlkQ0I3SUV4RlJsUmZVa1ZEVlZKVFNWWkZYMVJaVUVVc0lFbE5VRXhKUTBsVVRGbGZURVZHVkY5U1JVTlZVbE5KVmtWZlZGbFFSU0I5SUdaeWIyMGdYQ0l1TGk4dUxpOTBlWEJsYzF3aU8xeHVYRzVqYjI1emRDQjdJR1pwY25OMElIMGdQU0JoY25KaGVWVjBhV3hwZEdsbGN6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdZMnhoYzNNZ1NXMXdiR2xqYVhSc2VVeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1SUdWNGRHVnVaSE1nVEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNGdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaDBlWEJsTENCd1lYSjBjeXdnY25Wc1pVNWhiV1VzSUdSbFptbHVhWFJwYjI0c0lISmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGN5d2diR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3l3Z2JHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRwSUh0Y2JpQWdJQ0J6ZFhCbGNpaDBlWEJsTENCd1lYSjBjeXdnY25Wc1pVNWhiV1VzSUdSbFptbHVhWFJwYjI0c0lISmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGN5d2diR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lrN1hHNWNiaUFnSUNCMGFHbHpMbXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlEMGdiR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0N1hHNGdJSDFjYmx4dUlDQm5aWFJNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpZ3BJSHRjYmlBZ0lDQjBhR2x6TG14bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVJRDBnYkdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNDdYRzRnSUgxY2JseHVJQ0J5WlhCc1lXTmxLSEoxYkdWTllYQXBJSHRjYmlBZ0lDQmpiMjV6ZENCeWRXeGxJRDBnY25Wc1pVMWhjRnQwYUdsekxuSjFiR1ZPWVcxbFhTQjhmQ0J1ZFd4c0xGeHVJQ0FnSUNBZ0lDQWdJSEpsY0d4aFkyVmtSR1ZtYVc1cGRHbHZiaUE5SUhSb2FYTXViR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0c0lDQXZMeTljYmlBZ0lDQWdJQ0FnSUNCeVpYQnNZV05sYldWdWRFUmxabWx1YVhScGIyNGdQU0IwYUdsek95QXZMeTljYmx4dUlDQWdJSEoxYkdVdWNtVndiR0ZqWlVSbFptbHVhWFJwYjI0b2NtVndiR0ZqWldSRVpXWnBibWwwYVc5dUxDQnlaWEJzWVdObGJXVnVkRVJsWm1sdWFYUnBiMjRwTzF4dUlDQjlYRzVjYmlBZ2MzUmhkR2xqSUdaeWIyMVNkV3hsVG1GdFpVeGxablJTWldOMWNuTnBkbVZTZFd4bFRtRnRaVUZ1WkZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1ektISjFiR1ZPWVcxbExDQnNaV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1VzSUhKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1ektTQjdYRzRnSUNBZ2JHVjBJR2x0Y0d4cFkybDBiSGxNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpQTlJRzUxYkd3N1hHNWNiaUFnSUNCamIyNXpkQ0JzWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpQTlJR1pwYm1STVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaWh5ZFd4bFRtRnRaU3dnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbExDQnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjeWs3WEc1Y2JpQWdJQ0JwWmlBb2JHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRnSVQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJSFI1Y0dVZ1BTQkpUVkJNU1VOSlZFeFpYMHhGUmxSZlVrVkRWVkpUU1ZaRlgxUlpVRVVzWEc0Z0lDQWdJQ0FnSUNBZ0lDQndZWEowY3lBOUlHeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1TG1kbGRGQmhjblJ6S0Nrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5ZFd4bFRtRnRaU0E5SUd4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVMbWRsZEZKMWJHVk9ZVzFsS0Nrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1SUQwZ2JuVnNiQ3dnTHk4dlhHNGdJQ0FnSUNBZ0lDQWdJQ0J5WldOMWNuTnBkbVZTZFd4bFRtRnRaWE1nUFNCc1pXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaTVuWlhSU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNb0tTeGNiaUFnSUNBZ0lDQWdJQ0FnSUd4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpYTWdQU0JzWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpNW5aWFJNWldaMFVtVmpkWEp6YVhabFVuVnNaVTVoYldWektDazdYRzVjYmlBZ0lDQWdJR2x0Y0d4cFkybDBiSGxNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpQTlJRzVsZHlCSmJYQnNhV05wZEd4NVRHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRvZEhsd1pTd2djR0Z5ZEhNc0lISjFiR1ZPWVcxbExDQmtaV1pwYm1sMGFXOXVMQ0J5WldOMWNuTnBkbVZTZFd4bFRtRnRaWE1zSUd4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpYTXNJR3hsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCeVpYUjFjbTRnYVcxd2JHbGphWFJzZVV4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVPMXh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdacGJtUk1aV1owVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmloeWRXeGxUbUZ0WlN3Z2JHVm1kRkpsWTNWeWMybDJaVkoxYkdWT1lXMWxMQ0J5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1Y3lrZ2UxeHVJQ0JzWlhRZ2JHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRnUFNCdWRXeHNPMXh1WEc0Z0lHTnZibk4wSUd4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjMUJoZEdnZ1BTQm1hVzVrVEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNoeWRXeGxUbUZ0WlN3Z2JHVm1kRkpsWTNWeWMybDJaVkoxYkdWT1lXMWxMQ0J5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1Y3lrN1hHNWNiaUFnYVdZZ0tHeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1YzFCaGRHZ2dJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQmpiMjV6ZENCbWFYSnpkRXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlEMGdabWx5YzNRb2JHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjV6VUdGMGFDazdYRzVjYmlBZ0lDQnNaV1owVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmlBOUlHWnBjbk4wVEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNDdJQzh2TDF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUd4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm1hVzVrVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2Ym5OUVlYUm9LSEoxYkdWT1lXMWxMQ0J5WldOMWNuTnBkbVZTZFd4bFRtRnRaU3dnY21WamRYSnphWFpsUkdWbWFXNXBkR2x2Ym5NcElIdGNiaUFnYkdWMElISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNBOUlHNTFiR3c3WEc1Y2JpQWdjbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk11YzI5dFpTZ29jbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaXdnYVc1a1pYZ3BJRDArSUh0Y2JpQWdJQ0JqYjI1emRDQnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVVblZzWlU1aGJXVWdQU0J5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1TG1kbGRGSjFiR1ZPWVcxbEtDa3NYRzRnSUNBZ0lDQWdJQ0FnY21WamRYSnphWFpsUkdWbWFXNXBkR2x2YmxKMWJHVk9ZVzFsVW1WamRYSnphWFpsVW5Wc1pVNWhiV1VnUFNBb2NtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJsSjFiR1ZPWVcxbElEMDlQU0J5WldOMWNuTnBkbVZTZFd4bFRtRnRaU2s3WEc1Y2JpQWdJQ0JwWmlBb2NtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJsSjFiR1ZPWVcxbFVtVmpkWEp6YVhabFVuVnNaVTVoYldVcElIdGNiaUFnSUNBZ0lISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNBOUlISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpMbk5zYVdObEtHbHVaR1Y0S1R0Y2JseHVJQ0FnSUNBZ2NtVjBkWEp1SUhSeWRXVTdYRzRnSUNBZ2ZWeHVJQ0I5S1R0Y2JseHVJQ0J5WlhSMWNtNGdjbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk5RWVhSb08xeHVmVnh1WEc1bWRXNWpkR2x2YmlCbWFXNWtUR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1elVHRjBhQ2h5ZFd4bFRtRnRaU3dnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbExDQnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjeWtnZTF4dUlDQnNaWFFnYkdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNBOUlHNTFiR3c3WEc1Y2JpQWdZMjl1YzNRZ2NtVmpkWEp6YVhabFVuVnNaVTVoYldVZ1BTQnNaV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1VzSUNBdkx5OWNiaUFnSUNBZ0lISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNBOUlHWnBibVJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1YzFCaGRHZ29jblZzWlU1aGJXVXNJSEpsWTNWeWMybDJaVkoxYkdWT1lXMWxMQ0J5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1Y3lrN1hHNWNiaUFnYVdZZ0tISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNBaFBUMGdiblZzYkNrZ2UxeHVJQ0FnSUdOdmJuTjBJSEpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjV6VUdGMGFFeGxablJTWldOMWNuTnBkbVVnUFNCcGMxSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUV4bFpuUlNaV04xY25OcGRtVW9jblZzWlU1aGJXVXNJSEpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjV6VUdGMGFDazdYRzVjYmlBZ0lDQnBaaUFvY21WamRYSnphWFpsUkdWbWFXNXBkR2x2Ym5OUVlYUm9UR1ZtZEZKbFkzVnljMmwyWlNrZ2UxeHVJQ0FnSUNBZ2JHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjV6VUdGMGFDQTlJSEpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjV6VUdGMGFEc2dJQzh2TDF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJzWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJuTlFZWFJvTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJwYzFKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1elVHRjBhRXhsWm5SU1pXTjFjbk5wZG1Vb2NuVnNaVTVoYldVc0lISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNrZ2UxeHVJQ0JqYjI1emRDQnlkV3hsVG1GdFpYTWdQU0J5ZFd4bFRtRnRaWE5HY205dFVuVnNaVTVoYldWQmJtUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjMUJoZEdnb2NuVnNaVTVoYldVc0lISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNrc1hHNGdJQ0FnSUNBZ0lISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUV4bFpuUlNaV04xY25OcGRtVWdQU0J5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1YzFCaGRHZ3VaWFpsY25rb0tISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNHNJR2x1WkdWNEtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ1kyOXVjM1FnZEhsd1pTQTlJSEpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjR1WjJWMFZIbHdaU2dwTzF4dVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hSNWNHVWdQVDA5SUV4RlJsUmZVa1ZEVlZKVFNWWkZYMVJaVUVVcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJSEoxYkdWT1lXMWxJRDBnY25Wc1pVNWhiV1Z6VzJsdVpHVjRYU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpYTWdQU0J5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1TG1kbGRFeGxablJTWldOMWNuTnBkbVZTZFd4bFRtRnRaWE1vS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHeGxablJTWldOMWNuTnBkbVZTZFd4bFRtRnRaWE5KYm1Oc2RXUmxjMUoxYkdWT1lXMWxJRDBnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGN5NXBibU5zZFdSbGN5aHlkV3hsVG1GdFpTazdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hzWldaMFVtVmpkWEp6YVhabFVuVnNaVTVoYldWelNXNWpiSFZrWlhOU2RXeGxUbUZ0WlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnZEhKMVpUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDBwTzF4dVhHNGdJSEpsZEhWeWJpQnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjMUJoZEdoTVpXWjBVbVZqZFhKemFYWmxPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnlkV3hsVG1GdFpYTkdjbTl0VW5Wc1pVNWhiV1ZCYm1SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dWMxQmhkR2dvY25Wc1pVNWhiV1VzSUhKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1elVHRjBhQ2tnZTF4dUlDQmpiMjV6ZENCeWRXeGxUbUZ0WlhNZ1BTQnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjMUJoZEdndWJXRndLQ2h5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1S1NBOVBpQnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVMbWRsZEZKMWJHVk9ZVzFsS0NrcE8xeHVYRzRnSUhKMWJHVk9ZVzFsY3k1d2RYTm9LSEoxYkdWT1lXMWxLVHRjYmx4dUlDQmpiMjV6ZENCbWFYSnpkRkoxYkdWT1lXMWxJRDBnY25Wc1pVNWhiV1Z6TG5Ob2FXWjBLQ2tzWEc0Z0lDQWdJQ0FnSUd4aGMzUlNkV3hsVG1GdFpTQTlJR1pwY25OMFVuVnNaVTVoYldVN0lDOHZMMXh1WEc0Z0lISjFiR1ZPWVcxbGN5NXdkWE5vS0d4aGMzUlNkV3hsVG1GdFpTazdYRzVjYmlBZ2NtVjBkWEp1SUhKMWJHVk9ZVzFsY3p0Y2JuMWNiaUpkTENKdVlXMWxjeUk2V3lKbWFYSnpkQ0lzSW1GeWNtRjVWWFJwYkdsMGFXVnpJaXdpU1cxd2JHbGphWFJzZVV4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVJaXdpZEhsd1pTSXNJbkJoY25Seklpd2ljblZzWlU1aGJXVWlMQ0prWldacGJtbDBhVzl1SWl3aWNtVmpkWEp6YVhabFVuVnNaVTVoYldWeklpd2liR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lJc0lteGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1SWl3aVoyVjBUR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0aUxDSnlaWEJzWVdObElpd2ljblZzWlUxaGNDSXNJbkoxYkdVaUxDSnlaWEJzWVdObFpFUmxabWx1YVhScGIyNGlMQ0p5WlhCc1lXTmxiV1Z1ZEVSbFptbHVhWFJwYjI0aUxDSnlaWEJzWVdObFJHVm1hVzVwZEdsdmJpSXNJbVp5YjIxU2RXeGxUbUZ0WlV4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpVRnVaRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjV6SWl3aWJHVm1kRkpsWTNWeWMybDJaVkoxYkdWT1lXMWxJaXdpY21WamRYSnphWFpsUkdWbWFXNXBkR2x2Ym5NaUxDSnBiWEJzYVdOcGRHeDVUR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0aUxDSm1hVzVrVEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNGlMQ0pKVFZCTVNVTkpWRXhaWDB4RlJsUmZVa1ZEVlZKVFNWWkZYMVJaVUVVaUxDSm5aWFJRWVhKMGN5SXNJbWRsZEZKMWJHVk9ZVzFsSWl3aVoyVjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpJaXdpWjJWMFRHVm1kRkpsWTNWeWMybDJaVkoxYkdWT1lXMWxjeUlzSWt4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVJaXdpYkdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNJc0ltWnBibVJNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJuTlFZWFJvSWl3aVptbHljM1JNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpSXNJbVpwYm1SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dWMxQmhkR2dpTENKeVpXTjFjbk5wZG1WU2RXeGxUbUZ0WlNJc0luSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpVR0YwYUNJc0luTnZiV1VpTENKeVpXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlpd2lhVzVrWlhnaUxDSnlaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVVblZzWlU1aGJXVWlMQ0p5WldOMWNuTnBkbVZFWldacGJtbDBhVzl1VW5Wc1pVNWhiV1ZTWldOMWNuTnBkbVZTZFd4bFRtRnRaU0lzSW5Oc2FXTmxJaXdpY21WamRYSnphWFpsUkdWbWFXNXBkR2x2Ym5OUVlYUm9UR1ZtZEZKbFkzVnljMmwyWlNJc0ltbHpVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk5RWVhSb1RHVm1kRkpsWTNWeWMybDJaU0lzSW5KMWJHVk9ZVzFsY3lJc0luSjFiR1ZPWVcxbGMwWnliMjFTZFd4bFRtRnRaVUZ1WkZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1elVHRjBhQ0lzSW1WMlpYSjVJaXdpWjJWMFZIbHdaU0lzSWt4RlJsUmZVa1ZEVlZKVFNWWkZYMVJaVUVVaUxDSnNaV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1Z6U1c1amJIVmtaWE5TZFd4bFRtRnRaU0lzSW1sdVkyeDFaR1Z6SWl3aWJXRndJaXdpY0hWemFDSXNJbVpwY25OMFVuVnNaVTVoYldVaUxDSnphR2xtZENJc0lteGhjM1JTZFd4bFRtRnRaU0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzUTBGQldTeFhRVUZCTEVOQlFVTTdPenRGUVVGaU8zZENRVUZCTzBGQlJTdENMRWRCUVZjc1EwRkJXQ3hWUVVGWE8wRkJSVTRzUjBGQlowTXNRMEZCYUVNc1kwRkJaME03UVVGRlFTeEhRVUZoTEVOQlFXSXNUVUZCWVRzN096czdPenM3T3pzN096czdPemhFUVU1cVJqdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRlJRU3hIUVVGTExFTkJRVWRCTEV0QlFVc3NSMEZCUzBNc1ZVRkJZeXhuUWtGQmVFSkVMRXRCUVVzN1FVRkZSU3hIUVVGTExFTkJRVU5GTEdsRFFVRnBReXhwUWtGQmRrTXNVVUZCVVR0NVJVRldka0k3TzJGQlZYRkNRU3hwUTBGQmFVTXNRMEZEZUVORExFbEJRVWtzUlVGQlJVTXNTMEZCU3l4RlFVRkZReXhSUVVGUkxFVkJRVVZETEZWQlFWVXNSVUZCUlVNc2EwSkJRV3RDTEVWQlFVVkRMSE5DUVVGelFpeEZRVUZGUXl4MVFrRkJkVUk3WjBWQldIQklPenRyUTBGWlZVNHNTVUZCU1N4RlFVRkZReXhMUVVGTExFVkJRVVZETEZGQlFWRXNSVUZCUlVNc1ZVRkJWU3hGUVVGRlF5eHJRa0ZCYTBJc1JVRkJSVU1zYzBKQlFYTkNMRU5EV25aR0xFTkVXWGxHTzJOQlJXaEdReXgxUWtGQmRVSXNSMEZCUjBFc2RVSkJRWFZDTEVOQlFVTTdPenM3TzFsQlIzcEVReXhIUVVFd1FpeEZRVUV4UWtFc1EwRkJNRUk3YlVKQlFURkNRU3hSUVVGUkxFTkJRVkpCTERCQ1FVRXdRaXhIUVVGSExFTkJRVU03WjBKQlF6VkNMRWxCUVVrc1EwRkJRMFFzZFVKQlFYVkNMRWRCUVVkQkxIVkNRVUYxUWl4RFFVRkRPMWxCUTNwRUxFTkJRVU03T3p0WlFVVkVSU3hIUVVGUExFVkJRVkJCTEVOQlFVODdiVUpCUVZCQkxGRkJRVkZETEVOQlFWSkVMRTlCUVU4c1EwRkJRME1zVDBGQlR5eEZRVUZGTEVOQlFVTTdaMEpCUTJoQ0xFZEJRVXNzUTBGQlEwTXNTVUZCU1N4SFFVRkhSQ3hQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZEVUN4UlFVRlJMRXRCUVVzc1NVRkJTU3hGUVVOeVExTXNhMEpCUVd0Q0xFZEJRVWNzU1VGQlNTeERRVUZEVEN4MVFrRkJkVUlzUlVGRGFrUk5MSEZDUVVGeFFpeEhRVUZITEVsQlFVa3NSVUZCUlN4RlFVRkhMRUZCUVVnc1EwRkJSenRuUWtGRmRrTkdMRWxCUVVrc1EwRkJRMGNzYVVKQlFXbENMRU5CUVVOR0xHdENRVUZyUWl4RlFVRkZReXh4UWtGQmNVSXNRMEZCUXl4RFFVRkRPMWxCUTNCRkxFTkJRVU03T3pzN1dVRkZUVVVzUjBGQmQwUXNSVUZCZUVSQkxFTkJRWGRFTzIxQ1FVRXZSQ3hSUVVGUkxFTkJRVVJCTEhkRVFVRjNSQ3hEUVVGRFdpeFJRVUZSTEVWQlFVVmhMSEZDUVVGeFFpeEZRVUZGUXl4dlFrRkJiMElzUlVGQlJTeERRVUZETzJkQ1FVTjBTQ3hIUVVGSExFTkJRVU5ETEdsRFFVRnBReXhIUVVGSExFbEJRVWs3WjBKQlJUVkRMRWRCUVVzc1EwRkJRMWdzZFVKQlFYVkNMRWRCUVVkWkxESkNRVUV5UWl4RFFVRkRhRUlzVVVGQlVTeEZRVUZGWVN4eFFrRkJjVUlzUlVGQlJVTXNiMEpCUVc5Q08yZENRVVZxU0N4RlFVRkZMRVZCUVVWV0xIVkNRVUYxUWl4TFFVRkxMRWxCUVVrc1JVRkJSU3hEUVVGRE8yOUNRVU55UXl4SFFVRkxMRU5CUVVOT0xFbEJRVWtzUjBGQlIyMUNMRTFCUVRoQ0xHbERRVU55UTJ4Q0xFdEJRVXNzUjBGQlIwc3NkVUpCUVhWQ0xFTkJRVU5qTEZGQlFWRXNTVUZEZUVOc1FpeFZRVUZSTEVkQlFVZEpMSFZDUVVGMVFpeERRVUZEWlN4WFFVRlhMRWxCUXpsRGJFSXNWVUZCVlN4SFFVRkhMRWxCUVVrc1JVRkRha0pETEd0Q1FVRnJRaXhIUVVGSFJTeDFRa0ZCZFVJc1EwRkJRMmRDTEhGQ1FVRnhRaXhKUVVOc1JXcENMSE5DUVVGelFpeEhRVUZIUXl4MVFrRkJkVUlzUTBGQlEybENMSGxDUVVGNVFqdHZRa0ZGYUVaT0xHbERRVUZwUXl4SFFVRkhMRWRCUVVjc1EwRkJRMnhDTEdsRFFVRnBReXhEUVVGRFF5eEpRVUZKTEVWQlFVVkRMRXRCUVVzc1JVRkJSVU1zVlVGQlVTeEZRVUZGUXl4VlFVRlZMRVZCUVVWRExHdENRVUZyUWl4RlFVRkZReXh6UWtGQmMwSXNSVUZCUlVNc2RVSkJRWFZDTEVOQlFVTXNRMEZCUXp0blFrRkRjRXdzUTBGQlF6dG5Ra0ZGUkN4TlFVRk5MRU5CUVVOWExHbERRVUZwUXp0WlFVTXhReXhEUVVGRE96dE5RVGxEU0RzN1JVRlZLMFJQTEdOQlFYVkNPMnRDUVVGcVJYcENMR2xEUVVGcFF5eEJRVlowUkR0VFFXbEVVMjFDTERKQ1FVRXlRaXhEUVVGRGFFSXNVVUZCVVN4RlFVRkZZU3h4UWtGQmNVSXNSVUZCUlVNc2IwSkJRVzlDTEVWQlFVVXNRMEZCUXp0SlFVTXpSaXhIUVVGSExFTkJRVU5XTEhWQ1FVRjFRaXhIUVVGSExFbEJRVWs3U1VGRmJFTXNSMEZCU3l4RFFVRkRiVUlzTkVKQlFUUkNMRWRCUVVkRExHZERRVUZuUXl4RFFVRkRlRUlzVVVGQlVTeEZRVUZGWVN4eFFrRkJjVUlzUlVGQlJVTXNiMEpCUVc5Q08wbEJSVE5JTEVWQlFVVXNSVUZCUlZNc05FSkJRVFJDTEV0QlFVc3NTVUZCU1N4RlFVRkZMRU5CUVVNN1VVRkRNVU1zUjBGQlN5eERRVUZEUlN3MFFrRkJORUlzUjBGQlJ6bENMRXRCUVVzc1EwRkJRelJDTERSQ1FVRTBRanRSUVVWMlJXNUNMSFZDUVVGMVFpeEhRVUZIY1VJc05FSkJRVFJDTEVOQlFVTXNRMEZCUXl4RlFVRkhMRUZCUVVnc1EwRkJSenRKUVVNM1JDeERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRja0lzZFVKQlFYVkNPMEZCUTJoRExFTkJRVU03VTBGRlVYTkNMRFJDUVVFMFFpeERRVUZETVVJc1VVRkJVU3hGUVVGRk1rSXNhVUpCUVdsQ0xFVkJRVVZpTEc5Q1FVRnZRaXhGUVVGRkxFTkJRVU03U1VGRGVFWXNSMEZCUnl4RFFVRkRZeXgzUWtGQmQwSXNSMEZCUnl4SlFVRkpPMGxCUlc1RFpDeHZRa0ZCYjBJc1EwRkJRMlVzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCVUVNc2JVSkJRVzFDTEVWQlFVVkRMRXRCUVVzc1JVRkJTeXhEUVVGRE8xRkJRM3BFTEVkQlFVc3NRMEZCUTBNc01rSkJRVEpDTEVkQlFVZEdMRzFDUVVGdFFpeERRVUZEV0N4WFFVRlhMRWxCUXpkRVl5dzBRMEZCTkVNc1IwRkJTVVFzTWtKQlFUSkNMRXRCUVV0TUxHbENRVUZwUWp0UlFVVjJSeXhGUVVGRkxFVkJRVVZOTERSRFFVRTBReXhGUVVGRkxFTkJRVU03V1VGRGFrUk1MSGRDUVVGM1FpeEhRVUZIWkN4dlFrRkJiMElzUTBGQlEyOUNMRXRCUVVzc1EwRkJRMGdzUzBGQlN5eERRVUZETEVOQlFVTTdXVUZGTjBRc1RVRkJUU3hEUVVGRExFbEJRVWs3VVVGRFlpeERRVUZETzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZTQ3hOUVVGTkxFTkJRVU5JTEhkQ1FVRjNRanRCUVVOcVF5eERRVUZETzFOQlJWRktMR2REUVVGblF5eERRVUZEZUVJc1VVRkJVU3hGUVVGRllTeHhRa0ZCY1VJc1JVRkJSVU1zYjBKQlFXOUNMRVZCUVVVc1EwRkJRenRKUVVOb1J5eEhRVUZITEVOQlFVTlRMRFJDUVVFMFFpeEhRVUZITEVsQlFVazdTVUZGZGtNc1IwRkJTeXhEUVVGRFNTeHBRa0ZCYVVJc1IwRkJSMlFzY1VKQlFYRkNMRVZCUXpORFpTeDNRa0ZCZDBJc1IwRkJSMFlzTkVKQlFUUkNMRU5CUVVNeFFpeFJRVUZSTEVWQlFVVXlRaXhwUWtGQmFVSXNSVUZCUldJc2IwSkJRVzlDTzBsQlJUZEhMRVZCUVVVc1JVRkJSV01zZDBKQlFYZENMRXRCUVVzc1NVRkJTU3hGUVVGRkxFTkJRVU03VVVGRGRFTXNSMEZCU3l4RFFVRkRUeXh4UTBGQmNVTXNSMEZCUjBNc2RVTkJRWFZETEVOQlFVTndReXhSUVVGUkxFVkJRVVUwUWl4M1FrRkJkMEk3VVVGRmVFZ3NSVUZCUlN4RlFVRkZUeXh4UTBGQmNVTXNSVUZCUlN4RFFVRkRPMWxCUXpGRFdpdzBRa0ZCTkVJc1IwRkJSMHNzZDBKQlFYZENMRU5CUVVNc1EwRkJSU3hGUVVGSExFRkJRVWdzUTBGQlJ6dFJRVU12UkN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlEwd3NORUpCUVRSQ08wRkJRM0pETEVOQlFVTTdVMEZGVVdFc2RVTkJRWFZETEVOQlFVTndReXhSUVVGUkxFVkJRVVUwUWl4M1FrRkJkMElzUlVGQlJTeERRVUZETzBsQlEzQkdMRWRCUVVzc1EwRkJRMU1zVTBGQlV5eEhRVUZIUXl4blJFRkJaMFFzUTBGQlEzUkRMRkZCUVZFc1JVRkJSVFJDTEhkQ1FVRjNRaXhIUVVNdlJrOHNjVU5CUVhGRExFZEJRVWRRTEhkQ1FVRjNRaXhEUVVGRFZ5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRlFWQ3h0UWtGQmJVSXNSVUZCUlVNc1MwRkJTeXhGUVVGTExFTkJRVU03VVVGRGRFY3NSMEZCU3l4RFFVRkRha01zU1VGQlNTeEhRVUZIWjBNc2JVSkJRVzFDTEVOQlFVTlZMRTlCUVU4N1VVRkZlRU1zUlVGQlJTeEZRVUZGTVVNc1NVRkJTU3hMUVVGTE1rTXNUVUZCYlVJc2MwSkJRVVVzUTBGQlF6dFpRVU5xUXl4SFFVRkxMRU5CUVVONlF5eFZRVUZSTEVkQlFVZHhReXhUUVVGVExFTkJRVU5PTEV0QlFVc3NSMEZETVVJMVFpeHpRa0ZCYzBJc1IwRkJSekpDTEcxQ1FVRnRRaXhEUVVGRFZDeDVRa0ZCZVVJc1NVRkRkRVZ4UWl4elEwRkJjME1zUjBGQlIzWkRMSE5DUVVGelFpeERRVUZEZDBNc1VVRkJVU3hEUVVGRE0wTXNWVUZCVVR0WlFVVjJSaXhGUVVGRkxFVkJRVVV3UXl4elEwRkJjME1zUlVGQlJTeERRVUZETzJkQ1FVTXpReXhOUVVGTkxFTkJRVU1zU1VGQlNUdFpRVU5pTEVOQlFVTTdVVUZEU0N4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWUUxFMUJRVTBzUTBGQlExQXNjVU5CUVhGRE8wRkJRemxETEVOQlFVTTdVMEZGVVVjc1owUkJRV2RFTEVOQlFVTjBReXhSUVVGUkxFVkJRVVUwUWl4M1FrRkJkMElzUlVGQlJTeERRVUZETzBsQlF6ZEdMRWRCUVVzc1EwRkJRMU1zVTBGQlV5eEhRVUZIVkN4M1FrRkJkMElzUTBGQlEyZENMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVkJrTEcxQ1FVRnRRanRsUVVGTFFTeHRRa0ZCYlVJc1EwRkJRMWdzVjBGQlZ6czdTVUZGZGtkclFpeFRRVUZUTEVOQlFVTlJMRWxCUVVrc1EwRkJRemRETEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUlhwQ0xFZEJRVXNzUTBGQlF6aERMR0ZCUVdFc1IwRkJSMVFzVTBGQlV5eERRVUZEVlN4TFFVRkxMRWxCUXk5Q1F5eFpRVUZaTEVkQlFVZEdMR0ZCUVdFc1JVRkJSU3hGUVVGSExFRkJRVWdzUTBGQlJ6dEpRVVYyUTFRc1UwRkJVeXhEUVVGRFVTeEpRVUZKTEVOQlFVTkhMRmxCUVZrc1EwRkJReXhEUVVGRE8wbEJSVGRDTEUxQlFVMHNRMEZCUTFnc1UwRkJVenRCUVVOc1FpeERRVUZESW4wPSIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbmVjZXNzYXJ5ID0gcmVxdWlyZShcIm5lY2Vzc2FyeVwiKTtcbnZhciBfcmVkdWNlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3J1bGUvcmVkdWNlZFwiKSk7XG52YXIgX3JlcGVhdGVkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcnVsZS9yZXBlYXRlZFwiKSk7XG52YXIgX3Jld3JpdHRlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3J1bGUvcmV3cml0dGVuXCIpKTtcbnZhciBfcmVwZWF0ZWQxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vZGVmaW5pdGlvbi9yZXBlYXRlZFwiKSk7XG52YXIgX3Jld3JpdHRlbjEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9kZWZpbml0aW9uL3Jld3JpdHRlblwiKSk7XG52YXIgX2xlZnRSZWN1cnNpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9kZWZpbml0aW9uL2xlZnRSZWN1cnNpdmVcIikpO1xudmFyIF9pbXBsaWNpdGx5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vZGVmaW5pdGlvbi9sZWZ0UmVjdXJzaXZlL2ltcGxpY2l0bHlcIikpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcbnZhciBfcnVsZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvcnVsZVwiKTtcbnZhciBfZGVmaW5pdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvZGVmaW5pdGlvblwiKTtcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbnZhciBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDtcbiAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xufVxudmFyIGZpcnN0ID0gX25lY2Vzc2FyeS5hcnJheVV0aWxpdGllcy5maXJzdDtcbnZhciBJbmRpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKExlZnRSZWN1cnNpdmVEZWZpbml0aW9uKSB7XG4gICAgX2luaGVyaXRzKEluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiwgTGVmdFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKTtcbiAgICBmdW5jdGlvbiBJbmRpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24odHlwZSwgcGFydHMsIHJ1bGVOYW1lLCBkZWZpbml0aW9uLCByZWN1cnNpdmVSdWxlTmFtZXMsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMsIGltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKTtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHBhcnRzLCBydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICAgICAgX3RoaXMuaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhJbmRpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldEltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyZXdyaXRlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmV3cml0ZShydWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLmdldERlZmluaXRpb24oKSwgcnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lKCksIHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gdGhpcy5nZXRMZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKCksIGZpcnN0TGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gZmlyc3QobGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyksIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGZpcnN0TGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZSA9IHJ1bGVNYXBbbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lXSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkUnVsZSA9ICgwLCBfcnVsZSkucmVkdWNlZFJ1bGVGcm9tUnVsZShsZWZ0UmVjdXJzaXZlUnVsZSwgcnVsZU1hcCwgX3JlZHVjZWQuZGVmYXVsdCksIHJlZHVjZWRSdWxlRW1wdHkgPSByZWR1Y2VkUnVsZS5pc0VtcHR5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZWRSdWxlRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25TdHJpbmcgPSBkZWZpbml0aW9uLmFzU3RyaW5nKCksIGltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IHRoaXMuZ2V0SW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKCksIGltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvblN0cmluZyA9IGltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5hc1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ1wiLmNvbmNhdChpbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb25TdHJpbmcsIFwiJyBpbXBsaWNpdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICdcIikuY29uY2F0KGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgXCInIHJ1bGUgaGFzIG5vIHNpYmxpbmcgbm9uLWxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb25zIGFuZCB0aGVyZWZvcmUgdGhlICdcIikuY29uY2F0KGRlZmluaXRpb25TdHJpbmcsIFwiJyBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICdcIikuY29uY2F0KHJ1bGVOYW1lLCBcIicgcnVsZSBjYW5ub3QgYmUgcmV3cml0dGVuLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXBlYXRlZFJ1bGUgPSAoMCwgX3J1bGUpLnJlcGVhdGVkUnVsZUZyb21SdWxlKGxlZnRSZWN1cnNpdmVSdWxlLCBydWxlTWFwLCBfcmVwZWF0ZWQuZGVmYXVsdCksIHJlcGVhdGVkRGVmaW5pdGlvbiA9IF9yZXBlYXRlZDEuZGVmYXVsdC5mcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICByZXBlYXRlZFJ1bGUuYWRkRGVmaW5pdGlvbihyZXBlYXRlZERlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgICgwLCBfcnVsZSkucmV3cml0dGVuUnVsZUZyb21SdWxlKGxlZnRSZWN1cnNpdmVSdWxlLCBydWxlTWFwLCBfcmV3cml0dGVuLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIHZhciByZXdyaXR0ZW5EZWZpbml0aW9uID0gX3Jld3JpdHRlbjEuZGVmYXVsdC5mcm9tRGVmaW5pdGlvbkFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShkZWZpbml0aW9uLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLCByZXBsYWNlbWVudERlZmluaXRpb24gPSB0aGlzOyAvLy9cbiAgICAgICAgICAgICAgICBydWxlLnJlcGxhY2VEZWZpbml0aW9uKHJlcGxhY2VtZW50RGVmaW5pdGlvbiwgcmV3cml0dGVuRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tUnVsZU5hbWVEZWZpbml0aW9uQW5kUmVjdXJzaXZlRGVmaW5pdGlvbnNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUnVsZU5hbWVEZWZpbml0aW9uQW5kUmVjdXJzaXZlRGVmaW5pdGlvbnMocnVsZU5hbWUsIGRlZmluaXRpb24sIHJlY3Vyc2l2ZURlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSAoMCwgX2RlZmluaXRpb24pLmxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0xlbmd0aCA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMubGVuZ3RoLCBkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNMZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLnNvbWUoZnVuY3Rpb24obGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZU5hbWVMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZSA9PT0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlTmFtZUxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gPSBfaW1wbGljaXRseS5kZWZhdWx0LmZyb21SdWxlTmFtZUxlZnRSZWN1cnNpdmVSdWxlTmFtZUFuZFJlY3Vyc2l2ZURlZmluaXRpb25zKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIHJlY3Vyc2l2ZURlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uVW5hcnkgPSAoMCwgX2RlZmluaXRpb24pLmlzRGVmaW5pdGlvblVuYXJ5KGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvblVuYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnXCIuY29uY2F0KGRlZmluaXRpb25TdHJpbmcsIFwiJyBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICdcIikuY29uY2F0KHJ1bGVOYW1lLCBcIicgcnVsZSBpcyB1bmFyeSBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSByZXdyaXR0ZW4uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbkNvbXBsZXggPSAoMCwgX2RlZmluaXRpb24pLmlzRGVmaW5pdGlvbkNvbXBsZXgoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uQ29tcGxleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25TdHJpbmcxID0gZGVmaW5pdGlvbi5hc1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdcIi5jb25jYXQoZGVmaW5pdGlvblN0cmluZzEsIFwiJyBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICdcIikuY29uY2F0KHJ1bGVOYW1lLCBcIicgcnVsZSBpcyBjb21wbGV4IGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIHJld3JpdHRlbi5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3R5cGVzLklORElSRUNUTFlfTEVGVF9SRUNVUlNJVkVfVFlQRSwgcGFydHMgPSBbXSwgcmVjdXJzaXZlUnVsZU5hbWVzID0gKDAsIF9kZWZpbml0aW9uKS5yZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gbmV3IEluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbih0eXBlLCBwYXJ0cywgcnVsZU5hbWUsIGRlZmluaXRpb24sIHJlY3Vyc2l2ZVJ1bGVOYW1lcywgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcywgaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBJbmRpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb247XG59KF9sZWZ0UmVjdXJzaXZlLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5a1pXWnBibWwwYVc5dUwyeGxablJTWldOMWNuTnBkbVV2YVc1a2FYSmxZM1JzZVM1cWN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjSW5WelpTQnpkSEpwWTNSY0lqdGNibHh1YVcxd2IzSjBJSHNnWVhKeVlYbFZkR2xzYVhScFpYTWdmU0JtY205dElGd2libVZqWlhOellYSjVYQ0k3WEc1Y2JtbHRjRzl5ZENCU1pXUjFZMlZrVW5Wc1pTQm1jbTl0SUZ3aUxpNHZMaTR2Y25Wc1pTOXlaV1IxWTJWa1hDSTdYRzVwYlhCdmNuUWdVbVZ3WldGMFpXUlNkV3hsSUdaeWIyMGdYQ0l1TGk4dUxpOXlkV3hsTDNKbGNHVmhkR1ZrWENJN1hHNXBiWEJ2Y25RZ1VtVjNjbWwwZEdWdVVuVnNaU0JtY205dElGd2lMaTR2TGk0dmNuVnNaUzl5WlhkeWFYUjBaVzVjSWp0Y2JtbHRjRzl5ZENCU1pYQmxZWFJsWkVSbFptbHVhWFJwYjI0Z1puSnZiU0JjSWk0dUx5NHVMMlJsWm1sdWFYUnBiMjR2Y21Wd1pXRjBaV1JjSWp0Y2JtbHRjRzl5ZENCU1pYZHlhWFIwWlc1RVpXWnBibWwwYVc5dUlHWnliMjBnWENJdUxpOHVMaTlrWldacGJtbDBhVzl1TDNKbGQzSnBkSFJsYmx3aU8xeHVhVzF3YjNKMElFeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1SUdaeWIyMGdYQ0l1TGk4dUxpOWtaV1pwYm1sMGFXOXVMMnhsWm5SU1pXTjFjbk5wZG1WY0lqdGNibWx0Y0c5eWRDQkpiWEJzYVdOcGRHeDVUR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0Z1puSnZiU0JjSWk0dUx5NHVMMlJsWm1sdWFYUnBiMjR2YkdWbWRGSmxZM1Z5YzJsMlpTOXBiWEJzYVdOcGRHeDVYQ0k3WEc1Y2JtbHRjRzl5ZENCN0lFbE9SRWxTUlVOVVRGbGZURVZHVkY5U1JVTlZVbE5KVmtWZlZGbFFSU0I5SUdaeWIyMGdYQ0l1TGk4dUxpOTBlWEJsYzF3aU8xeHVhVzF3YjNKMElIc2djbVZrZFdObFpGSjFiR1ZHY205dFVuVnNaU3dnY21Wd1pXRjBaV1JTZFd4bFJuSnZiVkoxYkdVc0lISmxkM0pwZEhSbGJsSjFiR1ZHY205dFVuVnNaU0I5SUdaeWIyMGdYQ0l1TGk4dUxpOTFkR2xzYVhScFpYTXZjblZzWlZ3aU8xeHVhVzF3YjNKMElIc2dhWE5FWldacGJtbDBhVzl1Vlc1aGNua3NJR2x6UkdWbWFXNXBkR2x2YmtOdmJYQnNaWGdzSUhKbFkzVnljMmwyWlZKMWJHVk9ZVzFsYzBaeWIyMUVaV1pwYm1sMGFXOXVMQ0JzWldaMFVtVmpkWEp6YVhabFVuVnNaVTVoYldWelJuSnZiVVJsWm1sdWFYUnBiMjRnZlNCbWNtOXRJRndpTGk0dkxpNHZkWFJwYkdsMGFXVnpMMlJsWm1sdWFYUnBiMjVjSWp0Y2JseHVZMjl1YzNRZ2V5Qm1hWEp6ZENCOUlEMGdZWEp5WVhsVmRHbHNhWFJwWlhNN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHTnNZWE56SUVsdVpHbHlaV04wYkhsTVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaUJsZUhSbGJtUnpJRXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlIdGNiaUFnWTI5dWMzUnlkV04wYjNJb2RIbHdaU3dnY0dGeWRITXNJSEoxYkdWT1lXMWxMQ0JrWldacGJtbDBhVzl1TENCeVpXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNc0lHeGxablJTWldOMWNuTnBkbVZTZFd4bFRtRnRaWE1zSUdsdGNHeHBZMmwwYkhsTVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaWtnZTF4dUlDQWdJSE4xY0dWeUtIUjVjR1VzSUhCaGNuUnpMQ0J5ZFd4bFRtRnRaU3dnWkdWbWFXNXBkR2x2Yml3Z2NtVmpkWEp6YVhabFVuVnNaVTVoYldWekxDQnNaV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1Z6S1R0Y2JseHVJQ0FnSUhSb2FYTXVhVzF3YkdsamFYUnNlVXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlEMGdhVzF3YkdsamFYUnNlVXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dU8xeHVJQ0I5WEc1Y2JpQWdaMlYwU1cxd2JHbGphWFJzZVV4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TG1sdGNHeHBZMmwwYkhsTVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZianRjYmlBZ2ZWeHVYRzRnSUhKbGQzSnBkR1VvY25Wc1pVMWhjQ2tnZTF4dUlDQWdJR052Ym5OMElHUmxabWx1YVhScGIyNGdQU0IwYUdsekxtZGxkRVJsWm1sdWFYUnBiMjRvS1N4Y2JpQWdJQ0FnSUNBZ0lDQnlkV3hsVG1GdFpTQTlJSFJvYVhNdVoyVjBVblZzWlU1aGJXVW9LU3hjYmlBZ0lDQWdJQ0FnSUNCeWRXeGxJRDBnY25Wc1pVMWhjRnR5ZFd4bFRtRnRaVjBnZkh3Z2JuVnNiRHRjYmx4dUlDQWdJR052Ym5OMElHeGxablJTWldOMWNuTnBkbVZTZFd4bFRtRnRaWE1nUFNCMGFHbHpMbWRsZEV4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpYTW9LU3hjYmlBZ0lDQWdJQ0FnSUNCbWFYSnpkRXhsWm5SU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlNBOUlHWnBjbk4wS0d4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpYTXBMRnh1SUNBZ0lDQWdJQ0FnSUd4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpTQTlJR1pwY25OMFRHVm1kRkpsWTNWeWMybDJaVkoxYkdWT1lXMWxMQ0F2THk5Y2JpQWdJQ0FnSUNBZ0lDQnNaV1owVW1WamRYSnphWFpsVW5Wc1pTQTlJSEoxYkdWTllYQmJiR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsWFNCOGZDQnVkV3hzTzF4dVhHNGdJQ0FnWTI5dWMzUWdjbVZrZFdObFpGSjFiR1VnUFNCeVpXUjFZMlZrVW5Wc1pVWnliMjFTZFd4bEtHeGxablJTWldOMWNuTnBkbVZTZFd4bExDQnlkV3hsVFdGd0xDQlNaV1IxWTJWa1VuVnNaU2tzWEc0Z0lDQWdJQ0FnSUNBZ2NtVmtkV05sWkZKMWJHVkZiWEIwZVNBOUlISmxaSFZqWldSU2RXeGxMbWx6Ulcxd2RIa29LVHRjYmx4dUlDQWdJR2xtSUNoeVpXUjFZMlZrVW5Wc1pVVnRjSFI1S1NCN1hHNGdJQ0FnSUNCamIyNXpkQ0JrWldacGJtbDBhVzl1VTNSeWFXNW5JRDBnWkdWbWFXNXBkR2x2Ymk1aGMxTjBjbWx1WnlncExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYVcxd2JHbGphWFJzZVV4bFpuUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVJRDBnZEdocGN5NW5aWFJKYlhCc2FXTnBkR3g1VEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNG9LU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHbHRjR3hwWTJsMGJIbE1aV1owVW1WamRYSnphWFpsUkdWbWFXNXBkR2x2YmxOMGNtbHVaeUE5SUdsdGNHeHBZMmwwYkhsTVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaTVoYzFOMGNtbHVaeWdwTzF4dVhHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWUZSb1pTQW5KSHRwYlhCc2FXTnBkR3g1VEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNVRkSEpwYm1kOUp5QnBiWEJzYVdOcGRHeDVJR3hsWm5RZ2NtVmpkWEp6YVhabElHUmxabWx1YVhScGIyNGdiMllnZEdobElDY2tlMnhsWm5SU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlgwbklISjFiR1VnYUdGeklHNXZJSE5wWW14cGJtY2dibTl1TFd4bFpuUWdjbVZqZFhKemFYWmxJR1JsWm1sdWFYUnBiMjV6SUdGdVpDQjBhR1Z5WldadmNtVWdkR2hsSUNja2UyUmxabWx1YVhScGIyNVRkSEpwYm1kOUp5QnBibVJwY21WamRHeDVJR3hsWm5RZ2NtVmpkWEp6YVhabElHUmxabWx1YVhScGIyNGdiMllnZEdobElDY2tlM0oxYkdWT1lXMWxmU2NnY25Wc1pTQmpZVzV1YjNRZ1ltVWdjbVYzY21sMGRHVnVMbUFwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR052Ym5OMElISmxjR1ZoZEdWa1VuVnNaU0E5SUhKbGNHVmhkR1ZrVW5Wc1pVWnliMjFTZFd4bEtHeGxablJTWldOMWNuTnBkbVZTZFd4bExDQnlkV3hsVFdGd0xDQlNaWEJsWVhSbFpGSjFiR1VwTEZ4dUlDQWdJQ0FnSUNBZ0lISmxjR1ZoZEdWa1JHVm1hVzVwZEdsdmJpQTlJRkpsY0dWaGRHVmtSR1ZtYVc1cGRHbHZiaTVtY205dFJHVm1hVzVwZEdsdmJpaGtaV1pwYm1sMGFXOXVLVHRjYmx4dUlDQWdJSEpsY0dWaGRHVmtVblZzWlM1aFpHUkVaV1pwYm1sMGFXOXVLSEpsY0dWaGRHVmtSR1ZtYVc1cGRHbHZiaWs3WEc1Y2JpQWdJQ0J5WlhkeWFYUjBaVzVTZFd4bFJuSnZiVkoxYkdVb2JHVm1kRkpsWTNWeWMybDJaVkoxYkdVc0lISjFiR1ZOWVhBc0lGSmxkM0pwZEhSbGJsSjFiR1VwTzF4dVhHNGdJQ0FnWTI5dWMzUWdjbVYzY21sMGRHVnVSR1ZtYVc1cGRHbHZiaUE5SUZKbGQzSnBkSFJsYmtSbFptbHVhWFJwYjI0dVpuSnZiVVJsWm1sdWFYUnBiMjVCYm1STVpXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVW9aR1ZtYVc1cGRHbHZiaXdnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbEtTeGNiaUFnSUNBZ0lDQWdJQ0J5WlhCc1lXTmxiV1Z1ZEVSbFptbHVhWFJwYjI0Z1BTQjBhR2x6T3lBdkx5OWNibHh1SUNBZ0lISjFiR1V1Y21Wd2JHRmpaVVJsWm1sdWFYUnBiMjRvY21Wd2JHRmpaVzFsYm5SRVpXWnBibWwwYVc5dUxDQnlaWGR5YVhSMFpXNUVaV1pwYm1sMGFXOXVLVHRjYmlBZ2ZWeHVYRzRnSUhOMFlYUnBZeUJtY205dFVuVnNaVTVoYldWRVpXWnBibWwwYVc5dVFXNWtVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk1vY25Wc1pVNWhiV1VzSUdSbFptbHVhWFJwYjI0c0lISmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNXpLU0I3WEc0Z0lDQWdiR1YwSUdsdVpHbHlaV04wYkhsTVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaUE5SUc1MWJHdzdYRzVjYmlBZ0lDQmpiMjV6ZENCc1pXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpJRDBnYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGMwWnliMjFFWldacGJtbDBhVzl1S0dSbFptbHVhWFJwYjI0cExGeHVJQ0FnSUNBZ0lDQWdJR3hsWm5SU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlhOTVpXNW5kR2dnUFNCc1pXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpMbXhsYm1kMGFDeGNiaUFnSUNBZ0lDQWdJQ0JrWldacGJtbDBhVzl1VEdWbWRGSmxZM1Z5YzJsMlpTQTlJQ2hzWldaMFVtVmpkWEp6YVhabFVuVnNaVTVoYldWelRHVnVaM1JvSUQ0Z01DazdYRzVjYmlBZ0lDQnBaaUFvWkdWbWFXNXBkR2x2Ymt4bFpuUlNaV04xY25OcGRtVXBJSHRjYmlBZ0lDQWdJR3hsWm5SU1pXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNdWMyOXRaU2dvYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbEtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSEoxYkdWT1lXMWxUR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsSUQwZ0tISjFiR1ZPWVcxbElEMDlQU0JzWldaMFVtVmpkWEp6YVhabFVuVnNaVTVoYldVcE8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNnaGNuVnNaVTVoYldWTVpXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVXBJSHRjYmlBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JwYlhCc2FXTnBkR3g1VEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNGdQU0JKYlhCc2FXTnBkR3g1VEdWbWRGSmxZM1Z5YzJsMlpVUmxabWx1YVhScGIyNHVabkp2YlZKMWJHVk9ZVzFsVEdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbFFXNWtVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk1vY25Wc1pVNWhiV1VzSUd4bFpuUlNaV04xY25OcGRtVlNkV3hsVG1GdFpTd2djbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk1wTzF4dVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0dsdGNHeHBZMmwwYkhsTVpXWjBVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZiaUFoUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ1pHVm1hVzVwZEdsdmJsVnVZWEo1SUQwZ2FYTkVaV1pwYm1sMGFXOXVWVzVoY25rb1pHVm1hVzVwZEdsdmJpazdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hrWldacGJtbDBhVzl1Vlc1aGNua3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ1pHVm1hVzVwZEdsdmJsTjBjbWx1WnlBOUlHUmxabWx1YVhScGIyNHVZWE5UZEhKcGJtY29LVHRjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9ZRlJvWlNBbkpIdGtaV1pwYm1sMGFXOXVVM1J5YVc1bmZTY2dhVzVrYVhKbFkzUnNlU0JzWldaMElISmxZM1Z5YzJsMlpTQmtaV1pwYm1sMGFXOXVJRzltSUhSb1pTQW5KSHR5ZFd4bFRtRnRaWDBuSUhKMWJHVWdhWE1nZFc1aGNua2dZVzVrSUhSb1pYSmxabTl5WlNCallXNXViM1FnWW1VZ2NtVjNjbWwwZEdWdUxtQXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JrWldacGJtbDBhVzl1UTI5dGNHeGxlQ0E5SUdselJHVm1hVzVwZEdsdmJrTnZiWEJzWlhnb1pHVm1hVzVwZEdsdmJpazdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hrWldacGJtbDBhVzl1UTI5dGNHeGxlQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmtaV1pwYm1sMGFXOXVVM1J5YVc1bklEMGdaR1ZtYVc1cGRHbHZiaTVoYzFOMGNtbHVaeWdwTzF4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhnVkdobElDY2tlMlJsWm1sdWFYUnBiMjVUZEhKcGJtZDlKeUJwYm1ScGNtVmpkR3g1SUd4bFpuUWdjbVZqZFhKemFYWmxJR1JsWm1sdWFYUnBiMjRnYjJZZ2RHaGxJQ2NrZTNKMWJHVk9ZVzFsZlNjZ2NuVnNaU0JwY3lCamIyMXdiR1Y0SUdGdVpDQjBhR1Z5WldadmNtVWdZMkZ1Ym05MElHSmxJSEpsZDNKcGRIUmxiaTVnS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2RIbHdaU0E5SUVsT1JFbFNSVU5VVEZsZlRFVkdWRjlTUlVOVlVsTkpWa1ZmVkZsUVJTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEJoY25SeklEMGdXMTBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpXTjFjbk5wZG1WU2RXeGxUbUZ0WlhNZ1BTQnlaV04xY25OcGRtVlNkV3hsVG1GdFpYTkdjbTl0UkdWbWFXNXBkR2x2Ymloa1pXWnBibWwwYVc5dUtUdGNibHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXNWthWEpsWTNSc2VVeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1SUQwZ2JtVjNJRWx1WkdseVpXTjBiSGxNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpaDBlWEJsTENCd1lYSjBjeXdnY25Wc1pVNWhiV1VzSUdSbFptbHVhWFJwYjI0c0lISmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGN5d2diR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3l3Z2FXMXdiR2xqYVhSc2VVeGxablJTWldOMWNuTnBkbVZFWldacGJtbDBhVzl1S1R0Y2JseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdhVzVrYVhKbFkzUnNlVXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dU8xeHVJQ0I5WEc1OVhHNGlYU3dpYm1GdFpYTWlPbHNpWm1seWMzUWlMQ0poY25KaGVWVjBhV3hwZEdsbGN5SXNJa2x1WkdseVpXTjBiSGxNWldaMFVtVmpkWEp6YVhabFJHVm1hVzVwZEdsdmJpSXNJblI1Y0dVaUxDSndZWEowY3lJc0luSjFiR1ZPWVcxbElpd2laR1ZtYVc1cGRHbHZiaUlzSW5KbFkzVnljMmwyWlZKMWJHVk9ZVzFsY3lJc0lteGxablJTWldOMWNuTnBkbVZTZFd4bFRtRnRaWE1pTENKcGJYQnNhV05wZEd4NVRHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjRpTENKblpYUkpiWEJzYVdOcGRHeDVUR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0aUxDSnlaWGR5YVhSbElpd2ljblZzWlUxaGNDSXNJbWRsZEVSbFptbHVhWFJwYjI0aUxDSm5aWFJTZFd4bFRtRnRaU0lzSW5KMWJHVWlMQ0puWlhSTVpXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVnpJaXdpWm1seWMzUk1aV1owVW1WamRYSnphWFpsVW5Wc1pVNWhiV1VpTENKc1pXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVWlMQ0pzWldaMFVtVmpkWEp6YVhabFVuVnNaU0lzSW5KbFpIVmpaV1JTZFd4bElpd2ljbVZrZFdObFpGSjFiR1ZHY205dFVuVnNaU0lzSWxKbFpIVmpaV1JTZFd4bElpd2ljbVZrZFdObFpGSjFiR1ZGYlhCMGVTSXNJbWx6Ulcxd2RIa2lMQ0prWldacGJtbDBhVzl1VTNSeWFXNW5JaXdpWVhOVGRISnBibWNpTENKcGJYQnNhV05wZEd4NVRHVm1kRkpsWTNWeWMybDJaVVJsWm1sdWFYUnBiMjVUZEhKcGJtY2lMQ0pGY25KdmNpSXNJbkpsY0dWaGRHVmtVblZzWlNJc0luSmxjR1ZoZEdWa1VuVnNaVVp5YjIxU2RXeGxJaXdpVW1Wd1pXRjBaV1JTZFd4bElpd2ljbVZ3WldGMFpXUkVaV1pwYm1sMGFXOXVJaXdpVW1Wd1pXRjBaV1JFWldacGJtbDBhVzl1SWl3aVpuSnZiVVJsWm1sdWFYUnBiMjRpTENKaFpHUkVaV1pwYm1sMGFXOXVJaXdpY21WM2NtbDBkR1Z1VW5Wc1pVWnliMjFTZFd4bElpd2lVbVYzY21sMGRHVnVVblZzWlNJc0luSmxkM0pwZEhSbGJrUmxabWx1YVhScGIyNGlMQ0pTWlhkeWFYUjBaVzVFWldacGJtbDBhVzl1SWl3aVpuSnZiVVJsWm1sdWFYUnBiMjVCYm1STVpXWjBVbVZqZFhKemFYWmxVblZzWlU1aGJXVWlMQ0p5WlhCc1lXTmxiV1Z1ZEVSbFptbHVhWFJwYjI0aUxDSnlaWEJzWVdObFJHVm1hVzVwZEdsdmJpSXNJbVp5YjIxU2RXeGxUbUZ0WlVSbFptbHVhWFJwYjI1QmJtUlNaV04xY25OcGRtVkVaV1pwYm1sMGFXOXVjeUlzSW5KbFkzVnljMmwyWlVSbFptbHVhWFJwYjI1eklpd2lhVzVrYVhKbFkzUnNlVXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlpd2liR1ZtZEZKbFkzVnljMmwyWlZKMWJHVk9ZVzFsYzBaeWIyMUVaV1pwYm1sMGFXOXVJaXdpYkdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbGMweGxibWQwYUNJc0lteGxibWQwYUNJc0ltUmxabWx1YVhScGIyNU1aV1owVW1WamRYSnphWFpsSWl3aWMyOXRaU0lzSW5KMWJHVk9ZVzFsVEdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbElpd2lTVzF3YkdsamFYUnNlVXhsWm5SU1pXTjFjbk5wZG1WRVpXWnBibWwwYVc5dUlpd2labkp2YlZKMWJHVk9ZVzFsVEdWbWRGSmxZM1Z5YzJsMlpWSjFiR1ZPWVcxbFFXNWtVbVZqZFhKemFYWmxSR1ZtYVc1cGRHbHZibk1pTENKa1pXWnBibWwwYVc5dVZXNWhjbmtpTENKcGMwUmxabWx1YVhScGIyNVZibUZ5ZVNJc0ltUmxabWx1YVhScGIyNURiMjF3YkdWNElpd2lhWE5FWldacGJtbDBhVzl1UTI5dGNHeGxlQ0lzSWtsT1JFbFNSVU5VVEZsZlRFVkdWRjlTUlVOVlVsTkpWa1ZmVkZsUVJTSXNJbkpsWTNWeWMybDJaVkoxYkdWT1lXMWxjMFp5YjIxRVpXWnBibWwwYVc5dUlpd2lUR1ZtZEZKbFkzVnljMmwyWlVSbFptbHVhWFJwYjI0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxFTkJRVmtzVjBGQlFTeERRVUZET3pzN1JVRkJZanQzUWtGQlFUdEJRVVVyUWl4SFFVRlhMRU5CUVZnc1ZVRkJWenRCUVVWc1FpeEhRVUZ2UWl4RFFVRndRaXhSUVVGdlFqdEJRVU51UWl4SFFVRnhRaXhEUVVGeVFpeFRRVUZ4UWp0QlFVTndRaXhIUVVGelFpeERRVUYwUWl4VlFVRnpRanRCUVVOcVFpeEhRVUV5UWl4RFFVRXpRaXhWUVVFeVFqdEJRVU14UWl4SFFVRTBRaXhEUVVFMVFpeFhRVUUwUWp0QlFVTjRRaXhIUVVGblF5eERRVUZvUXl4alFVRm5RenRCUVVOMFFpeEhRVUV5UXl4RFFVRXpReXhYUVVFeVF6dEJRVVV4UXl4SFFVRmhMRU5CUVdJc1RVRkJZVHRCUVVOeFFpeEhRVUZ6UWl4RFFVRjBRaXhMUVVGelFqdEJRVU4zUWl4SFFVRTBRaXhEUVVFMVFpeFhRVUUwUWpzN096czdPenM3T3pzN096czdPemhFUVdRelNqdHpRMEZCUVRzMlJFRkJRVHRwUlVGQlFUczdPenQzUlVGQlFUdG5SVUZCUVRzN096czdPMHRCUVVFN096czdPenM3T3pzN096czdUVUZCUVR0NVJFRkJRVHM3T3pzN096czdPenM3T3pzN08zVkNRVUZCT3p0TFFVRkJPenM3T3pKQ1FVRkJPenM3T3pzN096dHhSa0ZCUVRzN096czdPenM3T3pzN08yMUZRVUZCT3p0cFJFRkJRVHM3T3pzN1FVRm5Ra0VzUjBGQlN5eERRVUZIUVN4TFFVRkxMRWRCUVV0RExGVkJRV01zWjBKQlFYaENSQ3hMUVVGTE8wRkJSVVVzUjBGQlN5eERRVUZEUlN4cFEwRkJhVU1zYVVKQlFYWkRMRkZCUVZFN2VVVkJiRUoyUWpzN1lVRnJRbkZDUVN4cFEwRkJhVU1zUTBGRGVFTkRMRWxCUVVrc1JVRkJSVU1zUzBGQlN5eEZRVUZGUXl4UlFVRlJMRVZCUVVWRExGVkJRVlVzUlVGQlJVTXNhMEpCUVd0Q0xFVkJRVVZETEhOQ1FVRnpRaXhGUVVGRlF5eHBRMEZCYVVNN1owVkJia0k1U0RzN2EwTkJiMEpWVGl4SlFVRkpMRVZCUVVWRExFdEJRVXNzUlVGQlJVTXNVVUZCVVN4RlFVRkZReXhWUVVGVkxFVkJRVVZETEd0Q1FVRnJRaXhGUVVGRlF5eHpRa0ZCYzBJc1EwTndRblpHTEVORWIwSjVSanRqUVVWb1JrTXNhVU5CUVdsRExFZEJRVWRCTEdsRFFVRnBReXhEUVVGRE96czdPenRaUVVjM1JVTXNSMEZCYjBNc1JVRkJjRU5CTEVOQlFXOURPMjFDUVVGd1EwRXNVVUZCVVN4RFFVRlNRU3h2UTBGQmIwTXNSMEZCUnl4RFFVRkRPMmRDUVVOMFF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRSQ3hwUTBGQmFVTTdXVUZETDBNc1EwRkJRenM3TzFsQlJVUkZMRWRCUVU4c1JVRkJVRUVzUTBGQlR6dHRRa0ZCVUVFc1VVRkJVVU1zUTBGQlVrUXNUMEZCVHl4RFFVRkRReXhQUVVGUExFVkJRVVVzUTBGQlF6dG5Ra0ZEYUVJc1IwRkJTeXhEUVVGRFRpeFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRUeXhoUVVGaExFbEJReTlDVWl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRFV5eFhRVUZYTEVsQlF6TkNReXhKUVVGSkxFZEJRVWRJTEU5QlFVOHNRMEZCUTFBc1VVRkJVU3hMUVVGTExFbEJRVWs3WjBKQlJYUkRMRWRCUVVzc1EwRkJRMGNzYzBKQlFYTkNMRWRCUVVjc1NVRkJTU3hEUVVGRFVTeDVRa0ZCZVVJc1NVRkRka1JETERCQ1FVRXdRaXhIUVVGSGFrSXNTMEZCU3l4RFFVRkRVU3h6UWtGQmMwSXNSMEZEZWtSVkxIRkNRVUZ4UWl4SFFVRkhSQ3d3UWtGQk1FSXNSVUZEYkVSRkxHbENRVUZwUWl4SFFVRkhVQ3hQUVVGUExFTkJRVU5OTEhGQ1FVRnhRaXhMUVVGTExFbEJRVWs3WjBKQlJXaEZMRWRCUVVzc1EwRkJRMFVzVjBGQlZ5eFBRVUZIUXl4TFFVRnRRaXh6UWtGQlEwWXNhVUpCUVdsQ0xFVkJRVVZRTEU5QlFVOHNSVUZCUlZVc1VVRkJWeXhYUVVONlJVTXNaMEpCUVdkQ0xFZEJRVWRJTEZkQlFWY3NRMEZCUTBrc1QwRkJUenRuUWtGRk5VTXNSVUZCUlN4RlFVRkZSQ3huUWtGQlowSXNSVUZCUlN4RFFVRkRPMjlDUVVOeVFpeEhRVUZMTEVOQlFVTkZMR2RDUVVGblFpeEhRVUZIYmtJc1ZVRkJWU3hEUVVGRGIwSXNVVUZCVVN4SlFVTjBRMnBDTEdsRFFVRnBReXhIUVVGSExFbEJRVWtzUTBGQlEwTXNiME5CUVc5RExFbEJRemRGYVVJc2RVTkJRWFZETEVkQlFVZHNRaXhwUTBGQmFVTXNRMEZCUTJsQ0xGRkJRVkU3YjBKQlJURkdMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU5GTEV0QlFVc3NRMEZCUlN4RFFVRkxMRTlCUVRKR1ZpeE5RVUZ4UWl4RFFVRTVSMU1zZFVOQlFYVkRMRVZCUVVNc1EwRkJLME1zYTBSQlFXdEhSaXhOUVVGblFpeERRVUZvU0ZBc2NVSkJRWEZDTEVWQlFVTXNRMEZCZDBVc01rVkJRVzlGWWl4TlFVRlJMRU5CUVRGRmIwSXNaMEpCUVdkQ0xFVkJRVU1zUTBGQkswTXNhMFJCUVZjc1RVRkJNa0lzUTBGQmNFTndRaXhSUVVGUkxFVkJRVU1zUTBGQk1rSTdaMEpCUTNwVUxFTkJRVU03WjBKQlJVUXNSMEZCU3l4RFFVRkRkMElzV1VGQldTeFBRVUZIUXl4TFFVRnZRaXgxUWtGQlExZ3NhVUpCUVdsQ0xFVkJRVVZRTEU5QlFVOHNSVUZCUlcxQ0xGTkJRVmtzVjBGRE5VVkRMR3RDUVVGclFpeEhRVUZIUXl4VlFVRnJRaXhUUVVGRFF5eGpRVUZqTEVOQlFVTTFRaXhWUVVGVk8yZENRVVYyUlhWQ0xGbEJRVmtzUTBGQlEwMHNZVUZCWVN4RFFVRkRTQ3hyUWtGQmEwSXNRMEZCUXl4RFFVRkRPMjlDUVVVdlEwa3NTMEZCY1VJc2QwSkJRVU5xUWl4cFFrRkJhVUlzUlVGQlJWQXNUMEZCVHl4RlFVRkZlVUlzVlVGQllTeFRRVUZETEVOQlFVTTdaMEpCUldwRkxFZEJRVXNzUTBGQlEwTXNiVUpCUVcxQ0xFZEJRVWRETEZkQlFXMUNMRk5CUVVORExITkRRVUZ6UXl4RFFVRkRiRU1zVlVGQlZTeEZRVUZGV1N4eFFrRkJjVUlzUjBGRGJFaDFRaXh4UWtGQmNVSXNSMEZCUnl4SlFVRkpMRVZCUVVVc1JVRkJSeXhCUVVGSUxFTkJRVWM3WjBKQlJYWkRNVUlzU1VGQlNTeERRVUZETWtJc2FVSkJRV2xDTEVOQlFVTkVMSEZDUVVGeFFpeEZRVUZGU0N4dFFrRkJiVUlzUTBGQlF5eERRVUZETzFsQlEzSkZMRU5CUVVNN096czdXVUZGVFVzc1IwRkJOa01zUlVGQk4wTkJMRU5CUVRaRE8yMUNRVUZ3UkN4UlFVRlJMRU5CUVVSQkxEWkRRVUUyUXl4RFFVRkRkRU1zVVVGQlVTeEZRVUZGUXl4VlFVRlZMRVZCUVVWelF5eHZRa0ZCYjBJc1JVRkJSU3hEUVVGRE8yZENRVU5vUnl4SFFVRkhMRU5CUVVORExHbERRVUZwUXl4SFFVRkhMRWxCUVVrN1owSkJSVFZETEVkQlFVc3NRMEZCUTNKRExITkNRVUZ6UWl4UFFVRkhjME1zVjBGQmIwTXNkVU5CUVVONFF5eFZRVUZWTEVkQlEzaEZlVU1zTkVKQlFUUkNMRWRCUVVkMlF5eHpRa0ZCYzBJc1EwRkJRM2RETEUxQlFVMHNSVUZETlVSRExIVkNRVUYxUWl4SFFVRkpSaXcwUWtGQk5FSXNSMEZCUnl4RFFVRkRPMmRDUVVWcVJTeEZRVUZGTEVWQlFVVkZMSFZDUVVGMVFpeEZRVUZGTEVOQlFVTTdiMEpCUXpWQ2VrTXNjMEpCUVhOQ0xFTkJRVU13UXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGUWFFTXNjVUpCUVhGQ0xFVkJRVXNzUTBGQlF6dDNRa0ZEZEVRc1IwRkJTeXhEUVVGRGFVTXNOa0pCUVRaQ0xFZEJRVWs1UXl4UlFVRlJMRXRCUVV0aExIRkNRVUZ4UWp0M1FrRkZla1VzUlVGQlJTeEhRVUZIYVVNc05rSkJRVFpDTEVWQlFVVXNRMEZCUXpzMFFrRkRia01zUjBGQlN5eERRVUZETVVNc2FVTkJRV2xETEVkQlFVY3lReXhYUVVGcFF5eFRRVUZEUXl4M1JFRkJkMFFzUTBGQlEyaEVMRkZCUVZFc1JVRkJSV0VzY1VKQlFYRkNMRVZCUVVVd1FpeHZRa0ZCYjBJN05FSkJSVEZNTEVWQlFVVXNSVUZCUlc1RExHbERRVUZwUXl4TFFVRkxMRWxCUVVrc1JVRkJSU3hEUVVGRE8yZERRVU12UXl4SFFVRkxMRU5CUVVNMlF5eGxRVUZsTEU5QlFVZERMRmRCUVdsQ0xHOUNRVUZEYWtRc1ZVRkJWVHRuUTBGRmNFUXNSVUZCUlN4RlFVRkZaMFFzWlVGQlpTeEZRVUZGTEVOQlFVTTdiME5CUTNCQ0xFZEJRVXNzUTBGQlF6ZENMR2RDUVVGblFpeEhRVUZIYmtJc1ZVRkJWU3hEUVVGRGIwSXNVVUZCVVR0dlEwRkZOVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUTBVc1MwRkJTeXhEUVVGRkxFTkJRVXNzVDBGQmIwVjJRaXhOUVVGUkxFTkJRVEZGYjBJc1owSkJRV2RDTEVWQlFVTXNRMEZCSzBNc2EwUkJRVmNzVFVGQmEwUXNRMEZCTTBSd1FpeFJRVUZSTEVWQlFVTXNRMEZCYTBRN1owTkJRM1pLTEVOQlFVTTdaME5CUlVRc1IwRkJTeXhEUVVGRGJVUXNhVUpCUVdsQ0xFOUJRVWRETEZkQlFXMUNMSE5DUVVGRGJrUXNWVUZCVlR0blEwRkZlRVFzUlVGQlJTeEZRVUZGYTBRc2FVSkJRV2xDTEVWQlFVVXNRMEZCUXp0dlEwRkRkRUlzUjBGQlN5eERRVUZETDBJc2FVSkJRV2RDTEVkQlFVZHVRaXhWUVVGVkxFTkJRVU52UWl4UlFVRlJPMjlEUVVVMVF5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRSU3hMUVVGTExFTkJRVVVzUTBGQlN5eFBRVUZ2UlhaQ0xFMUJRVkVzUTBGQk1VVnZRaXhwUWtGQlowSXNSVUZCUXl4RFFVRXJReXhyUkVGQlZ5eE5RVUZ2UkN4RFFVRTNSSEJDTEZGQlFWRXNSVUZCUXl4RFFVRnZSRHRuUTBGRGVrb3NRMEZCUXp0blEwRkZSQ3hIUVVGTExFTkJRVU5HTEVsQlFVa3NSMEZCUjNWRUxFMUJRVGhDTEdsRFFVTnlRM1JFTEV0QlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkRWa2NzYTBKQlFXdENMRTlCUVVkdlJDeFhRVUZuUXl4dFEwRkJRM0pFTEZWQlFWVTdaME5CUlhSRmRVTXNhVU5CUVdsRExFZEJRVWNzUjBGQlJ5eERRVUZETTBNc2FVTkJRV2xETEVOQlFVTkRMRWxCUVVrc1JVRkJSVU1zUzBGQlN5eEZRVUZGUXl4UlFVRlJMRVZCUVVWRExGVkJRVlVzUlVGQlJVTXNhMEpCUVd0Q0xFVkJRVVZETEhOQ1FVRnpRaXhGUVVGRlF5eHBRMEZCYVVNc1EwRkJReXhEUVVGRE8yZERRVVUxVEN4TlFVRk5MRU5CUVVNc1NVRkJTVHMwUWtGRFlpeERRVUZETzNkQ1FVTklMRU5CUVVNN2IwSkJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTB3c1EwRkJRenRuUWtGRlJDeE5RVUZOTEVOQlFVTnZReXhwUTBGQmFVTTdXVUZETVVNc1EwRkJRenM3VFVFelIwZzdPMFZCYTBJclJHVXNZMEZCZFVJN2EwSkJRV3BGTVVRc2FVTkJRV2xETEVGQmJFSjBSQ0o5IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVjdXJzaXZlRGVmaW5pdGlvbiBmcm9tIFwiLi9kZWZpbml0aW9uL3JlY3Vyc2l2ZVwiO1xuaW1wb3J0IExlZnRSZWN1cnNpdmVEZWZpbml0aW9uIGZyb20gXCIuL2RlZmluaXRpb24vbGVmdFJlY3Vyc2l2ZVwiO1xuaW1wb3J0IERpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gZnJvbSBcIi4vZGVmaW5pdGlvbi9sZWZ0UmVjdXJzaXZlL2RpcmVjdGx5XCI7XG5pbXBvcnQgSW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uIGZyb20gXCIuL2RlZmluaXRpb24vbGVmdFJlY3Vyc2l2ZS9pbmRpcmVjdGx5XCI7XG5cbmltcG9ydCB7IGlzSW5zdGFuY2VPZiB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uKHN0YXJ0UnVsZSwgcnVsZU1hcCkge1xuICBjb25zdCBydWxlID0gc3RhcnRSdWxlLCAvLy9cbiAgICAgICAgcmVjdXJzaXZlRGVmaW5pdGlvbnMgPSBbXSxcbiAgICAgICAgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zID0gW107XG5cbiAgcmVwbGFjZVJlY3Vyc2l2ZURlZmluaXRpb25zKHJ1bGUsIHJlY3Vyc2l2ZURlZmluaXRpb25zLCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMsIHJ1bGVNYXApO1xuXG4gIHJld3JpdGVMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMobGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zLCBydWxlTWFwKTtcblxuICBjb25zdCBzdGFydFJ1bGVOYW1lID0gc3RhcnRSdWxlLmdldE5hbWUoKTtcblxuICBzdGFydFJ1bGUgPSBydWxlTWFwW3N0YXJ0UnVsZU5hbWVdOyAvLy9cblxuICByZXR1cm4gc3RhcnRSdWxlO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlUmVjdXJzaXZlRGVmaW5pdGlvbihydWxlTmFtZSwgZGVmaW5pdGlvbiwgcmVjdXJzaXZlRGVmaW5pdGlvbnMsIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucywgcnVsZU1hcCkge1xuICBjb25zdCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IEluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWVEZWZpbml0aW9uQW5kUmVjdXJzaXZlRGVmaW5pdGlvbnMocnVsZU5hbWUsIGRlZmluaXRpb24sIHJlY3Vyc2l2ZURlZmluaXRpb25zKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERpcmVjdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lQW5kRGVmaW5pdGlvbihydWxlTmFtZSwgZGVmaW5pdGlvbikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWVBbmREZWZpbml0aW9uKHJ1bGVOYW1lLCBkZWZpbml0aW9uKTtcblxuICBpZiAobGVmdFJlY3Vyc2l2ZURlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbkluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IGlzSW5zdGFuY2VPZihsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiwgSW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKTtcblxuICAgIGlmIChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbkluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbikge1xuICAgICAgY29uc3QgaW5kaXJlY3RseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uID0gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24sICAvLy9cbiAgICAgICAgICAgIGltcGxpY2l0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA9IGluZGlyZWN0bHlMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRJbXBsaWNpdGx5TGVmdFJlY3Vyc2l2ZURlZmluaXRpb24oKTtcblxuICAgICAgaW1wbGljaXRseUxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLnJlcGxhY2UocnVsZU1hcCk7XG4gICAgfVxuXG4gICAgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zLnB1c2gobGVmdFJlY3Vyc2l2ZURlZmluaXRpb24pO1xuICB9XG5cbiAgY29uc3QgcmVjdXJzaXZlRGVmaW5pdGlvbiA9IChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbiA6IC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlY3Vyc2l2ZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lQW5kRGVmaW5pdGlvbihydWxlTmFtZSwgZGVmaW5pdGlvbik7XG5cbiAgaWYgKHJlY3Vyc2l2ZURlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICByZWN1cnNpdmVEZWZpbml0aW9uLnJlcGxhY2UocnVsZU1hcCk7XG4gIH1cblxuICByZXR1cm4gcmVjdXJzaXZlRGVmaW5pdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVJlY3Vyc2l2ZURlZmluaXRpb25zKHJ1bGUsIHJlY3Vyc2l2ZURlZmluaXRpb25zLCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCk7XG5cbiAgZGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb25SZWN1cnNpdmVEZWZpbml0aW9uID0gaXNJbnN0YW5jZU9mKGRlZmluaXRpb24sIFJlY3Vyc2l2ZURlZmluaXRpb24pLFxuICAgICAgICAgIHJlY3Vyc2l2ZURlZmluaXRpb24gPSBkZWZpbml0aW9uUmVjdXJzaXZlRGVmaW5pdGlvbiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA6ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VSZWN1cnNpdmVEZWZpbml0aW9uKHJ1bGVOYW1lLCBkZWZpbml0aW9uLCByZWN1cnNpdmVEZWZpbml0aW9ucywgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zLCBydWxlTWFwKTtcblxuICAgIGlmIChyZWN1cnNpdmVEZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1JlY3Vyc2l2ZURlZmluaXRpb25zID0gWyAuLi5yZWN1cnNpdmVEZWZpbml0aW9ucywgcmVjdXJzaXZlRGVmaW5pdGlvbiBdLFxuICAgICAgICAgICAgcHJldmlvdXNSZWN1cnNpdmVSdWxlTmFtZXMgPSBwcmV2aW91c1JlY3Vyc2l2ZURlZmluaXRpb25zLm1hcCgocHJldmlvdXNSZWN1cnNpdmVEZWZpbml0aW9uKSA9PiByZWN1cnNpdmVSdWxlTmFtZUZyb21SZWN1cnNpdmVEZWZpbml0aW9uKHByZXZpb3VzUmVjdXJzaXZlRGVmaW5pdGlvbikpLFxuICAgICAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzID0gcmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRSZWN1cnNpdmVSdWxlTmFtZXMoKTtcblxuICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzLmZvckVhY2goKHJlY3Vyc2l2ZVJ1bGVOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSZWN1cnNpdmVSdWxlTmFtZSA9IHByZXZpb3VzUmVjdXJzaXZlUnVsZU5hbWVzLmluY2x1ZGVzKHJlY3Vyc2l2ZVJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAoIXByZXZpb3VzUmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcmVjdXJzaXZlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0gfHwgbnVsbDsgLy8vXG5cbiAgICAgICAgICBpZiAocnVsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVjdXJzaXZlRGVmaW5pdGlvbnMgPSBwcmV2aW91c1JlY3Vyc2l2ZURlZmluaXRpb25zOyAgLy8vXG5cbiAgICAgICAgICAgIHJlcGxhY2VSZWN1cnNpdmVEZWZpbml0aW9ucyhydWxlLCByZWN1cnNpdmVEZWZpbml0aW9ucywgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zLCBydWxlTWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJld3JpdGVMZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMobGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zLCBydWxlTWFwKSB7XG4gIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucy5mb3JFYWNoKChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbikgPT4gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24ucmV3cml0ZShydWxlTWFwKSk7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lRnJvbVJlY3Vyc2l2ZURlZmluaXRpb24ocmVjdXJzaXZlRGVmaW5pdGlvbikge1xuICBjb25zdCByZWN1cnNpdmVEZWZpbml0aW9uUnVsZU5hbWUgPSByZWN1cnNpdmVEZWZpbml0aW9uLmdldFJ1bGVOYW1lKCksXG4gICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lID0gcmVjdXJzaXZlRGVmaW5pdGlvblJ1bGVOYW1lOyAgLy8vXG5cbiAgcmV0dXJuIHJlY3Vyc2l2ZVJ1bGVOYW1lO1xuXG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSZWR1Y2VkTm9kZSBmcm9tIFwiLi9ub2RlL3JlZHVjZWRcIjtcbmltcG9ydCBSZXBlYXRlZE5vZGUgZnJvbSBcIi4vbm9kZS9yZXBlYXRlZFwiO1xuXG5pbXBvcnQgeyBpc0luc3RhbmNlT2YgfSBmcm9tIFwiLi91dGlsaXRpZXMvY2xhc3NcIjtcbmltcG9ydCB7IHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZSwgY2hlY2tSZWR1Y2VkUnVsZU5hbWVNYXRjaGVzUnVsZU5hbWUgfSBmcm9tIFwiLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlcyhub2RlKSB7XG4gIHJlbW92ZU9yUmVuYW1lUmVkdWNlZE5vZGVzKG5vZGUpO1xuXG4gIHJlbW92ZVJlcGVhdGVkTm9kZXMobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJlcGVhdGVkTm9kZXMobm9kZSkge1xuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgLy8vXG5cbiAgICBsZXQgY2hpbGROb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCk7XG5cbiAgICBjaGlsZE5vZGVzID0gcmVtb3ZlUmVwZWF0ZWRDaGlsZE5vZGVzKGNoaWxkTm9kZXMpO1xuXG4gICAgbm9uVGVybWluYWxOb2RlLnNldENoaWxkTm9kZXMoY2hpbGROb2RlcylcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSZXBlYXRlZENoaWxkTm9kZXMoY2hpbGROb2Rlcykge1xuICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5yZWR1Y2UoKGNoaWxkTm9kZXMsIGNoaWxkTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZVJlcGVhdGVkTm9kZSA9IGlzSW5zdGFuY2VPZihjaGlsZE5vZGUsIFJlcGVhdGVkTm9kZSk7XG5cbiAgICBpZiAoY2hpbGROb2RlUmVwZWF0ZWROb2RlKSB7XG4gICAgICBsZXQgY2hpbGROb2RlQ2hpbGROb2RlcyA9IGNoaWxkTm9kZS5nZXRDaGlsZE5vZGVzKCk7XG5cbiAgICAgIGNoaWxkTm9kZUNoaWxkTm9kZXMgPSByZW1vdmVSZXBlYXRlZENoaWxkTm9kZXMoY2hpbGROb2RlQ2hpbGROb2Rlcyk7XG5cbiAgICAgIGNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzLmNvbmNhdChjaGlsZE5vZGVDaGlsZE5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlUmVwZWF0ZWROb2RlcyhjaGlsZE5vZGUpO1xuXG4gICAgICBjaGlsZE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGROb2RlcztcbiAgfSwgW10pO1xuXG4gIHJldHVybiBjaGlsZE5vZGVzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPclJlbmFtZVJlZHVjZWROb2Rlcyhub2RlKSB7XG4gIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgbGV0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgY2hpbGROb2RlcyA9IHJlbW92ZU9yUmVuYW1lUmVkdWNlZENoaWxkTm9kZXMoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgbm9uVGVybWluYWxOb2RlLnNldENoaWxkTm9kZXMoY2hpbGROb2RlcylcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVPclJlbmFtZVJlZHVjZWRDaGlsZE5vZGVzKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5yZWR1Y2UoKGNoaWxkTm9kZXMsIGNoaWxkTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZVJlZHVjZWROb2RlID0gaXNJbnN0YW5jZU9mKGNoaWxkTm9kZSwgUmVkdWNlZE5vZGUpO1xuXG4gICAgaWYgKGNoaWxkTm9kZVJlZHVjZWROb2RlKSB7XG4gICAgICBjb25zdCByZWR1Y2VkTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICByZWR1Y2VkTm9kZVJ1bGVOYW1lID0gcmVkdWNlZE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJlZHVjZWRSdWxlTmFtZSA9IHJlZHVjZWROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgICAgIHJlZHVjZWRSdWxlTmFtZU1hdGNoZXNSdWxlTmFtZSA9IGNoZWNrUmVkdWNlZFJ1bGVOYW1lTWF0Y2hlc1J1bGVOYW1lKHJlZHVjZWRSdWxlTmFtZSwgcnVsZU5hbWUpO1xuXG4gICAgICBpZiAocmVkdWNlZFJ1bGVOYW1lTWF0Y2hlc1J1bGVOYW1lKSB7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZU5hbWVGcm9tUmVkdWNlZFJ1bGVOYW1lKHJlZHVjZWRSdWxlTmFtZSk7XG5cbiAgICAgICAgICBjaGlsZE5vZGUuc2V0UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgICAgICAgcmVtb3ZlT3JSZW5hbWVSZWR1Y2VkTm9kZXMoY2hpbGROb2RlKTtcblxuICAgICAgICAgIGNoaWxkTm9kZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjaGlsZE5vZGVDaGlsZE5vZGVzID0gY2hpbGROb2RlLmdldENoaWxkTm9kZXMoKTtcblxuICAgICAgICAgIGNoaWxkTm9kZUNoaWxkTm9kZXMgPSByZW1vdmVPclJlbmFtZVJlZHVjZWRDaGlsZE5vZGVzKGNoaWxkTm9kZUNoaWxkTm9kZXMpO1xuXG4gICAgICAgICAgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXMuY29uY2F0KGNoaWxkTm9kZUNoaWxkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUpO1xuXG4gICAgICAgIGNoaWxkTm9kZS5zZXRSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICAgICAgcmVtb3ZlT3JSZW5hbWVSZWR1Y2VkTm9kZXMoY2hpbGROb2RlKTtcblxuICAgICAgICBjaGlsZE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlT3JSZW5hbWVSZWR1Y2VkTm9kZXMoY2hpbGROb2RlKTtcblxuICAgICAgY2hpbGROb2Rlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkTm9kZXM7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gY2hpbGROb2Rlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uIH0gZnJvbSBcIi4vZWxpbWluYXRlTGVmdFJlY3Vyc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzIH0gZnJvbSBcIi4vcmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5jb25zdCBQYXJhZ3JhcGggPSB3aXRoU3R5bGUucGBcblxuICBtYXJnaW46IDJyZW0gMCAwIDA7XG4gIGZvbnQtc2l6ZTogMS43cmVtO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBQYXJhZ3JhcGg7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmNvbnN0IFN1YkhlYWRpbmcgPSB3aXRoU3R5bGUuaDJgXG5cbiAgbWFyZ2luOiAxcmVtIDAgMC41cmVtIDA7XG4gIGZvbnQtc2l6ZTogMnJlbTtcbiAgXG4gIDpmaXJzdC1vZi10eXBlIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IFN1YkhlYWRpbmc7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IFNpemVhYmxlRGl2IH0gZnJvbSBcImVhc3ktbGF5b3V0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShTaXplYWJsZURpdilgXG5cbiAgd2lkdGg6IDQ4cmVtO1xuICBtaW4td2lkdGg6IDI0cmVtO1xuICBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IFRleHRhcmVhIH0gZnJvbSBcImVhc3lcIjtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFRleHRhcmVhKWBcblxuICBib3JkZXI6IDFweCBzb2xpZCBkYXJrZ3JleTtcbiAgaGVpZ2h0OiAyNHJlbTtcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcbiAgcGFkZGluZzogMC4yNXJlbTtcbiAgZm9udC1zaXplOiAxLjJyZW07XG4gIHdoaXRlLXNwYWNlOiBwcmU7XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0YXJlYSBmcm9tIFwiLi4vdGV4dGFyZWFcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQk5GVGV4dGFyZWEgZXh0ZW5kcyBUZXh0YXJlYSB7XG4gIGdldEJORigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBibmYgPSB2YWx1ZTsgLy8vXG5cbiAgICByZXR1cm4gYm5mO1xuICB9XG5cbiAgc2V0Qk5GKGJuZikge1xuICAgIGNvbnN0IHZhbHVlID0gYm5mO1xuXG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBwYXJlbnRDb250ZXh0KCkge1xuICAgIGNvbnN0IGdldEJORiA9IHRoaXMuZ2V0Qk5GLmJpbmQodGhpcyksXG4gICAgICAgICAgc2V0Qk5GID0gdGhpcy5zZXRCTkYuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgZ2V0Qk5GLFxuICAgICAgc2V0Qk5GXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImJuZlwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGV4dGFyZWEgZnJvbSBcIi4uL3RleHRhcmVhXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgZ2V0Q29udGVudCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBjb250ZW50ID0gdmFsdWU7IC8vL1xuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbnRlbnQ7XG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0Q29udGVudCA9IHRoaXMuZ2V0Q29udGVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldENvbnRlbnQgPSB0aGlzLnNldENvbnRlbnQuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgZ2V0Q29udGVudCxcbiAgICAgIHNldENvbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29udGVudFwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGV4dGFyZWEgZnJvbSBcIi4uL3RleHRhcmVhXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlVHJlZVRleHRhcmVhIGV4dGVuZHMgVGV4dGFyZWEge1xuICBzZXRQYXJzZVRyZWUocGFyc2VUcmVlKSB7XG4gICAgaWYgKHBhcnNlVHJlZSAhPT0gbnVsbCkge1xuICAgICAgcGFyc2VUcmVlLnNoaWZ0TGluZSgpOyAgLy9cblxuICAgICAgY29uc3QgcGFyc2VUcmVlU3RyaW5nID0gcGFyc2VUcmVlLmFzU3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlVHJlZVN0cmluZzsgIC8vL1xuXG4gICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclBhcnNlVHJlZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyUGFyc2VUcmVlKCkge1xuICAgIGNvbnN0IHZhbHVlID0gXCJcIjtcblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXRQYXJzZVRyZWUgPSB0aGlzLnNldFBhcnNlVHJlZS5iaW5kKHRoaXMpLFxuICAgICAgICAgIGNsZWFyUGFyc2VUcmVlID0gdGhpcy5jbGVhclBhcnNlVHJlZS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBzZXRQYXJzZVRyZWUsXG4gICAgICBjbGVhclBhcnNlVHJlZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJ0b2tlbnNcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgSW5wdXQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBMZXhpY2FsUGF0dGVybklucHV0IGV4dGVuZHMgSW5wdXQge1xuICBnZXRMZXhpY2FsUGF0dGVybigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBsZXhpY2FsUGF0dGVybiA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBsZXhpY2FsUGF0dGVybjtcbiAgfVxuXG4gIHNldExleGljYWxQYXR0ZXJuKGxleGljYWxQYXR0ZXJuKSB7XG4gICAgY29uc3QgdmFsdWUgPSBsZXhpY2FsUGF0dGVybjsgLy8vXG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0TGV4aWNhbFBhdHRlcm4gPSB0aGlzLmdldExleGljYWxQYXR0ZXJuLmJpbmQodGhpcyksXG4gICAgICAgICAgc2V0TGV4aWNhbFBhdHRlcm4gPSB0aGlzLnNldExleGljYWxQYXR0ZXJuLmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIGdldExleGljYWxQYXR0ZXJuLFxuICAgICAgc2V0TGV4aWNhbFBhdHRlcm5cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwibGV4aWNhbC1wYXR0ZXJuXCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShMZXhpY2FsUGF0dGVybklucHV0KWBcblxuICBib3JkZXI6IDFweCBzb2xpZCBkYXJrZ3JleTtcbiAgcGFkZGluZzogMC4yNXJlbTtcbiAgZm9udC1zaXplOiAxLjJyZW07XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGp1c3RlZEJORlRleHRhcmVhIGV4dGVuZHMgVGV4dGFyZWEge1xuICBnZXRBZGp1c3RlZEJORigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBhZGp1c3RlZEJORiA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBhZGp1c3RlZEJORjtcbiAgfVxuXG4gIHNldEFkanVzdGVkQk5GKGFkanVzdGVkQk5GKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhZGp1c3RlZEJORjsgIC8vL1xuXG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBjbGVhckFkanVzdGVkQk5GKCkge1xuICAgIGNvbnN0IHZhbHVlID0gXCJcIjtcblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBnZXRBZGp1c3RlZEJORiA9IHRoaXMuZ2V0QWRqdXN0ZWRCTkYuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXRBZGp1c3RlZEJORiA9IHRoaXMuc2V0QWRqdXN0ZWRCTkYuYmluZCh0aGlzKSxcbiAgICAgICAgICBjbGVhckFkanVzdGVkQk5GID0gdGhpcy5jbGVhckFkanVzdGVkQk5GLmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIGdldEFkanVzdGVkQk5GLFxuICAgICAgc2V0QWRqdXN0ZWRCTkYsXG4gICAgICBjbGVhckFkanVzdGVkQk5GXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImFkanVzdGVkLWJuZlwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIixcbiAgICByZWFkT25seTogZmFsc2VcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgQ2hlY2tib3ggfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBSZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3ggZXh0ZW5kcyBDaGVja2JveCB7XG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgaXNSZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3hDaGVja2VkID0gdGhpcy5pc0NoZWNrZWQuYmluZCh0aGlzKTsgLy8vXG5cbiAgICByZXR1cm4gKHtcbiAgICAgIGlzUmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94Q2hlY2tlZFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJyZW1vdmUtb3ItcmVuYW1lLWludGVybWVkaWF0ZS1ub2Rlc1wiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoUmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94KWBcblxuICB6b29tOiAxLjU7XG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xuICB2ZXJ0aWNhbC1hbGlnbjogYm90dG9tO1xuICBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IFVOQVNTSUdORURfRU5UUlkgPSBcIl4uKiRcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmaXJzdCwgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcztcblxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNBc1N0cmluZyhydWxlcywgbXVsdGlMaW5lKSB7XG4gIGNvbnN0IG1heGltdW1SdWxlTmFtZUxlbmd0aCA9IHJ1bGVzLnJlZHVjZSgobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBydWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aDtcblxuICAgICAgICAgIG1heGltdW1SdWxlTmFtZUxlbmd0aCA9IE1hdGgubWF4KG1heGltdW1SdWxlTmFtZUxlbmd0aCwgcnVsZU5hbWVMZW5ndGgpO1xuXG4gICAgICAgICAgcmV0dXJuIG1heGltdW1SdWxlTmFtZUxlbmd0aDtcbiAgICAgICAgfSwgMCksXG4gICAgICAgIHJ1bGVzU3RyaW5nID0gcnVsZXMucmVkdWNlKChydWxlc1N0cmluZywgcnVsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJ1bGVTdHJpbmcgPSBydWxlLmFzU3RyaW5nKG1heGltdW1SdWxlTmFtZUxlbmd0aCwgbXVsdGlMaW5lKTtcblxuICAgICAgICAgIHJ1bGVzU3RyaW5nICs9IHJ1bGVTdHJpbmc7XG5cbiAgICAgICAgICByZXR1cm4gcnVsZXNTdHJpbmc7XG4gICAgICAgIH0sIEVNUFRZX1NUUklORykucmVwbGFjZSgvXlxcblxcbi8sIEVNUFRZX1NUUklORyk7XG5cbiAgcmV0dXJuIHJ1bGVzU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZU1hcEZyb21SdWxlcyhydWxlcykge1xuICBjb25zdCBydWxlTWFwID0ge307XG5cbiAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBydWxlTWFwW3J1bGVOYW1lXSA9IHJ1bGU7XG4gIH0pO1xuXG4gIHJldHVybiBydWxlTWFwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSdWxlRnJvbVJ1bGVzKHJ1bGVzKSB7XG4gIGNvbnN0IGZpcnN0UnVsZSA9IGZpcnN0KHJ1bGVzKSxcbiAgICAgICAgc3RhcnRSdWxlID0gZmlyc3RSdWxlOyAgLy8vXG5cbiAgcmV0dXJuIHN0YXJ0UnVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAoc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gIGNvbnN0IHJ1bGVzID0gT2JqZWN0LnZhbHVlcyhydWxlTWFwKSxcbiAgICAgICAgc3RhcnRSdWxlTmFtZSA9IHN0YXJ0UnVsZS5nZXROYW1lKCk7XG5cbiAgZmlsdGVyKHJ1bGVzLCAocnVsZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBpZiAocnVsZU5hbWUgIT09IHN0YXJ0UnVsZU5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZXMudW5zaGlmdChzdGFydFJ1bGUpO1xuXG4gIHJldHVybiBydWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQk5GTGV4ZXIgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5pbXBvcnQgeyBCTkZQYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgeyBydWxlTWFwRnJvbVJ1bGVzLCBzdGFydFJ1bGVGcm9tUnVsZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVzXCI7XG5cbmltcG9ydCBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uICBmcm9tIFwiLi4vZWxpbWluYXRlTGVmdFJlY3Vyc2lvblwiO1xuXG5jb25zdCBibmZMZXhlciA9IEJORkxleGVyLmZyb21Ob3RoaW5nKCksXG4gICAgICBibmZQYXJzZXIgPSBCTkZQYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzRnJvbUJORihibmYpIHtcbiAgY29uc3QgdG9rZW5zID0gYm5mTGV4ZXIudG9rZW5zRnJvbUJORihibmYpLFxuICAgICAgICBydWxlcyA9IGJuZlBhcnNlci5ydWxlc0Zyb21Ub2tlbnModG9rZW5zKTtcblxuICByZXR1cm4gcnVsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKSB7XG4gIGNvbnN0IHJ1bGVNYXAgPSBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKTtcblxuICBsZXQgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzKHJ1bGVzKTtcblxuICBzdGFydFJ1bGUgPSBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uKHN0YXJ0UnVsZSwgcnVsZU1hcCk7XG5cbiAgY29uc3QgcGFyc2VyID0gbmV3IENsYXNzKHN0YXJ0UnVsZSwgcnVsZU1hcCk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5pbXBvcnQgeyBCYXNpY0xleGVyIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuaW1wb3J0IHsgQmFzaWNQYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgUm93c0RpdiwgQ29sdW1uRGl2LCBDb2x1bW5zRGl2LCBWZXJ0aWNhbFNwbGl0dGVyRGl2IH0gZnJvbSBcImVhc3ktbGF5b3V0XCI7XG5pbXBvcnQgeyBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uLCByZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzIH0gZnJvbSBcIi4uL2luZGV4XCI7IC8vL1xuXG5pbXBvcnQgUGFyYWdyYXBoIGZyb20gXCIuL3BhcmFncmFwaFwiO1xuaW1wb3J0IFN1YkhlYWRpbmcgZnJvbSBcIi4vc3ViSGVhZGluZ1wiO1xuaW1wb3J0IFNpemVhYmxlRGl2IGZyb20gXCIuL2Rpdi9zaXplYWJsZVwiO1xuaW1wb3J0IEJORlRleHRhcmVhIGZyb20gXCIuL3RleHRhcmVhL2JuZlwiO1xuaW1wb3J0IENvbnRlbnRUZXh0YXJlYSBmcm9tIFwiLi90ZXh0YXJlYS9jb250ZW50XCI7XG5pbXBvcnQgUGFyc2VUcmVlVGV4dGFyZWEgZnJvbSBcIi4vdGV4dGFyZWEvcGFyc2VUcmVlXCI7XG5pbXBvcnQgTGV4aWNhbFBhdHRlcm5JbnB1dCBmcm9tIFwiLi9pbnB1dC9sZXhpY2FsUGF0dGVyblwiO1xuaW1wb3J0IEFkanVzdGVkQk5GVGV4dGFyZWEgZnJvbSBcIi4vdGV4dGFyZWEvYWRqdXN0ZWRCTkZcIjtcbmltcG9ydCBSZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3ggZnJvbSBcIi4vY2hlY2tib3gvcmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc1wiXG5cbmltcG9ydCB7IHJ1bGVzRnJvbUJORiB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFyc2VyXCI7XG5pbXBvcnQgeyBVTkFTU0lHTkVEX0VOVFJZIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgcnVsZXNBc1N0cmluZywgc3RhcnRSdWxlRnJvbVJ1bGVzLCBydWxlTWFwRnJvbVJ1bGVzLCBydWxlc0Zyb21TdGFydFJ1bGVBbmRSdWxlTWFwIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlc1wiO1xuXG5jbGFzcyBWaWV3IGV4dGVuZHMgRWxlbWVudCB7XG4gIGdldFBhcnNlVHJlZShzdGFydFJ1bGUsIHJ1bGVNYXApIHtcbiAgICBsZXQgcGFyc2VUcmVlID0gbnVsbDtcblxuICAgIGNvbnN0IGxleGljYWxQYXR0ZXJuID0gdGhpcy5nZXRMZXhpY2FsUGF0dGVybigpLFxuICAgICAgICAgIHVuYXNzaWduZWQgPSBVTkFTU0lHTkVEX0VOVFJZLFxuICAgICAgICAgIGN1c3RvbSA9IGxleGljYWxQYXR0ZXJuLCAgLy8vXG4gICAgICAgICAgZW50cmllcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY3VzdG9tXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB1bmFzc2lnbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBiYXNpY0xleGVyID0gQmFzaWNMZXhlci5mcm9tRW50cmllcyhlbnRyaWVzKSxcbiAgICAgICAgICBiYXNpY1BhcnNlciA9IG5ldyBCYXNpY1BhcnNlcihzdGFydFJ1bGUsIHJ1bGVNYXApLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIHRva2VucyA9IGJhc2ljTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgICAgbm9kZSA9IGJhc2ljUGFyc2VyLnBhcnNlKHRva2Vucyk7XG5cbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94Q2hlY2tlZCA9IHRoaXMuaXNSZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3hDaGVja2VkKCk7XG5cbiAgICAgIGlmIChyZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3hDaGVja2VkKSB7XG4gICAgICAgIHJlbW92ZU9yUmVuYW1lSW50ZXJtZWRpYXRlTm9kZXMobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlVHJlZSA9IG5vZGUuYXNQYXJzZVRyZWUodG9rZW5zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAga2V5VXBIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgdGhpcy5jaGFuZ2VIYW5kbGVyKCk7XG4gIH1cblxuICBjaGFuZ2VIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJuZiA9IHRoaXMuZ2V0Qk5GKCk7XG5cbiAgICAgIGxldCBydWxlcyA9IHJ1bGVzRnJvbUJORihibmYpLFxuICAgICAgICAgIHN0YXJ0UnVsZSA9IHN0YXJ0UnVsZUZyb21SdWxlcyhydWxlcyk7XG5cbiAgICAgIGNvbnN0IHJ1bGVNYXAgPSBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKTtcblxuICAgICAgc3RhcnRSdWxlID0gZWxpbWluYXRlTGVmdFJlY3Vyc2lvbihzdGFydFJ1bGUsIHJ1bGVNYXApO1xuXG4gICAgICBydWxlcyA9IHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAoc3RhcnRSdWxlLCBydWxlTWFwKTtcblxuICAgICAgY29uc3QgbXVsdGlMaW5lID0gdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlVHJlZSA9IHRoaXMuZ2V0UGFyc2VUcmVlKHN0YXJ0UnVsZSwgcnVsZU1hcCksXG4gICAgICAgICAgICBydWxlc1N0cmluZyA9IHJ1bGVzQXNTdHJpbmcocnVsZXMsIG11bHRpTGluZSksXG4gICAgICAgICAgICBhZGp1c3RlZEJORiA9IHJ1bGVzU3RyaW5nOyAgLy8vXG5cbiAgICAgIHRoaXMuc2V0UGFyc2VUcmVlKHBhcnNlVHJlZSk7XG5cbiAgICAgIHRoaXMuc2V0QWRqdXN0ZWRCTkYoYWRqdXN0ZWRCTkYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG5cbiAgICAgIHRoaXMuY2xlYXJQYXJzZVRyZWUoKTtcblxuICAgICAgdGhpcy5jbGVhckFkanVzdGVkQk5GKCk7XG4gICAgfVxuICB9XG5cbiAgY2hpbGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBrZXlVcEhhbmRsZXIgPSB0aGlzLmtleVVwSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICAgIGNoYW5nZUhhbmRsZXIgPSB0aGlzLmNoYW5nZUhhbmRsZXIuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoW1xuXG4gICAgICA8Q29sdW1uc0Rpdj5cbiAgICAgICAgPFNpemVhYmxlRGl2PlxuICAgICAgICAgIDxSb3dzRGl2PlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIExleGljYWwgcGF0dGVyblxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPExleGljYWxQYXR0ZXJuSW5wdXQgb25LZXlVcD17a2V5VXBIYW5kbGVyfSAvPlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIEJORlxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPEJORlRleHRhcmVhIG9uS2V5VXA9e2tleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBBZGp1c3RlZCBCTkZcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxBZGp1c3RlZEJORlRleHRhcmVhIHJlYWRPbmx5IC8+XG4gICAgICAgICAgPC9Sb3dzRGl2PlxuICAgICAgICA8L1NpemVhYmxlRGl2PlxuICAgICAgICA8VmVydGljYWxTcGxpdHRlckRpdiAvPlxuICAgICAgICA8Q29sdW1uRGl2PlxuICAgICAgICAgIDxSb3dzRGl2PlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIENvbnRlbnRcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxDb250ZW50VGV4dGFyZWEgb25LZXlVcD17a2V5VXBIYW5kbGVyfSAvPlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIFBhcnNlIHRyZWVcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxQYXJzZVRyZWVUZXh0YXJlYSAvPlxuICAgICAgICAgICAgPFBhcmFncmFwaD5cbiAgICAgICAgICAgICAgPFJlbW92ZU9yUmVuYW1lSW50ZXJtZWRpYXRlTm9kZXNDaGVja2JveCBvbkNoYW5nZT17Y2hhbmdlSGFuZGxlcn0gY2hlY2tlZCAvPlxuICAgICAgICAgICAgICBSZW1vdmUgb3IgcmVuYW1lIGludGVybWVkaWF0ZSBub2Rlc1xuICAgICAgICAgICAgPC9QYXJhZ3JhcGg+XG4gICAgICAgICAgPC9Sb3dzRGl2PlxuICAgICAgICA8L0NvbHVtbkRpdj5cbiAgICAgIDwvQ29sdW1uc0Rpdj5cblxuICAgIF0pO1xuICB9XG5cbiAgaW5pdGlhbGlzZSgpIHtcbiAgICB0aGlzLmFzc2lnbkNvbnRleHQoKTtcblxuICAgIGNvbnN0IHsgaW5pdGlhbEJORiwgaW5pdGlhbENvbnRlbnQsIGluaXRpYWxMZXhpY2FsUGF0dGVybiB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBibmYgPSBpbml0aWFsQk5GLCAvLy9cbiAgICAgICAgICBjb250ZW50ID0gaW5pdGlhbENvbnRlbnQsIC8vL1xuICAgICAgICAgIGxleGljYWxQYXR0ZXJuID0gaW5pdGlhbExleGljYWxQYXR0ZXJuOyAvLy9cblxuICAgIHRoaXMuc2V0Qk5GKGJuZik7XG5cbiAgICB0aGlzLnNldENvbnRlbnQoY29udGVudCk7XG5cbiAgICB0aGlzLnNldExleGljYWxQYXR0ZXJuKGxleGljYWxQYXR0ZXJuKTtcblxuICAgIHRoaXMua2V5VXBIYW5kbGVyKCk7XG4gIH1cblxuICBzdGF0aWMgaW5pdGlhbEJORiA9IGBcbmV4cHJlc3Npb24gICAgOjo9IGV4cHJlc3Npb24gb3BlcmF0b3IgZXhwcmVzc2lvblxuXG4gICAgICAgICAgICAgICAgfCBcIihcIiBleHByZXNzaW9uIFwiKVwiXG5cbiAgICAgICAgICAgICAgICB8IHRlcm1cblxuICAgICAgICAgICAgICAgIDtcblxub3BlcmF0b3IgICAgICA6Oj0gXCIrXCIgfCBcIi1cIiB8IFwiL1wiIHwgXCIqXCIgO1xuXG50ZXJtICAgICAgICAgIDo6PSAvXFxcXGQrLyA7XG5gO1xuXG4gIHN0YXRpYyBpbml0aWFsQ29udGVudCA9IFwiKDErMikvM1wiO1xuXG4gIHN0YXRpYyBpbml0aWFsTGV4aWNhbFBhdHRlcm4gPSBcIlxcXFxkK3wuXCI7XG5cbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwidmlld1wiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShWaWV3KWBcblxuICBwYWRkaW5nOiAxcmVtO1xuICBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcImp1eHRhcG9zZVwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBCb2R5IH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vZXhhbXBsZS92aWV3XCI7XG5cbmNvbnN0IHsgcmVuZGVyU3R5bGVzIH0gPSB3aXRoU3R5bGU7XG5cbmNvbnN0IGJvZHkgPSBuZXcgQm9keSgpO1xuXG5yZW5kZXJTdHlsZXMoKTtcblxuYm9keS5tb3VudChcblxuICA8Vmlldy8+XG5cbik7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFFcUIsU0FBTiwyQkFBUTt1QkFDVCxLQUFLLE1BQUk7O0FBQ25CLGFBQUssTUFBTTtBQUNYLGFBQUssT0FBTzs7OztVQUdkLEtBQUE7aUJBQUEsa0JBQVM7QUFDUCxtQkFBTyxLQUFLOzs7O1VBR2QsS0FBQTtpQkFBQSxtQkFBVTtBQUNSLG1CQUFPLEtBQUs7Ozs7OztzQkFYSzs7OztBQ0ZyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQUVxQixTQUFOLDJCQUFRO3VCQUNULEtBQUssTUFBTSxPQUFPLFFBQU07O0FBQ2xDLGFBQUssTUFBTTtBQUNYLGFBQUssT0FBTztBQUNaLGFBQUssUUFBUTtBQUNiLGFBQUssU0FBUzs7OztVQUdoQixLQUFBO2lCQUFBLGtCQUFTO0FBQ1AsbUJBQU8sS0FBSzs7OztVQUdkLEtBQUE7aUJBQUEsbUJBQVU7QUFDUixtQkFBTyxLQUFLOzs7O1VBR2QsS0FBQTtpQkFBQSxvQkFBVztBQUNULG1CQUFPLEtB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

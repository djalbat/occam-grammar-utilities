"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _easyWithStyle = _interopRequireDefault(require("easy-with-style"));
var _easy = require("easy");
var _occamLexers = require("occam-lexers");
var _occamParsers = require("occam-parsers");
var _easyLayout = require("easy-layout");
var _index = require("../index");
var _paragraph = _interopRequireDefault(require("./paragraph"));
var _subHeading = _interopRequireDefault(require("./subHeading"));
var _sizeable = _interopRequireDefault(require("./div/sizeable"));
var _bnf = _interopRequireDefault(require("./textarea/bnf"));
var _content = _interopRequireDefault(require("./textarea/content"));
var _parseTree = _interopRequireDefault(require("./textarea/parseTree"));
var _startRuleName = _interopRequireDefault(require("./input/startRuleName"));
var _lexicalPattern = _interopRequireDefault(require("./input/lexicalPattern"));
var _adjustedBNF = _interopRequireDefault(require("./textarea/adjustedBNF"));
var _removeOrRenameIntermediateNodes = _interopRequireDefault(require("./checkbox/removeOrRenameIntermediateNodes"));
var _rules = require("../utilities/rules");
var _constants = require("../constants");
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function _construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
        raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
}
var _typeof = function(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
};
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _templateObject() {
    var data = _taggedTemplateLiteral([
        "\n\n  padding: 1rem;\n  \n"
    ]);
    _templateObject = function _templateObject() {
        return data;
    };
    return data;
}
var rulesAsString = _index.rulesUtilities.rulesAsString, ruleMapFromRules = _index.rulesUtilities.ruleMapFromRules, startRuleFromRulesAndStartRuleName = _index.rulesUtilities.startRuleFromRulesAndStartRuleName;
var View = /*#__PURE__*/ function(Element) {
    _inherits(View, Element);
    var _super = _createSuper(View);
    function View() {
        _classCallCheck(this, View);
        return _super.apply(this, arguments);
    }
    _createClass(View, [
        {
            key: "getParseTree",
            value: function getParseTree(startRule, ruleMap) {
                var parseTree = null;
                var lexicalPattern = this.getLexicalPattern(), unassigned = _constants.UNASSIGNED_ENTRY, custom = lexicalPattern, entries = [
                    {
                        custom: custom
                    },
                    {
                        unassigned: unassigned
                    }
                ], basicLexer = _occamLexers.BasicLexer.fromEntries(entries), basicParser = new _occamParsers.BasicParser(startRule, ruleMap), content = this.getContent(), tokens = basicLexer.tokenise(content), node = basicParser.parse(tokens);
                if (node !== null) {
                    var removeOrRenameIntermediateNodesCheckboxChecked = this.isRemoveOrRenameIntermediateNodesCheckboxChecked();
                    if (removeOrRenameIntermediateNodesCheckboxChecked) {
                        (0, _index).removeOrRenameIntermediateNodes(node);
                    }
                    parseTree = node.asParseTree(tokens);
                }
                return parseTree;
            }
        },
        {
            key: "keyUpHandler",
            value: function keyUpHandler(event, element) {
                this.changeHandler();
            }
        },
        {
            key: "changeHandler",
            value: function changeHandler(event, element) {
                // try {
                var bnf = this.getBNF(), startRuleName = this.getStartRuleName();
                var rules = (0, _rules).rulesFromBNF(bnf);
                var ruleMap = ruleMapFromRules(rules);
                var startRule = startRuleFromRulesAndStartRuleName(rules, startRuleName);
                startRule = (0, _index).eliminateLeftRecursion(startRule, ruleMap);
                rules = (0, _rules).rulesFromStartRuleAndRuleMap(startRule, ruleMap);
                var multiLine = true, rulesString = rulesAsString(rules, multiLine), adjustedBNF = rulesString; ///
                this.setAdjustedBNF(adjustedBNF);
                var parseTree = this.getParseTree(startRule, ruleMap);
                this.setParseTree(parseTree);
            // } catch (error) {
            //   console.log(error);
            // }
            }
        },
        {
            key: "childElements",
            value: function childElements() {
                var keyUpHandler = this.keyUpHandler.bind(this), changeHandler = this.changeHandler.bind(this);
                return [
                    /*#__PURE__*/ React.createElement(_easyLayout.ColumnsDiv, null, /*#__PURE__*/ React.createElement(_sizeable.default, null, /*#__PURE__*/ React.createElement(_easyLayout.RowsDiv, null, /*#__PURE__*/ React.createElement(_subHeading.default, null, "Lexical pattern"), /*#__PURE__*/ React.createElement(_lexicalPattern.default, {
                        onKeyUp: keyUpHandler
                    }), /*#__PURE__*/ React.createElement(_subHeading.default, null, "BNF"), /*#__PURE__*/ React.createElement(_bnf.default, {
                        onKeyUp: keyUpHandler
                    }), /*#__PURE__*/ React.createElement(_subHeading.default, null, "Adjusted BNF"), /*#__PURE__*/ React.createElement(_adjustedBNF.default, {
                        readOnly: true
                    }))), /*#__PURE__*/ React.createElement(_easyLayout.VerticalSplitterDiv, null), /*#__PURE__*/ React.createElement(_easyLayout.ColumnDiv, null, /*#__PURE__*/ React.createElement(_easyLayout.RowsDiv, null, /*#__PURE__*/ React.createElement(_subHeading.default, null, "Start rule name"), /*#__PURE__*/ React.createElement(_startRuleName.default, {
                        onKeyUp: keyUpHandler
                    }), /*#__PURE__*/ React.createElement(_subHeading.default, null, "Content"), /*#__PURE__*/ React.createElement(_content.default, {
                        onKeyUp: keyUpHandler
                    }), /*#__PURE__*/ React.createElement(_subHeading.default, null, "Parse tree"), /*#__PURE__*/ React.createElement(_parseTree.default, null), /*#__PURE__*/ React.createElement(_paragraph.default, null, /*#__PURE__*/ React.createElement(_removeOrRenameIntermediateNodes.default, {
                        onChange: changeHandler,
                        checked: true
                    }), "Remove or rename intermediate nodes"))))
                ];
            }
        },
        {
            key: "initialise",
            value: function initialise() {
                this.assignContext();
                var _constructor = this.constructor, initialBNF = _constructor.initialBNF, initialContent = _constructor.initialContent, initialStartRuleName = _constructor.initialStartRuleName, initialLexicalPattern = _constructor.initialLexicalPattern, bnf = initialBNF, content = initialContent, startRuleName = initialStartRuleName, lexicalPattern = initialLexicalPattern; ///
                this.setBNF(bnf);
                this.setContent(content);
                this.setStartRuleName(startRuleName);
                this.setLexicalPattern(lexicalPattern);
                this.keyUpHandler();
            }
        }
    ]);
    return View;
}(_wrapNativeSuper(_easy.Element));
_defineProperty(View, "initialBNF", '\n \n\n    A ::= B "g"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A\n    \n        | "c"\n\n        ;\n\n\n\n');
_defineProperty(View, "initialContent", "ghh");
_defineProperty(View, "initialStartRuleName", "S");
_defineProperty(View, "initialLexicalPattern", ".");
_defineProperty(View, "tagName", "div");
_defineProperty(View, "defaultProperties", {
    className: "view"
});
var _default = (0, _easyWithStyle).default(View)(_templateObject());
exports.default = _default;
'\n\nRemember we have yet to rule out the cases when rules are both indirectly and directly recursive.\n\n-----------------------------------\n\n\nWe want to be clear what we mean by rewriting definitions. Ideally we want to avoid rewriting them in place. \nThis is currently done for both direct and indirectly left recursive definitions, albeit it different ways.\n\n-----------------------------------\n\nRecall that the reduced part in the rewritten directly left recursive rule should inherit the modifiers.\n\nAlso there needs to be a check that the modifiers on the first parts of the merged directly left recursive definitions are identical.\n\n-----------------------------------\n\nThere is a subtlety with eliminating direct left recursion from indirectly left recursive rules. Consider the following:\n\n    A ::= B "h"\n    \n        | "d"\n    \n        ;\n    \n    B ::= A "g"\n    \n        | B "f"\n\n        | B "e"\n    \n        | "c"\n\n        ;\n\nHere we can match dgeh:\n\nA : dgeh \n\nB : dge\n\nB : dg\n\nA : d  \n\nWe proceed as usual, first merging the indirect left recursion. This has nothing to do with the problem, by the way, it was just inherited from the example.\n\n    A ::= B "h"\n    \n        | "d"\n    \n        ;\n    \n    B ::= A "g"\n    \n        | B ( "f" | "e" )\n    \n        | "c"\n\n        ;\n        \nNow we reduce B, leaving the indirectly left recursive definition in place:\n\n    A ::= B "h"\n    \n        | "d"\n    \n        ;\n    \n    B ::= A "g"\n    \n        | B ( "f" | "e" )\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\nThis step is questionable, precisely because we have left the indirectly left recursive rule in place. It does no harm on its own, but the following is wrong:\n\n    A ::= B "h"\n    \n        | "d"\n    \n        ;\n    \n    B ::= A "g"\n    \n        | B_ ( "f" | "e" )*\n    \n        ;\n\n   B_ ::= "c" ;\n   \nNow we cannot match dgeh:\n\nA : dgeh\n\nB: dge\n\nB_ : dg   \n\nThis won\'t match and we have erred.\n\nSo we cannot eliminate direct left recursion in the presence of indirect left recursion.\n\nAnd so, at last, we should throw an exception if indirecct and direct left recursion are siblings.\n\n-----------------------------\n\nWe need to derive reduced parts from parts not rule names, see below.\n\n-----------------------------\n\nWe need further (bur relatively easy) checks to ensure that reduced and repeated rules are not empty. The latter means that we can do away with checks for unary definitions.\n\n-----------------------------\n\n\nThere is currently a bug in the fromIndirectlyLeftRecursiveRule() static factory method of the repeated rule whereby only one indirectly left recursive definition is treated.\n\nThis could work out, in some sense at least, because we will end up merging these indirectly left recursive definitions.\n\nIt is possible that even after merging there is still more than one indirectly left recursive definition, however.  \n\n-----------------------------\n\nIt should be possible to rewrite rules where it is the indirectly left recursive rule that is also directly left recursive.\n\n    A ::= B "g"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "h"\n    \n        | B "f"\n    \n        | "c"\n\n        ;\n\nFirst we rewrite the indirectly left recursive rule as before...\n\n    A ::= B "g"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A B~\n    \n        | B "f"\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n...the trick being to leave the indirectly left recursive definition effectively in place, although note that it is still subsequently rewritten with a repeated rule being produced:\n\nNow we eliminate B\'s direct left recursion in the usual way:\n\n    A ::= B "g"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A B~\n    \n        | B_ "f"*\n    \n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\nAnd now we do the usual substitution to eliminate indirect left recursion:\n\n    A ::= A B~ "g"\n    \n        | B_ "f"* "g"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A B~\n    \n        | B_ "f"*\n    \n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\nFinally, there is a second pass to eliminate direct left recursion. First the reduction...\n\n    A ::= A B~ "g"\n    \n        | A_\n    \n        ;\n    \n    B ::= A B~\n    \n        | B_ "f"*\n    \n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n   A_ ::= B_ "f"* "g"\n    \n        | "e"\n    \n        ;\n    \n...and then the rewrite:\n\n    A ::= A_ ( B~ "g" )* ;\n    \n    B ::= A B~\n    \n        | B_ "f"*\n    \n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n   A_ ::= B_ "f"* "g"\n    \n        | "e"\n    \n        ;\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-------------------------------\n\nWe need to make sure when rules are rewritten that they are only done so once. There may be more than one indirectly recursive definition, for example.\n\nIn this case, can they be merged beforehand?\n\n-------------------------------\n\nThe reducedPartFromPart() usage in the part utilities looks suspect. It is only called with the Rulename part. So why the need for recursion?\n\n--------------------------------\n\nWe introduce a repeated as well as a reduced rule:\n\n     A ::= B "g"\n    \n         | A "f"\n    \n         | "e"\n    \n         ;\n    \n    B ::= A B~\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n \nNow when we do the substitution...\n \n     A ::= A B~ "g"\n    \n         | B_ "g"\n\n         | A "f"\n\n         | "e"\n    \n         ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n...we keep the A to B to A relation when we match "h".\n\nContinuing, we reduce the A rule...\n\n     A ::= A B~ "g"\n    \n         | A "f"\n\n         | A_\n    \n         ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n   A_ ::= B_ "g"\n\n        | "e"\n    \n        ;\n    \n...merge the directly left recursive definitions...\n\n     A ::= A ( ( B~ "g" ) | "f" )\n\n         | A_\n    \n         ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n   A_ ::= B_ "g"\n\n        | "e"\n    \n        ;\n    \n...and rewrite:\n\n    A ::= A_ ( ( B~ "g" ) | "f" )* ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n\n   B_ ::= "c" ;\n\n   B~ ::= "h" ;\n\n   A_ ::= B_ "g"\n\n        | "e"\n    \n        ;\n    \nIn fact note that we may have to merge the indirectly left recursive definitions firstly, too!\n\n\n\n\n\n\n\n\n\n\n\n\n--------------------------------------------\n\nThis is an interesting case. We need to merge the implicitly left recursive definitions:\n\n    A ::= B "g"\n    \n        | A "f"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "h"\n    \n        | "c"\n\n        ;\n        \nBecause the A rule is directly left recursive, we need to substitute into that. First, we rewrite the B rule:\n\n    A ::= B "g"\n    \n        | A "f"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n        \n   B_ ::= "c" ;\n        \nNext we substitute the rewritten B rule\'s definitions for any occurence of the B rule name part in the A rule\'s implicitly left recursive definitions:\n\n    A ::= A "h" "g"\n    \n        | B_ "g"\n    \n        | A "f"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n        \n   B_ ::= "c" ;\n   \nNow we reduce the A rule...\n\n    A ::= A "h" "g"\n    \n        | A "f"\n    \n        | A_\n    \n        ;\n    \n    B ::= A "h"\n    \n        | B_\n\n        ;\n        \n   B_ ::= "c" ;\n    \n   A_ ::= B_ "g"\n    \n        | "e"\n    \n        ;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n--------------------------------------------\n\nWe go from here...\n\n    A ::= B "c"\n    \n        | A "h"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "f" "g"\n    \n        | "c"\n\n        ;\n                \n...to here:\n\n    A ::= A_ ( "h" | ( "f" "g" ) )* ;\n    \n    B ::= A "f" "g"\n    \n        | B_\n\n        ;\n    \n   A_ ::= B_ "c"\n    \n        | "e"\n    \n        ;\n\n   B_ ::= "c"\n\n        | "d"\n\n        ;        \n    \n--------------------------------------------\n\nTHe following rules mix direct and indirect left-recursion.\n\nNote that the directly left recursive definition is a sibling of the *implicitly* left recursive definition.\n\n    A ::= B\n\n        | A "f"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "g"\n    \n        ;\n\nA little thought should convince that these rules will match the following:\n\ne(f|g)*\n\nNow note that the directly left recursive definition forced us to do the substitution in the following direction:\n\n    A ::= A "g"\n\n        | A "f"\n    \n        | "e"\n    \n        ;\n        \nIn fact we *cannot* substitute the other way because we must leave the B indirectly left recursive definition in place.\n\nRearranging:\n\n    A ::= A ( "g" | "f" )\n\n        | "e"\n    \n        ;\n        \nAnd now we rewrite:\n\n    A ::= A_ ( "g" | "f" )* ;\n        \n   A_ ::= "e" ;\n\nNow consider tHe following rules that also mix direct and indirect left-recursion.\n\nHowever, note that in this case the directly left recursive definition is a sibling of the *indirectly* left recursive definition.\n    \n    A ::= B\n\n        | "e"\n    \n        ;\n    \n    B ::= B "f"\n    \n        | A "g"\n    \n        ;\n\nThis time we have to substitute A\'s definitions into the indirectly left recursive definition:\n\n    A ::= B\n\n        | "e"\n    \n        ;\n    \n    B ::= B "f"\n    \n        | B "g"\n    \n        | "e" "g"\n\n        ;\n\nRearranging:    \n\n    A ::= B\n\n        | "e"\n    \n        ;\n    \n    B ::= B ( "f" | "g" )\n    \n        | "e" "g"\n\n        ;\n\nNow rewriting:\n\n    A ::= B\n\n        | "e"\n    \n        ;\n    \n    B ::= B_ ( "f" | "g" )* ;\n\n   B_ ::= "e" "g" ;\n\nSo the moral is that eliminating indirect left recursion amounts to a rearrangement to direct left recursion...\n\n...and then from there, combining any directly left recursive definitions into on, before the usual rewriting.\n\nBy this token the following rules cannot be rewritten, at least not easily...\n\n    A ::= B\n\n        | A "e"\n\n        | "e"\n    \n        ;\n    \n    B ::= B "f"\n    \n        | A "g"\n    \n        ;\n\n...because we cannot get all the directly left recursive rules in one rule or the other.\n\nOr, at least, we can be forgiven for not trying.\n\n--------------------------------------------\n\nThe following rules...\n \nS ::= A "f"\n\n    | "e"\n    \n    ; \n    \nA ::= S "h" \n\n    | "g"\n    \n    ;  \n      \n...are rewritten to:\n\nS  ::= A "f"\n\n     | S_\n\n     ;\n\nA  ::= A_ ( "f" "h" )+? ;\n\nA_ ::= S_ "h"\n\n     | "g"\n\n     ;\n\nS_ ::= "e" ;\n\nLooking at the original rules, the following content will match:\n\nS -> A f or e\n\nA f -> S hf or gf\n\nS hf -> A fhf or ehf\n\nA fhf -> S hfhf or gfhf\n\netc\n\nSo we get e(hf)* or gf(hf)*\n\nIt is worth pointing out that these rewrite rules, although they allow us to deal with left recursion by hand, so to speak, would still result in an algorithm that would not terminate.\n\nChecking the rewritten rules in the same manner, immediately writing S_ as e wherever we encounter it: \n\nS -> A f or e\n\nA f -> A_ (fh)+ f\n\nA_ (fh)+ f -> e h (fh)+ f or g (fh)+ f\n\nNow e h(fh)+ f is just e(fh)+ and combined with e gives e (fh)* whilst g(fh)+ f is actually gf(hf)* and we are done.\n \n--------------------------------------------\n\nWe need to get this one working:\n\nA ::= C "f"\n\n    | B\n\n    ;\n\nB ::= "h" C ;\n\nC ::= A ;\n \n--------------------------------------------\n\nThis one has both direct and indirect left recursion.\n\n    A ::= B\n\n        | A "f"\n    \n        | "e"\n    \n        ;\n    \n    B ::= A "g"\n    \n        ;\n    \n--------------------------------------------\n\n\nThis one needs further investigation. Try removing the "e" definition and then remove each kind of left recursion in turn.\n\n    A ::= A "f"\n    \n        | B\n    \n        | "e"\n    \n        ;\n    \n    B ::= C\n    \n        | A "g"\n    \n        ;\n    \n    C ::= "h" ;\n    \n--------------------------------------------------\n\nThis one is also causing problems although the algorithm is in transition:\n\nA ::= B\n\n    | C "f"\n\n    ;\n\nB ::= "h" C ;\n\nC ::= A ;\n\n--------------------------------------------------\n\nThe following is an example of simplifying the rewrite process. The following...\n\nA ::= A... "h" "g" | "f" ;\n\n...can in fact be rewritten:\n\nA ::= A_... A~+? ;\n\nA_ ::= "f" ;\n\nA~ ::= "h" "g" ;\n\nIn fact we could even do away with the repeated rule and "inline" its definition:\n\nA ::= A_... ( "h" "g" )+? ;\n\nA_ ::= "f" ;\n\nAgain we make use of the sequence of parts part extention to the BNF.\n\n--------------------------------------------------\n\nThe new process would be:\n\n1. Find all of the directly and indirectly left recursive definitions by a depth first search over all recursive definitions\n\n2. Rewrite both the the directly and indirectly left recursive definitions as well as creating the corresponding repeated rules\n\n3. Rewrite the corresponding left recursive rules as well as cre \n\n--------------------------------------------------\n\nWhat if there are two directly left recursive definitions in the same rule?\n\nA ::= A "h"\n\n    | A... "g"\n    \n    | "f"\n    \n    ;\n        \nA  ::= A_... ( "h" | "g" )+? ;\n    \nA_  ::= "f" ;    \n\nThe only problem with this seems to be dealing with look-ahead. Otherwise we can simply combine the two repeated sub-definitions. \n  \n';

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9leGFtcGxlL3ZpZXcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuaW1wb3J0IHsgQmFzaWNMZXhlciB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcbmltcG9ydCB7IEJhc2ljUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IFJvd3NEaXYsIENvbHVtbkRpdiwgQ29sdW1uc0RpdiwgVmVydGljYWxTcGxpdHRlckRpdiB9IGZyb20gXCJlYXN5LWxheW91dFwiO1xuaW1wb3J0IHsgcnVsZXNVdGlsaXRpZXMsIGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24sIHJlbW92ZU9yUmVuYW1lSW50ZXJtZWRpYXRlTm9kZXMgfSBmcm9tIFwiLi4vaW5kZXhcIjsgLy8vXG5cbmltcG9ydCBQYXJhZ3JhcGggZnJvbSBcIi4vcGFyYWdyYXBoXCI7XG5pbXBvcnQgU3ViSGVhZGluZyBmcm9tIFwiLi9zdWJIZWFkaW5nXCI7XG5pbXBvcnQgU2l6ZWFibGVEaXYgZnJvbSBcIi4vZGl2L3NpemVhYmxlXCI7XG5pbXBvcnQgQk5GVGV4dGFyZWEgZnJvbSBcIi4vdGV4dGFyZWEvYm5mXCI7XG5pbXBvcnQgQ29udGVudFRleHRhcmVhIGZyb20gXCIuL3RleHRhcmVhL2NvbnRlbnRcIjtcbmltcG9ydCBQYXJzZVRyZWVUZXh0YXJlYSBmcm9tIFwiLi90ZXh0YXJlYS9wYXJzZVRyZWVcIjtcbmltcG9ydCBTdGFydFJ1bGVOYW1lSW5wdXQgZnJvbSBcIi4vaW5wdXQvc3RhcnRSdWxlTmFtZVwiO1xuaW1wb3J0IExleGljYWxQYXR0ZXJuSW5wdXQgZnJvbSBcIi4vaW5wdXQvbGV4aWNhbFBhdHRlcm5cIjtcbmltcG9ydCBBZGp1c3RlZEJORlRleHRhcmVhIGZyb20gXCIuL3RleHRhcmVhL2FkanVzdGVkQk5GXCI7XG5pbXBvcnQgUmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94IGZyb20gXCIuL2NoZWNrYm94L3JlbW92ZU9yUmVuYW1lSW50ZXJtZWRpYXRlTm9kZXNcIlxuXG5pbXBvcnQgeyBydWxlc0Zyb21CTkYgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVzXCI7XG5pbXBvcnQgeyBVTkFTU0lHTkVEX0VOVFJZIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZXNcIjtcblxuY29uc3QgeyBydWxlc0FzU3RyaW5nLCBydWxlTWFwRnJvbVJ1bGVzLCBzdGFydFJ1bGVGcm9tUnVsZXNBbmRTdGFydFJ1bGVOYW1lIH0gPSBydWxlc1V0aWxpdGllcztcblxuY2xhc3MgVmlldyBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRQYXJzZVRyZWUoc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgbGV0IHBhcnNlVHJlZSA9IG51bGw7XG5cbiAgICBjb25zdCBsZXhpY2FsUGF0dGVybiA9IHRoaXMuZ2V0TGV4aWNhbFBhdHRlcm4oKSxcbiAgICAgICAgICB1bmFzc2lnbmVkID0gVU5BU1NJR05FRF9FTlRSWSxcbiAgICAgICAgICBjdXN0b20gPSBsZXhpY2FsUGF0dGVybiwgIC8vL1xuICAgICAgICAgIGVudHJpZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGN1c3RvbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdW5hc3NpZ25lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgYmFzaWNMZXhlciA9IEJhc2ljTGV4ZXIuZnJvbUVudHJpZXMoZW50cmllcyksXG4gICAgICAgICAgYmFzaWNQYXJzZXIgPSBuZXcgQmFzaWNQYXJzZXIoc3RhcnRSdWxlLCBydWxlTWFwKSwgIC8vL1xuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICB0b2tlbnMgPSBiYXNpY0xleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIG5vZGUgPSBiYXNpY1BhcnNlci5wYXJzZSh0b2tlbnMpO1xuXG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbW92ZU9yUmVuYW1lSW50ZXJtZWRpYXRlTm9kZXNDaGVja2JveENoZWNrZWQgPSB0aGlzLmlzUmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94Q2hlY2tlZCgpO1xuXG4gICAgICBpZiAocmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94Q2hlY2tlZCkge1xuICAgICAgICByZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZVRyZWUgPSBub2RlLmFzUGFyc2VUcmVlKHRva2Vucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIGtleVVwSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgIHRoaXMuY2hhbmdlSGFuZGxlcigpO1xuICB9XG5cbiAgY2hhbmdlSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICAgIC8vIHRyeSB7XG4gICAgICBjb25zdCBibmYgPSB0aGlzLmdldEJORigpLFxuICAgICAgICAgICAgc3RhcnRSdWxlTmFtZSA9IHRoaXMuZ2V0U3RhcnRSdWxlTmFtZSgpO1xuXG4gICAgICBsZXQgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICAgICAgY29uc3QgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpO1xuXG4gICAgICBsZXQgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShydWxlcywgc3RhcnRSdWxlTmFtZSk7XG5cbiAgICAgIHN0YXJ0UnVsZSA9IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24oc3RhcnRSdWxlLCBydWxlTWFwKTtcblxuICAgICAgcnVsZXMgPSBydWxlc0Zyb21TdGFydFJ1bGVBbmRSdWxlTWFwKHN0YXJ0UnVsZSwgcnVsZU1hcCk7XG5cbiAgICAgIGNvbnN0IG11bHRpTGluZSA9IHRydWUsXG4gICAgICAgICAgICBydWxlc1N0cmluZyA9IHJ1bGVzQXNTdHJpbmcocnVsZXMsIG11bHRpTGluZSksXG4gICAgICAgICAgICBhZGp1c3RlZEJORiA9IHJ1bGVzU3RyaW5nOyAgLy8vXG5cbiAgICAgIHRoaXMuc2V0QWRqdXN0ZWRCTkYoYWRqdXN0ZWRCTkYpO1xuXG4gICAgICBjb25zdCBwYXJzZVRyZWUgPSB0aGlzLmdldFBhcnNlVHJlZShzdGFydFJ1bGUsIHJ1bGVNYXApO1xuXG4gICAgICB0aGlzLnNldFBhcnNlVHJlZShwYXJzZVRyZWUpO1xuICAgIC8vIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgLy8gfVxuICB9XG5cbiAgY2hpbGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBrZXlVcEhhbmRsZXIgPSB0aGlzLmtleVVwSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICAgIGNoYW5nZUhhbmRsZXIgPSB0aGlzLmNoYW5nZUhhbmRsZXIuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoW1xuXG4gICAgICA8Q29sdW1uc0Rpdj5cbiAgICAgICAgPFNpemVhYmxlRGl2PlxuICAgICAgICAgIDxSb3dzRGl2PlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIExleGljYWwgcGF0dGVyblxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPExleGljYWxQYXR0ZXJuSW5wdXQgb25LZXlVcD17a2V5VXBIYW5kbGVyfSAvPlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIEJORlxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPEJORlRleHRhcmVhIG9uS2V5VXA9e2tleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBBZGp1c3RlZCBCTkZcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxBZGp1c3RlZEJORlRleHRhcmVhIHJlYWRPbmx5IC8+XG4gICAgICAgICAgPC9Sb3dzRGl2PlxuICAgICAgICA8L1NpemVhYmxlRGl2PlxuICAgICAgICA8VmVydGljYWxTcGxpdHRlckRpdiAvPlxuICAgICAgICA8Q29sdW1uRGl2PlxuICAgICAgICAgIDxSb3dzRGl2PlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIFN0YXJ0IHJ1bGUgbmFtZVxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPFN0YXJ0UnVsZU5hbWVJbnB1dCBvbktleVVwPXtrZXlVcEhhbmRsZXJ9IC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgQ29udGVudFxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPENvbnRlbnRUZXh0YXJlYSBvbktleVVwPXtrZXlVcEhhbmRsZXJ9IC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgUGFyc2UgdHJlZVxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPFBhcnNlVHJlZVRleHRhcmVhIC8+XG4gICAgICAgICAgICA8UGFyYWdyYXBoPlxuICAgICAgICAgICAgICA8UmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94IG9uQ2hhbmdlPXtjaGFuZ2VIYW5kbGVyfSBjaGVja2VkIC8+XG4gICAgICAgICAgICAgIFJlbW92ZSBvciByZW5hbWUgaW50ZXJtZWRpYXRlIG5vZGVzXG4gICAgICAgICAgICA8L1BhcmFncmFwaD5cbiAgICAgICAgICA8L1Jvd3NEaXY+XG4gICAgICAgIDwvQ29sdW1uRGl2PlxuICAgICAgPC9Db2x1bW5zRGl2PlxuXG4gICAgXSk7XG4gIH1cblxuICBpbml0aWFsaXNlKCkge1xuICAgIHRoaXMuYXNzaWduQ29udGV4dCgpO1xuXG4gICAgY29uc3QgeyBpbml0aWFsQk5GLCBpbml0aWFsQ29udGVudCwgaW5pdGlhbFN0YXJ0UnVsZU5hbWUsIGluaXRpYWxMZXhpY2FsUGF0dGVybiB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBibmYgPSBpbml0aWFsQk5GLCAvLy9cbiAgICAgICAgICBjb250ZW50ID0gaW5pdGlhbENvbnRlbnQsIC8vL1xuICAgICAgICAgIHN0YXJ0UnVsZU5hbWUgPSBpbml0aWFsU3RhcnRSdWxlTmFtZSwgLy8vXG4gICAgICAgICAgbGV4aWNhbFBhdHRlcm4gPSBpbml0aWFsTGV4aWNhbFBhdHRlcm47IC8vL1xuXG4gICAgdGhpcy5zZXRCTkYoYm5mKTtcblxuICAgIHRoaXMuc2V0Q29udGVudChjb250ZW50KTtcblxuICAgIHRoaXMuc2V0U3RhcnRSdWxlTmFtZShzdGFydFJ1bGVOYW1lKTtcblxuICAgIHRoaXMuc2V0TGV4aWNhbFBhdHRlcm4obGV4aWNhbFBhdHRlcm4pO1xuXG4gICAgdGhpcy5rZXlVcEhhbmRsZXIoKTtcbiAgfVxuXG4gIHN0YXRpYyBpbml0aWFsQk5GID0gYFxuIFxuXG4gICAgQSA6Oj0gQiBcImdcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBXG4gICAgXG4gICAgICAgIHwgXCJjXCJcblxuICAgICAgICA7XG5cblxuXG5gO1xuXG4gIHN0YXRpYyBpbml0aWFsQ29udGVudCA9IFwiZ2hoXCI7XG5cbiAgc3RhdGljIGluaXRpYWxTdGFydFJ1bGVOYW1lID0gXCJTXCI7XG5cbiAgc3RhdGljIGluaXRpYWxMZXhpY2FsUGF0dGVybiA9IFwiLlwiO1xuXG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInZpZXdcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVmlldylgXG5cbiAgcGFkZGluZzogMXJlbTtcbiAgXG5gO1xuXG5gXG5cblJlbWVtYmVyIHdlIGhhdmUgeWV0IHRvIHJ1bGUgb3V0IHRoZSBjYXNlcyB3aGVuIHJ1bGVzIGFyZSBib3RoIGluZGlyZWN0bHkgYW5kIGRpcmVjdGx5IHJlY3Vyc2l2ZS5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5XZSB3YW50IHRvIGJlIGNsZWFyIHdoYXQgd2UgbWVhbiBieSByZXdyaXRpbmcgZGVmaW5pdGlvbnMuIElkZWFsbHkgd2Ugd2FudCB0byBhdm9pZCByZXdyaXRpbmcgdGhlbSBpbiBwbGFjZS4gXG5UaGlzIGlzIGN1cnJlbnRseSBkb25lIGZvciBib3RoIGRpcmVjdCBhbmQgaW5kaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9ucywgYWxiZWl0IGl0IGRpZmZlcmVudCB3YXlzLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5SZWNhbGwgdGhhdCB0aGUgcmVkdWNlZCBwYXJ0IGluIHRoZSByZXdyaXR0ZW4gZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgcnVsZSBzaG91bGQgaW5oZXJpdCB0aGUgbW9kaWZpZXJzLlxuXG5BbHNvIHRoZXJlIG5lZWRzIHRvIGJlIGEgY2hlY2sgdGhhdCB0aGUgbW9kaWZpZXJzIG9uIHRoZSBmaXJzdCBwYXJ0cyBvZiB0aGUgbWVyZ2VkIGRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb25zIGFyZSBpZGVudGljYWwuXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblRoZXJlIGlzIGEgc3VidGxldHkgd2l0aCBlbGltaW5hdGluZyBkaXJlY3QgbGVmdCByZWN1cnNpb24gZnJvbSBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIHJ1bGVzLiBDb25zaWRlciB0aGUgZm9sbG93aW5nOlxuXG4gICAgQSA6Oj0gQiBcImhcIlxuICAgIFxuICAgICAgICB8IFwiZFwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgQiBcImZcIlxuXG4gICAgICAgIHwgQiBcImVcIlxuICAgIFxuICAgICAgICB8IFwiY1wiXG5cbiAgICAgICAgO1xuXG5IZXJlIHdlIGNhbiBtYXRjaCBkZ2VoOlxuXG5BIDogZGdlaCBcblxuQiA6IGRnZVxuXG5CIDogZGdcblxuQSA6IGQgIFxuXG5XZSBwcm9jZWVkIGFzIHVzdWFsLCBmaXJzdCBtZXJnaW5nIHRoZSBpbmRpcmVjdCBsZWZ0IHJlY3Vyc2lvbi4gVGhpcyBoYXMgbm90aGluZyB0byBkbyB3aXRoIHRoZSBwcm9ibGVtLCBieSB0aGUgd2F5LCBpdCB3YXMganVzdCBpbmhlcml0ZWQgZnJvbSB0aGUgZXhhbXBsZS5cblxuICAgIEEgOjo9IEIgXCJoXCJcbiAgICBcbiAgICAgICAgfCBcImRcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQSBcImdcIlxuICAgIFxuICAgICAgICB8IEIgKCBcImZcIiB8IFwiZVwiIClcbiAgICBcbiAgICAgICAgfCBcImNcIlxuXG4gICAgICAgIDtcbiAgICAgICAgXG5Ob3cgd2UgcmVkdWNlIEIsIGxlYXZpbmcgdGhlIGluZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbiBpbiBwbGFjZTpcblxuICAgIEEgOjo9IEIgXCJoXCJcbiAgICBcbiAgICAgICAgfCBcImRcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQSBcImdcIlxuICAgIFxuICAgICAgICB8IEIgKCBcImZcIiB8IFwiZVwiIClcbiAgICBcbiAgICAgICAgfCBCX1xuXG4gICAgICAgIDtcblxuICAgQl8gOjo9IFwiY1wiIDtcblxuVGhpcyBzdGVwIGlzIHF1ZXN0aW9uYWJsZSwgcHJlY2lzZWx5IGJlY2F1c2Ugd2UgaGF2ZSBsZWZ0IHRoZSBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIHJ1bGUgaW4gcGxhY2UuIEl0IGRvZXMgbm8gaGFybSBvbiBpdHMgb3duLCBidXQgdGhlIGZvbGxvd2luZyBpcyB3cm9uZzpcblxuICAgIEEgOjo9IEIgXCJoXCJcbiAgICBcbiAgICAgICAgfCBcImRcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQSBcImdcIlxuICAgIFxuICAgICAgICB8IEJfICggXCJmXCIgfCBcImVcIiApKlxuICAgIFxuICAgICAgICA7XG5cbiAgIEJfIDo6PSBcImNcIiA7XG4gICBcbk5vdyB3ZSBjYW5ub3QgbWF0Y2ggZGdlaDpcblxuQSA6IGRnZWhcblxuQjogZGdlXG5cbkJfIDogZGcgICBcblxuVGhpcyB3b24ndCBtYXRjaCBhbmQgd2UgaGF2ZSBlcnJlZC5cblxuU28gd2UgY2Fubm90IGVsaW1pbmF0ZSBkaXJlY3QgbGVmdCByZWN1cnNpb24gaW4gdGhlIHByZXNlbmNlIG9mIGluZGlyZWN0IGxlZnQgcmVjdXJzaW9uLlxuXG5BbmQgc28sIGF0IGxhc3QsIHdlIHNob3VsZCB0aHJvdyBhbiBleGNlcHRpb24gaWYgaW5kaXJlY2N0IGFuZCBkaXJlY3QgbGVmdCByZWN1cnNpb24gYXJlIHNpYmxpbmdzLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5XZSBuZWVkIHRvIGRlcml2ZSByZWR1Y2VkIHBhcnRzIGZyb20gcGFydHMgbm90IHJ1bGUgbmFtZXMsIHNlZSBiZWxvdy5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuV2UgbmVlZCBmdXJ0aGVyIChidXIgcmVsYXRpdmVseSBlYXN5KSBjaGVja3MgdG8gZW5zdXJlIHRoYXQgcmVkdWNlZCBhbmQgcmVwZWF0ZWQgcnVsZXMgYXJlIG5vdCBlbXB0eS4gVGhlIGxhdHRlciBtZWFucyB0aGF0IHdlIGNhbiBkbyBhd2F5IHdpdGggY2hlY2tzIGZvciB1bmFyeSBkZWZpbml0aW9ucy5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5UaGVyZSBpcyBjdXJyZW50bHkgYSBidWcgaW4gdGhlIGZyb21JbmRpcmVjdGx5TGVmdFJlY3Vyc2l2ZVJ1bGUoKSBzdGF0aWMgZmFjdG9yeSBtZXRob2Qgb2YgdGhlIHJlcGVhdGVkIHJ1bGUgd2hlcmVieSBvbmx5IG9uZSBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gaXMgdHJlYXRlZC5cblxuVGhpcyBjb3VsZCB3b3JrIG91dCwgaW4gc29tZSBzZW5zZSBhdCBsZWFzdCwgYmVjYXVzZSB3ZSB3aWxsIGVuZCB1cCBtZXJnaW5nIHRoZXNlIGluZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnMuXG5cbkl0IGlzIHBvc3NpYmxlIHRoYXQgZXZlbiBhZnRlciBtZXJnaW5nIHRoZXJlIGlzIHN0aWxsIG1vcmUgdGhhbiBvbmUgaW5kaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uLCBob3dldmVyLiAgXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byByZXdyaXRlIHJ1bGVzIHdoZXJlIGl0IGlzIHRoZSBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIHJ1bGUgdGhhdCBpcyBhbHNvIGRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlLlxuXG4gICAgQSA6Oj0gQiBcImdcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIFwiaFwiXG4gICAgXG4gICAgICAgIHwgQiBcImZcIlxuICAgIFxuICAgICAgICB8IFwiY1wiXG5cbiAgICAgICAgO1xuXG5GaXJzdCB3ZSByZXdyaXRlIHRoZSBpbmRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIHJ1bGUgYXMgYmVmb3JlLi4uXG5cbiAgICBBIDo6PSBCIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgQn5cbiAgICBcbiAgICAgICAgfCBCIFwiZlwiXG4gICAgXG4gICAgICAgIHwgQl9cblxuICAgICAgICA7XG5cbiAgIEJfIDo6PSBcImNcIiA7XG5cbiAgIEJ+IDo6PSBcImhcIiA7XG5cbi4uLnRoZSB0cmljayBiZWluZyB0byBsZWF2ZSB0aGUgaW5kaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIGVmZmVjdGl2ZWx5IGluIHBsYWNlLCBhbHRob3VnaCBub3RlIHRoYXQgaXQgaXMgc3RpbGwgc3Vic2VxdWVudGx5IHJld3JpdHRlbiB3aXRoIGEgcmVwZWF0ZWQgcnVsZSBiZWluZyBwcm9kdWNlZDpcblxuTm93IHdlIGVsaW1pbmF0ZSBCJ3MgZGlyZWN0IGxlZnQgcmVjdXJzaW9uIGluIHRoZSB1c3VhbCB3YXk6XG5cbiAgICBBIDo6PSBCIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgQn5cbiAgICBcbiAgICAgICAgfCBCXyBcImZcIipcbiAgICBcbiAgICAgICAgO1xuXG4gICBCXyA6Oj0gXCJjXCIgO1xuXG4gICBCfiA6Oj0gXCJoXCIgO1xuXG5BbmQgbm93IHdlIGRvIHRoZSB1c3VhbCBzdWJzdGl0dXRpb24gdG8gZWxpbWluYXRlIGluZGlyZWN0IGxlZnQgcmVjdXJzaW9uOlxuXG4gICAgQSA6Oj0gQSBCfiBcImdcIlxuICAgIFxuICAgICAgICB8IEJfIFwiZlwiKiBcImdcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIEJ+XG4gICAgXG4gICAgICAgIHwgQl8gXCJmXCIqXG4gICAgXG4gICAgICAgIDtcblxuICAgQl8gOjo9IFwiY1wiIDtcblxuICAgQn4gOjo9IFwiaFwiIDtcblxuRmluYWxseSwgdGhlcmUgaXMgYSBzZWNvbmQgcGFzcyB0byBlbGltaW5hdGUgZGlyZWN0IGxlZnQgcmVjdXJzaW9uLiBGaXJzdCB0aGUgcmVkdWN0aW9uLi4uXG5cbiAgICBBIDo6PSBBIEJ+IFwiZ1wiXG4gICAgXG4gICAgICAgIHwgQV9cbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgQn5cbiAgICBcbiAgICAgICAgfCBCXyBcImZcIipcbiAgICBcbiAgICAgICAgO1xuXG4gICBCXyA6Oj0gXCJjXCIgO1xuXG4gICBCfiA6Oj0gXCJoXCIgO1xuXG4gICBBXyA6Oj0gQl8gXCJmXCIqIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuLi4uYW5kIHRoZW4gdGhlIHJld3JpdGU6XG5cbiAgICBBIDo6PSBBXyAoIEJ+IFwiZ1wiICkqIDtcbiAgICBcbiAgICBCIDo6PSBBIEJ+XG4gICAgXG4gICAgICAgIHwgQl8gXCJmXCIqXG4gICAgXG4gICAgICAgIDtcblxuICAgQl8gOjo9IFwiY1wiIDtcblxuICAgQn4gOjo9IFwiaFwiIDtcblxuICAgQV8gOjo9IEJfIFwiZlwiKiBcImdcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbldlIG5lZWQgdG8gbWFrZSBzdXJlIHdoZW4gcnVsZXMgYXJlIHJld3JpdHRlbiB0aGF0IHRoZXkgYXJlIG9ubHkgZG9uZSBzbyBvbmNlLiBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBpbmRpcmVjdGx5IHJlY3Vyc2l2ZSBkZWZpbml0aW9uLCBmb3IgZXhhbXBsZS5cblxuSW4gdGhpcyBjYXNlLCBjYW4gdGhleSBiZSBtZXJnZWQgYmVmb3JlaGFuZD9cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGUgcmVkdWNlZFBhcnRGcm9tUGFydCgpIHVzYWdlIGluIHRoZSBwYXJ0IHV0aWxpdGllcyBsb29rcyBzdXNwZWN0LiBJdCBpcyBvbmx5IGNhbGxlZCB3aXRoIHRoZSBSdWxlbmFtZSBwYXJ0LiBTbyB3aHkgdGhlIG5lZWQgZm9yIHJlY3Vyc2lvbj9cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuV2UgaW50cm9kdWNlIGEgcmVwZWF0ZWQgYXMgd2VsbCBhcyBhIHJlZHVjZWQgcnVsZTpcblxuICAgICBBIDo6PSBCIFwiZ1wiXG4gICAgXG4gICAgICAgICB8IEEgXCJmXCJcbiAgICBcbiAgICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIEJ+XG4gICAgXG4gICAgICAgIHwgQl9cblxuICAgICAgICA7XG5cbiAgIEJfIDo6PSBcImNcIiA7XG5cbiAgIEJ+IDo6PSBcImhcIiA7XG4gXG5Ob3cgd2hlbiB3ZSBkbyB0aGUgc3Vic3RpdHV0aW9uLi4uXG4gXG4gICAgIEEgOjo9IEEgQn4gXCJnXCJcbiAgICBcbiAgICAgICAgIHwgQl8gXCJnXCJcblxuICAgICAgICAgfCBBIFwiZlwiXG5cbiAgICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIFwiaFwiXG4gICAgXG4gICAgICAgIHwgQl9cblxuICAgICAgICA7XG5cbiAgIEJfIDo6PSBcImNcIiA7XG5cbiAgIEJ+IDo6PSBcImhcIiA7XG5cbi4uLndlIGtlZXAgdGhlIEEgdG8gQiB0byBBIHJlbGF0aW9uIHdoZW4gd2UgbWF0Y2ggXCJoXCIuXG5cbkNvbnRpbnVpbmcsIHdlIHJlZHVjZSB0aGUgQSBydWxlLi4uXG5cbiAgICAgQSA6Oj0gQSBCfiBcImdcIlxuICAgIFxuICAgICAgICAgfCBBIFwiZlwiXG5cbiAgICAgICAgIHwgQV9cbiAgICBcbiAgICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIFwiaFwiXG4gICAgXG4gICAgICAgIHwgQl9cblxuICAgICAgICA7XG5cbiAgIEJfIDo6PSBcImNcIiA7XG5cbiAgIEJ+IDo6PSBcImhcIiA7XG5cbiAgIEFfIDo6PSBCXyBcImdcIlxuXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuLi4ubWVyZ2UgdGhlIGRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb25zLi4uXG5cbiAgICAgQSA6Oj0gQSAoICggQn4gXCJnXCIgKSB8IFwiZlwiIClcblxuICAgICAgICAgfCBBX1xuICAgIFxuICAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgXCJoXCJcbiAgICBcbiAgICAgICAgfCBCX1xuXG4gICAgICAgIDtcblxuICAgQl8gOjo9IFwiY1wiIDtcblxuICAgQn4gOjo9IFwiaFwiIDtcblxuICAgQV8gOjo9IEJfIFwiZ1wiXG5cbiAgICAgICAgfCBcImVcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4uLi5hbmQgcmV3cml0ZTpcblxuICAgIEEgOjo9IEFfICggKCBCfiBcImdcIiApIHwgXCJmXCIgKSogO1xuICAgIFxuICAgIEIgOjo9IEEgXCJoXCJcbiAgICBcbiAgICAgICAgfCBCX1xuXG4gICAgICAgIDtcblxuICAgQl8gOjo9IFwiY1wiIDtcblxuICAgQn4gOjo9IFwiaFwiIDtcblxuICAgQV8gOjo9IEJfIFwiZ1wiXG5cbiAgICAgICAgfCBcImVcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG5JbiBmYWN0IG5vdGUgdGhhdCB3ZSBtYXkgaGF2ZSB0byBtZXJnZSB0aGUgaW5kaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9ucyBmaXJzdGx5LCB0b28hXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGlzIGlzIGFuIGludGVyZXN0aW5nIGNhc2UuIFdlIG5lZWQgdG8gbWVyZ2UgdGhlIGltcGxpY2l0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnM6XG5cbiAgICBBIDo6PSBCIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgQSBcImZcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBBIFwiaFwiXG4gICAgXG4gICAgICAgIHwgXCJjXCJcblxuICAgICAgICA7XG4gICAgICAgIFxuQmVjYXVzZSB0aGUgQSBydWxlIGlzIGRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlLCB3ZSBuZWVkIHRvIHN1YnN0aXR1dGUgaW50byB0aGF0LiBGaXJzdCwgd2UgcmV3cml0ZSB0aGUgQiBydWxlOlxuXG4gICAgQSA6Oj0gQiBcImdcIlxuICAgIFxuICAgICAgICB8IEEgXCJmXCJcbiAgICBcbiAgICAgICAgfCBcImVcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQSBcImhcIlxuICAgIFxuICAgICAgICB8IEJfXG5cbiAgICAgICAgO1xuICAgICAgICBcbiAgIEJfIDo6PSBcImNcIiA7XG4gICAgICAgIFxuTmV4dCB3ZSBzdWJzdGl0dXRlIHRoZSByZXdyaXR0ZW4gQiBydWxlJ3MgZGVmaW5pdGlvbnMgZm9yIGFueSBvY2N1cmVuY2Ugb2YgdGhlIEIgcnVsZSBuYW1lIHBhcnQgaW4gdGhlIEEgcnVsZSdzIGltcGxpY2l0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnM6XG5cbiAgICBBIDo6PSBBIFwiaFwiIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgQl8gXCJnXCJcbiAgICBcbiAgICAgICAgfCBBIFwiZlwiXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgXCJoXCJcbiAgICBcbiAgICAgICAgfCBCX1xuXG4gICAgICAgIDtcbiAgICAgICAgXG4gICBCXyA6Oj0gXCJjXCIgO1xuICAgXG5Ob3cgd2UgcmVkdWNlIHRoZSBBIHJ1bGUuLi5cblxuICAgIEEgOjo9IEEgXCJoXCIgXCJnXCJcbiAgICBcbiAgICAgICAgfCBBIFwiZlwiXG4gICAgXG4gICAgICAgIHwgQV9cbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgXCJoXCJcbiAgICBcbiAgICAgICAgfCBCX1xuXG4gICAgICAgIDtcbiAgICAgICAgXG4gICBCXyA6Oj0gXCJjXCIgO1xuICAgIFxuICAgQV8gOjo9IEJfIFwiZ1wiXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbldlIGdvIGZyb20gaGVyZS4uLlxuXG4gICAgQSA6Oj0gQiBcImNcIlxuICAgIFxuICAgICAgICB8IEEgXCJoXCJcbiAgICBcbiAgICAgICAgfCBcImVcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQSBcImZcIiBcImdcIlxuICAgIFxuICAgICAgICB8IFwiY1wiXG5cbiAgICAgICAgO1xuICAgICAgICAgICAgICAgIFxuLi4udG8gaGVyZTpcblxuICAgIEEgOjo9IEFfICggXCJoXCIgfCAoIFwiZlwiIFwiZ1wiICkgKSogO1xuICAgIFxuICAgIEIgOjo9IEEgXCJmXCIgXCJnXCJcbiAgICBcbiAgICAgICAgfCBCX1xuXG4gICAgICAgIDtcbiAgICBcbiAgIEFfIDo6PSBCXyBcImNcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcblxuICAgQl8gOjo9IFwiY1wiXG5cbiAgICAgICAgfCBcImRcIlxuXG4gICAgICAgIDsgICAgICAgIFxuICAgIFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuVEhlIGZvbGxvd2luZyBydWxlcyBtaXggZGlyZWN0IGFuZCBpbmRpcmVjdCBsZWZ0LXJlY3Vyc2lvbi5cblxuTm90ZSB0aGF0IHRoZSBkaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIGlzIGEgc2libGluZyBvZiB0aGUgKmltcGxpY2l0bHkqIGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24uXG5cbiAgICBBIDo6PSBCXG5cbiAgICAgICAgfCBBIFwiZlwiXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEEgXCJnXCJcbiAgICBcbiAgICAgICAgO1xuXG5BIGxpdHRsZSB0aG91Z2h0IHNob3VsZCBjb252aW5jZSB0aGF0IHRoZXNlIHJ1bGVzIHdpbGwgbWF0Y2ggdGhlIGZvbGxvd2luZzpcblxuZShmfGcpKlxuXG5Ob3cgbm90ZSB0aGF0IHRoZSBkaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIGZvcmNlZCB1cyB0byBkbyB0aGUgc3Vic3RpdHV0aW9uIGluIHRoZSBmb2xsb3dpbmcgZGlyZWN0aW9uOlxuXG4gICAgQSA6Oj0gQSBcImdcIlxuXG4gICAgICAgIHwgQSBcImZcIlxuICAgIFxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICAgICAgXG5JbiBmYWN0IHdlICpjYW5ub3QqIHN1YnN0aXR1dGUgdGhlIG90aGVyIHdheSBiZWNhdXNlIHdlIG11c3QgbGVhdmUgdGhlIEIgaW5kaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIGluIHBsYWNlLlxuXG5SZWFycmFuZ2luZzpcblxuICAgIEEgOjo9IEEgKCBcImdcIiB8IFwiZlwiIClcblxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICAgICAgXG5BbmQgbm93IHdlIHJld3JpdGU6XG5cbiAgICBBIDo6PSBBXyAoIFwiZ1wiIHwgXCJmXCIgKSogO1xuICAgICAgICBcbiAgIEFfIDo6PSBcImVcIiA7XG5cbk5vdyBjb25zaWRlciB0SGUgZm9sbG93aW5nIHJ1bGVzIHRoYXQgYWxzbyBtaXggZGlyZWN0IGFuZCBpbmRpcmVjdCBsZWZ0LXJlY3Vyc2lvbi5cblxuSG93ZXZlciwgbm90ZSB0aGF0IGluIHRoaXMgY2FzZSB0aGUgZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbiBpcyBhIHNpYmxpbmcgb2YgdGhlICppbmRpcmVjdGx5KiBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uLlxuICAgIFxuICAgIEEgOjo9IEJcblxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBCIFwiZlwiXG4gICAgXG4gICAgICAgIHwgQSBcImdcIlxuICAgIFxuICAgICAgICA7XG5cblRoaXMgdGltZSB3ZSBoYXZlIHRvIHN1YnN0aXR1dGUgQSdzIGRlZmluaXRpb25zIGludG8gdGhlIGluZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbjpcblxuICAgIEEgOjo9IEJcblxuICAgICAgICB8IFwiZVwiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBCIDo6PSBCIFwiZlwiXG4gICAgXG4gICAgICAgIHwgQiBcImdcIlxuICAgIFxuICAgICAgICB8IFwiZVwiIFwiZ1wiXG5cbiAgICAgICAgO1xuXG5SZWFycmFuZ2luZzogICAgXG5cbiAgICBBIDo6PSBCXG5cbiAgICAgICAgfCBcImVcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQiAoIFwiZlwiIHwgXCJnXCIgKVxuICAgIFxuICAgICAgICB8IFwiZVwiIFwiZ1wiXG5cbiAgICAgICAgO1xuXG5Ob3cgcmV3cml0aW5nOlxuXG4gICAgQSA6Oj0gQlxuXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEJfICggXCJmXCIgfCBcImdcIiApKiA7XG5cbiAgIEJfIDo6PSBcImVcIiBcImdcIiA7XG5cblNvIHRoZSBtb3JhbCBpcyB0aGF0IGVsaW1pbmF0aW5nIGluZGlyZWN0IGxlZnQgcmVjdXJzaW9uIGFtb3VudHMgdG8gYSByZWFycmFuZ2VtZW50IHRvIGRpcmVjdCBsZWZ0IHJlY3Vyc2lvbi4uLlxuXG4uLi5hbmQgdGhlbiBmcm9tIHRoZXJlLCBjb21iaW5pbmcgYW55IGRpcmVjdGx5IGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb25zIGludG8gb24sIGJlZm9yZSB0aGUgdXN1YWwgcmV3cml0aW5nLlxuXG5CeSB0aGlzIHRva2VuIHRoZSBmb2xsb3dpbmcgcnVsZXMgY2Fubm90IGJlIHJld3JpdHRlbiwgYXQgbGVhc3Qgbm90IGVhc2lseS4uLlxuXG4gICAgQSA6Oj0gQlxuXG4gICAgICAgIHwgQSBcImVcIlxuXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IEIgXCJmXCJcbiAgICBcbiAgICAgICAgfCBBIFwiZ1wiXG4gICAgXG4gICAgICAgIDtcblxuLi4uYmVjYXVzZSB3ZSBjYW5ub3QgZ2V0IGFsbCB0aGUgZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgcnVsZXMgaW4gb25lIHJ1bGUgb3IgdGhlIG90aGVyLlxuXG5PciwgYXQgbGVhc3QsIHdlIGNhbiBiZSBmb3JnaXZlbiBmb3Igbm90IHRyeWluZy5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuVGhlIGZvbGxvd2luZyBydWxlcy4uLlxuIFxuUyA6Oj0gQSBcImZcIlxuXG4gICAgfCBcImVcIlxuICAgIFxuICAgIDsgXG4gICAgXG5BIDo6PSBTIFwiaFwiIFxuXG4gICAgfCBcImdcIlxuICAgIFxuICAgIDsgIFxuICAgICAgXG4uLi5hcmUgcmV3cml0dGVuIHRvOlxuXG5TICA6Oj0gQSBcImZcIlxuXG4gICAgIHwgU19cblxuICAgICA7XG5cbkEgIDo6PSBBXyAoIFwiZlwiIFwiaFwiICkrPyA7XG5cbkFfIDo6PSBTXyBcImhcIlxuXG4gICAgIHwgXCJnXCJcblxuICAgICA7XG5cblNfIDo6PSBcImVcIiA7XG5cbkxvb2tpbmcgYXQgdGhlIG9yaWdpbmFsIHJ1bGVzLCB0aGUgZm9sbG93aW5nIGNvbnRlbnQgd2lsbCBtYXRjaDpcblxuUyAtPiBBIGYgb3IgZVxuXG5BIGYgLT4gUyBoZiBvciBnZlxuXG5TIGhmIC0+IEEgZmhmIG9yIGVoZlxuXG5BIGZoZiAtPiBTIGhmaGYgb3IgZ2ZoZlxuXG5ldGNcblxuU28gd2UgZ2V0IGUoaGYpKiBvciBnZihoZikqXG5cbkl0IGlzIHdvcnRoIHBvaW50aW5nIG91dCB0aGF0IHRoZXNlIHJld3JpdGUgcnVsZXMsIGFsdGhvdWdoIHRoZXkgYWxsb3cgdXMgdG8gZGVhbCB3aXRoIGxlZnQgcmVjdXJzaW9uIGJ5IGhhbmQsIHNvIHRvIHNwZWFrLCB3b3VsZCBzdGlsbCByZXN1bHQgaW4gYW4gYWxnb3JpdGhtIHRoYXQgd291bGQgbm90IHRlcm1pbmF0ZS5cblxuQ2hlY2tpbmcgdGhlIHJld3JpdHRlbiBydWxlcyBpbiB0aGUgc2FtZSBtYW5uZXIsIGltbWVkaWF0ZWx5IHdyaXRpbmcgU18gYXMgZSB3aGVyZXZlciB3ZSBlbmNvdW50ZXIgaXQ6IFxuXG5TIC0+IEEgZiBvciBlXG5cbkEgZiAtPiBBXyAoZmgpKyBmXG5cbkFfIChmaCkrIGYgLT4gZSBoIChmaCkrIGYgb3IgZyAoZmgpKyBmXG5cbk5vdyBlIGgoZmgpKyBmIGlzIGp1c3QgZShmaCkrIGFuZCBjb21iaW5lZCB3aXRoIGUgZ2l2ZXMgZSAoZmgpKiB3aGlsc3QgZyhmaCkrIGYgaXMgYWN0dWFsbHkgZ2YoaGYpKiBhbmQgd2UgYXJlIGRvbmUuXG4gXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5XZSBuZWVkIHRvIGdldCB0aGlzIG9uZSB3b3JraW5nOlxuXG5BIDo6PSBDIFwiZlwiXG5cbiAgICB8IEJcblxuICAgIDtcblxuQiA6Oj0gXCJoXCIgQyA7XG5cbkMgOjo9IEEgO1xuIFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuVGhpcyBvbmUgaGFzIGJvdGggZGlyZWN0IGFuZCBpbmRpcmVjdCBsZWZ0IHJlY3Vyc2lvbi5cblxuICAgIEEgOjo9IEJcblxuICAgICAgICB8IEEgXCJmXCJcbiAgICBcbiAgICAgICAgfCBcImVcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4gICAgQiA6Oj0gQSBcImdcIlxuICAgIFxuICAgICAgICA7XG4gICAgXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblRoaXMgb25lIG5lZWRzIGZ1cnRoZXIgaW52ZXN0aWdhdGlvbi4gVHJ5IHJlbW92aW5nIHRoZSBcImVcIiBkZWZpbml0aW9uIGFuZCB0aGVuIHJlbW92ZSBlYWNoIGtpbmQgb2YgbGVmdCByZWN1cnNpb24gaW4gdHVybi5cblxuICAgIEEgOjo9IEEgXCJmXCJcbiAgICBcbiAgICAgICAgfCBCXG4gICAgXG4gICAgICAgIHwgXCJlXCJcbiAgICBcbiAgICAgICAgO1xuICAgIFxuICAgIEIgOjo9IENcbiAgICBcbiAgICAgICAgfCBBIFwiZ1wiXG4gICAgXG4gICAgICAgIDtcbiAgICBcbiAgICBDIDo6PSBcImhcIiA7XG4gICAgXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGlzIG9uZSBpcyBhbHNvIGNhdXNpbmcgcHJvYmxlbXMgYWx0aG91Z2ggdGhlIGFsZ29yaXRobSBpcyBpbiB0cmFuc2l0aW9uOlxuXG5BIDo6PSBCXG5cbiAgICB8IEMgXCJmXCJcblxuICAgIDtcblxuQiA6Oj0gXCJoXCIgQyA7XG5cbkMgOjo9IEEgO1xuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgb2Ygc2ltcGxpZnlpbmcgdGhlIHJld3JpdGUgcHJvY2Vzcy4gVGhlIGZvbGxvd2luZy4uLlxuXG5BIDo6PSBBLi4uIFwiaFwiIFwiZ1wiIHwgXCJmXCIgO1xuXG4uLi5jYW4gaW4gZmFjdCBiZSByZXdyaXR0ZW46XG5cbkEgOjo9IEFfLi4uIEF+Kz8gO1xuXG5BXyA6Oj0gXCJmXCIgO1xuXG5BfiA6Oj0gXCJoXCIgXCJnXCIgO1xuXG5JbiBmYWN0IHdlIGNvdWxkIGV2ZW4gZG8gYXdheSB3aXRoIHRoZSByZXBlYXRlZCBydWxlIGFuZCBcImlubGluZVwiIGl0cyBkZWZpbml0aW9uOlxuXG5BIDo6PSBBXy4uLiAoIFwiaFwiIFwiZ1wiICkrPyA7XG5cbkFfIDo6PSBcImZcIiA7XG5cbkFnYWluIHdlIG1ha2UgdXNlIG9mIHRoZSBzZXF1ZW5jZSBvZiBwYXJ0cyBwYXJ0IGV4dGVudGlvbiB0byB0aGUgQk5GLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGUgbmV3IHByb2Nlc3Mgd291bGQgYmU6XG5cbjEuIEZpbmQgYWxsIG9mIHRoZSBkaXJlY3RseSBhbmQgaW5kaXJlY3RseSBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9ucyBieSBhIGRlcHRoIGZpcnN0IHNlYXJjaCBvdmVyIGFsbCByZWN1cnNpdmUgZGVmaW5pdGlvbnNcblxuMi4gUmV3cml0ZSBib3RoIHRoZSB0aGUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnMgYXMgd2VsbCBhcyBjcmVhdGluZyB0aGUgY29ycmVzcG9uZGluZyByZXBlYXRlZCBydWxlc1xuXG4zLiBSZXdyaXRlIHRoZSBjb3JyZXNwb25kaW5nIGxlZnQgcmVjdXJzaXZlIHJ1bGVzIGFzIHdlbGwgYXMgY3JlIFxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5XaGF0IGlmIHRoZXJlIGFyZSB0d28gZGlyZWN0bHkgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnMgaW4gdGhlIHNhbWUgcnVsZT9cblxuQSA6Oj0gQSBcImhcIlxuXG4gICAgfCBBLi4uIFwiZ1wiXG4gICAgXG4gICAgfCBcImZcIlxuICAgIFxuICAgIDtcbiAgICAgICAgXG5BICA6Oj0gQV8uLi4gKCBcImhcIiB8IFwiZ1wiICkrPyA7XG4gICAgXG5BXyAgOjo9IFwiZlwiIDsgICAgXG5cblRoZSBvbmx5IHByb2JsZW0gd2l0aCB0aGlzIHNlZW1zIHRvIGJlIGRlYWxpbmcgd2l0aCBsb29rLWFoZWFkLiBPdGhlcndpc2Ugd2UgY2FuIHNpbXBseSBjb21iaW5lIHRoZSB0d28gcmVwZWF0ZWQgc3ViLWRlZmluaXRpb25zLiBcbiAgXG5gXG4iXSwibmFtZXMiOlsicnVsZXNBc1N0cmluZyIsInJ1bGVzVXRpbGl0aWVzIiwicnVsZU1hcEZyb21SdWxlcyIsInN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUiLCJWaWV3IiwiZ2V0UGFyc2VUcmVlIiwic3RhcnRSdWxlIiwicnVsZU1hcCIsInBhcnNlVHJlZSIsImxleGljYWxQYXR0ZXJuIiwiZ2V0TGV4aWNhbFBhdHRlcm4iLCJ1bmFzc2lnbmVkIiwiVU5BU1NJR05FRF9FTlRSWSIsImN1c3RvbSIsImVudHJpZXMiLCJiYXNpY0xleGVyIiwiQmFzaWNMZXhlciIsImZyb21FbnRyaWVzIiwiYmFzaWNQYXJzZXIiLCJCYXNpY1BhcnNlciIsImNvbnRlbnQiLCJnZXRDb250ZW50IiwidG9rZW5zIiwidG9rZW5pc2UiLCJub2RlIiwicGFyc2UiLCJyZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3hDaGVja2VkIiwiaXNSZW1vdmVPclJlbmFtZUludGVybWVkaWF0ZU5vZGVzQ2hlY2tib3hDaGVja2VkIiwicmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2RlcyIsImFzUGFyc2VUcmVlIiwia2V5VXBIYW5kbGVyIiwiZXZlbnQiLCJlbGVtZW50IiwiY2hhbmdlSGFuZGxlciIsImJuZiIsImdldEJORiIsInN0YXJ0UnVsZU5hbWUiLCJnZXRTdGFydFJ1bGVOYW1lIiwicnVsZXMiLCJydWxlc0Zyb21CTkYiLCJlbGltaW5hdGVMZWZ0UmVjdXJzaW9uIiwicnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcCIsIm11bHRpTGluZSIsInJ1bGVzU3RyaW5nIiwiYWRqdXN0ZWRCTkYiLCJzZXRBZGp1c3RlZEJORiIsInNldFBhcnNlVHJlZSIsImNoaWxkRWxlbWVudHMiLCJiaW5kIiwiQ29sdW1uc0RpdiIsIlNpemVhYmxlRGl2IiwiUm93c0RpdiIsIlN1YkhlYWRpbmciLCJMZXhpY2FsUGF0dGVybklucHV0Iiwib25LZXlVcCIsIkJORlRleHRhcmVhIiwiQWRqdXN0ZWRCTkZUZXh0YXJlYSIsInJlYWRPbmx5IiwiVmVydGljYWxTcGxpdHRlckRpdiIsIkNvbHVtbkRpdiIsIlN0YXJ0UnVsZU5hbWVJbnB1dCIsIkNvbnRlbnRUZXh0YXJlYSIsIlBhcnNlVHJlZVRleHRhcmVhIiwiUGFyYWdyYXBoIiwiUmVtb3ZlT3JSZW5hbWVJbnRlcm1lZGlhdGVOb2Rlc0NoZWNrYm94Iiwib25DaGFuZ2UiLCJjaGVja2VkIiwiaW5pdGlhbGlzZSIsImFzc2lnbkNvbnRleHQiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxCTkYiLCJpbml0aWFsQ29udGVudCIsImluaXRpYWxTdGFydFJ1bGVOYW1lIiwiaW5pdGlhbExleGljYWxQYXR0ZXJuIiwic2V0Qk5GIiwic2V0Q29udGVudCIsInNldFN0YXJ0UnVsZU5hbWUiLCJzZXRMZXhpY2FsUGF0dGVybiIsIkVsZW1lbnQiLCJ0YWdOYW1lIiwiZGVmYXVsdFByb3BlcnRpZXMiLCJjbGFzc05hbWUiLCJ3aXRoU3R5bGUiXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7Ozs7QUFFUyxJQUFBLGNBQWlCLGtDQUFqQixpQkFBaUIsRUFBQTtBQUVmLElBQUEsS0FBTSxXQUFOLE1BQU0sQ0FBQTtBQUNILElBQUEsWUFBYyxXQUFkLGNBQWMsQ0FBQTtBQUNiLElBQUEsYUFBZSxXQUFmLGVBQWUsQ0FBQTtBQUN5QixJQUFBLFdBQWEsV0FBYixhQUFhLENBQUE7QUFDTyxJQUFBLE1BQVUsV0FBVixVQUFVLENBQUE7QUFFNUUsSUFBQSxVQUFhLGtDQUFiLGFBQWEsRUFBQTtBQUNaLElBQUEsV0FBYyxrQ0FBZCxj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